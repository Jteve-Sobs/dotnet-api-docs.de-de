<Type Name="FileStream" FullName="System.IO.FileStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bbc237789865e4d30ebfeee5314fb7c2addf51d1" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83964957" /></Metadata><TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class FileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type FileStream = class&#xA;    inherit Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FileStream extends System.IO.Stream" FrameworkAlternate="netframework-4.0" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.IO.FileSystem" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.IO.FileSystem" FromVersion="4.1.0.0" To="System.Runtime" ToVersion="4.2.0.0" FrameworkAlternate="netcore-2.0" />
    <TypeForwarding From="System.IO.FileSystem" FromVersion="4.1.1.0" To="System.Runtime" ToVersion="4.2.1.0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
    <TypeForwarding From="System.IO.FileSystem" FromVersion="4.1.2.0" To="System.Runtime" ToVersion="4.2.2.0" FrameworkAlternate="netcore-3.1" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen <see cref="T:System.IO.Stream" /> für eine Datei bereit, wobei synchrone und asynchrone Lese- und Schreibvorgänge unterstützt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.IO.FileStream>-Klasse, um Dateien in einem Dateisystem zu lesen, zu schreiben, zu öffnen und zu schließen, und um andere Datei bezogene Betriebssystem Handles, einschließlich Pipes, Standardeingabe und Standardausgabe, zu bearbeiten. Sie können die Methoden <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.Stream.CopyTo%2A>und <xref:System.IO.FileStream.Flush%2A> verwenden, um synchrone Vorgänge auszuführen, oder die Methoden <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>und <xref:System.IO.FileStream.FlushAsync%2A>, um asynchrone Vorgänge auszuführen. Verwenden Sie die asynchronen Methoden, um ressourcenintensive Datei Vorgänge auszuführen, ohne den Haupt Thread zu blockieren. Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert. <xref:System.IO.FileStream> puffert Eingabe und Ausgabe, um die Leistung zu verbessern.  
  
> [!IMPORTANT]
>  Dieser Typ implementiert die <xref:System.IDisposable>-Schnittstelle. Nach Abschluss der Verwendung sollten Sie den Typ entweder direkt oder indirekt löschen. Zum direkten Löschen des Typs rufen Sie seine <xref:System.IDisposable.Dispose%2A>-Methode in einem `try`/`catch`-Block auf. Zum indirekten Löschen verwenden Sie ein Sprachkonstrukt wie `using` (in C#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt „Verwenden eines Objekts, das IDisposable implementiert“ des Themas „Die <xref:System.IDisposable>-Schnittstelle“.  
  
 Die <xref:System.IO.FileStream.IsAsync%2A>-Eigenschaft erkennt, ob das Datei Handle asynchron geöffnet wurde. Sie geben diesen Wert an, wenn Sie eine Instanz der <xref:System.IO.FileStream>-Klasse mithilfe eines Konstruktors erstellen, der einen `isAsync`-, `useAsync`-oder `options`-Parameter aufweist. Wenn die Eigenschaft `true`ist, verwendet der Stream überlappende e/a-Vorgänge zum asynchronen Ausführen von Datei Vorgängen. Die <xref:System.IO.FileStream.IsAsync%2A>-Eigenschaft muss jedoch nicht `true` werden, um die <xref:System.IO.FileStream.ReadAsync%2A>-, <xref:System.IO.FileStream.WriteAsync%2A>-oder <xref:System.IO.Stream.CopyToAsync%2A>-Methode aufzurufen. Wenn die <xref:System.IO.FileStream.IsAsync%2A>-Eigenschaft `false` ist und Sie die asynchronen Lese-und Schreibvorgänge aufzurufen, wird der UI-Thread immer noch nicht blockiert, aber der tatsächliche e/a-Vorgang wird synchron ausgeführt.  
  
 Die <xref:System.IO.FileStream.Seek%2A>-Methode unterstützt den zufälligen Zugriff auf Dateien. <xref:System.IO.FileStream.Seek%2A> ermöglicht, dass die Lese-/Schreibposition an eine beliebige Position innerhalb der Datei verschoben werden kann. Dies erfolgt mit Byte Offset-Verweis Punkt Parametern. Der Byte Offset ist relativ zum Seek-Referenzpunkt. Dies kann der Anfang, die aktuelle Position oder das Ende der zugrunde liegenden Datei sein, wie durch die drei Elemente der <xref:System.IO.SeekOrigin> Enumeration dargestellt.  
  
> [!NOTE]
>  Datenträger Dateien unterstützen immer den zufälligen Zugriff. Zum Zeitpunkt der Erstellung wird der <xref:System.IO.FileStream.CanSeek%2A>-Eigenschafts Wert abhängig vom zugrunde liegenden Dateityp auf `true` oder `false` festgelegt. Wenn der zugrunde liegende Dateityp FILE_TYPE_DISK ist, wie in Winbase. h definiert, ist der Wert der <xref:System.IO.FileStream.CanSeek%2A>-Eigenschaft `true`. Andernfalls wird der Wert der <xref:System.IO.FileStream.CanSeek%2A>-Eigenschaft `false`.  
  
 Wenn ein Prozess beendet wird, wenn ein Teil einer Datei gesperrt ist oder eine Datei mit ausstehenden Sperren schließt, ist das Verhalten nicht definiert.  
  
 Informationen zu Verzeichnis Vorgängen und anderen Datei Vorgängen finden Sie in den Klassen <xref:System.IO.File>, <xref:System.IO.Directory>und <xref:System.IO.Path>. Die <xref:System.IO.File>-Klasse ist eine Hilfsprogrammklasse, die über statische Methoden verfügt, die in erster Linie für die Erstellung von <xref:System.IO.FileStream> Objekten basierend auf Dateipfaden dienen. Die <xref:System.IO.MemoryStream>-Klasse erstellt einen Stream aus einem Bytearray und ähnelt der <xref:System.IO.FileStream>-Klasse.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
## <a name="detection-of-stream-position-changes"></a>Erkennen von Änderungen an der Streamposition  
 Wenn ein <xref:System.IO.FileStream> Objekt nicht über einen exklusiven Halt für sein Handle verfügt, könnte ein anderer Thread gleichzeitig auf das Datei Handle zugreifen und die Position des Dateizeigers des Betriebssystems ändern, der dem Datei Handle zugeordnet ist. In diesem Fall könnten die zwischengespeicherte Position im <xref:System.IO.FileStream> Objekt und die zwischengespeicherten Daten im Puffer kompromittiert werden. Das <xref:System.IO.FileStream> Objekt führt routinemäßig Prüfungen auf Methoden durch, die auf den zwischengespeicherten Puffer zugreifen, um sicherzustellen, dass die Handle-Position des Betriebssystems mit der zwischengespeicherten Position identisch ist, die vom <xref:System.IO.FileStream> Objekt verwendet wird.  
  
 Wenn eine unerwartete Änderung an der Position des Handles bei einem aufzurufenden <xref:System.IO.FileStream.Read%2A> Methode erkannt wird, verwirft der .NET Framework den Inhalt des Puffers und liest den Stream aus der Datei erneut. Dies kann sich auf die Leistung auswirken, abhängig von der Größe der Datei und anderen Prozessen, die sich auf die Position des Datei Datenstroms auswirken könnten.  
  
 Wenn eine unerwartete Änderung an der Position des Handles bei einem aufzurufenden <xref:System.IO.FileStream.Write%2A> Methode erkannt wird, wird der Inhalt des Puffers verworfen, und es wird eine <xref:System.IO.IOException> Ausnahme ausgelöst.  
  
 Ein <xref:System.IO.FileStream>-Objekt verfügt nicht über einen exklusiven Halt für sein handle, wenn auf die <xref:System.IO.FileStream.SafeFileHandle%2A>-Eigenschaft zugegriffen wird, um das Handle verfügbar zu machen, oder wenn dem <xref:System.IO.FileStream> Objekt die <xref:System.IO.FileStream.SafeFileHandle%2A>-Eigenschaft im Konstruktor zugewiesen wird.  
  
   
  
## Examples  
 Im folgenden Beispiel werden einige der <xref:System.IO.FileStream> Konstruktoren veranschaulicht.  
  
 [!code-cpp[fstream class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream Class/CPP/fstream class.cpp#1)]
 [!code-csharp[fstream class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream Class/CS/fstream class.cs#1)]
 [!code-vb[fstream class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream Class/VB/fstream class.vb#1)]  
  
 Im folgenden Beispiel wird gezeigt, wie Sie asynchron in eine Datei schreiben. Dieser Code wird in einer WPF-App ausgeführt, die einen TextBlock mit dem Namen UserInput und eine Schaltfläche enthält, die an einen Click-Ereignishandler mit dem Namen Button_Click angeschlossen ist. Der Dateipfad muss in eine Datei geändert werden, die auf dem Computer vorhanden ist.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.FileAccess" />
    <altmember cref="T:System.IO.FileMode" />
    <altmember cref="T:System.IO.FileShare" />
    <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
    <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
    <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
    <related type="Article" href="/dotnet/standard/io/how-to-read-and-write-to-a-newly-created-data-file">Gewusst wie: Lesen und Schreiben einer neu erstellten Datendatei</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.IO.FileStream" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine bitweise Kombination der Enumerationswerte, die die Eigenschaften <see cref="P:System.IO.FileStream.CanRead" /> und <see cref="P:System.IO.FileStream.CanWrite" /> des <see langword="FileStream" />-Objekts festlegen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle und mit der angegebenen Lese- und Schreibberechtigung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.IO.Stream.Close%2A> aufgerufen wird, wird das Handle ebenfalls geschlossen, und die Handle-Anzahl der Datei wird dekrementiert.  
  
 `FileStream` geht davon aus, dass Sie über eine exklusive Kontrolle über das Handle verfügt. Das Lesen, schreiben oder suchen, während eine `FileStream` auch ein Handle enthält, kann zu Daten Beschädigungen führen. Rufen Sie für die Datensicherheit vor der Verwendung des Handles <xref:System.IO.FileStream.Flush%2A> auf, und vermeiden Sie das Aufrufen von anderen Methoden als `Close`, nachdem Sie die Verwendung des Handles abgeschlossen haben.  
  
> [!CAUTION]
>  Wenn Sie einen Zeichensatz mit einer bestimmten Kultur Einstellung kompilieren und dieselben Zeichen mit einer anderen Kultur Einstellung abrufen, sind die Zeichen möglicherweise nicht interpretierbar und können dazu führen, dass eine Ausnahme ausgelöst wird.  
  
 `FileShare.Read` ist die Standardeinstellung für diese <xref:System.IO.FileStream> Konstruktoren ohne einen `FileShare`-Parameter.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" /> ist kein Feld von <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler, z. B. ein Datenträgerfehler, ist aufgetreten.  
  
 Oder  
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für das angegebene Dateihandle wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und das Dateihandle schreibgeschützt ist.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine bitweise Kombination der Enumerationswerte, die die Eigenschaften <see cref="P:System.IO.FileStream.CanRead" /> und <see cref="P:System.IO.FileStream.CanWrite" /> des <see langword="FileStream" />-Objekts festlegen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle und mit der angegebenen Lese- und Schreibberechtigung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.IO.Stream.Close%2A> aufgerufen wird, wird das Handle ebenfalls geschlossen, und die Handle-Anzahl der Datei wird dekrementiert.  
  
 `FileStream` geht davon aus, dass Sie über eine exklusive Kontrolle über das Handle verfügt. Das Lesen, schreiben oder suchen, während eine `FileStream` auch ein Handle enthält, kann zu Daten Beschädigungen führen. Rufen Sie für die Datensicherheit vor der Verwendung des Handles <xref:System.IO.FileStream.Flush%2A> auf, und vermeiden Sie das Aufrufen von anderen Methoden als `Close`, nachdem Sie die Verwendung des Handles abgeschlossen haben.  
  
> [!CAUTION]
>  Wenn Sie einen Zeichensatz mit einer bestimmten Kultur Einstellung kompilieren und dieselben Zeichen mit einer anderen Kultur Einstellung abrufen, sind die Zeichen möglicherweise nicht interpretierbar und können dazu führen, dass eine Ausnahme ausgelöst wird.  
  
 `FileShare.Read` ist die Standardeinstellung für diese <xref:System.IO.FileStream> Konstruktoren ohne einen `FileShare`-Parameter.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" /> ist kein Feld von <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler, z. B. ein Datenträgerfehler, ist aufgetreten.  
  
 Oder  
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für das angegebene Dateihandle wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und das Dateihandle schreibgeschützt ist.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Einer der Enumerationswerte, der bestimmt, wie die Datei geöffnet oder erstellt wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit dem angegebenen Pfad und dem angegebenen Erstellungsmodus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der .NET Framework unterstützt keinen direkten Zugriff auf physische Datenträger über Pfade, die Gerätenamen sind, z. b. "\\\\.\PHYSICALDRIVE0".  
  
 Der `path`-Parameter kann ein Dateiname sein, einschließlich einer Datei auf einer Universal Naming Convention Freigabe (UNC).  
  
 Der Konstruktor erhält Lese-/Schreibzugriff auf die Datei, und es wird das Freigeben von Lesezugriff geöffnet (d. h., dass Anforderungen zum Öffnen der Datei zum Schreiben durch diesen oder einen anderen Prozess fehlschlagen, bis das `FileStream` Objekt geschlossen wird, aber Leseversuche erfolgreich sind).  
  
 Sie können diesen Konstruktor nicht verwenden, um schreibgeschützte Dateien zu öffnen. Stattdessen müssen Sie einen Konstruktor verwenden, der einen `FileAccess`-Parameter akzeptiert, dessen Wert auf `FileAccess.Read`festgelegt ist.  
  
 Die Puffergröße wird auf die Standardgröße von 4096 Bytes (4 KB) festgelegt.  
  
> [!NOTE]
>  `path` muss keine Datei auf dem Datenträger gespeichert werden. Dies kann ein beliebiger Teil eines Systems sein, das den Zugriff über Streams unterstützt. Abhängig vom System kann diese Klasse z. b. auf ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A> ist für alle <xref:System.IO.FileStream> Objekte `true`, die Dateien kapseln. Wenn `path` ein Gerät angibt, das Suchvorgänge nicht unterstützt, wird die <xref:System.IO.FileStream.CanSeek%2A>-Eigenschaft des resultierenden <xref:System.IO.FileStream> `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read` ist die Standardeinstellung für diese <xref:System.IO.FileStream> Konstruktoren ohne einen `FileShare`-Parameter.  
  
 Für Konstruktoren ohne einen <xref:System.IO.FileAccess>-Parameter ist <xref:System.IO.FileAccess.Write> der Standard Zugriff, wenn der `mode` Parameter auf <xref:System.IO.FileMode.Append>festgelegt ist. Andernfalls wird der Zugriff auf <xref:System.IO.FileAccess.ReadWrite>festgelegt.  
  
> [!CAUTION]
>  Wenn Sie einen Zeichensatz mit einer bestimmten Kultur Einstellung kompilieren und dieselben Zeichen mit einer anderen Kultur Einstellung abrufen, sind die Zeichen möglicherweise nicht interpretierbar und können dazu führen, dass eine Ausnahme ausgelöst wird.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Daten in eine Datei geschrieben werden: Byte Weise Byte, und dann wird überprüft, ob die Daten ordnungsgemäß geschrieben wurden.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
Oder 
 <paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer Nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden. Dies ist z. B. der Fall, wenn <paramref name="mode" /> auf <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" /> festgelegt und die durch <paramref name="path" /> angegebene Datei nicht vorhanden ist. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> gibt eine schreibgeschützte Datei an.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegeben wurde, die durch <paramref name="path" /> angegebene Datei aber bereits vorhanden ist.  
  
Oder 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> enthält einen ungültigen Wert.</exception>
        <altmember cref="F:System.IO.Path.InvalidPathChars" />
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine <see cref="T:System.IO.FileAccess" />-Konstante, die die <see cref="P:System.IO.FileStream.CanRead" />- und <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaften des <see langword="FileStream" />-Objekts festlegt.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle mit den Angaben für die Lese-/Schreibberechtigung und die Puffergröße.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` geht davon aus, dass Sie über eine exklusive Kontrolle über das Handle verfügt. Das Lesen, schreiben oder suchen, während eine `FileStream` auch ein Handle enthält, kann zu Daten Beschädigungen führen. Rufen Sie für die Datensicherheit vor der Verwendung des Handles <xref:System.IO.FileStream.Flush%2A> auf, und vermeiden Sie das Aufrufen von anderen Methoden als `Close`, nachdem Sie die Verwendung des Handles abgeschlossen haben. Alternativ können Sie lesen und in das Handle schreiben, bevor Sie diesen `FileStream`-Konstruktor aufrufen.  
  
 `FileShare.Read` ist die Standardeinstellung für diese <xref:System.IO.FileStream> Konstruktoren ohne einen `FileShare`-Parameter.  
  
> [!CAUTION]
>  Wenn Sie einen Zeichensatz mit einer bestimmten Kultur Einstellung kompilieren und dieselben Zeichen mit einer anderen Kultur Einstellung abrufen, sind die Zeichen möglicherweise nicht interpretierbar und können dazu führen, dass eine Ausnahme ausgelöst wird.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="handle" />-Parameter ist ein ungültiges Handle.  
  
Oder 
Der <paramref name="handle" />-Parameter ist ein synchrones Handle und wurde asynchron verwendet.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="bufferSize" />-Parameter ist negativ.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler, z. B. ein Datenträgerfehler, ist aufgetreten.  
  
 Oder  
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für das angegebene Dateihandle wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und das Dateihandle schreibgeschützt ist.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ownsHandle" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine bitweise Kombination der Enumerationswerte, die die Eigenschaften <see cref="P:System.IO.FileStream.CanRead" /> und <see cref="P:System.IO.FileStream.CanWrite" /> des <see langword="FileStream" />-Objekts festlegen.</param>
        <param name="ownsHandle"><see langword="true" />, wenn das Dateihandle im Besitz dieser <see langword="FileStream" />-Instanz sein wird, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle mit den Angaben für die Lese-/Schreibberechtigung und für den Besitz der <see langword="FileStream" />-Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das `FileStream`-Objekt erhält den angegebenen Zugriff auf die Datei. Der Besitz des Handles wird wie angegeben angegeben. Wenn dieser Prozess das Handle besitzt, schließt ein Aufrufder <xref:System.IO.Stream.Close%2A>-Methode auch das Handle, und die Handle-Anzahl der Datei wird dekrementiert. Das `FileStream`-Objekt erhält die Standardpuffergröße von 4096 Bytes.  
  
 `FileStream` geht davon aus, dass Sie über eine exklusive Kontrolle über das Handle verfügt. Das Lesen, schreiben oder suchen, während eine `FileStream` auch ein Handle enthält, kann zu Daten Beschädigungen führen. Rufen Sie für die Datensicherheit vor der Verwendung des Handles <xref:System.IO.FileStream.Flush%2A> auf, und vermeiden Sie das Aufrufen von Methoden außer `Close`, nachdem Sie die Verwendung des Handles abgeschlossen haben.  
  
 `FileShare.Read` ist die Standardeinstellung für diese <xref:System.IO.FileStream> Konstruktoren ohne einen `FileShare`-Parameter.  
  
> [!CAUTION]
>  Wenn Sie einen Zeichensatz mit einer bestimmten Kultur Einstellung kompilieren und dieselben Zeichen mit einer anderen Kultur Einstellung abrufen, sind die Zeichen möglicherweise nicht interpretierbar und können dazu führen, dass eine Ausnahme ausgelöst wird.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" /> ist kein Feld von <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler, z. B. ein Datenträgerfehler, ist aufgetreten.  
  
 Oder  
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für das angegebene Dateihandle wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und das Dateihandle schreibgeschützt ist.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Einer der Enumerationswerte, der bestimmt, wie die Datei geöffnet oder erstellt wird.</param>
        <param name="access">Eine bitweise Kombination der Enumerationswerte, die bestimmt, wie vom <see langword="FileStream" />-Objekt auf die Datei zugegriffen werden kann. Dies bestimmt ebenfalls die von den <see cref="P:System.IO.FileStream.CanRead" />- und <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaften des <see langword="FileStream" />-Objekts zurückgegebenen Werte. <see cref="P:System.IO.FileStream.CanSeek" /> ist <see langword="true" />, wenn <paramref name="path" /> eine Datei auf einem Datenträger darstellt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus und die Lese-/Schreibberechtigung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der .NET Framework unterstützt keinen direkten Zugriff auf physische Datenträger über Pfade, die Gerätenamen sind, z. b. "\\\\.\PHYSICALDRIVE0".  
  
 Der `path`-Parameter kann ein Dateiname sein, einschließlich einer Datei auf einer Universal Naming Convention Freigabe (UNC).  
  
 Der Konstruktor erhält Lese-/Schreibzugriff auf die Datei, und es wird das Freigeben von Lesezugriff geöffnet (d. h., dass Anforderungen zum Öffnen der Datei zum Schreiben durch diesen oder einen anderen Prozess fehlschlagen, bis das `FileStream` Objekt geschlossen wird, aber Leseversuche erfolgreich sind). Die Puffergröße wird auf die Standardgröße von 4096 Bytes (4 KB) festgelegt.  
  
> [!NOTE]
>  `path` muss keine Datei auf dem Datenträger gespeichert werden. Dies kann ein beliebiger Teil eines Systems sein, das den Zugriff über Streams unterstützt. Abhängig vom System kann diese Klasse z. b. auf ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A> ist für alle <xref:System.IO.FileStream> Objekte `true`, die Dateien kapseln. Wenn `path` ein Gerät angibt, das Suchvorgänge nicht unterstützt, wird die <xref:System.IO.FileStream.CanSeek%2A>-Eigenschaft des resultierenden <xref:System.IO.FileStream> `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read` ist die Standardeinstellung für diese <xref:System.IO.FileStream> Konstruktoren ohne einen `FileShare`-Parameter.  
  
> [!CAUTION]
>  Wenn Sie einen Zeichensatz mit einer bestimmten Kultur Einstellung kompilieren und dieselben Zeichen mit einer anderen Kultur Einstellung abrufen, sind die Zeichen möglicherweise nicht interpretierbar und können dazu führen, dass eine Ausnahme ausgelöst wird.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
Oder 
 <paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer Nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden. Dies ist z. B. der Fall, wenn <paramref name="mode" /> auf <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" /> festgelegt und die durch <paramref name="path" /> angegebene Datei nicht vorhanden ist. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegeben wurde, die durch <paramref name="path" /> angegebene Datei aber bereits vorhanden ist.  
  
Oder 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für den angegebenen <paramref name="path" /> wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und die Datei bzw. das Verzeichnis schreibgeschützt ist.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> enthält einen ungültigen Wert.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="isAsync" Type="System.Boolean" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die von diesem <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine bitweise Kombination der Enumerationswerte, die die Eigenschaften <see cref="P:System.IO.FileStream.CanRead" /> und <see cref="P:System.IO.FileStream.CanWrite" /> des <see langword="FileStream" />-Objekts festlegen.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <param name="isAsync"><see langword="true" />, wenn das Handle asynchron geöffnet wurde (im überlappenden E/A-Modus), andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle mit den Angaben für die Lese-/Schreibberechtigung, die Puffergröße und den synchronen bzw. asynchronen Zustand.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie legen den `isAsync`-Parameter auf `true` fest, um das Datei Handle asynchron zu öffnen. Wenn der-Parameter `true`ist, verwendet der Stream überlappende e/a-Vorgänge zum asynchronen Ausführen von Datei Vorgängen. Der-Parameter muss jedoch nicht `true` werden, um die Methode <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>oder <xref:System.IO.Stream.CopyToAsync%2A> aufzurufen. Wenn der `isAsync`-Parameter `false` ist und Sie die asynchronen Lese-und Schreibvorgänge aufrufen, wird der UI-Thread immer noch nicht blockiert, aber der tatsächliche e/a-Vorgang wird synchron ausgeführt.  
  
 `FileStream` geht davon aus, dass Sie über eine exklusive Kontrolle über das Handle verfügt. Das Lesen, schreiben oder suchen, während eine `FileStream` auch ein Handle enthält, kann zu Daten Beschädigungen führen. Rufen Sie für die Datensicherheit vor der Verwendung des Handles <xref:System.IO.FileStream.Flush%2A> auf, und vermeiden Sie das Aufrufen von anderen Methoden als `Close`, nachdem Sie die Verwendung des Handles abgeschlossen haben. Alternativ können Sie lesen und in das Handle schreiben, bevor Sie diesen `FileStream`-Konstruktor aufrufen.  
  
 `FileShare.Read` ist die Standardeinstellung für diese <xref:System.IO.FileStream> Konstruktoren ohne einen `FileShare`-Parameter.  
  
> [!CAUTION]
>  Wenn Sie einen Zeichensatz mit einer bestimmten Kultur Einstellung kompilieren und dieselben Zeichen mit einer anderen Kultur Einstellung abrufen, sind die Zeichen möglicherweise nicht interpretierbar und können dazu führen, dass eine Ausnahme ausgelöst wird.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="handle" />-Parameter ist ein ungültiges Handle.  
  
Oder 
Der <paramref name="handle" />-Parameter ist ein synchrones Handle und wurde asynchron verwendet.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="bufferSize" />-Parameter ist negativ.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler, z. B. ein Datenträgerfehler, ist aufgetreten.  
  
 Oder  
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für das angegebene Dateihandle wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und das Dateihandle schreibgeschützt ist.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ownsHandle" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die von diesem <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine bitweise Kombination der Enumerationswerte, die die Eigenschaften <see cref="P:System.IO.FileStream.CanRead" /> und <see cref="P:System.IO.FileStream.CanWrite" /> des <see langword="FileStream" />-Objekts festlegen.</param>
        <param name="ownsHandle"><see langword="true" />, wenn das Dateihandle im Besitz dieser <see langword="FileStream" />-Instanz sein wird, andernfalls <see langword="false" />.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle mit den Angaben für die Lese-/Schreibberechtigung, den Besitz der <see langword="FileStream" />-Instanz und die Puffergröße.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das `FileStream`-Objekt erhält den angegebenen Zugriff auf die Datei. Der Besitz des Handles wird wie angegeben angegeben. Wenn dieses `FileStream` das Handle besitzt, schließt ein Aufrufder <xref:System.IO.Stream.Close%2A>-Methode auch das handle. Insbesondere die Handle-Anzahl der Datei wird dekrementiert. Das `FileStream` Objekt erhält die angegebene Puffergröße.  
  
 `FileStream` geht davon aus, dass Sie über eine exklusive Kontrolle über das Handle verfügt. Das Lesen, schreiben oder suchen, während eine `FileStream` auch ein Handle enthält, kann zu Daten Beschädigungen führen. Rufen Sie für die Datensicherheit vor der Verwendung des Handles <xref:System.IO.FileStream.Flush%2A> auf, und vermeiden Sie das Aufrufen von anderen Methoden als `Close`, nachdem Sie die Verwendung des Handles abgeschlossen haben. Alternativ können Sie lesen und in das Handle schreiben, bevor Sie diesen `FileStream`-Konstruktor aufrufen.  
  
 `FileShare.Read` ist die Standardeinstellung für diese <xref:System.IO.FileStream> Konstruktoren ohne einen `FileShare`-Parameter.  
  
> [!CAUTION]
>  Wenn Sie einen Zeichensatz mit einer bestimmten Kultur Einstellung kompilieren und dieselben Zeichen mit einer anderen Kultur Einstellung abrufen, sind die Zeichen möglicherweise nicht interpretierbar und können dazu führen, dass eine Ausnahme ausgelöst wird.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler, z. B. ein Datenträgerfehler, ist aufgetreten.  
  
 Oder  
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für das angegebene Dateihandle wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und das Dateihandle schreibgeschützt ist.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Einer der Enumerationswerte, der bestimmt, wie die Datei geöffnet oder erstellt wird.</param>
        <param name="access">Eine bitweise Kombination der Enumerationswerte, die bestimmt, wie vom <see langword="FileStream" />-Objekt auf die Datei zugegriffen werden kann. Dies bestimmt ebenfalls die von den <see cref="P:System.IO.FileStream.CanRead" />- und <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaften des <see langword="FileStream" />-Objekts zurückgegebenen Werte. <see cref="P:System.IO.FileStream.CanSeek" /> ist <see langword="true" />, wenn <paramref name="path" /> eine Datei auf einem Datenträger darstellt.</param>
        <param name="share">Eine bitweise Kombination der Enumerationswerte, die bestimmt, wie die Datei von Prozessen gemeinsam verwendet wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus, die Lese-/Schreib- und Freigabeberechtigung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der .NET Framework unterstützt keinen direkten Zugriff auf physische Datenträger über Pfade, die Gerätenamen sind, z. b. "\\\\.\PHYSICALDRIVE0".  
  
 Der `path`-Parameter kann ein Dateiname sein, einschließlich einer Datei auf einer Universal Naming Convention Freigabe (UNC).  
  
 Der Konstruktor erhält Lese-/Schreibzugriff auf die Datei, und es wird das Freigeben von Lesezugriff geöffnet (d. h., dass Anforderungen zum Öffnen der Datei zum Schreiben durch diesen oder einen anderen Prozess fehlschlagen, bis das `FileStream` Objekt geschlossen wird, aber Leseversuche erfolgreich sind). Die Puffergröße wird auf die Standardgröße von 4096 Bytes (4 KB) festgelegt.  
  
> [!NOTE]
>  `path` muss keine Datei auf dem Datenträger gespeichert werden. Dies kann ein beliebiger Teil eines Systems sein, das den Zugriff über Streams unterstützt. Abhängig vom System kann diese Klasse z. b. auf ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A> ist für alle <xref:System.IO.FileStream> Objekte `true`, die Dateien kapseln. Wenn `path` ein Gerät angibt, das Suchvorgänge nicht unterstützt, wird die <xref:System.IO.FileStream.CanSeek%2A>-Eigenschaft des resultierenden <xref:System.IO.FileStream> `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Wenn Sie einen Zeichensatz mit einer bestimmten Kultur Einstellung kompilieren und dieselben Zeichen mit einer anderen Kultur Einstellung abrufen, sind die Zeichen möglicherweise nicht interpretierbar und können dazu führen, dass eine Ausnahme ausgelöst wird.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.FileStream.Lock%2A>-Methode bereitgestellt wird.  
  
 [!code-cpp[System.IO.FileStream3#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#2)]
 [!code-csharp[System.IO.FileStream3#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#2)]
 [!code-vb[System.IO.FileStream3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
Oder 
 <paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer Nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden. Dies ist z. B. der Fall, wenn <paramref name="mode" /> auf <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" /> festgelegt und die durch <paramref name="path" /> angegebene Datei nicht vorhanden ist. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegeben wurde, die durch <paramref name="path" /> angegebene Datei aber bereits vorhanden ist.  
  
Oder 
Das System führt Windows 98 oder Windows 98 Zweite Ausgabe aus, und <paramref name="share" /> ist auf <see langword="FileShare.Delete" /> festgelegt.  
  
Oder 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für den angegebenen <paramref name="path" /> wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und die Datei bzw. das Verzeichnis schreibgeschützt ist.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> enthält einen ungültigen Wert.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ownsHandle" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="isAsync" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die von diesem <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine bitweise Kombination der Enumerationswerte, die die Eigenschaften <see cref="P:System.IO.FileStream.CanRead" /> und <see cref="P:System.IO.FileStream.CanWrite" /> des <see langword="FileStream" />-Objekts festlegen.</param>
        <param name="ownsHandle"><see langword="true" />, wenn das Dateihandle im Besitz dieser <see langword="FileStream" />-Instanz sein wird, andernfalls <see langword="false" />.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <param name="isAsync"><see langword="true" />, wenn das Handle asynchron geöffnet wurde (im überlappenden E/A-Modus), andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle mit den Angaben für die Lese-/Schreibberechtigung, den Besitz der <see langword="FileStream" />-Instanz, die Puffergröße und den synchronen bzw. asynchronen Zustand.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das `FileStream`-Objekt erhält den angegebenen Zugriff auf die Datei. Der Besitz des Handles wird wie angegeben angegeben. Wenn dieses `FileStream` das Handle besitzt, schließt ein Aufrufder <xref:System.IO.Stream.Close%2A>-Methode auch das handle. Insbesondere die Handle-Anzahl der Datei wird dekrementiert. Das `FileStream` Objekt erhält die angegebene Puffergröße.  
  
 `FileStream` geht davon aus, dass Sie über eine exklusive Kontrolle über das Handle verfügt. Das Lesen, schreiben oder suchen, während eine `FileStream` auch ein Handle enthält, kann zu Daten Beschädigungen führen. Rufen Sie für die Datensicherheit vor der Verwendung des Handles <xref:System.IO.FileStream.Flush%2A> auf, und vermeiden Sie das Aufrufen von anderen Methoden als `Close`, nachdem Sie die Verwendung des Handles abgeschlossen haben. Alternativ können Sie lesen und in das Handle schreiben, bevor Sie diesen `FileStream`-Konstruktor aufrufen.  
  
 `FileShare.Read` ist die Standardeinstellung für diese <xref:System.IO.FileStream> Konstruktoren ohne einen `FileShare`-Parameter.  
  
> [!CAUTION]
>  Wenn Sie einen Zeichensatz mit einer bestimmten Kultur Einstellung kompilieren und dieselben Zeichen mit einer anderen Kultur Einstellung abrufen, sind die Zeichen möglicherweise nicht interpretierbar und können dazu führen, dass eine Ausnahme ausgelöst wird.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="access" /> ist kleiner als <see langword="FileAccess.Read" /> oder größer als <see langword="FileAccess.ReadWrite" /> oder <paramref name="bufferSize" /> ist kleiner als oder gleich 0.</exception>
        <exception cref="T:System.ArgumentException">Das Handle ist ungültig.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler, z. B. ein Datenträgerfehler, ist aufgetreten.  
  
 Oder  
  
 Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für das angegebene Dateihandle wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und das Dateihandle schreibgeschützt ist.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Einer der Enumerationswerte, der bestimmt, wie die Datei geöffnet oder erstellt wird.</param>
        <param name="access">Eine bitweise Kombination der Enumerationswerte, die bestimmt, wie vom <see langword="FileStream" />-Objekt auf die Datei zugegriffen werden kann. Dies bestimmt ebenfalls die von den <see cref="P:System.IO.FileStream.CanRead" />- und <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaften des <see langword="FileStream" />-Objekts zurückgegebenen Werte. <see cref="P:System.IO.FileStream.CanSeek" /> ist <see langword="true" />, wenn <paramref name="path" /> eine Datei auf einem Datenträger darstellt.</param>
        <param name="share">Eine bitweise Kombination der Enumerationswerte, die bestimmt, wie die Datei von Prozessen gemeinsam verwendet wird.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus, die Lese-/Schreib- und Freigabeberechtigung sowie die Puffergröße.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der .NET Framework unterstützt keinen direkten Zugriff auf physische Datenträger über Pfade, die Gerätenamen sind, z. b. "\\\\.\PHYSICALDRIVE0".  
  
 Der `path`-Parameter kann ein Dateiname sein, einschließlich einer Datei auf einer Universal Naming Convention Freigabe (UNC).  
  
> [!NOTE]
>  `path` muss keine Datei auf dem Datenträger gespeichert werden. Dies kann ein beliebiger Teil eines Systems sein, das den Zugriff über Streams unterstützt. Abhängig vom System kann diese Klasse z. b. auf ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A> ist für alle <xref:System.IO.FileStream> Objekte `true`, die Dateien kapseln. Wenn `path` ein Gerät angibt, das Suchvorgänge nicht unterstützt, wird die <xref:System.IO.FileStream.CanSeek%2A>-Eigenschaft des resultierenden <xref:System.IO.FileStream> `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Wenn Sie einen Zeichensatz mit einer bestimmten Kultur Einstellung kompilieren und dieselben Zeichen mit einer anderen Kultur Einstellung abrufen, sind die Zeichen möglicherweise nicht interpretierbar und können dazu führen, dass eine Ausnahme ausgelöst wird.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
Oder 
 <paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer Nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> ist negativ oder 0 (null).  
  
Oder 
 <paramref name="mode" />, <paramref name="access" /> oder <paramref name="share" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden. Dies ist z. B. der Fall, wenn <paramref name="mode" /> auf <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" /> festgelegt und die durch <paramref name="path" /> angegebene Datei nicht vorhanden ist. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegeben wurde, die durch <paramref name="path" /> angegebene Datei aber bereits vorhanden ist.  
  
Oder 
Das System führt Windows 98 oder Windows 98 Zweite Ausgabe aus, und <paramref name="share" /> ist auf <see langword="FileShare.Delete" /> festgelegt.  
  
Oder 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für den angegebenen <paramref name="path" /> wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und die Datei bzw. das Verzeichnis schreibgeschützt ist.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, useAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, useAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Einer der Enumerationswerte, der bestimmt, wie die Datei geöffnet oder erstellt wird.</param>
        <param name="access">Eine bitweise Kombination der Enumerationswerte, die bestimmt, wie vom <see langword="FileStream" />-Objekt auf die Datei zugegriffen werden kann. Dies bestimmt ebenfalls die von den <see cref="P:System.IO.FileStream.CanRead" />- und <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaften des <see langword="FileStream" />-Objekts zurückgegebenen Werte. <see cref="P:System.IO.FileStream.CanSeek" /> ist <see langword="true" />, wenn <paramref name="path" /> eine Datei auf einem Datenträger darstellt.</param>
        <param name="share">Eine bitweise Kombination der Enumerationswerte, die bestimmt, wie die Datei von Prozessen gemeinsam verwendet wird.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <param name="useAsync">Gibt an, ob eine asynchrone E/A oder eine synchrone E/A verwendet wird. Beachten Sie jedoch, dass das zugrunde liegende Betriebssystem möglicherweise keine asynchrone E/A unterstützt, sodass das Handle je nach Plattform auch bei der Angabe von <see langword="true" /> möglicherweise synchron geöffnet wird. Bei asynchronem Öffnen liefern die <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />-Methode und die <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />-Methode bei umfangreichen Lese- oder Schreibvorgängen eine höhere Leistung, sind aber möglicherweise bei kleinen Lese- und Schreibvorgängen wesentlich langsamer. Wenn die Anwendung die Vorteile der asynchronen E/A nutzen kann, legen Sie den <paramref name="useAsync" />-Parameter auf <see langword="true" /> fest. Wird die asynchrone E/A richtig eingesetzt, können Anwendungen um ein Zehnfaches beschleunigt werden. Wenn die Anwendung jedoch nicht an eine asynchrone E/A angepasst wurde, kann dies die Leistung auch um das Zehnfache verringern.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus, die Lese-/Schreib- und Freigabeberechtigung, die Puffergröße und den synchronen bzw. asynchronen Zustand.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der .NET Framework unterstützt keinen direkten Zugriff auf physische Datenträger über Pfade, die Gerätenamen sind, z. b. "\\\\.\PHYSICALDRIVE0".  
  
 Der `path`-Parameter kann ein Dateiname sein, einschließlich einer Datei auf einer Universal Naming Convention Freigabe (UNC).  
  
> [!NOTE]
>  `path` muss keine Datei auf dem Datenträger gespeichert werden. Dies kann ein beliebiger Teil eines Systems sein, das den Zugriff über Streams unterstützt. Abhängig vom System kann diese Klasse z. b. auf ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A> ist für alle <xref:System.IO.FileStream> Objekte `true`, die Dateien kapseln. Wenn `path` ein Gerät angibt, das Suchvorgänge nicht unterstützt, wird die <xref:System.IO.FileStream.CanSeek%2A>-Eigenschaft des resultierenden <xref:System.IO.FileStream> `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Wenn Sie einen Zeichensatz mit einer bestimmten Kultur Einstellung kompilieren und dieselben Zeichen mit einer anderen Kultur Einstellung abrufen, sind die Zeichen möglicherweise nicht interpretierbar und können dazu führen, dass eine Ausnahme ausgelöst wird.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Sie Daten asynchron in eine Datei schreiben und dann überprüfen, ob die Daten ordnungsgemäß geschrieben wurden. Ein `State`-Objekt wird erstellt, um Informationen vom Haupt Thread an die Methoden `EndReadCallback` und `EndWriteCallback` zu übergeben.  
  
 [!code-cpp[System.IO.FileStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
Oder 
 <paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer Nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> ist negativ oder 0 (null).  
  
Oder 
 <paramref name="mode" />, <paramref name="access" /> oder <paramref name="share" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden. Dies ist z. B. der Fall, wenn <paramref name="mode" /> auf <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" /> festgelegt und die durch <paramref name="path" /> angegebene Datei nicht vorhanden ist. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegeben wurde, die durch <paramref name="path" /> angegebene Datei aber bereits vorhanden ist.  
  
Oder 
Das System führt Windows 98 oder Windows 98 Zweite Ausgabe aus, und <paramref name="share" /> ist auf <see langword="FileShare.Delete" /> festgelegt.  
  
Oder 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für den angegebenen <paramref name="path" /> wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und die Datei bzw. das Verzeichnis schreibgeschützt ist.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <altmember cref="T:System.IO.File" />
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.IO.FileMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="share" Type="System.IO.FileShare" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.FileOptions" Index="5" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Einer der Enumerationswerte, der bestimmt, wie die Datei geöffnet oder erstellt wird.</param>
        <param name="access">Eine bitweise Kombination der Enumerationswerte, die bestimmt, wie vom <see langword="FileStream" />-Objekt auf die Datei zugegriffen werden kann. Dies bestimmt ebenfalls die von den <see cref="P:System.IO.FileStream.CanRead" />- und <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaften des <see langword="FileStream" />-Objekts zurückgegebenen Werte. <see cref="P:System.IO.FileStream.CanSeek" /> ist <see langword="true" />, wenn <paramref name="path" /> eine Datei auf einem Datenträger darstellt.</param>
        <param name="share">Eine bitweise Kombination der Enumerationswerte, die bestimmt, wie die Datei von Prozessen gemeinsam verwendet wird.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die zusätzliche Dateioptionen angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus, die Lese-/Schreib- und Freigabeberechtigung, die Zugriffsmöglichkeiten anderer FileStreams auf die gleiche Datei, die Puffergröße und zusätzliche Dateioptionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der .NET Framework unterstützt keinen direkten Zugriff auf physische Datenträger über Pfade, die Gerätenamen sind, z. b. "\\\\.\PHYSICALDRIVE0".  
  
 Der `fileOptions`-Parameter wird verwendet, um Zugriff auf Erweiterte Vorgänge bereitzustellen, die beim Erstellen eines <xref:System.IO.FileStream> Objekts genutzt werden können.  
  
 Der `path`-Parameter kann ein Dateiname sein, einschließlich einer Datei auf einer Universal Naming Convention Freigabe (UNC).  
  
> [!NOTE]
>  `path` muss keine Datei auf dem Datenträger gespeichert werden. Dies kann ein beliebiger Teil eines Systems sein, das den Zugriff über Streams unterstützt. Abhängig vom System kann diese Klasse z. b. auf ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A> ist für alle <xref:System.IO.FileStream> Objekte `true`, die Dateien kapseln. Wenn `path` ein Gerät angibt, das Suchvorgänge nicht unterstützt, wird die <xref:System.IO.FileStream.CanSeek%2A>-Eigenschaft des resultierenden <xref:System.IO.FileStream> `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Wenn Sie einen Zeichensatz mit einer bestimmten Kultur Einstellung kompilieren und dieselben Zeichen mit einer anderen Kultur Einstellung abrufen, sind die Zeichen möglicherweise nicht interpretierbar und können dazu führen, dass eine Ausnahme ausgelöst wird.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
   
  
## Examples  
 Im folgenden Beispiel werden Daten in eine Datei geschrieben, und anschließend werden die Daten mithilfe des <xref:System.IO.FileStream>-Objekts gelesen.  
  
 [!code-cpp[IO.FileStream.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor1/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor1/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
Oder 
 <paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer Nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> ist negativ oder 0 (null).  
  
Oder 
 <paramref name="mode" />, <paramref name="access" /> oder <paramref name="share" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden. Dies ist z. B. der Fall, wenn <paramref name="mode" /> auf <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" /> festgelegt und die durch <paramref name="path" /> angegebene Datei nicht vorhanden ist. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegeben wurde, die durch <paramref name="path" /> angegebene Datei aber bereits vorhanden ist.  
  
Oder 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für den angegebenen <paramref name="path" /> wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und die Datei bzw. das Verzeichnis schreibgeschützt ist.  
  
Oder 
 <see cref="F:System.IO.FileOptions.Encrypted" /> ist für <paramref name="options" /> angegeben, aber Dateiverschlüsselung wird auf der aktuellen Plattform nicht unterstützt.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, rights As FileSystemRights, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.IO.FileMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="share" Type="System.IO.FileShare" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.FileOptions" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see cref="T:System.IO.FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Einer der Enumerationswerte, der bestimmt, wie die Datei geöffnet oder erstellt wird.</param>
        <param name="rights">Eine bitweise Kombination der Enumerationswerte, die die beim Erstellen der Zugriffs- und Überwachungsregeln für die Datei zu verwendenden Zugriffsrechte festlegt.</param>
        <param name="share">Eine bitweise Kombination der Enumerationswerte, die bestimmt, wie die Datei von Prozessen gemeinsam verwendet wird.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die zusätzliche Dateioptionen angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus, die Zugriffsrechte und die Freigabeberechtigung, die Puffergröße und zusätzliche Dateioptionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der .NET Framework unterstützt keinen direkten Zugriff auf physische Datenträger über Pfade, die Gerätenamen sind, z. b. "\\\\.\PHYSICALDRIVE0".  
  
 Verwenden Sie diesen <xref:System.IO.FileStream.%23ctor%2A>-Konstruktor, um zum Zeitpunkt der Erstellung einer Datei Zugriffsrechte anzuwenden. Zum Zugreifen auf oder Ändern von Rechten für eine vorhandene Datei sollten Sie die Methoden <xref:System.IO.File.GetAccessControl%2A> und <xref:System.IO.File.SetAccessControl%2A> verwenden.  
  
 Der `fileOptions`-Parameter wird verwendet, um Zugriff auf Erweiterte Vorgänge bereitzustellen, die beim Erstellen eines <xref:System.IO.FileStream> Objekts genutzt werden können.  
  
 Der `path`-Parameter kann ein Dateiname sein, einschließlich einer Datei auf einer Universal Naming Convention Freigabe (UNC).  
  
> [!NOTE]
>  `path` muss keine Datei auf dem Datenträger gespeichert werden. Dies kann ein beliebiger Teil eines Systems sein, das den Zugriff über Streams unterstützt. Abhängig vom System kann diese Klasse z. b. auf ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A> ist für alle <xref:System.IO.FileStream> Objekte `true`, die Dateien kapseln. Wenn `path` ein Gerät angibt, das Suchvorgänge nicht unterstützt, wird die <xref:System.IO.FileStream.CanSeek%2A>-Eigenschaft des resultierenden <xref:System.IO.FileStream> `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Wenn Sie einen Zeichensatz mit einer bestimmten Kultur Einstellung kompilieren und dieselben Zeichen mit einer anderen Kultur Einstellung abrufen, sind die Zeichen möglicherweise nicht interpretierbar und können dazu führen, dass eine Ausnahme ausgelöst wird.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
Oder 
 <paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer Nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> ist negativ oder 0 (null).  
  
Oder 
 <paramref name="mode" />, <paramref name="access" /> oder <paramref name="share" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden. Dies ist z. B. der Fall, wenn <paramref name="mode" /> auf <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" /> festgelegt und die durch <paramref name="path" /> angegebene Datei nicht vorhanden ist. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegeben wurde, die durch <paramref name="path" /> angegebene Datei aber bereits vorhanden ist.  
  
Oder 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für den angegebenen <paramref name="path" /> wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und die Datei bzw. das Verzeichnis schreibgeschützt ist.  
  
Oder 
 <see cref="F:System.IO.FileOptions.Encrypted" /> ist für <paramref name="options" /> angegeben, aber Dateiverschlüsselung wird auf der aktuellen Plattform nicht unterstützt.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene <paramref name="path" /> und/oder der angegebene Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, rights As FileSystemRights, share As FileShare, bufferSize As Integer, options As FileOptions, fileSecurity As FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions * System.Security.AccessControl.FileSecurity -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.IO.FileMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="share" Type="System.IO.FileShare" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.FileOptions" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see cref="T:System.IO.FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Einer der Enumerationswerte, der bestimmt, wie die Datei geöffnet oder erstellt wird.</param>
        <param name="rights">Eine bitweise Kombination der Enumerationswerte, die die beim Erstellen der Zugriffs- und Überwachungsregeln für die Datei zu verwendenden Zugriffsrechte festlegt.</param>
        <param name="share">Eine bitweise Kombination der Enumerationswerte, die bestimmt, wie die Datei von Prozessen gemeinsam verwendet wird.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <param name="options">Eine bitweise Kombination der Enumerationswerte, die zusätzliche Dateioptionen angibt.</param>
        <param name="fileSecurity">Ein Objekt, das die Zugriffssteuerung und die Überwachungssicherheit für die Datei bestimmt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus, die Zugriffsrechte und die Freigabeberechtigung, die Puffergröße, zusätzliche Dateioptionen, die Zugriffssteuerung und die Überwachungssicherheit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der .NET Framework unterstützt keinen direkten Zugriff auf physische Datenträger über Pfade, die Gerätenamen sind, z. b. "\\\\.\PHYSICALDRIVE0".  
  
 Verwenden Sie diesen <xref:System.IO.FileStream.%23ctor%2A>-Konstruktor, um zum Zeitpunkt der Erstellung einer Datei Zugriffsrechte anzuwenden. Zum Zugreifen auf oder Ändern von Rechten für eine vorhandene Datei sollten Sie die Methoden <xref:System.IO.File.GetAccessControl%2A> und <xref:System.IO.File.SetAccessControl%2A> verwenden.  
  
 Der `fileOptions`-Parameter wird verwendet, um Zugriff auf Erweiterte Vorgänge bereitzustellen, die beim Erstellen eines <xref:System.IO.FileStream> Objekts genutzt werden können.  
  
 Der `path`-Parameter kann ein Dateiname sein, einschließlich einer Datei auf einer Universal Naming Convention Freigabe (UNC).  
  
> [!NOTE]
>  `path` muss keine Datei auf dem Datenträger gespeichert werden. Dies kann ein beliebiger Teil eines Systems sein, das den Zugriff über Streams unterstützt. Abhängig vom System kann diese Klasse z. b. auf ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A> ist für alle <xref:System.IO.FileStream> Objekte `true`, die Dateien kapseln. Wenn `path` ein Gerät angibt, das Suchvorgänge nicht unterstützt, wird die <xref:System.IO.FileStream.CanSeek%2A>-Eigenschaft des resultierenden <xref:System.IO.FileStream> `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Wenn Sie einen Zeichensatz mit einer bestimmten Kultur Einstellung kompilieren und dieselben Zeichen mit einer anderen Kultur Einstellung abrufen, sind die Zeichen möglicherweise nicht interpretierbar und können dazu führen, dass eine Ausnahme ausgelöst wird.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
 > [!IMPORTANT]
 > Dieser Konstruktor ist in .net Core nicht vorhanden. Stattdessen können Sie ab .net Core 3,1 die folgende Erweiterungsmethode der `FileSystemAclExtensions`-Klasse innerhalb der `System.Security.AccessControl` Assembly verwenden: <xref:System.IO.FileSystemAclExtensions.Create(System.IO.FileInfo,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)>.
  
## Examples  
 Im folgenden Beispiel werden Daten in eine Datei geschrieben, und anschließend werden die Daten mithilfe des <xref:System.IO.FileStream>-Objekts gelesen.  
  
 [!code-cpp[IO.FileStream.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor2/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor2/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
Oder 
 <paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer Nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> ist negativ oder 0 (null).  
  
Oder 
 <paramref name="mode" />, <paramref name="access" /> oder <paramref name="share" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden. Dies ist z. B. der Fall, wenn <paramref name="mode" /> auf <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" /> festgelegt und die durch <paramref name="path" /> angegebene Datei nicht vorhanden ist. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegeben wurde, die durch <paramref name="path" /> angegebene Datei aber bereits vorhanden ist.  
  
Oder 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für den angegebenen <paramref name="path" /> wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und die Datei bzw. das Verzeichnis schreibgeschützt ist.  
  
Oder 
 <see cref="F:System.IO.FileOptions.Encrypted" /> ist für <paramref name="options" /> angegeben, aber Dateiverschlüsselung wird auf der aktuellen Plattform nicht unterstützt.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene <paramref name="path" /> und/oder der angegebene Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (array, offset, numBytes, callback, state)" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (buffer, offset, count, callback, state)" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (array, offset, numBytes, userCallback, stateObject)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="array">Der Puffer, in den Daten gelesen werden sollen.</param>
        <param name="buffer">Der Puffer, in den Daten gelesen werden sollen.</param>
        <param name="offset">Der Byteoffset im <paramref name="array" />, ab dem gelesen werden soll.</param>
        <param name="numBytes">Die maximale Anzahl der zu lesenden Bytes.</param>
        <param name="count">Die maximale Anzahl der zu lesenden Bytes.</param>
        <param name="callback">Die Methode, die aufgerufen werden soll, wenn der asynchrone Lesevorgang abgeschlossen ist.</param>
        <param name="userCallback">Die Methode, die aufgerufen werden soll, wenn der asynchrone Lesevorgang abgeschlossen ist.</param>
        <param name="state">Ein vom Benutzer bereitgestelltes Objekt, das zwischen dieser bestimmten asynchronen Leseanforderung und anderen Anforderungen unterscheidet.</param>
        <param name="stateObject">Ein vom Benutzer bereitgestelltes Objekt, das zwischen dieser bestimmten asynchronen Leseanforderung und anderen Anforderungen unterscheidet.</param>
        <summary>Startet einen asynchronen Lesevorgang. Verwenden Sie stattdessen <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.</summary>
        <returns>Ein Objekt, das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Die Arraylänge minus <paramref name="offset" /> ist kleiner als <paramref name="numBytes" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> oder <paramref name="numBytes" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.IO.IOException">Es wurde ein asynchroner Lesevorgang nach Erreichen des Dateiendes versucht.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (array, offset, numBytes, callback, state)" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (buffer, offset, count, callback, state)" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (array, offset, numBytes, userCallback, stateObject)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="array">Der Puffer mit den Daten, die in den aktuellen Stream geschrieben werden sollen.</param>
        <param name="buffer">Der Puffer mit den Daten, die in den aktuellen Stream geschrieben werden sollen.</param>
        <param name="offset">Der nullbasierte Byteoffset im <paramref name="array" />, ab dem Bytes in den aktuellen Stream kopiert werden.</param>
        <param name="numBytes">Die maximal zu schreibende Anzahl von Byte.</param>
        <param name="count">Die maximal zu schreibende Anzahl von Byte.</param>
        <param name="callback">Die Methode, die aufgerufen werden soll, wenn der asynchrone Schreibvorgang abgeschlossen ist.</param>
        <param name="userCallback">Die Methode, die aufgerufen werden soll, wenn der asynchrone Schreibvorgang abgeschlossen ist.</param>
        <param name="state">Ein vom Benutzer bereitgestelltes Objekt, das zwischen dieser bestimmten asynchronen Schreibanforderung und anderen Anforderungen unterscheidet.</param>
        <param name="stateObject">Ein vom Benutzer bereitgestelltes Objekt, das zwischen dieser bestimmten asynchronen Schreibanforderung und anderen Anforderungen unterscheidet.</param>
        <summary>Startet einen asynchronen Schreibvorgang. Verwenden Sie stattdessen <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.</summary>
        <returns>Ein Objekt, das auf den asynchronen Schreibvorgang verweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="array" /> minus <paramref name="offset" /> ist kleiner als <paramref name="numBytes" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> oder <paramref name="numBytes" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.NotSupportedException">Der Stream unterstützt das Schreiben nicht.</exception>
        <exception cref="T:System.ObjectDisposedException">Der Stream ist geschlossen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.FileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Stream Lesevorgänge unterstützt.</summary>
        <value><see langword="true" />, wenn der Stream Lesevorgänge unterstützt, <see langword="false" />, wenn der Stream geschlossen ist oder ausschließlich mit Schreibzugriff geöffnet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine von <xref:System.IO.Stream> abgeleitete Klasse Lesevorgänge nicht unterstützt, lösen Aufrufe der Methoden <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>und <xref:System.IO.FileStream.BeginRead%2A> eine <xref:System.NotSupportedException>aus.  
  
 Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `CanRead`-Eigenschaft veranschaulicht. Die Ausgabe dieses Codes lautet "MyFile. txt ist nicht beschreibbar". Um die Ausgabe Meldung zu erhalten, dass "MyFile. txt" geschrieben und aus gelesen werden kann, ändern Sie den `FileAccess`-Parameter in `ReadWrite` im `FileStream`-Konstruktor.  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.FileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Stream Suchvorgänge unterstützt.</summary>
        <value><see langword="true" />, wenn der Stream Suchvorgänge unterstützt, <see langword="false" />, wenn der Stream geschlossen ist oder der <see langword="FileStream" /> von einem Betriebssystemhandle, z. B. einer Pipe oder einer Ausgabe in der Konsole, erstellt wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine von <xref:System.IO.Stream> abgeleitete Klasse keine Suchvorgänge unterstützt, werden Aufrufe von <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>und <xref:System.IO.FileStream.Seek%2A> eine <xref:System.NotSupportedException>auslösen.  
  
 Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `CanSeek`-Eigenschaft verwendet, um zu prüfen, ob ein Stream Suchvorgänge unterstützt.  
  
 [!code-cpp[fstream canseek#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanSeek/CPP/fstream canseek.cpp#1)]
 [!code-csharp[fstream canseek#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanSeek/CS/fstream canseek.cs#1)]
 [!code-vb[fstream canseek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanSeek/VB/fstream canseek.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.FileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Stream Schreibvorgänge unterstützt.</summary>
        <value><see langword="true" />, wenn der Stream Schreibvorgänge unterstützt, <see langword="false" />, wenn der Stream geschlossen ist oder mit schreibgeschütztem Zugriff geöffnet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine von <xref:System.IO.Stream> abgeleitete Klasse Schreibvorgänge nicht unterstützt, löst ein <xref:System.IO.FileStream.SetLength%2A>-, <xref:System.IO.FileStream.Write%2A>-, <xref:System.IO.FileStream.BeginWrite%2A>-oder <xref:System.IO.FileStream.WriteByte%2A> einen <xref:System.NotSupportedException>aus.  
  
 Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `CanWrite`-Eigenschaft verwendet, um zu prüfen, ob ein Stream Schreibvorgänge unterstützt.  
  
 [!code-cpp[fstream canwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanWrite/CPP/fstream canwrite.cpp#1)]
 [!code-csharp[fstream canwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanWrite/CS/fstream canwrite.cs#1)]
 [!code-vb[fstream canwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanWrite/VB/fstream canwrite.vb#1)]  
  
 Im folgenden finden Sie ein Beispiel für die Verwendung der `CanWrite`-Eigenschaft. Die Ausgabe dieses Codes lautet "MyFile. txt ist beschreibbar". Um die Ausgabe Meldung zu erhalten, dass "MyFile. txt" geschrieben und aus gelesen werden kann, ändern Sie den `FileAccess`-Parameter in `ReadWrite` im `FileStream`-Konstruktor.  
  
 [!code-cpp[Classic FileStream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="fileStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt den aktuellen Stream und gibt alle dem aktuellen Stream zugeordneten Ressourcen frei (z. B. Sockets und Dateihandles).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Weitere Informationen zu dieser Methode finden Sie unter <xref:System.IO.Stream.Close?displayProperty=nameWithType>.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CopyToAsync (destination As Stream, bufferSize As Integer, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.CopyToAsync (destination, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination">Der Stream, in den der Inhalt des aktuellen Dateidatenstroms kopiert wird.</param>
        <param name="bufferSize">Die Größe des Cookies in Bytes. Dieser Wert muss größer als 0 sein. Die Standardgröße ist 81920.</param>
        <param name="cancellationToken">Das Token zum Überwachen von Abbruchanforderungen. Standardwert: <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Liest die Bytes asynchron aus dem aktuellen Dateidatenstrom und schreibt sie unter Verwendung einer angegebenen Puffergröße und eines Abbruchtokens in einen anderen Datenstrom.</summary>
        <returns>Eine Aufgabe, die den asynchronen Kopiervorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die `CopyToAsync`-Methode ermöglicht es Ihnen, ressourcenintensive e/a-Vorgänge auszuführen, ohne den Haupt Thread zu blockieren. Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert. Die Async-Methoden werden in Verbindung mit den Schlüsselwörtern `async` und `await` in Visual Basic C#und verwendet.

Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die zurückgegebene Aufgabe den <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> Wert für die <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType>-Eigenschaft.

Der Kopiervorgang beginnt an der aktuellen Position im aktuellen Dateistream.

Ein Beispiel für das Kopieren zwischen zwei Streams finden Sie in der <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> Überladung.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileStream.Dispose disposing" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="fileStream.Dispose disposing" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben. <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.IO.FileStream" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der öffentlichen <xref:System.ComponentModel.Component.Dispose%2A>-Methode und der <xref:System.Object.Finalize%2A>-Methode aufgerufen. <xref:System.ComponentModel.Component.Dispose%2A> Ruft die geschützte <xref:System.IO.FileStream.Dispose%2A> Methode auf, wobei der `disposing`-Parameter auf `true`festgelegt ist. <xref:System.Object.Finalize%2A> ruft <xref:System.IO.FileStream.Dispose%2A> auf, bei dem `disposing` auf `false`festgelegt ist.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.IO.FileStream> verweist. Diese Methode ruft die <xref:System.ComponentModel.Component.Dispose%2A>-Methode jedes referenzierten Objekts auf.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /> Sie darauf achten, nicht auf Objekte zu verweisen, die zuvor in einem früheren <see cref="M:System.ComponentModel.Component.Dispose" />von freigegeben wurden. Weitere Informationen zum Implementieren von <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />finden Sie unter [Implementieren einer](/dotnet/standard/garbage-collection/implementing-dispose)verwerfen-Methode.  
  
Weitere Informationen zu <see cref="M:System.ComponentModel.Component.Dispose" /> und <see cref="M:System.Object.Finalize" />finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](/dotnet/standard/garbage-collection/unmanaged).</para></block>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="fileStream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die nicht verwalteten Ressourcen, die von der <see cref="T:System.IO.FileStream" /> verwendet werden, asynchron frei.</summary>
        <returns>Eine Aufgabe, die den asynchronen Löschvorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Mit der `DisposeAsync`-Methode können Sie einen ressourcenintensiven Löschvorgang ausführen, ohne den Haupt Thread zu blockieren. Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert. Die Async-Methoden werden in Verbindung mit den Schlüsselwörtern `async` und `await` in Visual Basic C#und verwendet.

Diese Methode löscht den Datenstrom, indem alle Änderungen an den Sicherungs Speicher geschrieben und der Stream zum Freigeben von Ressourcen geschlossen wird.

Durch Aufrufen von `DisposeAsync` können die Ressourcen, die vom <xref:System.IO.FileStream> verwendet werden, für andere Zwecke neu zugeordnet werden. Weitere Informationen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](/dotnet/standard/garbage-collection/unmanaged).

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="fileStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Der Verweis auf die ausstehende asynchrone Anforderung, die abgewartet werden soll.</param>
        <summary>Wartet, bis der ausstehende asynchrone Lesevorgang abgeschlossen ist. (Verwenden Sie stattdessen <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</summary>
        <returns>Die Anzahl der aus dem Stream gelesenen Bytes. Diese Anzahl kann zwischen 0 und der Anzahl der angeforderten Bytes liegen. Streams geben nur am Ende des Streams 0 zurück, andernfalls sollten sie blockieren, bis mindestens 1 Byte verfügbar ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der .NET Framework 4 und früheren Versionen erforderlich, wie z. B. <xref:System.IO.FileStream.BeginRead%2A> und <xref:System.IO.FileStream.EndRead%2A> , asynchrone Datei-Vorgänge zu implementieren. Diese Methoden sind weiterhin im [!INCLUDE[net_v45](~/includes/net-v45-md.md)] verfügbar, um Legacy Code zu unterstützen. die neuen Async-Methoden, wie z. b. <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>und <xref:System.IO.FileStream.FlushAsync%2A>, unterstützen Sie jedoch bei der einfacheren Implementierung asynchroner Datei Vorgänge.  
  
 <xref:System.IO.FileStream.EndRead%2A> müssen für jeden Aufruf von <xref:System.IO.FileStream.BeginRead%2A>exakt aufgerufen werden. Wenn ein Lesevorgang nicht beendet wird, bevor ein anderer Lesevorgang gestartet wird, kann dies unerwünschte Verhalten wie Deadlocks verursachen.  
  
 Diese Methode überschreibt <xref:System.IO.Stream.EndRead%2A>.  
  
 <xref:System.IO.FileStream.EndRead%2A> können für jede <xref:System.IAsyncResult> von <xref:System.IO.FileStream.BeginRead%2A>aufgerufen werden. Der Aufruf von <xref:System.IO.FileStream.EndRead%2A> gibt Aufschluss darüber, wie viele Bytes aus dem Stream gelesen wurden. <xref:System.IO.FileStream.EndRead%2A> wird blockiert, bis der e/a-Vorgang abgeschlossen ist.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines größeren Beispiels, das für den <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>-Konstruktor bereitgestellt wird.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException">Dieses <see cref="T:System.IAsyncResult" />-Objekt wurde nicht durch Aufrufen von <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> für diese Klasse erstellt.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> wird mehrmals aufgerufen.</exception>
        <exception cref="T:System.IO.IOException">Der Stream ist geschlossen, oder ein interner Fehler ist aufgetreten.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
        <related type="Article" href="/dotnet/standard/io/asynchronous-file-i-o">Asynchrone Datei E/A</related>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="fileStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Die ausstehende asynchrone E/A-Anforderung.</param>
        <summary>Beendet einen asynchronen Schreibvorgang und blockiert, bis die E/A-Operation abgeschlossen wurde. (Verwenden Sie stattdessen <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der .NET Framework 4 und früheren Versionen erforderlich, wie z. B. <xref:System.IO.FileStream.BeginWrite%2A> und <xref:System.IO.FileStream.EndWrite%2A> , asynchrone Datei-Vorgänge zu implementieren. Diese Methoden sind weiterhin im [!INCLUDE[net_v45](~/includes/net-v45-md.md)] verfügbar, um Legacy Code zu unterstützen. die neuen Async-Methoden, wie z. b. <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>und <xref:System.IO.FileStream.FlushAsync%2A>, unterstützen Sie jedoch bei der einfacheren Implementierung asynchroner Datei Vorgänge.  
  
 Diese Methode überschreibt <xref:System.IO.Stream.EndWrite%2A>.  
  
 <xref:System.IO.FileStream.EndWrite%2A> müssen für jede <xref:System.IAsyncResult> von <xref:System.IO.FileStream.BeginWrite%2A>genau einmal aufgerufen werden. <xref:System.IO.FileStream.EndWrite%2A> wird blockiert, bis der e/a-Vorgang abgeschlossen ist.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines größeren Beispiels, das für den <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>-Konstruktor bereitgestellt wird.  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException">Dieses <see cref="T:System.IAsyncResult" />-Objekt wurde nicht durch Aufrufen von <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> für diese Klasse erstellt.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> wird mehrmals aufgerufen.</exception>
        <exception cref="T:System.IO.IOException">Der Stream ist geschlossen, oder ein interner Fehler ist aufgetreten.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
        <related type="Article" href="/dotnet/standard/io/asynchronous-file-i-o">Asynchrone Datei E/A</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt das Freigeben von Ressourcen und das Ausführen anderer Bereinigungsvorgänge sicher, wenn der Garbage Collector den <see langword="FileStream" /> verarbeitet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Garbage Collector ruft `Finalize` auf, wenn das aktuelle-Objekt für die Fertigstellung bereit ist. `Finalize` schließt die `FileStream`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht die Puffer für diesen Datenstrom und veranlasst die Ausgabe aller gepufferten Daten in die Datei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="fileStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht die Puffer für diesen Datenstrom und veranlasst die Ausgabe aller gepufferten Daten in die Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>.  
  
 Wenn Sie die <xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType>-Methode aufzurufen, wird der e/a-Puffer des Betriebssystems ebenfalls geleert.  
  
 Der Encoder eines Streams wird nicht geleert, es sei denn, Sie haben explizit <xref:System.IO.FileStream.Flush%2A> aufgerufen oder das Objekt verworfen. Wenn Sie <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> auf `true` festlegen, werden Daten aus dem Puffer in den Stream geleert, aber der Codierungs Status wird nicht geleert. Dies ermöglicht es dem Encoder, seinen Zustand (partielle Zeichen) beizubehalten, damit der nächste Zeichenblock ordnungsgemäß codiert werden kann. Dieses Szenario wirkt sich auf UTF8 und UTF7 aus, bei denen bestimmte Zeichen nur codiert werden können, nachdem der Encoder die angrenzenden Zeichen oder Zeichen empfangen hat.  
  
 Da ein Puffer zum Lesen oder schreiben verwendet werden kann, führt <xref:System.IO.FileStream.Flush> die folgenden beiden Funktionen aus:  
  
-   Alle Daten, die zuvor in den Puffer geschrieben wurden, werden in die Datei kopiert, und der Puffer wird mit Ausnahme des Codierungs Zustands gelöscht.  
  
-   Wenn <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType> `true` ist und Daten zum Lesen zuvor aus der Datei in den Puffer kopiert wurden, wird die aktuelle Position innerhalb der Datei um die Anzahl der ungelesenen Bytes im Puffer verringert. Der Puffer wird dann gelöscht.  
  
 Verwenden Sie die <xref:System.IO.FileStream.Flush%28System.Boolean%29> Methoden Überladung, wenn Sie sicherstellen möchten, dass alle gepufferten Daten in zwischen Datei Puffern auf den Datenträger geschrieben werden.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.FileStream.Lock%2A>-Methode bereitgestellt wird.  
  
 [!code-cpp[System.IO.FileStream3#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#4)]
 [!code-csharp[System.IO.FileStream3#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#4)]
 [!code-vb[System.IO.FileStream3#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.ObjectDisposedException">Der Stream ist geschlossen.</exception>
        <altmember cref="M:System.IO.FileStream.Flush(System.Boolean)" />
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Flush(bool flushToDisk);" />
      <MemberSignature Language="F#" Value="override this.Flush : bool -&gt; unit" Usage="fileStream.Flush flushToDisk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="flushToDisk"><see langword="true" />, um alle Zwischendateipuffer zu leeren, andernfalls <see langword="false" />.</param>
        <summary>Löscht die Puffer für diesen Datenstrom, veranlasst die Ausgabe aller gepufferten Daten in die Datei und löscht zudem alle Zwischendateipuffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, wenn Sie sicherstellen möchten, dass alle gepufferten Daten in zwischen Dateien auf den Datenträger geschrieben werden.  
  
 Wenn Sie die <xref:System.IO.FileStream.Flush%2A>-Methode aufzurufen, wird der e/a-Puffer des Betriebssystems ebenfalls geleert.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function FlushAsync (cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Das Token zum Überwachen von Abbruchanforderungen.</param>
        <summary>Löscht alle Puffer für diesen Stream asynchron und veranlasst die Ausgabe aller gepufferten Daten an das zugrunde liegende Gerät und überwacht Abbruchanforderungen.</summary>
        <returns>Eine Aufgabe, die die asynchrone Leerung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die zurückgegebene Aufgabe den <xref:System.Threading.Tasks.TaskStatus.Canceled> Wert für die <xref:System.Threading.Tasks.Task.Status%2A>-Eigenschaft. Wenn das Handle für die Datei verworfen wird, enthält die zurückgegebene Aufgabe die <xref:System.ObjectDisposedException> Ausnahme in der <xref:System.Threading.Tasks.Task.Exception%2A>-Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der Stream wurde verworfen.</exception>
        <related type="Article" href="/dotnet/standard/threading/cancellation-in-managed-threads">Abbruch</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.FileSecurity" Usage="fileStream.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein <see cref="T:System.Security.AccessControl.FileSecurity" />-Objekt ab, das die Einträge in der Zugriffssteuerungsliste für die Datei kapselt, das vom aktuellen <see cref="T:System.IO.FileStream" />-Objekt beschrieben wird.</summary>
        <returns>Ein Objekt, das die Zugriffssteuerungseinstellungen für die vom aktuellen <see cref="T:System.IO.FileStream" />-Objekt beschriebene Datei kapselt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Während die <xref:System.IO.FileStream>-Klasse und <xref:System.IO.FileStream.GetAccessControl%2A> verwendet werden können, um die Einträge in der Zugriffs Steuerungs Liste einer vorhandenen Datei abzurufen, sollten Sie die Verwendung <xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType>-Methode in Erwägung gezogen, da Sie einfacher zu verwenden ist.  
  
 Verwenden Sie die <xref:System.IO.FileStream.GetAccessControl%2A>-Methode, um die ACL-Einträge für eine Datei abzurufen.  
  
 Eine ACL beschreibt Personen und/oder Gruppen, die über Rechte für bestimmte Aktionen in der angegebenen Datei verfügen oder diese nicht besitzen. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](/dotnet/standard/io/how-to-add-or-remove-access-control-list-entries).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die Datei ist geschlossen.</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.SystemException">Die Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  
  
 Oder  
  
 Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.IO.FileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Dateihandle des Betriebssystems für die Datei ab, die durch das aktuelle <see langword="FileStream" />-Objekt gekapselt wird.</summary>
        <value>Das Dateihandle des Betriebssystems für die vom <see langword="FileStream" />-Objekt gekapselte Datei oder -1, wenn der <see langword="FileStream" /> geschlossen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist ein Betriebssystem Handle für die Verwendung mit vom Betriebssystem bereitgestellten Systemaufrufen (z. b. `ReadFile` unter Windows). Es funktioniert nicht mit C-Bibliotheksfunktionen, die einen Dateideskriptor erwarten, z. b. `fread`.  
  
 Das Betriebssystem Handle wurde möglicherweise synchron oder asynchron geöffnet, je nachdem, welcher `FileStream` Konstruktor aufgerufen wurde. Verwenden Sie die <xref:System.IO.FileStream.IsAsync%2A>-Eigenschaft, um zu ermitteln, ob dieses Handle asynchron geöffnet wurde. In Win32 bedeutet dies, dass das Handle für überlappende e/a-Vorgänge geöffnet wurde, und es sind unterschiedliche Parameter für `ReadFile` und `WriteFile`erforderlich.  
  
> [!CAUTION]
>  Die Beschädigung von Daten kann auftreten, wenn ein `FileStream` erstellt, das Handle weitergeleitet wird, ein Vorgang den Dateizeiger des Handles verschiebt und die `FileStream` wieder verwendet wird. Mehrere Threads können gleichzeitig nicht sicher in dieselbe Datei schreiben, und `FileStream` puffercode geht davon aus, dass er das Handle exklusiv steuert. `FileStream` könnte eine <xref:System.IO.IOException> auslösen, wenn `FileStream` erkennt, dass ein anderer Prozess den Dateizeiger verschoben hat. Um dies zu vermeiden, schreiben Sie keine Daten in einen Teil der Datei, den `FileStream` möglicherweise gepuffert haben, und stellen Sie den Dateizeiger auf den Speicherort wieder her, den er beim letzten Aufruf von Methoden auf `FileStream`besaß.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.FileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see langword="FileStream" /> asynchron oder synchron geöffnet wurde.</summary>
        <value><see langword="true" />, wenn <see langword="FileStream" /> asynchron geöffnet wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `IsAsync`-Eigenschaft erkennt, ob das `FileStream` handle asynchron geöffnet wurde, sodass der Code die <xref:System.IO.FileStream.Handle%2A>-Eigenschaft ordnungsgemäß verwenden kann. In Win32 bedeutet `IsAsync` true, dass das Handle für überlappende e/a-Vorgänge geöffnet wurde, und erfordert daher andere Parameter, um `ReadFile` und `WriteFile`.  
  
 Sie geben diesen Wert an, wenn Sie eine Instanz der <xref:System.IO.FileStream>-Klasse mithilfe eines Konstruktors erstellen, der einen `isAsync`-, `useAsync`-oder `options`-Parameter aufweist. Wenn die Eigenschaft `true`ist, verwendet der Stream überlappende e/a-Vorgänge zum asynchronen Ausführen von Datei Vorgängen. Die <xref:System.IO.FileStream.IsAsync%2A>-Eigenschaft muss jedoch nicht `true` werden, um die <xref:System.IO.FileStream.ReadAsync%2A>-, <xref:System.IO.FileStream.WriteAsync%2A>-oder <xref:System.IO.Stream.CopyToAsync%2A>-Methode aufzurufen. Wenn die <xref:System.IO.FileStream.IsAsync%2A>-Eigenschaft `false` ist und Sie die asynchronen Lese-und Schreibvorgänge aufzurufen, wird der UI-Thread immer noch nicht blockiert, aber der tatsächliche e/a-Vorgang wird synchron ausgeführt.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines größeren Beispiels, das für den <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>-Konstruktor bereitgestellt wird.  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.FileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Länge des Streams in Bytes ab.</summary>
        <value>Ein langer Wert stellt die Länge des Streams in Byte dar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Eigenschaften `Length` und `Position` verwendet, um eine dateiendebedingung zu überprüfen.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="P:System.IO.FileStream.CanSeek" /> ist für diesen Stream <see langword="false" />.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten, z. B. wurde die Datei geschlossen.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Lock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Lock : int64 * int64 -&gt; unit&#xA;override this.Lock : int64 * int64 -&gt; unit" Usage="fileStream.Lock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="position">Der Anfang des zu sperrenden Bereichs. Der Wert dieses Parameters muss größer oder gleich 0 sein.</param>
        <param name="length">Der zu sperrende Bereich.</param>
        <summary>Verhindert, dass andere Prozesse im <see cref="T:System.IO.FileStream" /> lesen oder schreiben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Bereich eines Datei Datenstroms gesperrt wird, werden den Threads des Sperr Prozesses exklusiver Zugriff auf diesen Bereich des Datei Datenstroms gewährt.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein Teil einer Datei gesperrt wird, damit ein anderer Prozess nicht auf den Teil der Datei zugreifen kann, obwohl er Lese-/Schreibzugriff auf die Datei hat. Führen Sie das Programm gleichzeitig in verschiedenen Befehls Fenstern aus, und untersuchen Sie die unterschiedlichen Konsolen Eingabeoptionen.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="position" /> oder <paramref name="length" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Datei ist geschlossen.</exception>
        <exception cref="T:System.IO.IOException">Der Prozess kann nicht auf die Datei zugreifen, da sie teilweise von einem anderen Prozess gesperrt ist.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.FileStream.Name" />
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den absoluten Pfad der Datei auf, die im <see langword="FileStream" /> geöffnet wurde.</summary>
        <value>Eine Zeichenfolge, die der absolute Pfad der Datei ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Wenn der absolute Pfad nicht bekannt ist, gibt diese Eigenschaft eine Zeichenfolge ähnlich "[unknown]" zurück.

 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines größeren Beispiels, das für den <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>-Konstruktor bereitgestellt wird.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.FileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle Position dieses Streams ab oder legt diese fest.</summary>
        <value>Die aktuelle Position dieses Streams.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Suchen nach einem beliebigen Speicherort über die Länge des Streams wird unterstützt.  Wenn Sie über die Länge der Datei hinaus suchen, wächst die Dateigröße.  In Microsoft Windows NT und neueren Daten werden alle Daten, die am Ende der Datei hinzugefügt werden, auf 0 (null) festgelegt.  In Microsoft Windows 98 oder früher werden alle Daten, die am Ende der Datei hinzugefügt werden, nicht auf 0 (null) festgelegt, was bedeutet, dass zuvor gelöschte Daten für den Stream sichtbar sind. Wenn die Position des Streams auf einen großen Wert über das Ende des Streams in Windows 98 oder früher festgelegt wird, wird möglicherweise eine Ausnahme ausgelöst.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Eigenschaften `Length` und `Position` verwendet, um eine dateiendebedingung zu überprüfen.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Vom Stream wird Suchen nicht unterstützt.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler  
  
Oder
  
 Die Position wurde auf einen sehr großen Wert festgelegt, der das Ende des Streams in Windows 98 oder früher überschreitet.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Es wurde versucht, die Position auf einen negativen Wert festzulegen.</exception>
        <exception cref="T:System.IO.EndOfStreamException">Es wurde versucht, über das Ende eines Streams hinaus zu suchen, der dies nicht unterstützt.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="fileStream.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Bereich im Arbeitsspeicher. Bei der Rückgabe dieser Methode werden die Inhalte dieses Bereichs durch die aus dem aktuellen Dateidatenstrom gelesenen Bytes ersetzt.</param>
        <summary>Liest eine Bytesequenz aus dem aktuellen Dateidatenstrom und setzt die Position in diesem Dateidatenstrom um die Anzahl der gelesenen Bytes nach vorn.</summary>
        <returns>Die Gesamtanzahl der in den Puffer eingelesenen Bytes. Dies kann weniger als die Anzahl der im Puffer zugeordneten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder 0 (null), wenn das Ende des Streams erreicht ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Verwenden Sie die <xref:System.IO.FileStream.CanRead%2A>-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt Verwenden Sie die <xref:System.IO.FileStream.ReadAsync%2A>-Methode, um asynchron aus dem aktuellen Stream zu lesen.

Diese Methode liest maximal `buffer.Length` Bytes aus dem aktuellen Dateistream und speichert Sie in `buffer`. Die aktuelle Position im Dateistream wird um die Anzahl der gelesenen Bytes erweitert. Wenn jedoch eine Ausnahme auftritt, bleibt die aktuelle Position im Dateistream unverändert. Die-Methode wird blockiert, bis mindestens ein Byte der Daten gelesen werden kann, wenn keine Daten verfügbar sind. `Read` gibt 0 nur zurück, wenn keine weiteren Daten im Dateistream vorhanden sind und nicht mehr erwartet wird (z. b. ein geschlossener Socket oder ein Dateiende). Die-Methode kann weniger Bytes zurückgeben als angefordert werden, auch wenn das Ende des Datei Datenstroms nicht erreicht wurde.

Verwenden Sie <xref:System.IO.BinaryReader> zum Lesen primitiver Datentypen.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] array, int32 offset, int32 count) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="fileStream.Read (array, offset, count)" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Enthält nach dem Beenden dieser Methode das angegebene Bytearray mit den Werten zwischen <paramref name="offset" /> und (<paramref name="offset" /> + <paramref name="count" /> - 1<c>)</c>, die durch die aus der aktuellen Quelle gelesenen Bytes ersetzt wurden.</param>
        <param name="offset">Das Byteoffset in <paramref name="array" />, an dem die gelesenen Bytes platziert werden.</param>
        <param name="count">Die maximale Anzahl der zu lesenden Bytes.</param>
        <summary>Liest einen Byteblock aus dem Stream und schreibt die Daten in einen angegebenen Puffer.</summary>
        <returns>Die Gesamtanzahl der in den Puffer eingelesenen Bytes. Dies kann weniger als die Anzahl der angeforderten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder 0, wenn das Streamende erreicht ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.Read%2A>.  
  
 Der `offset`-Parameter gibt den Offset des Bytes in `array` (dem Puffer Index) an, ab dem gelesen werden soll, und der `count`-Parameter gibt die maximale Anzahl von Bytes an, die aus diesem Stream gelesen werden sollen. Der zurückgegebene Wert ist die tatsächliche Anzahl von gelesenen Bytes, oder 0 (null), wenn das Ende des Streams erreicht ist. Wenn der Lesevorgang erfolgreich ist, wird die aktuelle Position des Streams um die Anzahl der gelesenen Bytes erweitert. Wenn eine Ausnahme auftritt, wird die aktuelle Position des Streams unverändert.  
  
 Die <xref:System.IO.FileStream.Read%2A>-Methode gibt 0 (null) nur zurück, nachdem das Ende des Streams erreicht wurde. Andernfalls liest <xref:System.IO.FileStream.Read%2A> vor der Rückgabe immer mindestens ein Byte aus dem Datenstrom. Wenn beim Abrufen von <xref:System.IO.FileStream.Read%2A>keine Daten aus dem Stream verfügbar sind, wird die-Methode blockiert, bis mindestens ein Byte mit Daten zurückgegeben werden kann. Eine-Implementierung kann weniger Bytes zurückgeben als angefordert werden, auch wenn das Ende des Streams nicht erreicht wurde.  
  
 Verwenden Sie <xref:System.IO.BinaryReader> zum Lesen primitiver Datentypen.  
  
 Unterbrechen Sie keinen Thread, der einen Lesevorgang ausführt. Obwohl die Anwendung nach der Blockierung des Threads möglicherweise erfolgreich ausgeführt wird, kann die Unterbrechung die Leistung und Zuverlässigkeit Ihrer Anwendung verringern.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Inhalt aus einem <xref:System.IO.FileStream> gelesen und in einen anderen <xref:System.IO.FileStream>geschrieben.  
  
 [!code-csharp[FSRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSRead/CS/fsread.cs#1)]
 [!code-vb[FSRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSRead/VB/fsread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.NotSupportedException">Lesevorgänge werden vom Stream nicht unterstützt.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> und <paramref name="count" /> bezeichnen einen ungültigen Bereich in <paramref name="array" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAsync (buffer As Memory(Of Byte), Optional cancellationToken As CancellationToken = null) As ValueTask(Of Integer)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="fileStream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den die Daten geschrieben werden sollen.</param>
        <param name="cancellationToken">Das Token zum Überwachen von Abbruchanforderungen. Standardwert: <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Liest eine Folge von Bytes asynchron aus dem aktuellen Dateidatenstrom, schreibt diese in einen Speicherbereich, erhöht die Position im Dateidatenstrom um die Anzahl der gelesenen Bytes und überwacht Abbruchsanforderungen.</summary>
        <returns>Eine Aufgabe, die den asynchronen Lesevorgang darstellt und die Gesamtzahl der in den Puffer gelesenen Bytes umschließt. Der Ergebniswert kann niedriger als die Anzahl der angeforderten Bytes sein, wenn die Anzahl an derzeit verfügbaren Bytes kleiner ist als die angeforderte Anzahl, oder sie kann 0 (null) sein, wenn das Datenstromende erreicht ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die `ReadAsync`-Methode ermöglicht es Ihnen, ressourcenintensive Datei Vorgänge auszuführen, ohne den Haupt Thread zu blockieren. Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert. Die Async-Methoden werden in Verbindung mit den Schlüsselwörtern `async` und `await` in Visual Basic C#und verwendet.

Verwenden Sie die <xref:System.IO.FileStream.CanRead%2A>-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt

Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die zurückgegebene Aufgabe den <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> Wert für die <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithtype>-Eigenschaft. Wenn das Handle für die Datei verworfen wird, enthält die zurückgegebene Aufgabe die <xref:System.ObjectDisposedException> Ausnahme in der <xref:System.Threading.Tasks.Task.Exception?displayProperty=nameWithType>-Eigenschaft.

## Examples

Im folgenden Beispiel wird gezeigt, wie Sie asynchron aus einer Datei lesen.  

[!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
[!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAsync (buffer As Byte(), offset As Integer, count As Integer, cancellationToken As CancellationToken) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="fileStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den die Daten geschrieben werden sollen.</param>
        <param name="offset">Der Byteoffset im <paramref name="buffer" />, ab dem Daten aus dem Stream geschrieben werden.</param>
        <param name="count">Die maximale Anzahl der zu lesenden Bytes.</param>
        <param name="cancellationToken">Das Token zum Überwachen von Abbruchanforderungen.</param>
        <summary>Liest eine Folge von Bytes asynchron aus dem aktuellen Dateidatenstrom, schreibt diese beginnend bei einem angegebenen Offset in ein Bytearray, erhöht die Position im Dateidatenstrom um die Anzahl der gelesenen Bytes und überwacht Abbruchsanforderungen.</summary>
        <returns>Eine Aufgabe, die den asynchronen Lesevorgang darstellt und die Gesamtzahl der in den Puffer gelesenen Bytes umschließt. Der Ergebniswert kann niedriger als die Anzahl der angeforderten Bytes sein, wenn die Anzahl an derzeit verfügbaren Bytes kleiner ist als die angeforderte Anzahl, oder sie kann 0 (null) sein, wenn das Datenstromende erreicht ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Die `ReadAsync`-Methode ermöglicht es Ihnen, ressourcenintensive Datei Vorgänge auszuführen, ohne den Haupt Thread zu blockieren. Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert. Die Async-Methoden werden in Verbindung mit den Schlüsselwörtern `async` und `await` in Visual Basic C#und verwendet.

Verwenden Sie die <xref:System.IO.FileStream.CanRead%2A>-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt

Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die zurückgegebene Aufgabe den <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> Wert für die <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType>-Eigenschaft. Wenn das Handle für die Datei verworfen wird, enthält die zurückgegebene Aufgabe die <xref:System.ObjectDisposedException> Ausnahme in der <xref:System.Threading.Tasks.Task.Exception?displayProperty=nameWithType>-Eigenschaft.

## Examples

Im folgenden Beispiel wird gezeigt, wie Sie asynchron aus einer Datei lesen.

[!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
[!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ArgumentException">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Pufferlänge.</exception>
        <exception cref="T:System.NotSupportedException">Lesevorgänge werden vom Stream nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Der Stream wurde verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Stream wird zurzeit von einem vorherigen Lesevorgang verwendet.</exception>
        <related type="Article" href="/dotnet/standard/threading/cancellation-in-managed-threads">Abbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="fileStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest ein Byte aus der Datei und erhöht die Leseposition um ein Byte.</summary>
        <returns>Das Byte, das in <see cref="T:System.Int32" /> umgewandelt wurde, oder -1, wenn das Ende des Streams erreicht wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.ReadByte%2A>.  
  
> [!NOTE]
>  Verwenden Sie die <xref:System.IO.FileStream.CanRead%2A>-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanRead%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Daten in eine Datei geschrieben werden: Byte Weise Byte, und dann wird überprüft, ob die Daten ordnungsgemäß geschrieben wurden.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Lesevorgänge werden vom aktuellen Stream nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Der aktuelle Stream wird geschlossen.</exception>
        <block subset="none" type="overrides"><para>Die Standard Implementierung auf <see langword="Stream" /> erstellt ein neues Einzel Byte Array und ruft dann <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />auf. Obwohl dies formal korrekt ist, ist es ineffizient. Jeder Datenstrom mit einem internen Puffer sollte diese Methode überschreiben und eine wesentlich effizientere Version bereitstellen, die den Puffer direkt liest, wobei die zusätzliche Array Zuordnung bei jedem-Befehl vermieden wird.  
  
Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).</para></block>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeFileHandle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.FileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" />-Objekt ab, das das Dateihandle des Betriebssystems für die Datei darstellt, die vom aktuellen <see cref="T:System.IO.FileStream" />-Objekt gekapselt wird.</summary>
        <value>Ein Objekt, das das Dateihandle des Betriebssystems für die Datei darstellt, von der das aktuelle <see cref="T:System.IO.FileStream" />-Objekt gekapselt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.FileStream.SafeFileHandle%2A>-Eigenschaft leert den Stream automatisch und legt die aktuelle Streamposition auf 0 fest.  Dadurch kann die Datei verschoben werden oder die Streamposition, die durch einen anderen Stream zurückgesetzt wird, mithilfe der <xref:System.IO.FileStream.SafeFileHandle%2A>, die von dieser Eigenschaft zurückgegeben wird.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="fileStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Der Punkt relativ zu <paramref name="origin" />, ab dem gesucht werden soll.</param>
        <param name="origin">Bestimmt den Anfang, das Ende oder die aktuelle Position als Bezugspunkt für <paramref name="offset" /> unter Verwendung eines Werts vom Typ <see cref="T:System.IO.SeekOrigin" />.</param>
        <summary>Legt die aktuelle Position dieses Streams auf den angegebenen Wert fest.</summary>
        <returns>Die neue Position im Stream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Verwenden Sie die <xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType>-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Suchvorgänge unterstützt Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>.  
  
 Sie können einen beliebigen Speicherort über die Länge des Streams hinaus suchen. Wenn Sie über die Länge der Datei hinaus suchen, wächst die Dateigröße. In Windows NT und höheren Versionen werden die am Ende der Datei hinzugefügten Daten auf 0 (null) festgelegt. In Windows 98 oder früheren Versionen werden am Ende der Datei hinzugefügte Daten nicht auf 0 (null) festgelegt, was bedeutet, dass zuvor gelöschte Daten für den Stream sichtbar sind.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Daten in eine Datei geschrieben werden: Byte Weise Byte, und dann wird überprüft, ob die Daten ordnungsgemäß geschrieben wurden.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 Im folgenden Beispiel wird der Text in umgekehrter Richtung vom Dateiende zum Anfang der Datei gelesen, indem die verschiedenen <xref:System.IO.SeekOrigin> Werte mit der <xref:System.IO.FileStream.Seek%2A>-Methode verwendet werden.  
  
 [!code-csharp[System.IO.FileStream.Seek#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.filestream.seek/cs/source.cs#1)]
 [!code-vb[System.IO.FileStream.Seek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.filestream.seek/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.NotSupportedException">Der Stream unterstützt beispielsweise keine Suchvorgänge, wenn der <see langword="FileStream" /> aus einer Pipe- oder Konsolenausgabe erstellt wird.</exception>
        <exception cref="T:System.ArgumentException">Es wird versucht, vor Beginn des Streams eine Suche auszuführen.</exception>
        <exception cref="T:System.ObjectDisposedException">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (fileSecurity As FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.FileSecurity -&gt; unit" Usage="fileStream.SetAccessControl fileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">Ein Objekt, das einen Eintrag in einer Zugriffssteuerungsliste beschreibt, der auf die aktuelle Datei angewendet werden soll.</param>
        <summary>Wendet von einem <see cref="T:System.Security.AccessControl.FileSecurity" />-Objekt beschriebene Einträge in Zugriffssteuerungslisten auf die Datei an, die vom aktuellen <see cref="T:System.IO.FileStream" />-Objekt beschrieben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Während die <xref:System.IO.FileStream>-Klasse und <xref:System.IO.FileStream.SetAccessControl%2A> für eine vorhandene Datei verwendet werden können, sollten Sie die <xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType>-Methode verwenden, da Sie einfacher zu verwenden ist.  
  
 Die <xref:System.IO.FileStream.SetAccessControl%2A>-Methode wendet Einträge in der Zugriffs Steuerungs Liste (ACL) auf eine Datei an, die die nicht geerbte ACL-Liste darstellt.  
  
> [!CAUTION]
>  Die für den `fileSecurity`-Parameter angegebene ACL ersetzt die vorhandene ACL für die Datei. Um Berechtigungen für einen neuen Benutzer hinzuzufügen, verwenden Sie die <xref:System.IO.FileStream.GetAccessControl%2A>-Methode, um die vorhandene ACL abzurufen, zu ändern und dann <xref:System.IO.FileStream.SetAccessControl%2A> zu verwenden, um Sie wieder auf die Datei anzuwenden.  
  
 Eine ACL beschreibt Personen und/oder Gruppen, die über Rechte für bestimmte Aktionen in der angegebenen Datei verfügen oder diese nicht besitzen. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](/dotnet/standard/io/how-to-add-or-remove-access-control-list-entries).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die Datei ist geschlossen.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="fileSecurity" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Die Datei konnte nicht gefunden oder geändert werden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der aktuelle Prozess hat keinen Zugriff zum Öffnen der Datei.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="fileStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Die neue Länge des Streams.</param>
        <summary>Legt die Länge dieses Streams auf den angegebenen Wert fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.SetLength%2A>.  
  
 Wenn der angegebene Wert kleiner als die aktuelle Länge des Streams ist, wird der Stream abgeschnitten. In diesem Szenario wird die aktuelle Position in das letzte Byte des Streams verschoben, wenn die aktuelle Position größer als die neue Länge ist. Wenn der angegebene Wert größer als die aktuelle Länge des Streams ist, wird der Stream erweitert, und die aktuelle Position bleibt unverändert. Wenn der Stream erweitert wird, ist der Inhalt des Streams zwischen der alten und der neuen Länge nicht definiert.  
  
 Ein Datenstrom muss sowohl das Schreiben als auch das Suchen nach `SetLength` unterstützen.  
  
> [!NOTE]
>  Verwenden Sie die <xref:System.IO.FileStream.CanWrite%2A>-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt, und die <xref:System.IO.FileStream.CanSeek%2A>-Eigenschaft, um zu bestimmen, ob die Suche Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanWrite%2A> und <xref:System.IO.Stream.CanSeek%2A>.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler ist aufgetreten.</exception>
        <exception cref="T:System.NotSupportedException">Der Stream unterstützt nicht gleichzeitig Schreib- und Suchvorgänge.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Es wurde versucht, den <paramref name="value" />-Parameter auf einen Wert kleiner 0 (null) festzulegen.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Unlock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Unlock : int64 * int64 -&gt; unit&#xA;override this.Unlock : int64 * int64 -&gt; unit" Usage="fileStream.Unlock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="length" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="position">Der Anfang des zu entsperrenden Bereichs.</param>
        <param name="length">Der zu entsperrende Bereich.</param>
        <summary>Ermöglicht anderen Prozessen den Zugriff auf die gesamte Datei oder einen Teil der Datei, die zuvor gesperrt war.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein Teil einer Datei gesperrt wird, damit ein anderer Prozess nicht auf den Teil der Datei zugreifen kann, obwohl er Lese-/Schreibzugriff auf die Datei hat und dann den angegebenen Teil der Datei entsperrt. Führen Sie das Programm gleichzeitig in verschiedenen Befehls Fenstern aus, und untersuchen Sie die unterschiedlichen Konsolen Eingabeoptionen.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="position" /> oder <paramref name="length" /> ist ein negativer Wert.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="fileStream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Bereich im Arbeitsspeicher. Diese Methode kopiert den Inhalt dieses Bereichs in den aktuellen Dateidatenstrom.</param>
        <summary>Schreibt eine Bytesequenz aus einer schreibgeschützten Spanne in den aktuellen Dateidatenstrom und setzt die aktuelle Position in diesem Dateidatenstrom um die Anzahl der geschriebenen Bytes nach vorn.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Verwenden Sie die Eigenschaft <xref:System.IO.FileStream.CanWrite%2A>, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt. Verwenden Sie die <xref:System.IO.FileStream.WriteAsync%2A>-Methode, um asynchron in den aktuellen Stream zu schreiben.

Wenn der Schreibvorgang erfolgreich ist, wird die Position innerhalb des Datei Datenstroms um die Anzahl der geschriebenen Bytes fortgesetzt. Wenn eine Ausnahme auftritt, bleibt die Position im Dateistream unverändert.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="fileStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Der Puffer mit den Daten, die in den Stream geschrieben werden sollen.</param>
        <param name="offset">Der nullbasierte Byteoffset im <paramref name="array" />, ab dem Bytes in den Stream kopiert werden.</param>
        <param name="count">Die maximal zu schreibende Anzahl von Byte.</param>
        <summary>Schreibt einen Block von Bytes in den Dateistream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.Write%2A>.  
  
 Der `offset`-Parameter gibt den Offset des Bytes in `array` (dem Puffer Index) an, an dem der Kopiervorgang beginnen soll, und der `count`-Parameter gibt die Anzahl der Bytes an, die in den Stream geschrieben werden. Wenn der Schreibvorgang erfolgreich ist, wird die aktuelle Position des Streams um die Anzahl der geschriebenen Bytes erweitert. Wenn eine Ausnahme auftritt, wird die aktuelle Position des Streams unverändert.  
  
> [!NOTE]
>  Verwenden Sie die Eigenschaft <xref:System.IO.FileStream.CanWrite%2A>, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanWrite%2A>.  
  
 Unterbrechen Sie keinen Thread, der einen Schreibvorgang ausführt. Obwohl die Anwendung nach der Blockierung des Threads möglicherweise erfolgreich ausgeführt wird, kann die Unterbrechung die Leistung und Zuverlässigkeit Ihrer Anwendung verringern.  
  
 Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.FileStream.Lock%2A>-Methode bereitgestellt wird.  
  
 [!code-cpp[System.IO.FileStream3#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#3)]
 [!code-csharp[System.IO.FileStream3#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#3)]
 [!code-vb[System.IO.FileStream3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> und <paramref name="count" /> bezeichnen einen ungültigen Bereich in <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler  
  
Oder
  
 Ein anderer Thread hat möglicherweise eine unerwartete Änderung der Position des Dateihandles des Betriebssystems verursacht.</exception>
        <exception cref="T:System.ObjectDisposedException">Der Stream ist geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Die aktuelle Streaminstanz unterstützt keine Schreibvorgänge.</exception>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteAsync (buffer As ReadOnlyMemory(Of Byte), Optional cancellationToken As CancellationToken = null) As ValueTask" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="fileStream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Die Region im Arbeitsspeicher, aus der die Daten für das Schreiben gelesen werden sollen.</param>
        <param name="cancellationToken">Das Token zum Überwachen von Abbruchanforderungen. Standardwert: <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Schreibt eine Bytesequenz aus einem Speicherbereich asynchron in den aktuellen Dateidatenstrom, erhöht die aktuelle Position im Dateidatenstrom um die Anzahl geschriebener Bytes und überwacht Abbruchanforderungen.</summary>
        <returns>Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Mit der `WriteAsync`-Methode können Sie ressourcenintensive e/a-Vorgänge durchführen, ohne den Haupt Thread zu blockieren. Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert. Die Async-Methoden werden in Verbindung mit den Schlüsselwörtern `async` und `await` in Visual Basic C#und verwendet.

Verwenden Sie die Eigenschaft <xref:System.IO.FileStream.CanWrite%2A>, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt.

Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die zurückgegebene Aufgabe den <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> Wert für die <xref:System.Threading.Tasks.Task.Status?displayProperty=nameWithType>-Eigenschaft.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteAsync (buffer As Byte(), offset As Integer, count As Integer, cancellationToken As CancellationToken) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, aus dem die Daten geschrieben werden.</param>
        <param name="offset">Der nullbasierte Byteoffset im <paramref name="buffer" />, ab dem Bytes in den Stream kopiert werden.</param>
        <param name="count">Die maximal zu schreibende Anzahl von Byte.</param>
        <param name="cancellationToken">Das Token zum Überwachen von Abbruchanforderungen.</param>
        <summary>Schreibt beim Überschreiben in einer abgeleiteten Klasse eine Folge von Bytes asynchron in den aktuellen Stream und erhöht die aktuelle Position im Stream um die Anzahl der geschriebenen Bytes und überwacht Abbruchanforderungen.</summary>
        <returns>Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.FileStream.WriteAsync%2A>-Methode ermöglicht es Ihnen, ressourcenintensive Datei Vorgänge auszuführen, ohne den Haupt Thread zu blockieren. Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert. Die Async-Methoden werden in Verbindung mit den Schlüsselwörtern `async` und `await` in Visual Basic C#und verwendet.  
  
 Verwenden Sie die Eigenschaft <xref:System.IO.FileStream.CanWrite%2A>, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt.  
  
 Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die zurückgegebene Aufgabe den <xref:System.Threading.Tasks.TaskStatus.Canceled> Wert für die <xref:System.Threading.Tasks.Task.Status%2A>-Eigenschaft. Wenn das Handle für die Datei verworfen wird, enthält die zurückgegebene Aufgabe die <xref:System.ObjectDisposedException> Ausnahme in der <xref:System.Threading.Tasks.Task.Exception%2A>-Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie asynchron in eine Datei geschrieben wird.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ArgumentException">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Pufferlänge.</exception>
        <exception cref="T:System.NotSupportedException">Der Stream unterstützt das Schreiben nicht.</exception>
        <exception cref="T:System.ObjectDisposedException">Der Stream wurde verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Stream wird zurzeit von einem vorherigen Schreibvorgang verwendet.</exception>
        <related type="Article" href="/dotnet/standard/threading/cancellation-in-managed-threads">Abbruch</related>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="fileStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Ein Byte, das in den Stream geschrieben werden soll.</param>
        <summary>Schreibt ein Byte an die aktuelle Position im Dateistream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.WriteByte%2A>.  
  
 Verwenden Sie `WriteByte`, um ein Byte effizient in eine `FileStream` zu schreiben. Wenn der Stream geschlossen oder nicht beschreibbar ist, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Verwenden Sie die Eigenschaft <xref:System.IO.FileStream.CanWrite%2A>, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanWrite%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Daten in eine Datei geschrieben werden: Byte Weise Byte, und dann wird überprüft, ob die Daten ordnungsgemäß geschrieben wurden.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der Stream ist geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Der Stream unterstützt das Schreiben nicht.</exception>
        <block subset="none" type="overrides"><para>Die Standard Implementierung auf <see langword="Stream" /> erstellt ein neues Einzel Byte Array und ruft dann <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />auf. Obwohl dies formal korrekt ist, ist es ineffizient. Jeder Datenstrom mit einem internen Puffer sollte diese Methode überschreiben und eine wesentlich effizientere Version bereitstellen, die den Puffer direkt liest, wobei die zusätzliche Array Zuordnung bei jedem-Befehl vermieden wird.  
  
Eine Liste der allgemeinen Datei-und Verzeichnis Vorgänge finden Sie unter [Allgemeine e/a-Aufgaben](/dotnet/standard/io/common-i-o-tasks).</para></block>
        <related type="Article" href="/dotnet/standard/io/">Datei- und Stream-E/A</related>
        <related type="Article" href="/dotnet/standard/io/how-to-read-text-from-a-file">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="/dotnet/standard/io/how-to-write-text-to-a-file">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
  </Members>
</Type>
