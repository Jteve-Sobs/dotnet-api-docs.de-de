<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7b76418562b5db09d375417c7bc3cf7e524f5baa" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75132165" /></Metadata><TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type FileSystemWatcher = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("Changed")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.IO.IODescription("")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.IO.IODescription("FileSystemWatcherDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Überwacht die Benachrichtigungen über Änderungen im Dateisystem und löst Ereignisse aus, wenn ein Verzeichnis oder eine Datei in einem Verzeichnis geändert werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie <xref:System.IO.FileSystemWatcher>, um Änderungen in einem angegebenen Verzeichnis zu überwachen. Sie können Änderungen in Dateien und Unterverzeichnissen des angegebenen Verzeichnisses überwachen. Sie können eine-Komponente erstellen, um Dateien auf einem lokalen Computer, einem Netzlaufwerk oder einem Remote Computer zu überwachen.  
  
 Legen Sie die <xref:System.IO.FileSystemWatcher.Filter%2A>-Eigenschaft auf eine leere Zeichenfolge ("") fest, oder verwenden Sie Platzhalter ("*", um Änderungen an allen Dateien zu überwachen.\*"). Um eine bestimmte Datei zu beobachten, legen Sie die <xref:System.IO.FileSystemWatcher.Filter%2A>-Eigenschaft auf den Dateinamen fest. Wenn Sie z. b. Änderungen in der Datei "MyDoc. txt" überwachen möchten, legen Sie die <xref:System.IO.FileSystemWatcher.Filter%2A>-Eigenschaft auf "MyDoc. txt" fest. Sie können auch auf Änderungen in einem bestimmten Dateityp achten. Wenn Sie z. b. Änderungen in Textdateien überwachen möchten, legen Sie die <xref:System.IO.FileSystemWatcher.Filter%2A>-Eigenschaft auf "\*. txt" fest.  
  
 Es gibt mehrere Arten von Änderungen, die Sie in einem Verzeichnis oder in einer Datei überwachen können. Beispielsweise können Sie auf Änderungen in `Attributes`, das `LastWrite` Datum und die Uhrzeit oder die `Size` von Dateien oder Verzeichnissen überwachen. Dies erfolgt durch Festlegen der <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>-Eigenschaft auf einen der <xref:System.IO.NotifyFilters> Werte. Weitere Informationen zu den Arten von Änderungen, die Sie überwachen können, finden Sie unter <xref:System.IO.NotifyFilters>.  
  
 Sie können das Umbenennen, löschen oder Erstellen von Dateien oder Verzeichnissen überwachen. Wenn Sie z. b. das Umbenennen von Textdateien überwachen möchten, legen Sie die <xref:System.IO.FileSystemWatcher.Filter%2A>-Eigenschaft auf "*. txt" fest, und nennen Sie die <xref:System.IO.FileSystemWatcher.WaitForChanged%2A>-Methode mit einer <xref:System.IO.WatcherChangeTypes.Renamed>, die für Ihren Parameter  
  
 Das Windows-Betriebssystem benachrichtigt die Komponente über Dateiänderungen in einem Puffer, der durch die <xref:System.IO.FileSystemWatcher>erstellt wurde. Wenn in kurzer Zeit viele Änderungen vorgenommen werden, kann der Puffer einen Überlauf verursachen. Dies bewirkt, dass die Komponente Änderungen im Verzeichnis nachverfolgt und nur eine Benachrichtigung über eine Benachrichtigung erhält. Das Erhöhen der Puffergröße mit der <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>-Eigenschaft ist aufwendig, da Sie aus nicht auslagertem Arbeitsspeicher stammt, der nicht auf den Datenträger ausgelagert werden kann, sodass der Puffer so klein ist, dass er keine Datei Änderungs Ereignisse verpasst. Um einen Pufferüberlauf zu vermeiden, verwenden Sie die Eigenschaften <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> und <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, damit unerwünschte Änderungs Benachrichtigungen herausgefiltert werden können.  
  
 Eine Liste der anfänglichen Eigenschaftswerte für eine Instanz von <xref:System.IO.FileSystemWatcher>finden Sie im <xref:System.IO.FileSystemWatcher.%23ctor%2A>-Konstruktor.  
  
 Beachten Sie Folgendes, wenn Sie die <xref:System.IO.FileSystemWatcher>-Klasse verwenden.  
  
-   Ausgeblendete Dateien werden nicht ignoriert.  
  
-   In manchen Systemen meldet <xref:System.IO.FileSystemWatcher> Änderungen an Dateien, die das kurze Format der Datei namens 8,3 aufweisen. Beispielsweise könnte eine Änderung an "longfilename. LongExtension" als "longfil ~" gemeldet werden. Lon ".  
  
-   Diese Klasse enthält einen Link Aufruf und eine Vererbungs Anforderung auf Klassenebene, die für alle Member gilt. Eine <xref:System.Security.SecurityException> wird ausgelöst, wenn der unmittelbare Aufrufer oder die abgeleitete Klasse nicht über die Berechtigung für volle Vertrauenswürdigkeit verfügt. Ausführliche Informationen zu Sicherheitsanforderungen finden Sie unter [Link](~/docs/framework/misc/link-demands.md)Aufrufe.  
  
-   Die maximale Größe, die Sie für die <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>-Eigenschaft festlegen können, um ein Verzeichnis über das Netzwerk zu überwachen, beträgt 64 KB.  
  
> [!NOTE]
>  Das Ausführen von <xref:System.IO.FileSystemWatcher> unter Windows 98 wird nicht unterstützt.  
  
## <a name="copying-and-moving-folders"></a>Kopieren und Verschieben von Ordnern  
 Das Betriebssystem und <xref:System.IO.FileSystemWatcher> Objekt interpretieren eine Ausschneide-und Einfügeaktion oder eine Verschiebungs Aktion als Umbenennungs Aktion für einen Ordner und seinen Inhalt. Wenn Sie einen Ordner mit Dateien ausschneiden und in einen zu überwachenden Ordner einfügen, meldet das <xref:System.IO.FileSystemWatcher> Objekt nur den Ordner als neu, jedoch nicht seinen Inhalt, da Sie im Wesentlichen nur umbenannt werden.  
  
 Um benachrichtigt zu werden, dass der Inhalt der Ordner verschoben oder in einen überwachten Ordner kopiert wurde, stellen Sie <xref:System.IO.FileSystemWatcher.OnChanged%2A> und <xref:System.IO.FileSystemWatcher.OnRenamed%2A> Ereignishandlermethoden bereit, wie in der folgenden Tabelle vorgeschlagen.  
  
|Ereignishandler|Behandelte Ereignisse|Führt|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<xref:System.IO.FileSystemWatcher.Changed>ist <xref:System.IO.FileSystemWatcher.Created>ist <xref:System.IO.FileSystemWatcher.Deleted>|Melden Sie Änderungen in Dateiattributen, erstellten Dateien und gelöschten Dateien.|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|Auflisten der alten und neuen Pfade umbenannter Dateien und Ordner, die bei Bedarf rekursiv erweitert werden.|  
  
## <a name="events-and-buffer-sizes"></a>Ereignisse und Puffergrößen  
 Beachten Sie, dass mehrere Faktoren beeinflussen können, welche Dateisystem Änderungs Ereignisse ausgelöst werden, wie im folgenden beschrieben:  
  
-   Allgemeine Dateisystem Vorgänge können mehr als ein Ereignis hervorrufen. Wenn eine Datei z. b. von einem Verzeichnis in ein anderes verschoben wird, werden möglicherweise mehrere <xref:System.IO.FileSystemWatcher.OnChanged%2A> und einige <xref:System.IO.FileSystemWatcher.OnCreated%2A>-und <xref:System.IO.FileSystemWatcher.OnDeleted%2A> Ereignisse ausgelöst. Das Verschieben einer Datei ist ein komplexer Vorgang, der aus mehreren einfachen Vorgängen besteht, wodurch mehrere Ereignisse erhöht werden. Ebenso können einige Anwendungen (z. b. Antivirussoftware) weitere Dateisystem Ereignisse auslösen, die von <xref:System.IO.FileSystemWatcher>erkannt werden.  
  
-   Der <xref:System.IO.FileSystemWatcher> kann Datenträger überwachen, solange Sie nicht gewechselt oder entfernt werden. Die <xref:System.IO.FileSystemWatcher> gibt keine Ereignisse für CDs und DVDs aus, da Zeitstempel und Eigenschaften nicht geändert werden können. Auf Remote Computern muss eine der erforderlichen Plattformen installiert sein, damit die Komponente ordnungsgemäß funktioniert.  
  
-   Wenn mehrere <xref:System.IO.FileSystemWatcher> Objekte denselben UNC-Pfad in Windows XP vor Service Pack 1 oder Windows 2000 SP2 oder früher beobachten, wird nur eines der Objekte ein Ereignis hervorrufen. Auf Computern, auf denen Windows XP SP1 und höher, Windows 2000 SP3 oder höher oder Windows Server 2003 ausgeführt wird, werden die entsprechenden Ereignisse von allen <xref:System.IO.FileSystemWatcher> Objekten ausgegeben.  
  
 Beachten Sie, dass ein <xref:System.IO.FileSystemWatcher> ein Ereignis übersehen kann, wenn die Puffergröße überschritten wird. Um fehlende Ereignisse zu vermeiden, befolgen Sie die folgenden Richtlinien:  
  
-   Vergrößern Sie die Puffergröße, indem Sie die <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>-Eigenschaft festlegen.  
  
-   Vermeiden Sie das Überwachen von Dateien mit langen Dateinamen, da ein langer Dateiname zum Auffüllen des Puffers beiträgt. Sie sollten diese Dateien unter Verwendung kürzerer Namen umbenennen.  
  
-   Halten Sie den Ereignis Behandlungs Code so kurz wie möglich.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.IO.FileSystemWatcher> erstellt, um das zur Laufzeit angegebene Verzeichnis zu überwachen. Die Komponente wird so festgelegt, dass Änderungen in `LastWrite` und `LastAccess` Zeit, das Erstellen, löschen oder Umbenennen von Textdateien im Verzeichnis überwacht werden. Wenn eine Datei geändert, erstellt oder gelöscht wird, wird der Pfad zur Datei in der Konsole gedruckt. Wenn eine Datei umbenannt wird, werden die alten und neuen Pfade in der Konsole gedruckt.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">zum Ableiten von der <see cref="T:System.Diagnostics.ProcessStartInfo" />-Klasse. Demand-Wert: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />; Benannte Berechtigungs Sätze: <see langword="FullTrust" />.</permission>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Using-a-FileSystemWatcher-4bc97af4">Verwenden einer FileSystemWatcher-Komponente in einem Windows Form</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileSystemWatcher" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileSystemWatcher" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Remote Computer, auf dem Windows NT oder Windows 2000 nicht vorhanden ist, kann nicht überwacht werden. Sie können einen Remote Computer mit Windows NT 4,0 nicht von einem Computer mit Windows NT 4,0 ansehen.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftswerte für eine Instanz von <xref:System.IO.FileSystemWatcher>angezeigt.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|bitweise OR-Kombination von `LastWrite`, `FileName`und `DirectoryName`|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|"*.\*"(alle Dateien überwachen.)|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|8192|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|leere Zeichenfolge ("")|  
  
> [!NOTE]
>  Die Komponente überwacht das angegebene Verzeichnis erst, wenn die <xref:System.IO.FileSystemWatcher.Path%2A> festgelegt ist und <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> `true`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.IO.FileSystemWatcher>-Objekt erstellt, um das zur Laufzeit angegebene Verzeichnis zu überwachen. Das <xref:System.IO.FileSystemWatcher>-Objekt überwacht Änderungen in `LastWrite` und `LastAccess` Zeiten und für das Erstellen, löschen oder Umbenennen von Textdateien im Verzeichnis. Wenn eine Datei geändert, erstellt oder gelöscht wird, wird der Pfad zur Datei in der Konsole angezeigt. Wenn eine Datei umbenannt wird, werden die alten und neuen Pfade in der Konsole angezeigt.  
  
 In diesem Beispiel werden die Namespaces <xref:System.Diagnostics> und <xref:System.IO> verwendet.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von Code verwendet werden, der nur teilweise vertrauenswürdig ist.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Das zu überwachende Verzeichnis in der Standard- oder UNC (Universal Naming Convention)-Notation.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileSystemWatcher" />-Klasse mit dem für die Überwachung angegebenen Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die Komponente überwacht das angegebene Verzeichnis erst, wenn die <xref:System.IO.FileSystemWatcher.Path%2A> festgelegt ist und <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> `true`ist.  
  
 Die-Komponente kann Dateien auf Ihrem persönlichen Computer, auf einem Netzlaufwerk oder auf einem Remote Computer überwachen.  
  
 Ein Remote Computer, auf dem Windows NT oder Windows 2000 nicht vorhanden ist, kann nicht überwacht werden. Sie können einen Remote Computer mit Windows NT 4,0 nicht von einem Computer mit Windows NT 4,0 ansehen. Die <xref:System.IO.FileSystemWatcher.Filter%2A>-Eigenschaft wird standardmäßig festgelegt, um alle Dateien zu überwachen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist eine leere Zeichenfolge ("").  
  
- oder - 
Der durch den <paramref name="path" />-Parameter angegebene Pfad ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> ist zu lang.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von Code verwendet werden, der nur teilweise vertrauenswürdig ist.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string * string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher (path, filter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Das zu überwachende Verzeichnis in der Standard- oder UNC (Universal Naming Convention)-Notation.</param>
        <param name="filter">Der zu überwachende Dateityp. Bei "*.txt" werden z. B. alle Textdateien auf Änderungen überwacht.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileSystemWatcher" />-Klasse mit dem für die Überwachung angegebenen Verzeichnis und Dateityp.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die Komponente überwacht das angegebene Verzeichnis erst, wenn die <xref:System.IO.FileSystemWatcher.Path%2A> festgelegt ist und <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> `true`ist.  
  
 Die-Komponente kann Dateien auf Ihrem persönlichen Computer, auf einem Netzlaufwerk oder auf einem Remote Computer überwachen.  
  
 Ein Remote Computer, auf dem Windows NT oder Windows 2000 nicht vorhanden ist, kann nicht überwacht werden. Sie können einen Remote Computer mit Windows NT 4,0 nicht von einem Computer mit Windows NT 4,0 ansehen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="path" /> ist <see langword="null" />.  
  
- oder - 
Der Parameter <paramref name="filter" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist eine leere Zeichenfolge ("").  
  
- oder - 
Der durch den <paramref name="path" />-Parameter angegebene Pfad ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> ist zu lang.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von Code verwendet werden, der nur teilweise vertrauenswürdig ist.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="fileSystemWatcher.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beginnt die Initialisierung von <see cref="T:System.IO.FileSystemWatcher" /> für die Verwendung in einem Formular oder durch eine andere Komponente. Die Initialisierung erfolgt zur Laufzeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Entwurfs Umgebung verwendet diese Methode, um die Initialisierung einer Komponente zu starten, die in einem Formular oder von einer anderen Komponente verwendet wird. Die <xref:System.IO.FileSystemWatcher.EndInit%2A>-Methode beendet die Initialisierung. Die Verwendung der Methoden <xref:System.IO.FileSystemWatcher.BeginInit%2A> und <xref:System.IO.FileSystemWatcher.EndInit%2A> verhindert, dass das-Steuerelement verwendet wird, bevor es vollständig initialisiert wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : System.IO.FileSystemEventHandler " Usage="member this.Changed : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory change matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Changed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn im angegebenen <see cref="P:System.IO.FileSystemWatcher.Path" /> eine Datei oder ein Verzeichnis geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.IO.FileSystemWatcher.Changed> Ereignis wird ausgelöst, wenn Änderungen an der Größe, den System Attributen, dem Zeitpunkt des letzten Schreibzugriffs, dem Zeitpunkt des letzten Zugriffs oder den Sicherheits Berechtigungen einer Datei oder eines Verzeichnisses in dem überwachten Verzeichnis vorgenommen werden.  
  
> [!NOTE]
>  Allgemeine Dateisystem Vorgänge können mehr als ein Ereignis hervorrufen. Wenn eine Datei z. b. von einem Verzeichnis in ein anderes verschoben wird, werden möglicherweise mehrere <xref:System.IO.FileSystemWatcher.OnChanged%2A> und einige <xref:System.IO.FileSystemWatcher.OnCreated%2A>-und <xref:System.IO.FileSystemWatcher.OnDeleted%2A> Ereignisse ausgelöst. Das Verschieben einer Datei ist ein komplexer Vorgang, der aus mehreren einfachen Vorgängen besteht, wodurch mehrere Ereignisse erhöht werden. Ebenso können einige Anwendungen (z. b. Antivirussoftware) weitere Dateisystem Ereignisse auslösen, die von <xref:System.IO.FileSystemWatcher>erkannt werden.  
  
 Verwenden Sie <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, um die Anzahl der Benachrichtigungen einzuschränken, die beim Behandeln dieses Ereignisses ausgelöst werden.  
  
> [!NOTE]
>  Das <xref:System.IO.FileSystemWatcher.Changed> Ereignis wird beim Umbenennen einer Datei unerwartet ausgelöst, aber nicht ausgelöst, wenn ein Verzeichnis umbenannt wird. Um das Umbenennen zu überwachen, verwenden Sie das <xref:System.IO.FileSystemWatcher.Renamed>-Ereignis.  
  
> [!NOTE]
>  Die Reihenfolge, in der das <xref:System.IO.FileSystemWatcher.Changed> Ereignis im Verhältnis zu den anderen <xref:System.IO.FileSystemWatcher> Ereignissen ausgelöst wird, kann sich ändern, wenn die <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>-Eigenschaft nicht `null`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das <xref:System.IO.FileSystemWatcher.Changed>-Ereignis verwendet, um den Dateipfad der Konsole anzuzeigen, wenn die überwachte Datei geändert wird.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberSignature Language="F#" Value="member this.Created : System.IO.FileSystemEventHandler " Usage="member this.Created : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory creation matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Created")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn im angegebenen <see cref="P:System.IO.FileSystemWatcher.Path" /> eine Datei oder ein Verzeichnis erstellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige häufige Vorkommen, z. b. das Kopieren oder Verschieben einer Datei oder eines Verzeichnisses, entsprechen nicht direkt einem Ereignis, aber diese Vorkommen bewirken, dass Ereignisse ausgelöst werden. Wenn Sie eine Datei oder ein Verzeichnis kopieren, löst das System ein <xref:System.IO.FileSystemWatcher.Created> Ereignis in dem Verzeichnis aus, in das die Datei kopiert wurde, wenn dieses Verzeichnis überwacht wird. Wenn das Verzeichnis, von dem kopiert wurde, von einer anderen Instanz von <xref:System.IO.FileSystemWatcher>beobachtet wurde, wird kein Ereignis ausgelöst. Beispielsweise erstellen Sie zwei Instanzen von <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 ist auf "c:\Eigene Dokumente" festgelegt, und "FileSystemWatcher2" ist so festgelegt, dass "c:\Your Documents" angezeigt wird. Wenn Sie eine Datei aus "meine Dokumente" in "Ihre Dokumente" kopieren, wird ein <xref:System.IO.FileSystemWatcher.Created> Ereignis von FileSystemWatcher2 ausgelöst, es wird jedoch kein Ereignis für FileSystemWatcher1 ausgelöst. Im Gegensatz zum Kopieren werden durch das Verschieben einer Datei oder eines Verzeichnisses zwei Ereignisse erhoben. Wenn Sie aus dem vorherigen Beispiel eine Datei von "eigene Dokumente" in "Ihre Dokumente" verschoben haben, wird ein <xref:System.IO.FileSystemWatcher.Created> Ereignis von FileSystemWatcher2 ausgelöst, und ein <xref:System.IO.FileSystemWatcher.Deleted> Ereignis wird von FileSystemWatcher1 ausgelöst.  
  
> [!NOTE]
>  Allgemeine Dateisystem Vorgänge können mehr als ein Ereignis hervorrufen. Wenn eine Datei z. b. von einem Verzeichnis in ein anderes verschoben wird, werden möglicherweise mehrere <xref:System.IO.FileSystemWatcher.OnChanged%2A> und einige <xref:System.IO.FileSystemWatcher.OnCreated%2A>-und <xref:System.IO.FileSystemWatcher.OnDeleted%2A> Ereignisse ausgelöst. Das Verschieben einer Datei ist ein komplexer Vorgang, der aus mehreren einfachen Vorgängen besteht, wodurch mehrere Ereignisse erhöht werden. Ebenso können einige Anwendungen (z. b. Antivirussoftware) weitere Dateisystem Ereignisse auslösen, die von <xref:System.IO.FileSystemWatcher>erkannt werden.  
  
> [!NOTE]
>  Die Reihenfolge, in der das <xref:System.IO.FileSystemWatcher.Created> Ereignis im Verhältnis zu den anderen <xref:System.IO.FileSystemWatcher> Ereignissen ausgelöst wird, kann sich ändern, wenn die <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>-Eigenschaft nicht `null`ist.  
  
 Das <xref:System.IO.FileSystemWatcher.OnCreated%2A>-Ereignis wird ausgelöst, sobald eine Datei erstellt wird. Wenn eine Datei kopiert oder in ein beobachteter Verzeichnis übertragen wird, wird das <xref:System.IO.FileSystemWatcher.OnCreated%2A> Ereignis sofort ausgelöst, gefolgt von einem oder mehreren <xref:System.IO.FileSystemWatcher.OnChanged%2A> Ereignissen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das <xref:System.IO.FileSystemWatcher.Created>-Ereignis verwendet, um den Dateipfad der Konsole anzuzeigen, wenn die überwachte Datei erstellt wird.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : System.IO.FileSystemEventHandler " Usage="member this.Deleted : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory deletion matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Deleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn im angegebenen <see cref="P:System.IO.FileSystemWatcher.Path" /> eine Datei oder ein Verzeichnis gelöscht wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige häufige Vorkommen, z. b. das Kopieren oder Verschieben einer Datei oder eines Verzeichnisses, entsprechen nicht direkt einem Ereignis, aber diese Vorkommen bewirken, dass Ereignisse ausgelöst werden. Wenn Sie eine Datei oder ein Verzeichnis kopieren, löst das System ein <xref:System.IO.FileSystemWatcher.Created> Ereignis in dem Verzeichnis aus, in das die Datei kopiert wurde, wenn dieses Verzeichnis überwacht wird. Wenn das Verzeichnis, von dem kopiert wurde, von einer anderen Instanz von <xref:System.IO.FileSystemWatcher>beobachtet wurde, wird kein Ereignis ausgelöst. Beispielsweise erstellen Sie zwei Instanzen von <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 ist auf "c:\Eigene Dokumente" festgelegt, und "FileSystemWatcher2" ist so festgelegt, dass "c:\Your Documents" angezeigt wird. Wenn Sie eine Datei aus "meine Dokumente" in "Ihre Dokumente" kopieren, wird ein <xref:System.IO.FileSystemWatcher.Created> Ereignis von FileSystemWatcher2 ausgelöst, es wird jedoch kein Ereignis für FileSystemWatcher1 ausgelöst. Im Gegensatz zum Kopieren werden durch das Verschieben einer Datei oder eines Verzeichnisses zwei Ereignisse erhoben. Wenn Sie aus dem vorherigen Beispiel eine Datei von "eigene Dokumente" in "Ihre Dokumente" verschoben haben, wird ein <xref:System.IO.FileSystemWatcher.Created> Ereignis von FileSystemWatcher2 ausgelöst, und ein <xref:System.IO.FileSystemWatcher.Deleted> Ereignis wird von FileSystemWatcher1 ausgelöst.  
  
> [!NOTE]
>  Allgemeine Dateisystem Vorgänge können mehr als ein Ereignis hervorrufen. Wenn eine Datei z. b. von einem Verzeichnis in ein anderes verschoben wird, werden möglicherweise mehrere <xref:System.IO.FileSystemWatcher.OnChanged%2A> und einige <xref:System.IO.FileSystemWatcher.OnCreated%2A>-und <xref:System.IO.FileSystemWatcher.OnDeleted%2A> Ereignisse ausgelöst. Das Verschieben einer Datei ist ein komplexer Vorgang, der aus mehreren einfachen Vorgängen besteht, wodurch mehrere Ereignisse erhöht werden. Ebenso können einige Anwendungen (z. b. Antivirussoftware) weitere Dateisystem Ereignisse auslösen, die von <xref:System.IO.FileSystemWatcher>erkannt werden.  
  
> [!NOTE]
>  Die Reihenfolge, in der das <xref:System.IO.FileSystemWatcher.Deleted> Ereignis im Verhältnis zu den anderen <xref:System.IO.FileSystemWatcher> Ereignissen ausgelöst wird, kann sich ändern, wenn die <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>-Eigenschaft nicht `null`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das <xref:System.IO.FileSystemWatcher.Deleted>-Ereignis verwendet, um den Dateipfad der Konsole anzuzeigen, wenn die überwachte Datei gelöscht wird.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die von <see cref="T:System.IO.FileSystemWatcher" /> verwendeten, nicht verwalteten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Veröffentlicht die durch den <see cref="T:System.IO.FileSystemWatcher" /> verwendeten nicht verwalteten Ressourcen und nimmt eine optionale Veröffentlichung der verwalteten Ressourcen vor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der öffentlichen <xref:System.ComponentModel.Component.Dispose%2A>-Methode und der <xref:System.Object.Finalize%2A>-Methode aufgerufen. <xref:System.ComponentModel.Component.Dispose%2A> Ruft die geschützte <xref:System.IO.FileSystemWatcher.Dispose%2A> Methode auf, wobei der `disposing`-Parameter auf `true`festgelegt ist. <xref:System.Object.Finalize%2A> ruft <xref:System.IO.FileSystemWatcher.Dispose%2A> auf, bei dem `disposing` auf `false`festgelegt ist.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.IO.Compression.DeflateStream> verweist. Diese Methode ruft die <xref:System.ComponentModel.Component.Dispose%2A>-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" /> Sie darauf achten, nicht auf Objekte zu verweisen, die zuvor in einem früheren <see cref="M:System.ComponentModel.Component.Dispose" />von freigegeben wurden. Weitere Informationen zum Implementieren von <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />finden Sie unter [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.  
  
Weitere Informationen zu <see cref="M:System.ComponentModel.Component.Dispose" /> und <see cref="M:System.Object.Finalize" />finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate if this instance is active")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Enabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Komponente aktiviert ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Komponente aktiviert ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />. Wenn Sie die Komponente in einem Designer in [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] verwenden, ist der Standardwert <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Komponente gibt nur dann Ereignisse aus, wenn Sie <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> auf `true`festgelegt haben.  
  
> [!NOTE]
>  Die Komponente überwacht das angegebene Verzeichnis erst, wenn die <xref:System.IO.FileSystemWatcher.Path%2A>-Eigenschaft festgelegt wurde und <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> `true`wird.  
  
 Mit der <xref:System.IO.FileSystemWatcher.WaitForChanged%2A>-Methode können Ereignishandler aufgerufen werden, um auf Dateiänderungen zu reagieren, auch wenn diese Eigenschaft auf `false`festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.IO.FileSystemWatcher> erstellt, um das zur Laufzeit angegebene Verzeichnis zu überwachen. Die Komponente wird so festgelegt, dass Änderungen in `LastWrite` und `LastAccess` Zeit, das Erstellen, löschen oder Umbenennen von Textdateien im Verzeichnis überwacht werden. Wenn eine Datei geändert, erstellt oder gelöscht wird, wird der Pfad zur Datei in der Konsole gedruckt. Wenn eine Datei umbenannt wird, werden die alten und neuen Pfade in der Konsole gedruckt.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.IO.FileSystemWatcher" />-Objekt wurde verworfen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Microsoft Windows NT oder höher.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Das in <see cref="P:System.IO.FileSystemWatcher.Path" /> angegebene Verzeichnis konnte nicht gefunden werden.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.IO.FileSystemWatcher.Path" /> wurde nicht festgelegt oder ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="fileSystemWatcher.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet die Initialisierung von <see cref="T:System.IO.FileSystemWatcher" /> für die Verwendung in einem Formular oder durch eine andere Komponente. Die Initialisierung erfolgt zur Laufzeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Entwurfs Umgebung verwendet diese Methode, um die Initialisierung einer Komponente zu beenden, die in einem Formular oder von einer anderen Komponente verwendet wird. Die <xref:System.IO.FileSystemWatcher.BeginInit%2A>-Methode startet die Initialisierung. Die Verwendung der Methoden <xref:System.IO.FileSystemWatcher.BeginInit%2A> und <xref:System.IO.FileSystemWatcher.EndInit%2A> verhindert, dass das-Steuerelement verwendet wird, bevor es vollständig initialisiert wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.ErrorEventHandler " Usage="member this.Error : System.IO.ErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die Instanz von <see cref="T:System.IO.FileSystemWatcher" /> das Überwachen von Änderungen nicht fortzusetzen kann oder wenn der interne Puffer überläuft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird immer dann ausgelöst, wenn das <xref:System.IO.FileSystemWatcher> Objekt das Überwachen von Änderungen verhindert. Wenn das Objekt z. b. Änderungen in einem Remote Verzeichnis überwacht und die Verbindung mit diesem Verzeichnis verloren geht, wird das <xref:System.IO.FileSystemWatcher.Error> Ereignis ausgelöst.  
  
 Das System benachrichtigt Sie über Dateiänderungen und speichert diese Änderungen in einem Puffer, den die Komponente erstellt und an die APIs übergibt. Wenn in kurzer Zeit viele Änderungen vorgenommen werden, kann der Puffer einen Überlauf verursachen. Dies bewirkt, dass die Komponente Änderungen im Verzeichnis nachverfolgt und nur eine Benachrichtigung über eine Benachrichtigung erhält. Die Vergrößerung des Puffers ist aufwendig, da er aus nicht auslagererem Speicher stammt, der nicht auf den Datenträger ausgelagert werden kann, sodass der Puffer so klein wie möglich bleibt. Um einen Pufferüberlauf zu vermeiden, verwenden Sie die Eigenschaften <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.Filter%2A>und <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, um unerwünschte Änderungs Benachrichtigungen herauszufiltern.  
  
> [!NOTE]
>  Allgemeine Dateisystem Vorgänge können mehr als ein Ereignis hervorrufen. Wenn eine Datei z. b. von einem Verzeichnis in ein anderes verschoben wird, werden möglicherweise mehrere <xref:System.IO.FileSystemWatcher.OnChanged%2A> und einige <xref:System.IO.FileSystemWatcher.OnCreated%2A>-und <xref:System.IO.FileSystemWatcher.OnDeleted%2A> Ereignisse ausgelöst. Das Verschieben einer Datei ist ein komplexer Vorgang, der aus mehreren einfachen Vorgängen besteht, wodurch mehrere Ereignisse erhöht werden. Ebenso können einige Anwendungen (z. b. Antivirussoftware) weitere Dateisystem Ereignisse auslösen, die von <xref:System.IO.FileSystemWatcher>erkannt werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : string with get, set" Usage="System.IO.FileSystemWatcher.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("*.*")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("File name filter pattern")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Filterzeichenfolge ab, mit der die in einem Verzeichnis zu überwachenden Dateien bestimmt werden, oder legt die Filterzeichenfolge fest.</summary>
        <value>Die Filterzeichenfolge. Der Standardwert ist "*.\*"(überwacht alle Dateien.)</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie die <xref:System.IO.FileSystemWatcher.Filter%2A>-Eigenschaft auf eine leere Zeichenfolge ("") fest, um Änderungen an allen Dateien anzuzeigen. Um eine bestimmte Datei zu beobachten, legen Sie die <xref:System.IO.FileSystemWatcher.Filter%2A>-Eigenschaft auf den Dateinamen fest. Wenn Sie z. b. Änderungen in der Datei "MyDoc. txt" überwachen möchten, legen Sie die <xref:System.IO.FileSystemWatcher.Filter%2A>-Eigenschaft auf "MyDoc. txt" fest. Sie können auch auf Änderungen in einem bestimmten Dateityp achten. Wenn Sie z. b. Änderungen in Textdateien überwachen möchten, legen Sie die <xref:System.IO.FileSystemWatcher.Filter%2A>-Eigenschaft auf "*. txt" fest. Die Verwendung mehrerer Filter, z. b. "&#124;\*. txt\*. doc", wird nicht unterstützt.  
  
 Die <xref:System.IO.FileSystemWatcher.Filter%2A>-Eigenschaft kann geändert werden, nachdem das <xref:System.IO.FileSystemWatcher> Objekt mit dem empfangen von Ereignissen begonnen hat.  
  
 Weitere Informationen zum Herausfiltern unerwünschter Benachrichtigungen finden Sie unter den Eigenschaften <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>und <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>.  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A> akzeptiert Platzhalter für übereinstimmende Dateien, wie in den folgenden Beispielen gezeigt.  
  
|Filterzeichenfolge|Überwacht die folgenden Dateien:|  
|-------------------|---------------------------------|  
|*.\*|Alle Dateien (Standard). Eine leere Zeichenfolge ("") überwacht auch alle Dateien.|  
|*.txt|Alle Dateien mit der Erweiterung "txt".|  
|* Rezept. doc|Alle Dateien, die mit der Erweiterung "doc" enden.|  
|Win*. XML|Alle Dateien, die mit "Win" mit der Erweiterung "XML" beginnen.|  
|Sales * 200?. xls|Entspricht Folgendem:<br /><br />-Sales Juli 2001. xls <br/>-Sales Aug 2002. xls <br/>-Sales März 2004. xls<br /><br /> entspricht jedoch nicht:<br /><br />-Sales Nov 1999. xls|  
|MyReport.Doc|Überwacht nur "myReport. doc".|  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.IO.FileSystemWatcher> erstellt, um das zur Laufzeit angegebene Verzeichnis zu überwachen. Die Komponente wird so festgelegt, dass Änderungen in `LastWrite` und `LastAccess` Zeit, das Erstellen, löschen oder Umbenennen von Textdateien im Verzeichnis überwacht werden. Wenn eine Datei geändert, erstellt oder gelöscht wird, wird der Pfad zur Datei in der Konsole gedruckt. Wenn eine Datei umbenannt wird, werden die alten und neuen Pfade in der Konsole gedruckt.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Filters">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;string&gt; Filters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;string&gt; Filters" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Filters As Collection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ Filters { System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Filters : System.Collections.ObjectModel.Collection&lt;string&gt;" Usage="System.IO.FileSystemWatcher.Filters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung aller Filter ab, mit denen bestimmt wird, welche Dateien in einem Verzeichnis überwacht werden.</summary>
        <value>Eine Filter Auflistung.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileSystemWatcher.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die von der aktuellen Instanz reservierten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
> Der Anwendungscode ruft diese Methode nicht auf. Sie wird automatisch während Garbage Collection aufgerufen, es sei denn, die Garbage Collector wurde deaktiviert. Weitere Informationen finden Sie unter <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> und <xref:System.Object.Finalize>. Diese Methode überschreibt <xref:System.Object.Finalize>.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeSubdirectories : bool with get, set" Usage="System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate we want to watch subdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_IncludeSubdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Unterverzeichnisse im angegebenen Pfad überwacht werden sollen, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Unterverzeichnisse überwacht werden sollen, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> auf `true` fest, wenn Sie auf Änderungs Benachrichtigungen für Dateien und Verzeichnisse überwachen möchten, die in dem Verzeichnis enthalten sind, das über die Eigenschaft <xref:System.IO.FileSystemWatcher.Path%2A> und deren Unterverzeichnisse angegeben wird. Wenn Sie die <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>-Eigenschaft auf `false` festlegen, verringern Sie die Anzahl der Benachrichtigungen, die an den internen Puffer gesendet werden. Weitere Informationen zum Herausfiltern unerwünschter Benachrichtigungen finden Sie unter den Eigenschaften <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> und <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>.  
  
 Wenn `true`, wird <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> durch die gesamte Unterstruktur rekursiv, nicht nur die direkt untergeordneten Verzeichnisse. Der relative Pfad zu einer Datei oder einem Verzeichnis innerhalb der Teilstruktur wird in der <xref:System.IO.FileSystemEventArgs.Name%2A>-Eigenschaft von <xref:System.IO.FileSystemEventArgs> und der <xref:System.IO.RenamedEventArgs.OldName%2A>-Eigenschaft von <xref:System.IO.RenamedEventArgs>zurückgegeben, je nach den Änderungen, die Sie überwachen. Sie können den voll qualifizierten Pfad von der <xref:System.IO.FileSystemEventArgs.FullPath%2A>-Eigenschaft <xref:System.IO.FileSystemEventArgs> und der Eigenschaft <xref:System.IO.RenamedEventArgs.OldFullPath%2A> von <xref:System.IO.RenamedEventArgs>abhängig von den Änderungen, die Sie überwachen, erhalten.  
  
 Wenn ein Verzeichnis in der Teilstruktur des zu überwachenden Verzeichnisses erstellt wird und <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> `true`ist, wird dieses Verzeichnis automatisch überwacht.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.InternalBufferSize : int with get, set" Usage="System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(8192)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe (in Byte) des internen Puffers ab oder legt diese fest.</summary>
        <value>Die interne Puffergröße in Byte. Der Standardwert ist 8192 (8 KB).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den Puffer auf 4 KB oder größer festlegen, er darf jedoch 64 KB nicht überschreiten. Wenn Sie versuchen, die <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>-Eigenschaft auf weniger als 4096 Bytes festzulegen, wird der Wert verworfen, und die <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>-Eigenschaft wird auf 4096 Bytes festgelegt. Verwenden Sie für eine optimale Leistung ein Vielfaches von 4 KB auf Intel-basierten Computern.  
  
 Das System benachrichtigt die Komponente über Dateiänderungen und speichert diese Änderungen in einem Puffer, der von der Komponente erstellt und an die APIs weitergeleitet wird. Jedes Ereignis kann bis zu 16 Byte Arbeitsspeicher (ohne den Dateinamen) verwenden. Wenn in kurzer Zeit viele Änderungen vorgenommen werden, kann der Puffer einen Überlauf verursachen. Dies bewirkt, dass die Komponente Änderungen im Verzeichnis nachverfolgt und nur eine Benachrichtigung über eine Benachrichtigung erhält. Wenn Sie die Puffergröße vergrößern, können fehlende Dateisystem Änderungs Ereignisse verhindert werden. Die Erhöhung der Puffergröße ist jedoch teuer, da Sie aus nicht auslagerlichem Speicher stammt, der nicht auf den Datenträger ausgelagert werden kann, sodass der Puffer so klein wie möglich bleibt. Um einen Pufferüberlauf zu vermeiden, verwenden Sie die Eigenschaften <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> und <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, um unerwünschte Änderungs Benachrichtigungen herauszufiltern.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyFilter : System.IO.NotifyFilters with get, set" Usage="System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate which change event we want to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_ChangedFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ der zu überwachenden Änderungen ab oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.IO.NotifyFilters" />-Werte. Der Standardwert ist die bitweise OR-Kombination von <see langword="LastWrite" />, <see langword="FileName" /> und <see langword="DirectoryName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die Elemente der <xref:System.IO.NotifyFilters> Enumeration kombinieren, um mehr als eine Art von Änderung gleichzeitig zu überwachen. Beispielsweise können Sie Änderungen an der Größe einer Datei und auf Änderungen in der `LastWrite` Zeit überwachen. Dies löst immer dann ein Ereignis aus, wenn die Datei-oder Ordner Größe geändert wird, oder eine Änderung der `LastWrite` Uhrzeit der Datei oder des Ordners.  
  
 Dies ist eine Möglichkeit, unerwünschte Benachrichtigungen herauszufiltern. Weitere Informationen zum Herausfiltern unerwünschter Benachrichtigungen finden Sie unter den Eigenschaften <xref:System.IO.FileSystemWatcher.Filter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>und <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.IO.FileSystemWatcher> erstellt, um das zur Laufzeit angegebene Verzeichnis zu überwachen. Die Komponente wird so festgelegt, dass Änderungen in `LastWrite` und `LastAccess` Zeit, das Erstellen, löschen oder Umbenennen von Textdateien im Verzeichnis überwacht werden. Wenn eine Datei geändert, erstellt oder gelöscht wird, wird der Pfad zur Datei in der Konsole gedruckt. Wenn eine Datei umbenannt wird, werden die alten und neuen Pfade in der Konsole gedruckt.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Wert ist keine gültige bitweise OR-Kombination der <see cref="T:System.IO.NotifyFilters" />-Werte.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der festgelegte Wert ist ungültig.</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.IO.FileSystemEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.IO.FileSystemWatcher.Changed" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnChanged%2A> wird aufgerufen, wenn Änderungen an der Größe, den System Attributen, dem Zeitpunkt des letzten Schreibzugriffs, dem Zeitpunkt des letzten Zugriffs oder den Sicherheits Berechtigungen einer Datei oder eines Verzeichnisses in dem überwachten Verzeichnis vorgenommen werden.  
  
 Verwenden Sie die <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>-Eigenschaft, um die Anzahl der Ereignisse einzuschränken, die beim Behandeln des <xref:System.IO.FileSystemWatcher.Changed> Ereignisses ausgelöst werden.  
  
 Das <xref:System.IO.FileSystemWatcher.OnCreated%2A>-Ereignis wird ausgelöst, sobald eine Datei erstellt wird. Wenn eine Datei kopiert oder in ein beobachteter Verzeichnis übertragen wird, wird das <xref:System.IO.FileSystemWatcher.OnCreated%2A> Ereignis sofort ausgelöst, gefolgt von einem oder mehreren <xref:System.IO.FileSystemWatcher.OnChanged%2A> Ereignissen.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> in einer abgeleiteten Klasse überschreiben, stellen Sie sicher, dass Sie die <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />-Methode der Basisklasse aufzurufen.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnCreated : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.IO.FileSystemEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.IO.FileSystemWatcher.Created" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> wird aufgerufen, wenn eine Datei oder ein Verzeichnis in dem überwachten Verzeichnis erstellt wird.  
  
 Einige häufige Vorkommen, z. b. das Kopieren oder Verschieben einer Datei oder eines Verzeichnisses, entsprechen nicht direkt einem Ereignis, aber diese Vorkommen bewirken, dass Ereignisse ausgelöst werden. Wenn Sie eine Datei oder ein Verzeichnis kopieren, löst das System ein <xref:System.IO.FileSystemWatcher.Created> Ereignis in dem Verzeichnis aus, in das die Datei kopiert wurde, wenn dieses Verzeichnis überwacht wird. Wenn das Verzeichnis, von dem kopiert wurde, von einer anderen Instanz von <xref:System.IO.FileSystemWatcher>beobachtet wurde, wird kein Ereignis ausgelöst. Beispielsweise erstellen Sie zwei Instanzen von <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 ist auf "c:\Eigene Dokumente" festgelegt, und "FileSystemWatcher2" ist so festgelegt, dass "c:\Your Documents" angezeigt wird. Wenn Sie eine Datei aus "meine Dokumente" Kopieren und in "Ihre Dokumente" einfügen, wird in FileSystemWatcher2 ein <xref:System.IO.FileSystemWatcher.Created> Ereignis ausgelöst, es wird jedoch kein Ereignis für FileSystemWatcher1 ausgelöst. Im Gegensatz zum Kopieren löst das Verschieben einer Datei oder eines Verzeichnisses zwei Ereignisse aus. Wenn Sie aus dem vorherigen Beispiel eine Datei von "eigene Dokumente" in "Ihre Dokumente" verschoben haben, wird in FileSystemWatcher2 ein <xref:System.IO.FileSystemWatcher.Created> Ereignis ausgelöst, und in FileSystemWatcher1 wird ein <xref:System.IO.FileSystemWatcher.Deleted> Ereignis ausgelöst.  
  
 Das <xref:System.IO.FileSystemWatcher.OnCreated%2A>-Ereignis wird ausgelöst, sobald eine Datei erstellt wird. Wenn eine Datei kopiert oder in ein beobachteter Verzeichnis übertragen wird, wird das <xref:System.IO.FileSystemWatcher.OnCreated%2A> Ereignis sofort ausgelöst, gefolgt von einem oder mehreren <xref:System.IO.FileSystemWatcher.OnChanged%2A> Ereignissen.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> in einer abgeleiteten Klasse überschreiben, stellen Sie sicher, dass Sie die <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />-Methode der Basisklasse aufzurufen.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnDeleted : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.IO.FileSystemEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.IO.FileSystemWatcher.Deleted" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> wird aufgerufen, wenn eine Datei oder ein Verzeichnis innerhalb des überwachten Verzeichnisses gelöscht wird.  
  
 Einige häufige Vorkommen, z. b. das Kopieren oder Verschieben einer Datei oder eines Verzeichnisses, entsprechen nicht direkt einem Ereignis, aber diese Vorkommen bewirken, dass Ereignisse ausgelöst werden. Wenn Sie eine Datei oder ein Verzeichnis kopieren, löst das System ein <xref:System.IO.FileSystemWatcher.Created> Ereignis in dem Verzeichnis aus, in das die Datei kopiert wurde, wenn dieses Verzeichnis überwacht wird. Wenn das Verzeichnis, von dem kopiert wurde, von einer anderen Instanz von <xref:System.IO.FileSystemWatcher>beobachtet wurde, wird kein Ereignis ausgelöst. Beispielsweise erstellen Sie zwei Instanzen von <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 ist auf "c:\Eigene Dokumente" festgelegt, und "FileSystemWatcher2" ist so festgelegt, dass "c:\Your Documents" angezeigt wird. Wenn Sie eine Datei aus "meine Dokumente" in "Ihre Dokumente" kopieren, wird ein <xref:System.IO.FileSystemWatcher.Created> Ereignis von FileSystemWatcher2 ausgelöst, es wird jedoch kein Ereignis für FileSystemWatcher1 ausgelöst. Im Gegensatz zum Kopieren löst das Verschieben einer Datei oder eines Verzeichnisses zwei Ereignisse aus. Wenn Sie aus dem vorherigen Beispiel eine Datei von "eigene Dokumente" in "Ihre Dokumente" verschoben haben, wird ein <xref:System.IO.FileSystemWatcher.Created> Ereignis von FileSystemWatcher2 ausgelöst, und ein <xref:System.IO.FileSystemWatcher.Deleted> Ereignis wird von FileSystemWatcher1 ausgelöst.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> in einer abgeleiteten Klasse überschreiben, stellen Sie sicher, dass Sie die <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />-Methode der Basisklasse aufzurufen.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnError : System.IO.ErrorEventArgs -&gt; unit" Usage="fileSystemWatcher.OnError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.IO.ErrorEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.IO.FileSystemWatcher.Error" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnError%2A> wird aufgerufen, wenn ein Fehler auftritt.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> in einer abgeleiteten Klasse überschreiben, stellen Sie sicher, dass Sie die <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />-Methode der Basisklasse aufzurufen.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnRenamed : System.IO.RenamedEventArgs -&gt; unit" Usage="fileSystemWatcher.OnRenamed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.IO.RenamedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.IO.FileSystemWatcher.Renamed" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnRenamed%2A> wird aufgerufen, wenn eine Datei oder ein Verzeichnis innerhalb des überwachten Verzeichnisses umbenannt wird. Das <xref:System.IO.RenamedEventArgs>-Argument enthält Informationen zum Umbenennungs Vorgang, z. b. den Typ der Änderung, den alten und den neuen Pfad und den alten und neuen Namen. Beachten Sie, dass die <xref:System.IO.FileSystemEventArgs.Name>-Eigenschaft für umbenannte Ereignisse NULL sein kann, wenn die <xref:System.IO.FileSystemWatcher> keine übereinstimmenden alten und neuen Namen Ereignisse aus dem Betriebssystem erhält. 
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> in einer abgeleiteten Klasse überschreiben, stellen Sie sicher, dass Sie die <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />-Methode der Basisklasse aufzurufen.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.IO.FileSystemWatcher.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The directory to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pfad des zu überwachenden Verzeichnisses ab oder legt diesen fest.</summary>
        <value>Der zu überwachende Pfad. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dabei handelt es sich um einen voll qualifizierten Pfad zu einem Verzeichnis. Wenn die <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>-Eigenschaft `true`ist, ist dieses Verzeichnis das Stammverzeichnis, in dem das System auf Änderungen überwacht wird. Andernfalls ist es das einzige Verzeichnis, das überwacht wird. Um eine bestimmte Datei zu beobachten, legen Sie die <xref:System.IO.FileSystemWatcher.Path%2A>-Eigenschaft auf das voll qualifizierte, korrekte Verzeichnis und die <xref:System.IO.FileSystemWatcher.Filter%2A>-Eigenschaft auf den Dateinamen fest.  
  
 Die <xref:System.IO.FileSystemWatcher.Path%2A>-Eigenschaft unterstützt Universal Naming Convention (UNC)-Pfade.  
  
> [!NOTE]
>  Diese Eigenschaft muss festgelegt werden, bevor die Komponente Änderungen überwachen kann.  
  
 Wenn ein Verzeichnis umbenannt wird, wird der <xref:System.IO.FileSystemWatcher> automatisch an das neu umbenannte Element angefügt. Wenn Sie z. b. die <xref:System.IO.FileSystemWatcher.Path%2A>-Eigenschaft auf "c:\Eigene Dokumente" festlegen und dann das Verzeichnis manuell in "c:\Your Documents" umbenennen, überwacht die Komponente weiterhin Änderungs Benachrichtigungen für das neu umbenannte Verzeichnis. Wenn Sie jedoch nach der <xref:System.IO.FileSystemWatcher.Path%2A>-Eigenschaft Fragen, enthält Sie den alten Pfad. Dies liegt daran, dass die Komponente bestimmt, welche Verzeichnisse auf der Grundlage des Handles überwacht werden, und nicht auf den Namen des Verzeichnisses. Das Umbenennen wirkt sich nicht auf das Handle aus. Wenn Sie also die Komponente zerstören und dann neu erstellen, ohne die <xref:System.IO.FileSystemWatcher.Path%2A>-Eigenschaft zu aktualisieren, schlägt die Anwendung fehl, da das Verzeichnis nicht mehr vorhanden ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.IO.FileSystemWatcher> erstellt, um das zur Laufzeit angegebene Verzeichnis zu überwachen. Die Komponente wird so festgelegt, dass Änderungen in `LastWrite` und `LastAccess` Zeit, das Erstellen, löschen oder Umbenennen von Textdateien im Verzeichnis überwacht werden. Wenn eine Datei geändert, erstellt oder gelöscht wird, wird der Pfad zur Datei in der Konsole gedruckt. Wenn eine Datei umbenannt wird, werden die alten und neuen Pfade in der Konsole gedruckt.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der angegebene Pfad ist nicht vorhanden oder konnte nicht gefunden werden.  
  
 - oder -  
  
 Der angegebene Pfad enthält Platzhalterzeichen.  
  
 - oder -  
  
 Der angegebene Pfad enthält ungültige Zeichen.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberSignature Language="F#" Value="member this.Renamed : System.IO.RenamedEventHandler " Usage="member this.Renamed : System.IO.RenamedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory rename matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Renamed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn im angegebenen <see cref="P:System.IO.FileSystemWatcher.Path" /> eine Datei oder ein Verzeichnis umbenannt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das `Renamed`-Ereignis ist ein <xref:System.IO.RenamedEventHandler> Delegat mit der folgenden Signatur:

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 Das <xref:System.IO.RenamedEventArgs>-Objekt enthält Informationen zum Umbenennungs Vorgang, z. b. den Typ der Umbenennung (die <xref:System.IO.FileSystemEventArgs.ChangeType>-Eigenschaft), den alten und neuen Namen sowie den alten und den neuen Pfad. Beachten Sie, dass die <xref:System.IO.FileSystemEventArgs.Name>-Eigenschaft für umbenannte Ereignisse NULL sein kann, wenn die <xref:System.IO.FileSystemWatcher> keine übereinstimmenden alten und neuen Namen Ereignisse aus dem Betriebssystem erhält.

 Beim Umbenennen des Verzeichnisses, das Sie überwachen, wird keine Benachrichtigung erhoben. Benachrichtigungen werden nur für Einträge in dem Verzeichnis ausgelöst, das Sie überwachen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das <xref:System.IO.FileSystemWatcher.Renamed>-Ereignis verwendet, um den Dateipfad der Konsole anzuzeigen, wenn die überwachte Datei umbenannt wird.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.IO.FileSystemWatcher.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.ComponentModel.ISite" /> für den <see cref="T:System.IO.FileSystemWatcher" /> ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.ComponentModel.ISite" /> für den <see cref="T:System.IO.FileSystemWatcher" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 -Standorte binden eine <xref:System.ComponentModel.Component> an eine <xref:System.ComponentModel.Design.IDesignerHost.Container%2A> und ermöglichen die Kommunikation zwischen Ihnen sowie eine Möglichkeit für den Container, seine Komponenten zu verwalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_SynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab, das zum Marshallen von Ereignishandleraufrufen verwendet wird, die aufgrund einer Verzeichnisänderung ausgegeben werden, oder legt dieses fest.</summary>
        <value>Das <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, das das Objekt zum Marshallen der Ereignishandleraufrufe darstellt, die aufgrund einer Verzeichnisänderung ausgegeben werden. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> `null`wird, werden Methoden, die die Ereignisse <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>und <xref:System.IO.FileSystemWatcher.Renamed> verarbeiten, in einem Thread aus dem Thread Pool des Systems aufgerufen. Weitere Informationen zu System Thread Pools finden Sie unter <xref:System.Threading.ThreadPool>.  
  
 Wenn die <xref:System.IO.FileSystemWatcher.Changed>-, <xref:System.IO.FileSystemWatcher.Created>-, <xref:System.IO.FileSystemWatcher.Deleted>-und <xref:System.IO.FileSystemWatcher.Renamed>-Ereignisse von einer visuellen Windows Forms Komponente behandelt werden, z. b. eine <xref:System.Windows.Forms.Button>, funktioniert der Zugriff auf die Komponente über den System Thread Pool möglicherweise nicht, oder es kann zu einer Ausnahme kommen. Vermeiden Sie dies, indem Sie <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> auf eine Windows Forms Komponente festlegen, die bewirkt, dass die Methoden, die die <xref:System.IO.FileSystemWatcher.Changed>-, <xref:System.IO.FileSystemWatcher.Created>-, <xref:System.IO.FileSystemWatcher.Deleted>-und <xref:System.IO.FileSystemWatcher.Renamed> Ereignisse behandeln, in demselben Thread aufgerufen werden, auf dem die Komponente erstellt wurde.  
  
 Wenn der <xref:System.IO.FileSystemWatcher> innerhalb [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in einem Windows Forms-Designer verwendet wird, legt <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> automatisch auf das Steuerelement fest, das den <xref:System.IO.FileSystemWatcher>enthält. Wenn Sie z. b. eine <xref:System.IO.FileSystemWatcher> in einem Designer für Form1 platzieren (der von <xref:System.Windows.Forms.Form>erbt), wird die Eigenschaft <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> von <xref:System.IO.FileSystemWatcher> auf die Instanz von Form1 festgelegt.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Eine synchrone Methode, die eine Struktur mit spezifischen Informationen zur eingetretenen Änderung zurückgibt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged changeType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType">Die zu überwachenden <see cref="T:System.IO.WatcherChangeTypes" />.</param>
        <summary>Eine synchrone Methode, die eine Struktur mit spezifischen Informationen zur eingetretenen Änderung zurückgibt, sofern diese mit der Art der Änderung übereinstimmt, die überwacht werden soll.</summary>
        <returns>Ein <see cref="T:System.IO.WaitForChangedResult" /> mit spezifischen Informationen zur eingetretenen Änderung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wartet unbegrenzt, bis die erste Änderung stattfindet, und gibt dann zurück. Dies entspricht dem Verwenden von <xref:System.IO.FileSystemWatcher.WaitForChanged%2A>, wobei der `timeout`-Parameter auf-1 festgelegt ist.  
  
> [!NOTE]
>  Diese Methode ermöglicht, dass ein Ereignishandler aufgerufen wird, um auf Dateiänderungen zu reagieren, auch wenn die <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>-Eigenschaft auf `false`festgelegt ist.  
  
 In manchen Systemen meldet <xref:System.IO.FileSystemWatcher> Änderungen an Dateien, die das kurze Format der Datei namens 8,3 aufweisen. Beispielsweise könnte eine Änderung an "longfilename. LongExtension" als "LongFi ~" (longfi ~) gemeldet werden. Lon ".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes * int -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged (changeType, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType">Die zu überwachenden <see cref="T:System.IO.WatcherChangeTypes" />.</param>
        <param name="timeout">Die Wartezeit (in Millisekunden) bis zum Timeout.</param>
        <summary>Eine synchrone Methode, die eine Struktur mit spezifischen Informationen zur eingetretenen Änderung zurückgibt, sofern diese mit der Art der zu überwachenden Änderung übereinstimmt und die Zeit (in Millisekunden) bis zum Timeout nicht abgelaufen ist.</summary>
        <returns>Ein <see cref="T:System.IO.WaitForChangedResult" /> mit spezifischen Informationen zur eingetretenen Änderung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wartet, bis eine Änderung auftritt oder ein Timeout aufgetreten ist. Der Wert-1 für den `timeout`-Parameter bedeutet, unbegrenzt zu warten.  
  
> [!NOTE]
>  Diese Methode ermöglicht, dass ein Ereignishandler aufgerufen wird, um auf Dateiänderungen zu reagieren, auch wenn die <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>-Eigenschaft auf `false`festgelegt ist.  
  
 In manchen Systemen meldet <xref:System.IO.FileSystemWatcher> Änderungen an Dateien, die das kurze Format der Datei namens 8,3 aufweisen. Beispielsweise könnte eine Änderung an "longfilename. LongExtension" als "LongFi ~" (longfi ~) gemeldet werden. Lon ".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>
