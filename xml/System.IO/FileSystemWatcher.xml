<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata><Meta Name="ms.openlocfilehash" Value="34b59e176f6aacaeb6923e933cee1e249087efb6" /><Meta Name="ms.sourcegitcommit" Value="22744e2f9d07a51900a968efffd9e390117d64a1" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/03/2019" /><Meta Name="ms.locfileid" Value="55673695" /></Metadata><TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type FileSystemWatcher = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("Changed")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.IO.IODescription("")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.IO.IODescription("FileSystemWatcherDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Überwacht die Benachrichtigungen über Änderungen im Dateisystem und löst Ereignisse aus, wenn ein Verzeichnis oder eine Datei in einem Verzeichnis geändert werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.IO.FileSystemWatcher> auf Änderungen in einem angegebenen Verzeichnis. Sie können Änderungen in Dateien und Unterverzeichnisse des angegebenen Verzeichnisses anzeigen. Sie können eine Komponente zum Überwachen von Dateien auf einem lokalen Computer, einem Netzlaufwerk oder einem Remotecomputer erstellen.  
  
 Legen Sie zum Überwachen auf Änderungen in allen Dateien der <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft auf eine leere Zeichenfolge ("") oder verwenden Sie Platzhalterzeichen ("*.\*"). Legen Sie zum Überwachen einer bestimmten Datei die <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft an den Dateinamen an. Um Änderungen in der Datei MyDoc.txt zu überwachen, z. B. Festlegen der <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft auf "MyDoc.txt". Sie können auch auf Änderungen in einen bestimmten Typ einer Datei anzeigen. Legen Sie z. B. zum Überwachen auf Änderungen in Textdateien die <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft "\*.txt".  
  
 Es gibt mehrere Arten von Änderungen, die Sie in einem Verzeichnis oder Datei in Betracht ziehen können. Sie können beispielsweise überwachen, Änderungen in `Attributes`, `LastWrite` Datum und die Uhrzeit oder `Size` der Dateien oder Verzeichnisse. Dies erfolgt durch Festlegen der <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> Eigenschaft eines der <xref:System.IO.NotifyFilters> Werte. Weitere Informationen zu den Typ der Änderungen, die Sie überwachen können, finden Sie unter <xref:System.IO.NotifyFilters>.  
  
 Sie können verfolgen, zum Umbenennen, löschen, und Erstellen von Dateien oder Verzeichnisse. Legen Sie z. B. zum Überwachen von Textdateien Umbenennen der <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft auf "*.txt", und rufen die <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> -Methode mit einem <xref:System.IO.WatcherChangeTypes.Renamed> festgelegten Parameter.  
  
 Das Windows-Betriebssystem benachrichtigt die Komponente der dateiänderungen in einem Puffer von erstellt die <xref:System.IO.FileSystemWatcher>. Wenn in kurzer Zeit viele Änderungen vorhanden sind, kann der Puffer überlaufen. Dies bewirkt, dass die Komponente, die Änderungen im Verzeichnis verliert, und stellen sie nur pauschaler-Benachrichtigung. Durch Erhöhen der Größe des Puffers mit der <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> -Eigenschaft ist aufwändig, wie es geht aus dem nicht ausgelagerte Arbeitsspeicher, die ausgelagert werden kann, auf die Festplatte als kleine Puffer noch große genug, um verpassen Sie nicht auf eine beliebige Datei Ereignisse ändern. Um einen Pufferüberlauf zu vermeiden, verwenden die <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> und <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> änderungsbenachrichtigungen für Eigenschaften, sodass Sie unerwünschte herausfiltern können.  
  
 Eine Liste der anfänglichen Eigenschaftswerte für eine Instanz von <xref:System.IO.FileSystemWatcher>, finden Sie unter den <xref:System.IO.FileSystemWatcher.%23ctor%2A> Konstruktor.  
  
 Beachten Sie Folgendes, wenn Sie verwenden die <xref:System.IO.FileSystemWatcher> Klasse.  
  
-   Ausgeblendete Dateien werden nicht ignoriert.  
  
-   In manchen Systemen – <xref:System.IO.FileSystemWatcher> meldet Änderungen an Dateien, die mit der kurzen der 8.3-Namensformat. Beispielsweise könnte eine Änderung an "Longfilename.LongExtension würde dann" gemeldet werden, als "LongFil ~. LON".  
  
-   Diese Klasse enthält einen Linkaufruf und einer vererbungsanforderung auf Klassenebene, die für alle Elemente gilt. Ein <xref:System.Security.SecurityException> wird ausgelöst, wenn Sie entweder den unmittelbaren Aufrufer oder die abgeleitete Klasse nicht über volle Vertrauenswürdigkeit verfügt. Weitere Informationen zu sicherheitsanforderungen, finden Sie unter [Verknüpfungsaufrufe](~/docs/framework/misc/link-demands.md).  
  
-   Die maximale Größe, Sie, für festlegen können, die <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> -Eigenschaft für die Überwachung von einem Verzeichnis über das Netzwerk ist 64 KB.  
  
> [!NOTE]
>  Ausführung <xref:System.IO.FileSystemWatcher> wird unter Windows 98 nicht unterstützt.  
  
## <a name="copying-and-moving-folders"></a>Kopieren und Verschieben von Ordnern  
 Das Betriebssystem und <xref:System.IO.FileSystemWatcher> Objekt interpretieren, eine Aktion Ausschneiden und einfügen oder eine Verschiebeaktion als Umbenennungsaktion für einen Ordner und seinen Inhalt. Wenn Sie Ausschneiden und Einfügen von einem Ordner mit Dateien in einen Ordner, der beobachtet wird, die <xref:System.IO.FileSystemWatcher> Objekt meldet nur den Ordner als neu, aber nicht dessen Inhalt, da sie nur im Grunde umbenannt werden.  
  
 Um benachrichtigt zu werden, dass die Inhalte der Ordner verschoben oder in einen überwachten Ordner kopiert wurden, bieten <xref:System.IO.FileSystemWatcher.OnChanged%2A> und <xref:System.IO.FileSystemWatcher.OnRenamed%2A> Ereignishandlermethoden gemäß dem Vorschlag in der folgenden Tabelle.  
  
|Ereignishandler|Behandelt Ereignisse|Führt|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>|Melden Sie Änderungen an Dateiattributen, erstellte Dateien und gelöschten Dateien.|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|Listen Sie die alten und neuen Pfade der umbenannten Dateien und Ordner rekursiv erweitert wird, falls erforderlich.|  
  
## <a name="events-and-buffer-sizes"></a>Ereignisse und die Puffergrößen  
 Beachten Sie, dass die Änderung von Dateisystemereignissen ausgelöst werden, verschiedene Faktoren beeinträchtigen können, wie im folgenden beschrieben:  
  
-   Allgemeine Dateisystemvorgänge können mehr als ein Ereignis auslösen. Z. B. wenn eine Datei aus einem Verzeichnis in einen anderen, mehrere verschoben wird <xref:System.IO.FileSystemWatcher.OnChanged%2A> und einige <xref:System.IO.FileSystemWatcher.OnCreated%2A> und <xref:System.IO.FileSystemWatcher.OnDeleted%2A> Ereignisse ausgelöst werden können. Verschieben von, dass eine Datei ein komplexer Vorgang, der aus mehreren einfachen Vorgängen besteht, daher auslöst mehrere Ereignisse. Ebenso einige Anwendungen (z. B. Antivirenprogramme) können dazu führen, dass zusätzliche Dateisystemereignissen, die vom erkannt werden <xref:System.IO.FileSystemWatcher>.  
  
-   Die <xref:System.IO.FileSystemWatcher> Datenträger können sich ansehen, solange sie nicht geändert oder entfernt werden. Die <xref:System.IO.FileSystemWatcher> löst keine Ereignisse für CDs und DVDs, da der Zeitstempel und Eigenschaften nicht geändert werden können. Remote-Computern müssen eines der erforderlichen Plattformen für die Komponente ordnungsgemäß installiert haben.  
  
-   Wenn mehrere <xref:System.IO.FileSystemWatcher> beobachten Objekte den gleichen UNC-Pfad in Windows XP vor Service Pack 1 oder Windows 2000 Service Pack 2 oder früher, und klicken Sie dann nur eines der Objekte wird ein Ereignis auslösen. Ausführen von auf Computern Windows XP SP1 und höher, Windows 2000 SP3 oder höher oder Windows Server 2003, alle <xref:System.IO.FileSystemWatcher> Objekte werden die entsprechenden Ereignisse auszulösen.  
  
 Beachten Sie, dass eine <xref:System.IO.FileSystemWatcher> verpassen Sie möglicherweise ein Ereignis, wenn die Größe des Puffers überschritten wird. Beachten Sie Folgendes, um fehlende Ereignisse zu vermeiden:  
  
-   Erhöhen Sie die Größe des Puffers durch Festlegen der <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> Eigenschaft.  
  
-   Vermeiden Sie die Überwachung von Dateien mit langen Dateinamen, da es sich bei ein langer Dateiname füllt den Puffer unterstützt. Sollten Sie diese Dateien mithilfe von kürzeren Namen umbenennen.  
  
-   Behalten Sie den Ereignisbehandlungscode so kurz wie möglich.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.IO.FileSystemWatcher> zum Überwachen des Verzeichnisses, das zur Laufzeit angegeben. Die Komponente festgelegt ist, auf Änderungen in `LastWrite` und `LastAccess` Zeit, zu erstellen, löschen oder Umbenennen von Textdateien im Verzeichnis. Wenn eine Datei geändert wird, erstellt oder gelöscht wird, gibt den Pfad zur Datei an der Konsole aus. Wenn eine Datei umbenannt wird, werden die alten und neuen Pfade auf der Konsole ausgegeben.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">für die Ableitung von der <see cref="T:System.Diagnostics.ProcessStartInfo" /> Klasse. Anforderungswert: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />; Benannte Berechtigungssätze: <see langword="FullTrust" />.</permission>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Using-a-FileSystemWatcher-4bc97af4">Mithilfe einer FileSystemWatcher-Komponente in einem Windows-Formular</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileSystemWatcher" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileSystemWatcher" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können keinen Remotecomputer anzeigen, die nicht Windows NT oder Windows 2000. Sie können kein Remotecomputer Windows NT 4.0 auf einem Windows NT 4.0-Computer überwacht.  
  
 In der folgende Tabelle werden die anfänglichen Eigenschaftenwerte für eine Instanz von <xref:System.IO.FileSystemWatcher>.  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|bitweise OR-Kombination von `LastWrite`, `FileName`, und `DirectoryName`|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|"*. \*"(Alle Dateien überwachen.)|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|8192|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|eine leere Zeichenfolge ("")|  
  
> [!NOTE]
>  Die Komponente wird nicht sehen Sie sich das angegebene Verzeichnis an, bis die <xref:System.IO.FileSystemWatcher.Path%2A> festgelegt ist, und <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> ist `true`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.IO.FileSystemWatcher> Objekt, das Überwachen des Verzeichnisses, das zur Laufzeit angegeben. Die <xref:System.IO.FileSystemWatcher> Objekt wird überwacht, ob Sie Änderungen in `LastWrite` und `LastAccess` Wiederherstellungszeiten und für die Erstellung, löschen oder Umbenennen von Text-Dateien im Verzeichnis. Wenn eine Datei geändert wird, erstellt oder gelöscht wird, zeigt der Pfad zur Datei, in der Konsole. Wenn eine Datei umbenannt wird, werden die alten und neuen Pfade in der Konsole anzeigen.  
  
 Dieses Beispiel verwendet die <xref:System.Diagnostics> und <xref:System.IO> Namespaces.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Das zu überwachende Verzeichnis in der Standard- oder UNC (Universal Naming Convention)-Notation.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileSystemWatcher" />-Klasse mit dem für die Überwachung angegebenen Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die Komponente wird nicht sehen Sie sich das angegebene Verzeichnis an, bis die <xref:System.IO.FileSystemWatcher.Path%2A> festgelegt ist, und <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> ist `true`.  
  
 Die Komponente kann Dateien auf Ihrem PC, einem Netzlaufwerk oder einem Remotecomputer anzeigen.  
  
 Sie können keinen Remotecomputer anzeigen, die nicht Windows NT oder Windows 2000. Sie können kein Remotecomputer Windows NT 4.0 auf einem Windows NT 4.0-Computer überwacht. Die <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft ist standardmäßig so eingestellt, alle Dateien überwacht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist eine leere Zeichenfolge ("").  
  
- oder - 
Der durch den <paramref name="path" />-Parameter angegebene Pfad ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> ist zu lang.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string * string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher (path, filter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Das zu überwachende Verzeichnis in der Standard- oder UNC (Universal Naming Convention)-Notation.</param>
        <param name="filter">Der zu überwachende Dateityp. Bei "*.txt" werden z. B. alle Textdateien auf Änderungen überwacht.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileSystemWatcher" />-Klasse mit dem für die Überwachung angegebenen Verzeichnis und Dateityp.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die Komponente wird nicht sehen Sie sich das angegebene Verzeichnis an, bis die <xref:System.IO.FileSystemWatcher.Path%2A> festgelegt ist, und <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> ist `true`.  
  
 Die Komponente kann Dateien auf Ihrem PC, einem Netzlaufwerk oder einem Remotecomputer anzeigen.  
  
 Sie können keinen Remotecomputer anzeigen, die nicht Windows NT oder Windows 2000. Sie können kein Remotecomputer Windows NT 4.0 auf einem Windows NT 4.0-Computer überwacht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.  
  
- oder - 
Der <paramref name="filter" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist eine leere Zeichenfolge ("").  
  
- oder - 
Der durch den <paramref name="path" />-Parameter angegebene Pfad ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> ist zu lang.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">für volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann von nur teilweise vertrauenswürdigem Code nicht verwendet werden.</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="fileSystemWatcher.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beginnt die Initialisierung von <see cref="T:System.IO.FileSystemWatcher" /> für die Verwendung in einem Formular oder durch eine andere Komponente. Die Initialisierung erfolgt zur Laufzeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Entwurf, die Umgebung verwendet diese Methode, um die Initialisierung einer Komponente starten Verwendung in einem Formular oder von einer anderen Komponente verwendet. Die <xref:System.IO.FileSystemWatcher.EndInit%2A> -Methode beendet die Initialisierung. Mithilfe der <xref:System.IO.FileSystemWatcher.BeginInit%2A> und <xref:System.IO.FileSystemWatcher.EndInit%2A> Methoden wird verhindert, dass das Steuerelement verwendet werden, bevor er vollständig initialisiert wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : System.IO.FileSystemEventHandler " Usage="member this.Changed : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory change matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Changed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn im angegebenen <see cref="P:System.IO.FileSystemWatcher.Path" /> eine Datei oder ein Verzeichnis geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.FileSystemWatcher.Changed> -Ereignis wird ausgelöst, wenn Änderungen vorgenommen werden, auf die Größe, Systemattributen letzter Schreibzugriff Zeit, Zeitpunkt des letzten Zugriffs oder Sicherheitsberechtigungen einer Datei oder Verzeichnis in das Verzeichnis, die überwacht werden.  
  
> [!NOTE]
>  Allgemeine Dateisystemvorgänge können mehr als ein Ereignis auslösen. Z. B. wenn eine Datei aus einem Verzeichnis in einen anderen, mehrere verschoben wird <xref:System.IO.FileSystemWatcher.OnChanged%2A> und einige <xref:System.IO.FileSystemWatcher.OnCreated%2A> und <xref:System.IO.FileSystemWatcher.OnDeleted%2A> Ereignisse ausgelöst werden können. Verschieben von, dass eine Datei ein komplexer Vorgang, der aus mehreren einfachen Vorgängen besteht, daher auslöst mehrere Ereignisse. Ebenso einige Anwendungen (z. B. Antivirenprogramme) können dazu führen, dass zusätzliche Dateisystemereignissen, die vom erkannt werden <xref:System.IO.FileSystemWatcher>.  
  
 Verwendung <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> zum Einschränken der Anzahl von Benachrichtigungen wird ausgelöst, wenn dieses Ereignis behandelt wird.  
  
> [!NOTE]
>  Die <xref:System.IO.FileSystemWatcher.Changed> -Ereignis unerwartet ausgelöst, wenn eine Datei umbenannt wird, aber nicht ausgelöst, wenn ein Verzeichnis umbenannt wird. Verwenden Sie zum Umbenennen von zu überwachen, die <xref:System.IO.FileSystemWatcher.Renamed> Ereignis.  
  
> [!NOTE]
>  Die Reihenfolge, in der <xref:System.IO.FileSystemWatcher.Changed> Ereignis wird ausgelöst, in Bezug auf die andere <xref:System.IO.FileSystemWatcher> Ereignisse möglicherweise ändern, wenn die <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> Eigenschaft ist nicht `null`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.FileSystemWatcher.Changed> Ereignis, um den Dateipfad in der Konsole anzeigen, wenn die überwachte Datei geändert wird.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberSignature Language="F#" Value="member this.Created : System.IO.FileSystemEventHandler " Usage="member this.Created : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory creation matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Created")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn im angegebenen <see cref="P:System.IO.FileSystemWatcher.Path" /> eine Datei oder ein Verzeichnis erstellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige allgemeine Vorgänge, z. B. kopieren oder Verschieben einer Datei oder eines Verzeichnisses, entsprechen nicht direkt auf ein Ereignis, aber solche führen dazu, dass Ereignisse ausgelöst werden. Wenn Sie eine Datei oder ein Verzeichnis kopieren, löst das System eine <xref:System.IO.FileSystemWatcher.Created> Ereignis in das Verzeichnis, die Datei wurde kopiert, sofern dieses Verzeichnis überwacht wird. Wenn das Verzeichnis, aus der Sie kopiert, wurde von einer anderen Instanz beobachtet <xref:System.IO.FileSystemWatcher>, würde kein Ereignis ausgelöst werden. Beispielsweise erstellen Sie zwei Instanzen von <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 nastaven NA hodnotu "C:\My Dokumente" sehen Sie sich, und FileSystemWatcher2 nastaven NA hodnotu "C:\Your Dokumente" sehen Sie sich an. Wenn Sie eine Datei aus "Eigene Dateien" in "Ihre Dokumente", Kopieren einer <xref:System.IO.FileSystemWatcher.Created> Ereignis wird von FileSystemWatcher2 ausgelöst werden, aber kein Ereignis für FileSystemWatcher1 ausgelöst. Im Gegensatz zu kopieren, würde das Verschieben einer Datei oder Verzeichnis zwei Ereignisse auslösen. Aus dem vorherigen Beispiel, wenn Sie eine Datei aus "Eigene Dokumente" auf "Ihre Dokumente" verschoben eine <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2-Ereignis ausgelöst werden und ein <xref:System.IO.FileSystemWatcher.Deleted> FileSystemWatcher1-Ereignis ausgelöst werden.  
  
> [!NOTE]
>  Allgemeine Dateisystemvorgänge können mehr als ein Ereignis auslösen. Z. B. wenn eine Datei aus einem Verzeichnis in einen anderen, mehrere verschoben wird <xref:System.IO.FileSystemWatcher.OnChanged%2A> und einige <xref:System.IO.FileSystemWatcher.OnCreated%2A> und <xref:System.IO.FileSystemWatcher.OnDeleted%2A> Ereignisse ausgelöst werden können. Verschieben von, dass eine Datei ein komplexer Vorgang, der aus mehreren einfachen Vorgängen besteht, daher auslöst mehrere Ereignisse. Ebenso einige Anwendungen (z. B. Antivirenprogramme) können dazu führen, dass zusätzliche Dateisystemereignissen, die vom erkannt werden <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  Die Reihenfolge, in der <xref:System.IO.FileSystemWatcher.Created> Ereignis wird ausgelöst, in Bezug auf die andere <xref:System.IO.FileSystemWatcher> Ereignisse möglicherweise ändern, wenn die <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> Eigenschaft ist nicht `null`.  
  
 Die <xref:System.IO.FileSystemWatcher.OnCreated%2A> Ereignis wird ausgelöst, sobald eine Datei erstellt wird. Wenn eine Datei wird in einem überwachten Verzeichnis kopiert oder Übertragen der <xref:System.IO.FileSystemWatcher.OnCreated%2A> Ereignis ausgelöst, gefolgt von einem oder mehreren <xref:System.IO.FileSystemWatcher.OnChanged%2A> Ereignisse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.FileSystemWatcher.Created> Ereignis, um den Dateipfad in der Konsole anzeigen, wenn die überwachte Datei erstellt wird.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : System.IO.FileSystemEventHandler " Usage="member this.Deleted : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory deletion matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Deleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn im angegebenen <see cref="P:System.IO.FileSystemWatcher.Path" /> eine Datei oder ein Verzeichnis gelöscht wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige allgemeine Vorgänge, z. B. kopieren oder Verschieben einer Datei oder eines Verzeichnisses, entsprechen nicht direkt auf ein Ereignis, aber solche führen dazu, dass Ereignisse ausgelöst werden. Wenn Sie eine Datei oder ein Verzeichnis kopieren, löst das System eine <xref:System.IO.FileSystemWatcher.Created> Ereignis in das Verzeichnis, die Datei wurde kopiert, sofern dieses Verzeichnis überwacht wird. Wenn das Verzeichnis, aus der Sie kopiert, wurde von einer anderen Instanz beobachtet <xref:System.IO.FileSystemWatcher>, würde kein Ereignis ausgelöst werden. Beispielsweise erstellen Sie zwei Instanzen von <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 nastaven NA hodnotu "C:\My Dokumente" sehen Sie sich, und FileSystemWatcher2 nastaven NA hodnotu "C:\Your Dokumente" sehen Sie sich an. Wenn Sie eine Datei aus "Eigene Dateien" in "Ihre Dokumente", Kopieren einer <xref:System.IO.FileSystemWatcher.Created> Ereignis wird von FileSystemWatcher2 ausgelöst werden, aber kein Ereignis für FileSystemWatcher1 ausgelöst. Im Gegensatz zu kopieren, würde das Verschieben einer Datei oder Verzeichnis zwei Ereignisse auslösen. Aus dem vorherigen Beispiel, wenn Sie eine Datei aus "Eigene Dokumente" auf "Ihre Dokumente" verschoben eine <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2-Ereignis ausgelöst werden und ein <xref:System.IO.FileSystemWatcher.Deleted> FileSystemWatcher1-Ereignis ausgelöst werden.  
  
> [!NOTE]
>  Allgemeine Dateisystemvorgänge können mehr als ein Ereignis auslösen. Z. B. wenn eine Datei aus einem Verzeichnis in einen anderen, mehrere verschoben wird <xref:System.IO.FileSystemWatcher.OnChanged%2A> und einige <xref:System.IO.FileSystemWatcher.OnCreated%2A> und <xref:System.IO.FileSystemWatcher.OnDeleted%2A> Ereignisse ausgelöst werden können. Verschieben von, dass eine Datei ein komplexer Vorgang, der aus mehreren einfachen Vorgängen besteht, daher auslöst mehrere Ereignisse. Ebenso einige Anwendungen (z. B. Antivirenprogramme) können dazu führen, dass zusätzliche Dateisystemereignissen, die vom erkannt werden <xref:System.IO.FileSystemWatcher>.  
  
> [!NOTE]
>  Die Reihenfolge, in der <xref:System.IO.FileSystemWatcher.Deleted> Ereignis wird ausgelöst, in Bezug auf die andere <xref:System.IO.FileSystemWatcher> Ereignisse möglicherweise ändern, wenn die <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> Eigenschaft ist nicht `null`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.FileSystemWatcher.Deleted> Ereignis, um den Dateipfad an der Konsole angezeigt wird, sobald die überwachte Datei gelöscht wird.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.IO.FileSystemWatcher" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, von der öffentlichen <xref:System.ComponentModel.Component.Dispose%2A> Methode und die <xref:System.Object.Finalize%2A> Methode. <xref:System.ComponentModel.Component.Dispose%2A> Ruft die geschützte <xref:System.IO.FileSystemWatcher.Dispose%2A> -Methode mit dem `disposing` Parametersatz zu `true`. <xref:System.Object.Finalize%2A> Ruft <xref:System.IO.FileSystemWatcher.Dispose%2A> mit `disposing` festgelegt `false`.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.IO.Compression.DeflateStream> verweist. Diese Methode ruft die <xref:System.ComponentModel.Component.Dispose%2A>-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" /> Achten Sie darauf, dass Sie nicht auf Objekte verweisen, die zuvor von einem früheren Aufruf freigegeben wurden <see cref="M:System.ComponentModel.Component.Dispose" />. Weitere Informationen zur Implementierung <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Weitere Informationen zu <see cref="M:System.ComponentModel.Component.Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate if this instance is active")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Enabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Komponente aktiviert ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Komponente aktiviert ist, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />. Wenn Sie die Komponente in einem Designer in [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] verwenden, ist der Standardwert <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Komponente werden keine Ereignisse ausgelöst, es sei denn, Sie <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> zu `true`.  
  
> [!NOTE]
>  Die Komponente wird nicht sehen Sie sich das angegebene Verzeichnis an, bis die <xref:System.IO.FileSystemWatcher.Path%2A> -Eigenschaft festgelegt wurde und <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> ist `true`.  
  
 Die <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> Methode ermöglicht die Ereignishandler aufgerufen werden, um auf Änderungen zu reagieren, selbst wenn diese Eigenschaft, um festgelegt wird `false`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.IO.FileSystemWatcher> zum Überwachen des Verzeichnisses, das zur Laufzeit angegeben. Die Komponente festgelegt ist, auf Änderungen in `LastWrite` und `LastAccess` Zeit, zu erstellen, löschen oder Umbenennen von Textdateien im Verzeichnis. Wenn eine Datei geändert wird, erstellt oder gelöscht wird, gibt den Pfad zur Datei an der Konsole aus. Wenn eine Datei umbenannt wird, werden die alten und neuen Pfade auf der Konsole ausgegeben.  
  
 Verwenden der <xref:System.Diagnostics> und <xref:System.IO> Namespaces für dieses Beispiel.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.IO.FileSystemWatcher" />-Objekt wurde verworfen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Microsoft Windows NT oder höher.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Das in <see cref="P:System.IO.FileSystemWatcher.Path" /> angegebene Verzeichnis konnte nicht gefunden werden.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.IO.FileSystemWatcher.Path" /> wurde nicht festgelegt oder ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="fileSystemWatcher.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet die Initialisierung von <see cref="T:System.IO.FileSystemWatcher" /> für die Verwendung in einem Formular oder durch eine andere Komponente. Die Initialisierung erfolgt zur Laufzeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Entwurf, die Umgebung verwendet diese Methode beendet die Initialisierung einer Komponente in einem Formular verwendet oder von einer anderen Komponente verwendet. Die <xref:System.IO.FileSystemWatcher.BeginInit%2A> -Methode startet die Initialisierung. Mithilfe der <xref:System.IO.FileSystemWatcher.BeginInit%2A> und <xref:System.IO.FileSystemWatcher.EndInit%2A> Methoden wird verhindert, dass das Steuerelement verwendet werden, bevor er vollständig initialisiert wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.ErrorEventHandler " Usage="member this.Error : System.IO.ErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die Instanz von <see cref="T:System.IO.FileSystemWatcher" /> das Überwachen von Änderungen nicht fortzusetzen kann oder wenn der interne Puffer überläuft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn etwas wird verhindert, dass die <xref:System.IO.FileSystemWatcher> Objekt von der Überwachung von Änderungen. Wenn das Objekt Änderungen in einem Remoteverzeichnis überwacht und die Verbindung zu diesem Verzeichnis verloren geht, z. B. die <xref:System.IO.FileSystemWatcher.Error> Ereignis wird ausgelöst.  
  
 Das System benachrichtigt Sie bei Änderungen der Datenbankdatei und speichert die Änderungen in einen Puffer, den der Komponente erstellt und übergibt an die APIs. Wenn in kurzer Zeit viele Änderungen vorhanden sind, kann der Puffer überlaufen. Dies bewirkt, dass die Komponente, die Änderungen im Verzeichnis verliert, und stellen sie nur pauschaler-Benachrichtigung. Durch Erhöhen der Größe des Puffers ist teuer, da es nicht stammt ausgelagerte Arbeitsspeicher, die ausgelagert werden kann, auf den Datenträger also lassen den Puffer so klein wie möglich. Um einen Pufferüberlauf zu vermeiden, verwenden die <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.Filter%2A>, und <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> Eigenschaften filtern, die unerwünschte änderungsbenachrichtigungen.  
  
> [!NOTE]
>  Allgemeine Dateisystemvorgänge können mehr als ein Ereignis auslösen. Z. B. wenn eine Datei aus einem Verzeichnis in einen anderen, mehrere verschoben wird <xref:System.IO.FileSystemWatcher.OnChanged%2A> und einige <xref:System.IO.FileSystemWatcher.OnCreated%2A> und <xref:System.IO.FileSystemWatcher.OnDeleted%2A> Ereignisse ausgelöst werden können. Verschieben von, dass eine Datei ein komplexer Vorgang, der aus mehreren einfachen Vorgängen besteht, daher auslöst mehrere Ereignisse. Ebenso einige Anwendungen (z. B. Antivirenprogramme) können dazu führen, dass zusätzliche Dateisystemereignissen, die vom erkannt werden <xref:System.IO.FileSystemWatcher>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : string with get, set" Usage="System.IO.FileSystemWatcher.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("*.*")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("File name filter pattern")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Filterzeichenfolge ab, mit der die in einem Verzeichnis zu überwachenden Dateien bestimmt werden, oder legt die Filterzeichenfolge fest.</summary>
        <value>Die Filterzeichenfolge. Der Standardwert ist "*. \*"(Alle Dateien überwachen.)</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie zum Überwachen von Änderungen in allen Dateien der <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft auf eine leere Zeichenfolge (""). Legen Sie zum Überwachen einer bestimmten Datei die <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft an den Dateinamen an. Um Änderungen in der Datei MyDoc.txt zu überwachen, z. B. Festlegen der <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft auf "MyDoc.txt". Sie können auch auf Änderungen in einen bestimmten Typ einer Datei anzeigen. Legen Sie z. B. zum Überwachen auf Änderungen in jedem Text-Dateien der <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft auf "*.txt". Verwendung von mehreren Filtern, z. B. "\*.txt&#124;\*doc" wird nicht unterstützt.  
  
 Die <xref:System.IO.FileSystemWatcher.Filter%2A> -Eigenschaft geändert werden kann, nachdem die <xref:System.IO.FileSystemWatcher> Objekt wurde empfangen von Ereignissen gestartet.  
  
 Weitere Informationen zum Filtern unerwünschter Benachrichtigungen finden Sie unter den <xref:System.IO.FileSystemWatcher.NotifyFilter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, und <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> Eigenschaften.  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A> akzeptiert Platzhalter für übereinstimmende Dateien an, wie in den folgenden Beispielen gezeigt.  
  
|Filterzeichenfolge|Überwacht die folgenden Dateien|  
|-------------------|---------------------------------|  
|*.\*|Alle Dateien (Standard). Eine leere Zeichenfolge ("") ebenfalls alle Dateien überwacht.|  
|*.txt|Alle Dateien mit der Erweiterung "Txt".|  
|*Recipe.doc|Alle Dateien in "Rezept" mit der Erweiterung "Doc" enden.|  
|win*.xml|Alle Dateien, die mit der Erweiterung "Xml" ab "Win".|  
|Umsatz * 200. xls|Entspricht der folgenden:<br /><br /> Sales Juli 2001.xlsSales Aug 2002.xlsSales März 2004.xls<br /><br /> stimmt jedoch nicht mit:<br /><br /> Sales Nov 1999.xls|  
|MyReport.Doc|Überwacht nur MyReport.doc.|  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.IO.FileSystemWatcher> zum Überwachen des Verzeichnisses, das zur Laufzeit angegeben. Die Komponente festgelegt ist, auf Änderungen in `LastWrite` und `LastAccess` Zeit, zu erstellen, löschen oder Umbenennen von Textdateien im Verzeichnis. Wenn eine Datei geändert wird, erstellt oder gelöscht wird, gibt den Pfad zur Datei an der Konsole aus. Wenn eine Datei umbenannt wird, werden die alten und neuen Pfade auf der Konsole ausgegeben.  
  
 Verwenden der <xref:System.Diagnostics> und <xref:System.IO> Namespaces für dieses Beispiel.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileSystemWatcher.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeSubdirectories : bool with get, set" Usage="System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate we want to watch subdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_IncludeSubdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Unterverzeichnisse im angegebenen Pfad überwacht werden sollen, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Unterverzeichnisse überwacht werden sollen, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> zu `true` sollen für änderungsbenachrichtigungen für Dateien und Verzeichnissen über angegebene Verzeichnis enthaltenen sehen Sie sich die <xref:System.IO.FileSystemWatcher.Path%2A> Eigenschaft und seinen Unterverzeichnissen. Festlegen der <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> Eigenschaft `false` können reduziert werden, die Anzahl der Benachrichtigungen, die auf den internen Puffer gesendet. Weitere Informationen zum Filtern unerwünschter Benachrichtigungen finden Sie unter den <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> und <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> Eigenschaften.  
  
 Wenn `true`, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> wird die gesamte Teilstruktur, nicht nur die unmittelbar untergeordneten Verzeichnisse rekursiv. Gibt der relative Pfad zu einer Datei oder Verzeichnis innerhalb der Teilstruktur zurück, der <xref:System.IO.FileSystemEventArgs.Name%2A> Eigenschaft <xref:System.IO.FileSystemEventArgs> und <xref:System.IO.RenamedEventArgs.OldName%2A> Eigenschaft <xref:System.IO.RenamedEventArgs>, je nachdem, auf Änderungen, die Sie für beobachten. Erhalten Sie den vollständig qualifizierten Pfad von der <xref:System.IO.FileSystemEventArgs.FullPath%2A> Eigenschaft <xref:System.IO.FileSystemEventArgs> und <xref:System.IO.RenamedEventArgs.OldFullPath%2A> Eigenschaft <xref:System.IO.RenamedEventArgs>, je nachdem, auf die Änderungen, die Sie für beobachten.  
  
 Wenn ein Verzeichnis in der Teilstruktur des Verzeichnisses erstellt wurde, Sie beobachten, und <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> ist `true`, dieses Verzeichnis automatisch überwacht.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.InternalBufferSize : int with get, set" Usage="System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(8192)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe (in Byte) des internen Puffers ab oder legt diese fest.</summary>
        <value>Die interne Puffergröße in Byte. Der Standardwert ist 8192 (8 KB).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den Puffer auf 4 KB oder höher festlegen, aber es darf nicht mehr als 64 KB. Wenn Sie versuchen, legen Sie die <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> Eigenschaft zu kleiner als 4096 Bytes, den Wert verworfen und die <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> -Eigenschaftensatz auf maximal 4096 Bytes. Verwenden Sie für eine optimale Leistung ein Vielfaches von 4 KB auf Intel-basierten Computern.  
  
 Benachrichtigt die Komponente von dateiänderungen, das System, und speichert die Änderungen in einem Puffer, den der Komponente erstellt und übergibt an die APIs. Jedes Ereignis können bis zu 16 Bytes an Arbeitsspeicher, ohne den Dateinamen an. Wenn in kurzer Zeit viele Änderungen vorhanden sind, kann der Puffer überlaufen. Dies bewirkt, dass die Komponente, die Änderungen im Verzeichnis verliert, und stellen sie nur pauschaler-Benachrichtigung. Durch Erhöhen der Größe des Puffers kann verhindern, dass Ereignisse fehlen Dateisystem ändern. Erhöhen der Größe des Puffers ist jedoch teuer, da es nicht ausgelagerten Speicher, die ausgelagert werden kann stammt, um auf den Datenträger, sodass Sie die so klein wie möglich halten sollten. Um einen Pufferüberlauf zu vermeiden, verwenden die <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> und <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> Eigenschaften filtern, die unerwünschte änderungsbenachrichtigungen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyFilter : System.IO.NotifyFilters with get, set" Usage="System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate which change event we want to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_ChangedFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ der zu überwachenden Änderungen ab oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.IO.NotifyFilters" />-Werte. Der Standardwert ist die bitweise OR-Kombination von <see langword="LastWrite" />, <see langword="FileName" /> und <see langword="DirectoryName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die Mitglieder der Kombinieren der <xref:System.IO.NotifyFilters> Enumeration, um für mehr als eine Art der Änderung zu einem Zeitpunkt ansehen. Sie können beispielsweise überwachen, bis Änderungen an der Größe einer Datei, und Änderungen in der `LastWrite` Zeit. Dies löst ein Ereignis jedes Mal, wenn eine Änderung im Datei- oder Ordnergröße vorhanden, oder eine Änderung ist die `LastWrite` der Datei oder des Ordners.  
  
 Dies ist eine Möglichkeit zum Filtern unerwünschter Benachrichtigungen. Weitere Informationen zum Filtern unerwünschter Benachrichtigungen finden Sie unter den <xref:System.IO.FileSystemWatcher.Filter%2A>, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>, und <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> Eigenschaften.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.IO.FileSystemWatcher> zum Überwachen des Verzeichnisses, das zur Laufzeit angegeben. Die Komponente festgelegt ist, auf Änderungen in `LastWrite` und `LastAccess` Zeit, zu erstellen, löschen oder Umbenennen von Textdateien im Verzeichnis. Wenn eine Datei geändert wird, erstellt oder gelöscht wird, gibt den Pfad zur Datei an der Konsole aus. Wenn eine Datei umbenannt wird, werden die alten und neuen Pfade auf der Konsole ausgegeben.  
  
 Verwenden der <xref:System.Diagnostics> und <xref:System.IO> Namespaces für dieses Beispiel.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Wert ist keine gültige bitweise OR-Kombination der <see cref="T:System.IO.NotifyFilters" />-Werte.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der festgelegte Wert ist ungültig.</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.IO.FileSystemEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.IO.FileSystemWatcher.Changed" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnChanged%2A> wird aufgerufen, wenn Änderungen an der Größe, Systemattribute, letzte Schreibzeit, Zeitpunkt des letzten Zugriffs oder Sicherheitsberechtigungen einer Datei oder Verzeichnis im überwachten Verzeichnis vorgenommen werden.  
  
 Verwenden der <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> Eigenschaft zum Einschränken der Anzahl von Ereignissen wird ausgelöst, wenn die <xref:System.IO.FileSystemWatcher.Changed> -Ereignis behandelt wird.  
  
 Die <xref:System.IO.FileSystemWatcher.OnCreated%2A> Ereignis wird ausgelöst, sobald eine Datei erstellt wird. Wenn eine Datei wird in einem überwachten Verzeichnis kopiert oder Übertragen der <xref:System.IO.FileSystemWatcher.OnCreated%2A> Ereignis ausgelöst, gefolgt von einem oder mehreren <xref:System.IO.FileSystemWatcher.OnChanged%2A> Ereignisse.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Beim Überschreiben von <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> in einer abgeleiteten Klasse, werden Sie sicher, dass der Basisklasse aufrufen <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> Methode.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnCreated : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.IO.FileSystemEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.IO.FileSystemWatcher.Created" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> wird aufgerufen, wenn eine Datei oder ein Verzeichnis im überwachten Verzeichnis erstellt wird.  
  
 Einige allgemeine Vorgänge, z. B. kopieren oder Verschieben einer Datei oder eines Verzeichnisses, entsprechen nicht direkt auf ein Ereignis, aber solche führen dazu, dass Ereignisse ausgelöst werden. Wenn Sie eine Datei oder ein Verzeichnis kopieren, löst das System eine <xref:System.IO.FileSystemWatcher.Created> Ereignis in das Verzeichnis, die Datei wurde kopiert, sofern dieses Verzeichnis überwacht wird. Wenn das Verzeichnis, aus der Sie kopiert, wurde von einer anderen Instanz beobachtet <xref:System.IO.FileSystemWatcher>, würde kein Ereignis ausgelöst werden. Beispielsweise erstellen Sie zwei Instanzen von <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 nastaven NA hodnotu "C:\My Dokumente" sehen Sie sich, und FileSystemWatcher2 nastaven NA hodnotu "C:\Your Dokumente" sehen Sie sich an. Wenn Sie eine Datei aus "Eigene Dateien" kopieren und fügen Sie ihn in "Ihre Dokumente", eine <xref:System.IO.FileSystemWatcher.Created> in FileSystemWatcher2 Ereignis ausgelöst, aber kein Ereignis für FileSystemWatcher1 ausgelöst. Im Gegensatz zu kopieren, Verschieben einer Datei oder Verzeichnis werden zwei Ereignisse ausgelöst. Aus dem vorherigen Beispiel, wenn Sie eine Datei aus "Eigene Dokumente" auf "Ihre Dokumente" verschoben eine <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2-Ereignis ausgelöst werden und ein <xref:System.IO.FileSystemWatcher.Deleted> FileSystemWatcher1-Ereignis ausgelöst werden.  
  
 Die <xref:System.IO.FileSystemWatcher.OnCreated%2A> Ereignis wird ausgelöst, sobald eine Datei erstellt wird. Wenn eine Datei wird in einem überwachten Verzeichnis kopiert oder Übertragen der <xref:System.IO.FileSystemWatcher.OnCreated%2A> Ereignis ausgelöst, gefolgt von einem oder mehreren <xref:System.IO.FileSystemWatcher.OnChanged%2A> Ereignisse.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Beim Überschreiben von <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> in einer abgeleiteten Klasse, werden Sie sicher, dass der Basisklasse aufrufen <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> Methode.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnDeleted : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.IO.FileSystemEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.IO.FileSystemWatcher.Deleted" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> wird aufgerufen, wenn eine Datei oder ein Verzeichnis, in das Verzeichnis, das überwacht wird, gelöscht wird.  
  
 Einige allgemeine Vorgänge, z. B. kopieren oder Verschieben einer Datei oder eines Verzeichnisses, entsprechen nicht direkt auf ein Ereignis, aber solche führen dazu, dass Ereignisse ausgelöst werden. Wenn Sie eine Datei oder ein Verzeichnis kopieren, löst das System eine <xref:System.IO.FileSystemWatcher.Created> Ereignis in das Verzeichnis, die Datei wurde kopiert, sofern dieses Verzeichnis überwacht wird. Wenn das Verzeichnis, aus der Sie kopiert, wurde von einer anderen Instanz beobachtet <xref:System.IO.FileSystemWatcher>, würde kein Ereignis ausgelöst werden. Beispielsweise erstellen Sie zwei Instanzen von <xref:System.IO.FileSystemWatcher>. FileSystemWatcher1 nastaven NA hodnotu "C:\My Dokumente" sehen Sie sich, und FileSystemWatcher2 nastaven NA hodnotu "C:\Your Dokumente" sehen Sie sich an. Wenn Sie eine Datei aus "Eigene Dateien" in "Ihre Dokumente", Kopieren einer <xref:System.IO.FileSystemWatcher.Created> Ereignis wird von FileSystemWatcher2 ausgelöst werden, aber kein Ereignis für FileSystemWatcher1 ausgelöst. Im Gegensatz zu kopieren, Verschieben einer Datei oder Verzeichnis werden zwei Ereignisse ausgelöst. Aus dem vorherigen Beispiel, wenn Sie eine Datei aus "Eigene Dokumente" auf "Ihre Dokumente" verschoben eine <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2-Ereignis ausgelöst werden und ein <xref:System.IO.FileSystemWatcher.Deleted> FileSystemWatcher1-Ereignis ausgelöst werden.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Beim Überschreiben von <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> in einer abgeleiteten Klasse, werden Sie sicher, dass der Basisklasse aufrufen <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> Methode.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnError : System.IO.ErrorEventArgs -&gt; unit" Usage="fileSystemWatcher.OnError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.IO.ErrorEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.IO.FileSystemWatcher.Error" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnError%2A> wird aufgerufen, wenn ein Fehler auftritt.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Beim Überschreiben von <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> in einer abgeleiteten Klasse, werden Sie sicher, dass der Basisklasse aufrufen <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> Methode.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnRenamed : System.IO.RenamedEventArgs -&gt; unit" Usage="fileSystemWatcher.OnRenamed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.IO.RenamedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.IO.FileSystemWatcher.Renamed" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnRenamed%2A> wird aufgerufen, wenn eine Datei oder ein Verzeichnis im überwachten Verzeichnis umbenannt wird. Die <xref:System.IO.RenamedEventArgs> Argument enthält Informationen zu den Umbenennungsvorgang, z. B. der Typ der Änderung der alten und neuen Pfad und den alten und neuen Namen. Beachten Sie, dass die <xref:System.IO.FileSystemEventArgs.Name> Eigenschaft ist möglicherweise null für Ereignisse umbenannt, wenn die <xref:System.IO.FileSystemWatcher> ist nicht übereinstimmende alte und neue Ereignisse vom Betriebssystem abzurufen. 
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Beim Überschreiben von <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> in einer abgeleiteten Klasse, werden Sie sicher, dass der Basisklasse aufrufen <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> Methode.</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.IO.FileSystemWatcher.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The directory to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pfad des zu überwachenden Verzeichnisses ab oder legt diesen fest.</summary>
        <value>Der zu überwachende Pfad. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein vollqualifizierter Pfad zu einem Verzeichnis. Wenn die <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> Eigenschaft `true`, dieses Verzeichnis ist der Stamm, an dem das System wird überwacht, Änderungen ob; andernfalls ist es nur dieses Verzeichnis überwacht. Legen Sie zum Überwachen einer bestimmten Datei die <xref:System.IO.FileSystemWatcher.Path%2A> Eigenschaft in das Verzeichnis voll gekennzeichneten, richtig, und die <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft an den Dateinamen an.  
  
 Die <xref:System.IO.FileSystemWatcher.Path%2A> -Eigenschaft unterstützt die Pfade (Universal Naming Convention).  
  
> [!NOTE]
>  Diese Eigenschaft muss festgelegt werden, bevor Änderungen an die Komponente zu überwachen kann.  
  
 Wenn ein Verzeichnis umbenannt wird, die <xref:System.IO.FileSystemWatcher> Zieldatenträger selbst automatisch das umbenannte Element. Wenn Sie festlegen, z. B. die <xref:System.IO.FileSystemWatcher.Path%2A> Eigenschaft auf "C:\My Dokumente" und klicken Sie dann das Verzeichnis "Dokumente C:\Your" manuell umbenennen, die Komponente weiterhin für das änderungsbenachrichtigungen für das gerade umbenannte Verzeichnis. Wenn Sie stellen aber für die <xref:System.IO.FileSystemWatcher.Path%2A> -Eigenschaft enthält den alten Pfad. Dies geschieht, weil die Komponente bestimmt überwachende Verzeichnis basierend auf den Namen des Verzeichnisses, anstatt das Handle. Umbenennen, hat dies keine Auswirkungen auf das Handle. Wenn Sie die Komponente zerstören und anschließend neu erstellen, ohne Aktualisierung der <xref:System.IO.FileSystemWatcher.Path%2A> -Eigenschaft, die Anwendung schlägt fehl, da das Verzeichnis nicht mehr vorhanden ist.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.IO.FileSystemWatcher> zum Überwachen des Verzeichnisses, das zur Laufzeit angegeben. Die Komponente festgelegt ist, auf Änderungen in `LastWrite` und `LastAccess` Zeit, zu erstellen, löschen oder Umbenennen von Textdateien im Verzeichnis. Wenn eine Datei geändert wird, erstellt oder gelöscht wird, gibt den Pfad zur Datei an der Konsole aus. Wenn eine Datei umbenannt wird, werden die alten und neuen Pfade auf der Konsole ausgegeben.  
  
 Verwenden der <xref:System.Diagnostics> und <xref:System.IO> Namespaces für dieses Beispiel.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der angegebene Pfad ist nicht vorhanden oder konnte nicht gefunden werden.  
  
- oder - 
Der angegebene Pfad enthält Platzhalterzeichen.  
  
- oder - 
Der angegebene Pfad enthält ungültige Zeichen.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberSignature Language="F#" Value="member this.Renamed : System.IO.RenamedEventHandler " Usage="member this.Renamed : System.IO.RenamedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory rename matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Renamed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn im angegebenen <see cref="P:System.IO.FileSystemWatcher.Path" /> eine Datei oder ein Verzeichnis umbenannt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Renamed` Ereignis ist ein <xref:System.IO.RenamedEventHandler> Delegat mit der folgenden Signatur:

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 Die <xref:System.IO.RenamedEventArgs> -Objekt stellt Informationen über den Umbenennungsvorgang, z. B. der Typ der Umbenennung (die <xref:System.IO.FileSystemEventArgs.ChangeType> Eigenschaft), die alten und neuen Namen und den alten und neuen Pfad. Beachten Sie, dass die <xref:System.IO.FileSystemEventArgs.Name> Eigenschaft ist möglicherweise null für Ereignisse umbenannt, wenn die <xref:System.IO.FileSystemWatcher> ist nicht übereinstimmende alte und neue Ereignisse vom Betriebssystem abzurufen.

 Umbenennen des Verzeichnisses, die Sie überwachen, wird eine Benachrichtigung nicht auslösen. Benachrichtigungen werden nur Einträge im Verzeichnis ausgelöst werden, die Sie überwachen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.FileSystemWatcher.Renamed> Ereignis, um den Dateipfad in der Konsole anzeigen, die überwachte Datei umbenannt wird.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.IO.FileSystemWatcher.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.ComponentModel.ISite" /> für den <see cref="T:System.IO.FileSystemWatcher" /> ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.ComponentModel.ISite" /> für das <see cref="T:System.IO.FileSystemWatcher" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sites binden ein <xref:System.ComponentModel.Component> auf eine <xref:System.ComponentModel.Design.IDesignerHost.Container%2A> und ermöglichen die Kommunikation zwischen diesen sowie bieten eine Möglichkeit für den Container, seine Komponenten zu verwalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_SynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab, das zum Marshallen von Ereignishandleraufrufen verwendet wird, die aufgrund einer Verzeichnisänderung ausgegeben werden, oder legt dieses fest.</summary>
        <value>Das <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, das das Objekt zum Marshallen der Ereignishandleraufrufe darstellt, die aufgrund einer Verzeichnisänderung ausgegeben werden. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> ist `null`, Methoden zum Behandeln der <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, und <xref:System.IO.FileSystemWatcher.Renamed> Ereignisse werden auf einem Thread vom Threadpool Systems aufgerufen. Weitere Informationen zu System Threadpools, finden Sie unter <xref:System.Threading.ThreadPool>.  
  
 Wenn die <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, und <xref:System.IO.FileSystemWatcher.Renamed> Ereignisse werden von einer visuellen Windows Forms-Komponente, behandelt, wie z. B. eine <xref:System.Windows.Forms.Button>, Zugriff auf die Komponente über den systemthreadpool funktionieren möglicherweise nicht oder möglicherweise eine Ausnahme ausgelöst. Vermeiden Sie dies durch Festlegen von <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> an eine Windows Forms-Komponente, wodurch die Methoden, behandeln die <xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>, und <xref:System.IO.FileSystemWatcher.Renamed> Ereignisse auf dem gleichen Thread aufgerufen werden, auf dem die Komponente erstellt wurde.  
  
 Wenn die <xref:System.IO.FileSystemWatcher> dient in [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in einem Windows Forms-Designer <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> legt automatisch auf das Steuerelement, enthält die <xref:System.IO.FileSystemWatcher>. Wenn Sie platzieren z. B. eine <xref:System.IO.FileSystemWatcher> in einem Designer für Form1 (erbt von <xref:System.Windows.Forms.Form>) die <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> Eigenschaft <xref:System.IO.FileSystemWatcher> festgelegt ist, mit der Instanz von Form1.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Eine synchrone Methode, die eine Struktur mit spezifischen Informationen zur eingetretenen Änderung zurückgibt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged changeType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType">Die zu überwachenden <see cref="T:System.IO.WatcherChangeTypes" />.</param>
        <summary>Eine synchrone Methode, die eine Struktur mit spezifischen Informationen zur eingetretenen Änderung zurückgibt, sofern diese mit der Art der Änderung übereinstimmt, die überwacht werden soll.</summary>
        <returns>Ein <see cref="T:System.IO.WaitForChangedResult" /> mit spezifischen Informationen zur eingetretenen Änderung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wartet unbegrenzt, bis die erste Änderung tritt ein, und gibt dann zurück. Dies ist identisch mit <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> mit der `timeout` Parameter auf-1 festgelegt.  
  
> [!NOTE]
>  Diese Methode ermöglicht, einen Ereignishandler aufgerufen werden, zum Reagieren auf Änderungen selbst wenn die <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> -Eigenschaftensatz auf `false`.  
  
 In manchen Systemen – <xref:System.IO.FileSystemWatcher> meldet Änderungen an Dateien, die mit der kurzen der 8.3-Namensformat. Beispielsweise könnte eine Änderung an "Longfilename.LongExtension würde dann" gemeldet werden, als "LongFi ~. LON".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes * int -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged (changeType, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType">Die zu überwachenden <see cref="T:System.IO.WatcherChangeTypes" />.</param>
        <param name="timeout">Die Wartezeit (in Millisekunden) bis zum Timeout.</param>
        <summary>Eine synchrone Methode, die eine Struktur mit spezifischen Informationen zur eingetretenen Änderung zurückgibt, sofern diese mit der Art der zu überwachenden Änderung übereinstimmt und die Zeit (in Millisekunden) bis zum Timeout nicht abgelaufen ist.</summary>
        <returns>Ein <see cref="T:System.IO.WaitForChangedResult" /> mit spezifischen Informationen zur eingetretenen Änderung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wartet, bis eine Änderung vorgenommen wird, oder es Timeout. Der Wert-1 für die `timeout` Parameter bedeutet unbegrenzt zu warten.  
  
> [!NOTE]
>  Diese Methode ermöglicht, einen Ereignishandler aufgerufen werden, zum Reagieren auf Änderungen selbst wenn die <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> -Eigenschaftensatz auf `false`.  
  
 In manchen Systemen – <xref:System.IO.FileSystemWatcher> meldet Änderungen an Dateien, die mit der kurzen der 8.3-Namensformat. Beispielsweise könnte eine Änderung an "Longfilename.LongExtension würde dann" gemeldet werden, als "LongFi ~. LON".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>