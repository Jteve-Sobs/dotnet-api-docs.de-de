<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dcbd7e6e95ad513a0f7d632f433e79ef46ca42f3" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86669568" /></Metadata><TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type FileSystemWatcher = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0" />
  <TypeSignature Language="C#" Value="public class FileSystemWatcher : IDisposable" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.Object implements class System.IDisposable" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Implements IDisposable" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : IDisposable" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="F#" Value="type FileSystemWatcher = class&#xA;    interface IDisposable" FrameworkAlternate="netcore-1.0;netcore-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, IDisposable, System.ComponentModel.ISupportInitialize" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize, class System.IDisposable" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements IDisposable, ISupportInitialize" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, IDisposable, System::ComponentModel::ISupportInitialize" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="F#" Value="type FileSystemWatcher = class&#xA;    inherit Component&#xA;    interface IDisposable&#xA;    interface ISupportInitialize" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.IO.FileSystem.Watcher" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-1.0;netcore-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="netcore-1.0;netcore-1.1;xamarinandroid-7.1;xamarinios-10.8">
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0">
      <AttributeName Language="C#">[System.ComponentModel.DefaultEvent("Changed")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultEvent("Changed")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.IO.IODescription("FileSystemWatcherDesc")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.IO.IODescription("FileSystemWatcherDesc")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName Language="C#">[System.IO.IODescription("")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.IO.IODescription("")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Überwacht die Benachrichtigungen über Änderungen im Dateisystem und löst Ereignisse aus, wenn ein Verzeichnis oder eine Datei in einem Verzeichnis geändert werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie <xref:System.IO.FileSystemWatcher> , um Änderungen in einem angegebenen Verzeichnis zu überwachen. Sie können Änderungen in Dateien und Unterverzeichnissen des angegebenen Verzeichnisses überwachen. Sie können eine-Komponente erstellen, um Dateien auf einem lokalen Computer, einem Netzlaufwerk oder einem Remote Computer zu überwachen.  
  
 Um Änderungen in allen Dateien zu überwachen, legen Sie die- <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft auf eine leere Zeichenfolge ("") fest, oder verwenden Sie Platzhalter ("*. \* "). Um eine bestimmte Datei zu beobachten, legen Sie die- <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft auf den Dateinamen fest. Wenn Sie z. b. Änderungen in der Datei MyDoc.txt überwachen möchten, legen Sie die- <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft auf "MyDoc.txt" fest. Sie können auch auf Änderungen in einem bestimmten Dateityp achten. Wenn Sie z. b. Änderungen in Textdateien überwachen möchten, legen Sie die- <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft auf " \* . txt" fest.  
  
 Es gibt mehrere Arten von Änderungen, die Sie in einem Verzeichnis oder in einer Datei überwachen können. Beispielsweise können Sie Änderungen in `Attributes` , das `LastWrite` Datum und die Uhrzeit oder den `Size` von Dateien oder Verzeichnissen überwachen. Dies erfolgt durch Festlegen der- <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> Eigenschaft auf einen der- <xref:System.IO.NotifyFilters> Werte. Weitere Informationen zu den Arten von Änderungen, die Sie überwachen können, finden Sie unter <xref:System.IO.NotifyFilters> .  
  
 Sie können das Umbenennen, löschen oder Erstellen von Dateien oder Verzeichnissen überwachen. Wenn Sie z. b. das Umbenennen von Textdateien überwachen möchten, legen Sie die <xref:System.IO.FileSystemWatcher.Filter%2A> -Eigenschaft auf "*. txt" fest, und wenden Sie die- <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> Methode mit einem <xref:System.IO.WatcherChangeTypes.Renamed> für den Parameter angegebenen  
  
 Das Windows-Betriebssystem benachrichtigt die Komponente über Dateiänderungen in einem Puffer, der von erstellt wurde <xref:System.IO.FileSystemWatcher> . Wenn in kurzer Zeit viele Änderungen vorgenommen werden, kann der Puffer einen Überlauf verursachen. Dies bewirkt, dass die Komponente Änderungen im Verzeichnis nachverfolgt und nur eine Benachrichtigung über eine Benachrichtigung erhält. Die Vergrößerung des Puffers mit der- <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> Eigenschaft ist teuer, da Sie aus nicht auslagertem Arbeitsspeicher stammt, der nicht auf den Datenträger ausgelagert werden kann, sodass der Puffer so klein ist, dass er keine Datei Änderungs Ereignisse verpasst. Um einen Pufferüberlauf zu vermeiden, verwenden <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> Sie die-Eigenschaft und die-Eigenschaft, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> sodass Sie unerwünschte Änderungs Benachrichtigungen herausfiltern können.  
  
 Eine Liste der anfänglichen Eigenschaftswerte für eine Instanz von <xref:System.IO.FileSystemWatcher> finden Sie im- <xref:System.IO.FileSystemWatcher.%23ctor%2A> Konstruktor.  
  
 Beachten Sie Folgendes, wenn Sie die- <xref:System.IO.FileSystemWatcher> Klasse verwenden.  
  
-   Ausgeblendete Dateien werden nicht ignoriert.  
  
-   In manchen Systemen <xref:System.IO.FileSystemWatcher> meldet Änderungen an Dateien mithilfe des kurzen Dateinamen Formats 8,3. Beispielsweise könnte eine Änderung an "longfilename. LongExtension" als "longfil ~" gemeldet werden. Lon ".  
  
-   Diese Klasse enthält einen Link Aufruf und eine Vererbungs Anforderung auf Klassenebene, die für alle Member gilt. Eine <xref:System.Security.SecurityException> wird ausgelöst, wenn der unmittelbare Aufrufer oder die abgeleitete Klasse nicht über die Berechtigung für volle Vertrauenswürdigkeit verfügt. Ausführliche Informationen zu Sicherheitsanforderungen finden Sie unter [Link](/dotnet/framework/misc/link-demands)Aufrufe.  
  
-   Die maximale Größe, die Sie für die- <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> Eigenschaft für die Überwachung eines Verzeichnisses über das Netzwerk festlegen können, beträgt 64 KB.  
  
> [!NOTE]
>  Die Ausführung unter <xref:System.IO.FileSystemWatcher> Windows 98 wird nicht unterstützt.  
  
## <a name="copying-and-moving-folders"></a>Kopieren und Verschieben von Ordnern  
 Das Betriebssystem und das <xref:System.IO.FileSystemWatcher> Objekt interpretieren eine Ausschneide-und Einfügeaktion oder eine Verschiebungs Aktion als Umbenennungs Aktion für einen Ordner und seinen Inhalt. Wenn Sie einen Ordner mit Dateien ausschneiden und in einen zu überwachenden Ordner einfügen, <xref:System.IO.FileSystemWatcher> meldet das Objekt nur den Ordner als neu, jedoch nicht seinen Inhalt, da Sie im Wesentlichen nur umbenannt werden.  
  
 Um benachrichtigt zu werden, dass der Inhalt der Ordner verschoben oder in einen überwachten Ordner kopiert wurde, geben Sie die <xref:System.IO.FileSystemWatcher.OnChanged%2A> -und- <xref:System.IO.FileSystemWatcher.OnRenamed%2A> Ereignishandlermethoden an, wie in der folgenden Tabelle vorgeschlagen.  
  
|Ereignishandler|Behandelte Ereignisse|Leistung|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>|Melden Sie Änderungen in Dateiattributen, erstellten Dateien und gelöschten Dateien.|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|Auflisten der alten und neuen Pfade umbenannter Dateien und Ordner, die bei Bedarf rekursiv erweitert werden.|  
  
## <a name="events-and-buffer-sizes"></a>Ereignisse und Puffergrößen  
 Beachten Sie, dass mehrere Faktoren beeinflussen können, welche Dateisystem Änderungs Ereignisse ausgelöst werden, wie im folgenden beschrieben:  
  
-   Allgemeine Dateisystem Vorgänge können mehr als ein Ereignis hervorrufen. Wenn eine Datei z. b. von einem Verzeichnis in ein anderes verschoben wird, <xref:System.IO.FileSystemWatcher.OnChanged%2A> <xref:System.IO.FileSystemWatcher.OnCreated%2A> werden möglicherweise mehrere und einige-und- <xref:System.IO.FileSystemWatcher.OnDeleted%2A> Ereignisse ausgelöst. Das Verschieben einer Datei ist ein komplexer Vorgang, der aus mehreren einfachen Vorgängen besteht, wodurch mehrere Ereignisse erhöht werden. Ebenso können einige Anwendungen (z. b. Antivirussoftware) zusätzliche Dateisystem Ereignisse auslösen, die von erkannt werden <xref:System.IO.FileSystemWatcher> .  
  
-   Der kann Datenträger überwachen, solange <xref:System.IO.FileSystemWatcher> Sie nicht gewechselt oder entfernt werden. Der <xref:System.IO.FileSystemWatcher> gibt keine Ereignisse für CDs und DVDs aus, da Zeitstempel und Eigenschaften nicht geändert werden können. Auf Remote Computern muss eine der erforderlichen Plattformen installiert sein, damit die Komponente ordnungsgemäß funktioniert.  
  
 Beachten Sie, dass ein ein <xref:System.IO.FileSystemWatcher> Ereignis übersehen kann, wenn die Puffergröße überschritten wird. Um fehlende Ereignisse zu vermeiden, befolgen Sie die folgenden Richtlinien:  
  
-   Vergrößern Sie die Puffergröße, indem Sie die- <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> Eigenschaft festlegen.  
  
-   Vermeiden Sie das Überwachen von Dateien mit langen Dateinamen, da ein langer Dateiname zum Auffüllen des Puffers beiträgt. Sie sollten diese Dateien unter Verwendung kürzerer Namen umbenennen.  
  
-   Halten Sie den Ereignis Behandlungs Code so kurz wie möglich.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein erstellt <xref:System.IO.FileSystemWatcher> , um das zur Laufzeit angegebene Verzeichnis zu überwachen. Die Komponente wird so festgelegt, dass Sie Änderungen in `LastWrite` und `LastAccess` Uhrzeit, das Erstellen, löschen oder Umbenennen von Textdateien im Verzeichnis überwacht. Wenn eine Datei geändert, erstellt oder gelöscht wird, wird der Pfad zur Datei in der Konsole gedruckt. Wenn eine Datei umbenannt wird, werden die alten und neuen Pfade in der Konsole gedruckt.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
    <related type="ExternalDocumentation" href="https://github.com/microsoftarchive/msdn-code-gallery-community-s-z/tree/master/Using%20a%20FileSystemWatcher%20Component%20in%20a%20Windows%20Form%20with%20C%23">Verwenden einer FileSystemWatcher-Komponente in einem Windows Form</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileSystemWatcher" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileSystemWatcher" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Remote Computer, auf dem Windows NT oder Windows 2000 nicht vorhanden ist, kann nicht überwacht werden. Sie können einen Remote Computer mit Windows NT 4,0 nicht von einem Computer mit Windows NT 4,0 ansehen.  
  
 In der folgenden Tabelle werden die anfänglichen Eigenschaftswerte für eine Instanz von angezeigt <xref:System.IO.FileSystemWatcher> .  
  
|Eigenschaft|Anfangswert|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|bitweise OR-Kombination von `LastWrite` , `FileName` und`DirectoryName`|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|"*.\*" (Alle Dateien überwachen.)|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|8192|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|leere Zeichenfolge ("")|  
  
> [!NOTE]
>  Die Komponente überwacht das angegebene Verzeichnis erst, wenn der <xref:System.IO.FileSystemWatcher.Path%2A> festgelegt ist, und <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> ist `true` .  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein- <xref:System.IO.FileSystemWatcher> Objekt erstellt, um das zur Laufzeit angegebene Verzeichnis zu überwachen. Das <xref:System.IO.FileSystemWatcher> -Objekt überwacht die Änderungen in `LastWrite` und `LastAccess` -Zeiten sowie beim Erstellen, löschen oder Umbenennen von Textdateien im Verzeichnis. Wenn eine Datei geändert, erstellt oder gelöscht wird, wird der Pfad zur Datei in der Konsole angezeigt. Wenn eine Datei umbenannt wird, werden die alten und neuen Pfade in der Konsole angezeigt.  
  
 In diesem Beispiel werden die <xref:System.Diagnostics> -und- <xref:System.IO> Namespaces verwendet.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Das zu überwachende Verzeichnis in der Standard- oder UNC (Universal Naming Convention)-Notation.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileSystemWatcher" />-Klasse mit dem für die Überwachung angegebenen Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die Komponente überwacht das angegebene Verzeichnis erst, wenn der <xref:System.IO.FileSystemWatcher.Path%2A> festgelegt ist, und <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> ist `true` .  
  
 Die-Komponente kann Dateien auf Ihrem persönlichen Computer, auf einem Netzlaufwerk oder auf einem Remote Computer überwachen.  
  
 Ein Remote Computer, auf dem Windows NT oder Windows 2000 nicht vorhanden ist, kann nicht überwacht werden. Sie können einen Remote Computer mit Windows NT 4,0 nicht von einem Computer mit Windows NT 4,0 ansehen. Die- <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft wird standardmäßig festgelegt, um alle Dateien zu überwachen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist eine leere Zeichenfolge ("").  
  
Oder 
Der durch den <paramref name="path" />-Parameter angegebene Pfad ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> ist zu lang.</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string * string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher (path, filter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Das zu überwachende Verzeichnis in der Standard- oder UNC (Universal Naming Convention)-Notation.</param>
        <param name="filter">Der zu überwachende Dateityp. Bei "*.txt" werden z. B. alle Textdateien auf Änderungen überwacht.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileSystemWatcher" />-Klasse mit dem für die Überwachung angegebenen Verzeichnis und Dateityp.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die Komponente überwacht das angegebene Verzeichnis erst, wenn der <xref:System.IO.FileSystemWatcher.Path%2A> festgelegt ist, und <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> ist `true` .  
  
 Die-Komponente kann Dateien auf Ihrem persönlichen Computer, auf einem Netzlaufwerk oder auf einem Remote Computer überwachen.  
  
 Ein Remote Computer, auf dem Windows NT oder Windows 2000 nicht vorhanden ist, kann nicht überwacht werden. Sie können einen Remote Computer mit Windows NT 4,0 nicht von einem Computer mit Windows NT 4,0 ansehen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.  
  
Oder 
Der <paramref name="filter" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist eine leere Zeichenfolge ("").  
  
Oder 
Der durch den <paramref name="path" />-Parameter angegebene Pfad ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> ist zu lang.</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="fileSystemWatcher.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beginnt die Initialisierung von <see cref="T:System.IO.FileSystemWatcher" /> für die Verwendung in einem Formular oder durch eine andere Komponente. Die Initialisierung erfolgt zur Laufzeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Entwurfs Umgebung verwendet diese Methode, um die Initialisierung einer Komponente zu starten, die in einem Formular oder von einer anderen Komponente verwendet wird. Die- <xref:System.IO.FileSystemWatcher.EndInit%2A> Methode beendet die Initialisierung. Die Verwendung der <xref:System.IO.FileSystemWatcher.BeginInit%2A> -Methode und der- <xref:System.IO.FileSystemWatcher.EndInit%2A> Methode verhindert, dass das Steuerelement verwendet wird, bevor es vollständig initialisiert  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : System.IO.FileSystemEventHandler " Usage="member this.Changed : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.IO.IODescription("FSW_Changed")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.IO.IODescription("FSW_Changed")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.IO.IODescription("Occurs when a file/directory change matches the filter")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.IO.IODescription("Occurs when a file/directory change matches the filter")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn im angegebenen <see cref="P:System.IO.FileSystemWatcher.Path" /> eine Datei oder ein Verzeichnis geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das- <xref:System.IO.FileSystemWatcher.Changed> Ereignis wird ausgelöst, wenn Änderungen an der Größe, den System Attributen, dem Zeitpunkt des letzten Schreibzugriffs, dem Zeitpunkt des letzten Zugriffs oder den Sicherheits Berechtigungen einer Datei oder eines Verzeichnisses in dem überwachten Verzeichnis vorgenommen werden.  
  
> [!NOTE]
>  Allgemeine Dateisystem Vorgänge können mehr als ein Ereignis hervorrufen. Wenn eine Datei z. b. von einem Verzeichnis in ein anderes verschoben wird, <xref:System.IO.FileSystemWatcher.OnChanged%2A> <xref:System.IO.FileSystemWatcher.OnCreated%2A> werden möglicherweise mehrere und einige-und- <xref:System.IO.FileSystemWatcher.OnDeleted%2A> Ereignisse ausgelöst. Das Verschieben einer Datei ist ein komplexer Vorgang, der aus mehreren einfachen Vorgängen besteht, wodurch mehrere Ereignisse erhöht werden. Ebenso können einige Anwendungen (z. b. Antivirussoftware) zusätzliche Dateisystem Ereignisse auslösen, die von erkannt werden <xref:System.IO.FileSystemWatcher> .  
  
 Verwenden <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> Sie, um die Anzahl der Benachrichtigungen einzuschränken, die beim Behandeln dieses Ereignisses ausgelöst werden.  
  
> [!NOTE]
>  Das <xref:System.IO.FileSystemWatcher.Changed> Ereignis wird beim Umbenennen einer Datei unerwartet ausgelöst, aber nicht ausgelöst, wenn ein Verzeichnis umbenannt wird. Um das Umbenennen zu überwachen, verwenden Sie das- <xref:System.IO.FileSystemWatcher.Renamed> Ereignis.  
  
> [!NOTE]
>  Die Reihenfolge, in der das <xref:System.IO.FileSystemWatcher.Changed> Ereignis im Verhältnis zu den anderen Ereignissen ausgelöst wird, <xref:System.IO.FileSystemWatcher> kann sich ändern, wenn die- <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> Eigenschaft nicht ist `null` .  
  
   
  
## Examples  
 Im folgenden Beispiel wird das- <xref:System.IO.FileSystemWatcher.Changed> Ereignis verwendet, um den Dateipfad der Konsole anzuzeigen, wenn die überwachte Datei geändert wird.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberSignature Language="F#" Value="member this.Created : System.IO.FileSystemEventHandler " Usage="member this.Created : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.IO.IODescription("FSW_Created")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.IO.IODescription("FSW_Created")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.IO.IODescription("Occurs when a file/directory creation matches the filter")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.IO.IODescription("Occurs when a file/directory creation matches the filter")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn im angegebenen <see cref="P:System.IO.FileSystemWatcher.Path" /> eine Datei oder ein Verzeichnis erstellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige häufige Vorkommen, z. b. das Kopieren oder Verschieben einer Datei oder eines Verzeichnisses, entsprechen nicht direkt einem Ereignis, aber diese Vorkommen bewirken, dass Ereignisse ausgelöst werden. Wenn Sie eine Datei oder ein Verzeichnis kopieren, löst das System ein- <xref:System.IO.FileSystemWatcher.Created> Ereignis in dem Verzeichnis aus, in das die Datei kopiert wurde, wenn dieses Verzeichnis überwacht wird. Wenn das Verzeichnis, von dem Sie kopiert wurden, von einer anderen Instanz von überwacht wurde <xref:System.IO.FileSystemWatcher> , wird kein Ereignis ausgelöst. Beispielsweise erstellen Sie zwei Instanzen von <xref:System.IO.FileSystemWatcher> . FileSystemWatcher1 ist auf "c:\Eigene Dokumente" festgelegt, und "FileSystemWatcher2" ist so festgelegt, dass "c:\Your Documents" angezeigt wird. Wenn Sie eine Datei aus "meine Dokumente" in "Ihre Dokumente" kopieren, wird ein- <xref:System.IO.FileSystemWatcher.Created> Ereignis von FileSystemWatcher2 ausgelöst, aber für FileSystemWatcher1 wird kein Ereignis ausgelöst. Im Gegensatz zum Kopieren werden durch das Verschieben einer Datei oder eines Verzeichnisses zwei Ereignisse erhoben. Wenn Sie aus dem vorherigen Beispiel eine Datei von "eigene Dokumente" in "Ihre Dokumente" verschoben haben, <xref:System.IO.FileSystemWatcher.Created> wird ein-Ereignis von FileSystemWatcher2 ausgelöst, und ein- <xref:System.IO.FileSystemWatcher.Deleted> Ereignis wird von FileSystemWatcher1 ausgelöst.  
  
> [!NOTE]
>  Allgemeine Dateisystem Vorgänge können mehr als ein Ereignis hervorrufen. Wenn eine Datei z. b. von einem Verzeichnis in ein anderes verschoben wird, <xref:System.IO.FileSystemWatcher.OnChanged%2A> <xref:System.IO.FileSystemWatcher.OnCreated%2A> werden möglicherweise mehrere und einige-und- <xref:System.IO.FileSystemWatcher.OnDeleted%2A> Ereignisse ausgelöst. Das Verschieben einer Datei ist ein komplexer Vorgang, der aus mehreren einfachen Vorgängen besteht, wodurch mehrere Ereignisse erhöht werden. Ebenso können einige Anwendungen (z. b. Antivirussoftware) zusätzliche Dateisystem Ereignisse auslösen, die von erkannt werden <xref:System.IO.FileSystemWatcher> .  
  
> [!NOTE]
>  Die Reihenfolge, in der das <xref:System.IO.FileSystemWatcher.Created> Ereignis im Verhältnis zu den anderen Ereignissen ausgelöst wird, <xref:System.IO.FileSystemWatcher> kann sich ändern, wenn die- <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> Eigenschaft nicht ist `null` .  
  
 Das- <xref:System.IO.FileSystemWatcher.OnCreated%2A> Ereignis wird ausgelöst, sobald eine Datei erstellt wird. Wenn eine Datei kopiert oder in ein beobachteter Verzeichnis übertragen wird, <xref:System.IO.FileSystemWatcher.OnCreated%2A> wird das Ereignis sofort ausgelöst, gefolgt von einem oder mehreren <xref:System.IO.FileSystemWatcher.OnChanged%2A> Ereignissen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das- <xref:System.IO.FileSystemWatcher.Created> Ereignis verwendet, um den Dateipfad zur Konsole anzuzeigen, wenn die überwachte Datei erstellt wird.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : System.IO.FileSystemEventHandler " Usage="member this.Deleted : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.IO.IODescription("FSW_Deleted")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.IO.IODescription("FSW_Deleted")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.IO.IODescription("Occurs when a file/directory deletion matches the filter")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.IO.IODescription("Occurs when a file/directory deletion matches the filter")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn im angegebenen <see cref="P:System.IO.FileSystemWatcher.Path" /> eine Datei oder ein Verzeichnis gelöscht wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige häufige Vorkommen, z. b. das Kopieren oder Verschieben einer Datei oder eines Verzeichnisses, entsprechen nicht direkt einem Ereignis, aber diese Vorkommen bewirken, dass Ereignisse ausgelöst werden. Wenn Sie eine Datei oder ein Verzeichnis kopieren, löst das System ein- <xref:System.IO.FileSystemWatcher.Created> Ereignis in dem Verzeichnis aus, in das die Datei kopiert wurde, wenn dieses Verzeichnis überwacht wird. Wenn das Verzeichnis, von dem Sie kopiert wurden, von einer anderen Instanz von überwacht wurde <xref:System.IO.FileSystemWatcher> , wird kein Ereignis ausgelöst. Beispielsweise erstellen Sie zwei Instanzen von <xref:System.IO.FileSystemWatcher> . FileSystemWatcher1 ist auf "c:\Eigene Dokumente" festgelegt, und "FileSystemWatcher2" ist so festgelegt, dass "c:\Your Documents" angezeigt wird. Wenn Sie eine Datei aus "meine Dokumente" in "Ihre Dokumente" kopieren, wird ein- <xref:System.IO.FileSystemWatcher.Created> Ereignis von FileSystemWatcher2 ausgelöst, aber für FileSystemWatcher1 wird kein Ereignis ausgelöst. Im Gegensatz zum Kopieren werden durch das Verschieben einer Datei oder eines Verzeichnisses zwei Ereignisse erhoben. Wenn Sie aus dem vorherigen Beispiel eine Datei von "eigene Dokumente" in "Ihre Dokumente" verschoben haben, <xref:System.IO.FileSystemWatcher.Created> wird ein-Ereignis von FileSystemWatcher2 ausgelöst, und ein- <xref:System.IO.FileSystemWatcher.Deleted> Ereignis wird von FileSystemWatcher1 ausgelöst.  
  
> [!NOTE]
>  Allgemeine Dateisystem Vorgänge können mehr als ein Ereignis hervorrufen. Wenn eine Datei z. b. von einem Verzeichnis in ein anderes verschoben wird, <xref:System.IO.FileSystemWatcher.OnChanged%2A> <xref:System.IO.FileSystemWatcher.OnCreated%2A> werden möglicherweise mehrere und einige-und- <xref:System.IO.FileSystemWatcher.OnDeleted%2A> Ereignisse ausgelöst. Das Verschieben einer Datei ist ein komplexer Vorgang, der aus mehreren einfachen Vorgängen besteht, wodurch mehrere Ereignisse erhöht werden. Ebenso können einige Anwendungen (z. b. Antivirussoftware) zusätzliche Dateisystem Ereignisse auslösen, die von erkannt werden <xref:System.IO.FileSystemWatcher> .  
  
> [!NOTE]
>  Die Reihenfolge, in der das <xref:System.IO.FileSystemWatcher.Deleted> Ereignis im Verhältnis zu den anderen Ereignissen ausgelöst wird, <xref:System.IO.FileSystemWatcher> kann sich ändern, wenn die- <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> Eigenschaft nicht ist `null` .  
  
   
  
## Examples  
 Im folgenden Beispiel wird das- <xref:System.IO.FileSystemWatcher.Deleted> Ereignis verwendet, um den Dateipfad der Konsole anzuzeigen, wenn die überwachte Datei gelöscht wird.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die nicht verwalteten Ressourcen frei, die von <see cref="T:System.IO.FileSystemWatcher" /> verwendet werden.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" FrameworkAlternate="netcore-1.0;netcore-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.IO.FileSystemWatcher" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der öffentlichen <xref:System.ComponentModel.Component.Dispose%2A> -Methode und der- <xref:System.Object.Finalize%2A> Methode aufgerufen. <xref:System.ComponentModel.Component.Dispose%2A>Ruft die geschützte <xref:System.IO.FileSystemWatcher.Dispose%2A> Methode auf, wobei der- `disposing` Parameter auf festgelegt ist `true` . <xref:System.Object.Finalize%2A>Ruft <xref:System.IO.FileSystemWatcher.Dispose%2A> `disposing` auf, wobei auf gesetzt ist `false` .  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.IO.Compression.DeflateStream> verweist. Diese Methode ruft die <xref:System.ComponentModel.Component.Dispose%2A>-Methode jedes referenzierten Objekts auf.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Wenn Sie überschreiben, sollten <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" /> Sie darauf achten, nicht auf Objekte zu verweisen, die zuvor in einem früheren-Aufrufpunkt verworfen wurden <see cref="M:System.ComponentModel.Component.Dispose" /> . Weitere Informationen zum Implementieren von finden Sie <see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" /> unter [Implementieren einer](/dotnet/standard/garbage-collection/implementing-dispose)verwerfen-Methode.  
  
Weitere Informationen zu <see cref="M:System.ComponentModel.Component.Dispose" /> und <see cref="M:System.Object.Finalize" /> finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](/dotnet/standard/garbage-collection/unmanaged).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.IO.IODescription("FSW_Enabled")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.IO.IODescription("FSW_Enabled")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.IO.IODescription("Flag to indicate if this instance is active")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.IO.IODescription("Flag to indicate if this instance is active")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Komponente aktiviert ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Komponente aktiviert ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />. Wenn Sie die Komponente in einem Designer in [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] verwenden, ist der Standardwert <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Komponente gibt nur dann Ereignisse aus, wenn Sie auf festgelegt haben <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> `true` .  
  
> [!NOTE]
>  Die Komponente überwacht das angegebene Verzeichnis erst, wenn die <xref:System.IO.FileSystemWatcher.Path%2A> -Eigenschaft festgelegt wurde und <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> ist `true` .  
  
 Mit der- <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> Methode können Ereignishandler aufgerufen werden, um auf Dateiänderungen zu reagieren, auch wenn diese Eigenschaft auf festgelegt ist `false` .  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein erstellt <xref:System.IO.FileSystemWatcher> , um das zur Laufzeit angegebene Verzeichnis zu überwachen. Die Komponente wird so festgelegt, dass Sie Änderungen in `LastWrite` und `LastAccess` Uhrzeit, das Erstellen, löschen oder Umbenennen von Textdateien im Verzeichnis überwacht. Wenn eine Datei geändert, erstellt oder gelöscht wird, wird der Pfad zur Datei in der Konsole gedruckt. Wenn eine Datei umbenannt wird, werden die alten und neuen Pfade in der Konsole gedruckt.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.IO.FileSystemWatcher" />-Objekt wurde verworfen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Microsoft Windows NT oder höher.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Das in <see cref="P:System.IO.FileSystemWatcher.Path" /> angegebene Verzeichnis konnte nicht gefunden werden.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.IO.FileSystemWatcher.Path" /> wurde nicht festgelegt oder ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="fileSystemWatcher.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet die Initialisierung von <see cref="T:System.IO.FileSystemWatcher" /> für die Verwendung in einem Formular oder durch eine andere Komponente. Die Initialisierung erfolgt zur Laufzeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Entwurfs Umgebung verwendet diese Methode, um die Initialisierung einer Komponente zu beenden, die in einem Formular oder von einer anderen Komponente verwendet wird. Die- <xref:System.IO.FileSystemWatcher.BeginInit%2A> Methode startet die Initialisierung. Die Verwendung der <xref:System.IO.FileSystemWatcher.BeginInit%2A> -Methode und der- <xref:System.IO.FileSystemWatcher.EndInit%2A> Methode verhindert, dass das Steuerelement verwendet wird, bevor es vollständig initialisiert  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.ErrorEventHandler " Usage="member this.Error : System.IO.ErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die Instanz von <see cref="T:System.IO.FileSystemWatcher" /> das Überwachen von Änderungen nicht fortzusetzen kann oder wenn der interne Puffer überläuft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird immer dann ausgelöst, wenn das <xref:System.IO.FileSystemWatcher> Objektänderungen an der Überwachung von Änderungen verhindert. Wenn das Objekt z. b. Änderungen in einem Remote Verzeichnis überwacht und die Verbindung mit diesem Verzeichnis unterbrochen wird, wird das- <xref:System.IO.FileSystemWatcher.Error> Ereignis ausgelöst.  
  
 Das System benachrichtigt Sie über Dateiänderungen und speichert diese Änderungen in einem Puffer, den die Komponente erstellt und an die APIs übergibt. Wenn in kurzer Zeit viele Änderungen vorgenommen werden, kann der Puffer einen Überlauf verursachen. Dies bewirkt, dass die Komponente Änderungen im Verzeichnis nachverfolgt und nur eine Benachrichtigung über eine Benachrichtigung erhält. Die Vergrößerung des Puffers ist aufwendig, da er aus nicht auslagererem Speicher stammt, der nicht auf den Datenträger ausgelagert werden kann, sodass der Puffer so klein wie möglich bleibt. Um einen Pufferüberlauf zu vermeiden, verwenden <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> <xref:System.IO.FileSystemWatcher.Filter%2A> Sie die Eigenschaften, und, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> um unerwünschte Änderungs Benachrichtigungen herauszufiltern.  
  
> [!NOTE]
>  Allgemeine Dateisystem Vorgänge können mehr als ein Ereignis hervorrufen. Wenn eine Datei z. b. von einem Verzeichnis in ein anderes verschoben wird, <xref:System.IO.FileSystemWatcher.OnChanged%2A> <xref:System.IO.FileSystemWatcher.OnCreated%2A> werden möglicherweise mehrere und einige-und- <xref:System.IO.FileSystemWatcher.OnDeleted%2A> Ereignisse ausgelöst. Das Verschieben einer Datei ist ein komplexer Vorgang, der aus mehreren einfachen Vorgängen besteht, wodurch mehrere Ereignisse erhöht werden. Ebenso können einige Anwendungen (z. b. Antivirussoftware) zusätzliche Dateisystem Ereignisse auslösen, die von erkannt werden <xref:System.IO.FileSystemWatcher> .  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string? Filter { get; set; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : string with get, set" Usage="System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue("*.*")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue("*.*")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.RecommendedAsConfigurable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.RecommendedAsConfigurable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.IO.IODescription("FSW_Filter")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.IO.IODescription("FSW_Filter")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1">
          <AttributeName Language="C#">[System.ComponentModel.SettingsBindable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.SettingsBindable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.IO.IODescription("File name filter pattern")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.IO.IODescription("File name filter pattern")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Filterzeichenfolge ab, mit der die in einem Verzeichnis zu überwachenden Dateien bestimmt werden, oder legt die Filterzeichenfolge fest.</summary>
        <value>Die Filterzeichenfolge. Der Standardwert ist "* \* ". (Überwacht alle Dateien.)</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie die- <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft auf eine leere Zeichenfolge ("") fest, um Änderungen an allen Dateien anzuzeigen. Um eine bestimmte Datei zu beobachten, legen Sie die- <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft auf den Dateinamen fest. Wenn Sie z. b. Änderungen in der Datei MyDoc.txt überwachen möchten, legen Sie die- <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft auf "MyDoc.txt" fest. Sie können auch auf Änderungen in einem bestimmten Dateityp achten. Wenn Sie z. b. Änderungen in Textdateien überwachen möchten, legen Sie die- <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft auf "*. txt" fest. Die Verwendung mehrerer Filter, z. b. " \* . txt&#124;\* . doc", wird nicht unterstützt.  
  
 Die- <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft kann geändert werden, nachdem das Objekt mit dem <xref:System.IO.FileSystemWatcher> empfangen von Ereignissen begonnen hat.  
  
 Weitere Informationen zum Herausfiltern unerwünschter Benachrichtigungen finden Sie in <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> den <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> Eigenschaften, und <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> .  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A>akzeptiert Platzhalter für übereinstimmende Dateien, wie in den folgenden Beispielen gezeigt.  
  
|Filterzeichenfolge|Überwacht die folgenden Dateien:|  
|-------------------|---------------------------------|  
|*.\*|Alle Dateien (Standard). Eine leere Zeichenfolge ("") überwacht auch alle Dateien.|  
|*.txt|Alle Dateien mit der Erweiterung "txt".|  
|* recipe.doc|Alle Dateien, die mit der Erweiterung "doc" enden.|  
|Win*. XML|Alle Dateien, die mit "Win" mit der Erweiterung "XML" beginnen.|  
|Sales * 200?. xls|Entspricht Folgendem:<br /><br />-Sales Juli 2001.xls <br/>-Sales Aug 2002.xls <br/>-2004.xls Sales März<br /><br /> entspricht jedoch nicht:<br /><br />-Sales Nov 1999.xls|  
|MyReport.Doc|Überwacht nur MyReport.doc|  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein erstellt <xref:System.IO.FileSystemWatcher> , um das zur Laufzeit angegebene Verzeichnis zu überwachen. Die Komponente wird so festgelegt, dass Sie Änderungen in `LastWrite` und `LastAccess` Uhrzeit, das Erstellen, löschen oder Umbenennen von Textdateien im Verzeichnis überwacht. Wenn eine Datei geändert, erstellt oder gelöscht wird, wird der Pfad zur Datei in der Konsole gedruckt. Wenn eine Datei umbenannt wird, werden die alten und neuen Pfade in der Konsole gedruckt.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Filters">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;string&gt;? Filters { get; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;string&gt; Filters" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Filters As Collection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ Filters { System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Filters : System.Collections.ObjectModel.Collection&lt;string&gt;" Usage="System.IO.FileSystemWatcher.Filters" />
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;string&gt; Filters { get; }" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung aller Filter ab, mit denen bestimmt wird, welche Dateien in einem Verzeichnis überwacht werden.</summary>
        <value>Eine Filter Auflistung.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileSystemWatcher.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die von der aktuellen Instanz reservierten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
> Der Anwendungscode ruft diese Methode nicht auf. Sie wird automatisch während Garbage Collection aufgerufen, es sei denn, die Garbage Collector wurde deaktiviert. Weitere Informationen finden Sie unter <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> und <xref:System.Object.Finalize>. Diese Methode überschreibt <xref:System.Object.Finalize>.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeSubdirectories : bool with get, set" Usage="System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.IO.IODescription("FSW_IncludeSubdirectories")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.IO.IODescription("FSW_IncludeSubdirectories")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.IO.IODescription("Flag to indicate we want to watch subdirectories")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.IO.IODescription("Flag to indicate we want to watch subdirectories")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Unterverzeichnisse im angegebenen Pfad überwacht werden sollen, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Unterverzeichnisse überwacht werden sollen, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> Sie auf fest, `true` Wenn Sie auf Änderungs Benachrichtigungen für Dateien und Verzeichnisse überwachen möchten, die in dem Verzeichnis enthalten sind, das durch die <xref:System.IO.FileSystemWatcher.Path%2A> -Eigenschaft und deren Unterverzeichnisse angegeben wird. Wenn Sie die- <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> Eigenschaft auf festlegen, wird `false` die Anzahl der Benachrichtigungen verringert, die an den internen Puffer gesendet werden. Weitere Informationen zum Herausfiltern unerwünschter Benachrichtigungen finden Sie unter <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> den <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> Eigenschaften und.  
  
 Wenn `true` , <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> wird durch die gesamte Unterstruktur rekursiv, nicht nur die direkt untergeordneten Verzeichnisse. Der relative Pfad zu einer Datei oder einem Verzeichnis innerhalb der Teilstruktur gibt in der <xref:System.IO.FileSystemEventArgs.Name%2A> -Eigenschaft von <xref:System.IO.FileSystemEventArgs> und in der- <xref:System.IO.RenamedEventArgs.OldName%2A> Eigenschaft von zurück <xref:System.IO.RenamedEventArgs> , abhängig von den Änderungen, die Sie überwachen. Abhängig von den Änderungen, die Sie überwachen, können Sie den voll qualifizierten Pfad aus der <xref:System.IO.FileSystemEventArgs.FullPath%2A> -Eigenschaft von <xref:System.IO.FileSystemEventArgs> und der- <xref:System.IO.RenamedEventArgs.OldFullPath%2A> Eigenschaft von erhalten <xref:System.IO.RenamedEventArgs> .  
  
 Wenn ein Verzeichnis in der Teilstruktur des zu überwachenden Verzeichnisses erstellt wird und ist, wird <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> `true` dieses Verzeichnis automatisch überwacht.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.InternalBufferSize : int with get, set" Usage="System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(8192)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(8192)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe (in Byte) des internen Puffers ab oder legt diese fest.</summary>
        <value>Die interne Puffergröße in Byte. Der Standardwert ist 8192 (8 KB).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den Puffer auf 4 KB oder größer festlegen, er darf jedoch 64 KB nicht überschreiten. Wenn Sie versuchen, die- <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> Eigenschaft auf weniger als 4096 Bytes festzulegen, wird der Wert verworfen und die- <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> Eigenschaft auf 4096 Bytes festgelegt. Verwenden Sie für eine optimale Leistung ein Vielfaches von 4 KB auf Intel-basierten Computern.  
  
 Das System benachrichtigt die Komponente über Dateiänderungen und speichert diese Änderungen in einem Puffer, der von der Komponente erstellt und an die APIs weitergeleitet wird. Jedes Ereignis kann bis zu 16 Byte Arbeitsspeicher (ohne den Dateinamen) verwenden. Wenn in kurzer Zeit viele Änderungen vorgenommen werden, kann der Puffer einen Überlauf verursachen. Dies bewirkt, dass die Komponente Änderungen im Verzeichnis nachverfolgt und nur eine Benachrichtigung über eine Benachrichtigung erhält. Wenn Sie die Puffergröße vergrößern, können fehlende Dateisystem Änderungs Ereignisse verhindert werden. Die Erhöhung der Puffergröße ist jedoch teuer, da Sie aus nicht auslagerlichem Speicher stammt, der nicht auf den Datenträger ausgelagert werden kann, sodass der Puffer so klein wie möglich bleibt. Um einen Pufferüberlauf zu vermeiden, verwenden <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> Sie die-Eigenschaft und die-Eigenschaft, <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> um unerwünschte Änderungs Benachrichtigungen herauszufiltern.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyFilter : System.IO.NotifyFilters with get, set" Usage="System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.IO.IODescription("FSW_ChangedFilter")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.IO.IODescription("FSW_ChangedFilter")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.IO.IODescription("Flag to indicate which change event we want to monitor")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.IO.IODescription("Flag to indicate which change event we want to monitor")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ der zu überwachenden Änderungen ab oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.IO.NotifyFilters" />-Werte. Der Standardwert ist die bitweise OR-Kombination von <see langword="LastWrite" />, <see langword="FileName" /> und <see langword="DirectoryName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die Member der- <xref:System.IO.NotifyFilters> Enumeration kombinieren, um mehrere Arten von Änderungen gleichzeitig zu überwachen. Beispielsweise können Sie Änderungen an der Größe einer Datei und auf Änderungen in der Zeit überwachen `LastWrite` . Dies löst immer dann ein Ereignis aus, wenn die Datei-oder Ordner Größe geändert wird, oder eine Änderung der `LastWrite` Datei oder des Ordners.  
  
 Dies ist eine Möglichkeit, unerwünschte Benachrichtigungen herauszufiltern. Weitere Informationen zum Herausfiltern unerwünschter Benachrichtigungen finden Sie in <xref:System.IO.FileSystemWatcher.Filter%2A> den <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> Eigenschaften, und <xref:System.IO.FileSystemWatcher.InternalBufferSize%2A> .  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein erstellt <xref:System.IO.FileSystemWatcher> , um das zur Laufzeit angegebene Verzeichnis zu überwachen. Die Komponente wird so festgelegt, dass Sie Änderungen in `LastWrite` und `LastAccess` Uhrzeit, das Erstellen, löschen oder Umbenennen von Textdateien im Verzeichnis überwacht. Wenn eine Datei geändert, erstellt oder gelöscht wird, wird der Pfad zur Datei in der Konsole gedruckt. Wenn eine Datei umbenannt wird, werden die alten und neuen Pfade in der Konsole gedruckt.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Wert ist keine gültige bitweise OR-Kombination der <see cref="T:System.IO.NotifyFilters" />-Werte.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Der festgelegte Wert ist ungültig.</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.IO.FileSystemEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.IO.FileSystemWatcher.Changed" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnChanged%2A>wird aufgerufen, wenn Änderungen an der Größe, den System Attributen, dem Zeitpunkt des letzten Schreibzugriffs, dem Zeitpunkt des letzten Zugriffs oder den Sicherheits Berechtigungen einer Datei oder eines Verzeichnisses in dem überwachten Verzeichnis vorgenommen werden.  
  
 Verwenden Sie die- <xref:System.IO.FileSystemWatcher.NotifyFilter%2A> Eigenschaft, um die Anzahl der Ereignisse einzuschränken, die ausgelöst werden, wenn das <xref:System.IO.FileSystemWatcher.Changed> Ereignis behandelt wird.  
  
 Das- <xref:System.IO.FileSystemWatcher.OnCreated%2A> Ereignis wird ausgelöst, sobald eine Datei erstellt wird. Wenn eine Datei kopiert oder in ein beobachteter Verzeichnis übertragen wird, <xref:System.IO.FileSystemWatcher.OnCreated%2A> wird das Ereignis sofort ausgelöst, gefolgt von einem oder mehreren <xref:System.IO.FileSystemWatcher.OnChanged%2A> Ereignissen.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auswerfen von Ereignissen](/dotnet/standard/events/).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Stellen Sie beim Überschreiben <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> in einer abgeleiteten Klasse sicher, dass Sie die-Methode der Basisklasse aufzurufen <see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" /> .</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnCreated : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.IO.FileSystemEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.IO.FileSystemWatcher.Created" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>wird aufgerufen, wenn eine Datei oder ein Verzeichnis in dem überwachten Verzeichnis erstellt wird.  
  
 Einige häufige Vorkommen, z. b. das Kopieren oder Verschieben einer Datei oder eines Verzeichnisses, entsprechen nicht direkt einem Ereignis, aber diese Vorkommen bewirken, dass Ereignisse ausgelöst werden. Wenn Sie eine Datei oder ein Verzeichnis kopieren, löst das System ein- <xref:System.IO.FileSystemWatcher.Created> Ereignis in dem Verzeichnis aus, in das die Datei kopiert wurde, wenn dieses Verzeichnis überwacht wird. Wenn das Verzeichnis, von dem Sie kopiert wurden, von einer anderen Instanz von überwacht wurde <xref:System.IO.FileSystemWatcher> , wird kein Ereignis ausgelöst. Beispielsweise erstellen Sie zwei Instanzen von <xref:System.IO.FileSystemWatcher> . FileSystemWatcher1 ist auf "c:\Eigene Dokumente" festgelegt, und "FileSystemWatcher2" ist so festgelegt, dass "c:\Your Documents" angezeigt wird. Wenn Sie eine Datei aus "meine Dokumente" Kopieren und in "Ihre Dokumente" einfügen, wird ein- <xref:System.IO.FileSystemWatcher.Created> Ereignis in FileSystemWatcher2 ausgelöst, es wird jedoch kein Ereignis für FileSystemWatcher1 ausgelöst. Im Gegensatz zum Kopieren löst das Verschieben einer Datei oder eines Verzeichnisses zwei Ereignisse aus. Wenn Sie aus dem vorherigen Beispiel eine Datei von "eigene Dokumente" in "Ihre Dokumente" verschoben haben, <xref:System.IO.FileSystemWatcher.Created> wird in FileSystemWatcher2 ein-Ereignis ausgelöst, und <xref:System.IO.FileSystemWatcher.Deleted> in FileSystemWatcher1 wird ein-Ereignis ausgelöst.  
  
 Das- <xref:System.IO.FileSystemWatcher.OnCreated%2A> Ereignis wird ausgelöst, sobald eine Datei erstellt wird. Wenn eine Datei kopiert oder in ein beobachteter Verzeichnis übertragen wird, <xref:System.IO.FileSystemWatcher.OnCreated%2A> wird das Ereignis sofort ausgelöst, gefolgt von einem oder mehreren <xref:System.IO.FileSystemWatcher.OnChanged%2A> Ereignissen.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auswerfen von Ereignissen](/dotnet/standard/events/).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Stellen Sie beim Überschreiben <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> in einer abgeleiteten Klasse sicher, dass Sie die-Methode der Basisklasse aufzurufen <see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" /> .</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnDeleted : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.IO.FileSystemEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.IO.FileSystemWatcher.Deleted" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnDeleted%2A>wird aufgerufen, wenn eine Datei oder ein Verzeichnis innerhalb des überwachten Verzeichnisses gelöscht wird.  
  
 Einige häufige Vorkommen, z. b. das Kopieren oder Verschieben einer Datei oder eines Verzeichnisses, entsprechen nicht direkt einem Ereignis, aber diese Vorkommen bewirken, dass Ereignisse ausgelöst werden. Wenn Sie eine Datei oder ein Verzeichnis kopieren, löst das System ein- <xref:System.IO.FileSystemWatcher.Created> Ereignis in dem Verzeichnis aus, in das die Datei kopiert wurde, wenn dieses Verzeichnis überwacht wird. Wenn das Verzeichnis, von dem Sie kopiert wurden, von einer anderen Instanz von überwacht wurde <xref:System.IO.FileSystemWatcher> , wird kein Ereignis ausgelöst. Beispielsweise erstellen Sie zwei Instanzen von <xref:System.IO.FileSystemWatcher> . FileSystemWatcher1 ist auf "c:\Eigene Dokumente" festgelegt, und "FileSystemWatcher2" ist so festgelegt, dass "c:\Your Documents" angezeigt wird. Wenn Sie eine Datei aus "meine Dokumente" in "Ihre Dokumente" kopieren, wird ein- <xref:System.IO.FileSystemWatcher.Created> Ereignis von FileSystemWatcher2 ausgelöst, aber für FileSystemWatcher1 wird kein Ereignis ausgelöst. Im Gegensatz zum Kopieren löst das Verschieben einer Datei oder eines Verzeichnisses zwei Ereignisse aus. Wenn Sie aus dem vorherigen Beispiel eine Datei von "eigene Dokumente" in "Ihre Dokumente" verschoben haben, <xref:System.IO.FileSystemWatcher.Created> wird ein-Ereignis von FileSystemWatcher2 ausgelöst, und ein- <xref:System.IO.FileSystemWatcher.Deleted> Ereignis wird von FileSystemWatcher1 ausgelöst.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auswerfen von Ereignissen](/dotnet/standard/events/).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Stellen Sie beim Überschreiben <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> in einer abgeleiteten Klasse sicher, dass Sie die-Methode der Basisklasse aufzurufen <see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" /> .</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnError : System.IO.ErrorEventArgs -&gt; unit" Usage="fileSystemWatcher.OnError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.IO.ErrorEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.IO.FileSystemWatcher.Error" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnError%2A>wird aufgerufen, wenn ein Fehler auftritt.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auswerfen von Ereignissen](/dotnet/standard/events/).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Stellen Sie beim Überschreiben <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> in einer abgeleiteten Klasse sicher, dass Sie die-Methode der Basisklasse aufzurufen <see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" /> .</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnRenamed : System.IO.RenamedEventArgs -&gt; unit" Usage="fileSystemWatcher.OnRenamed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.IO.RenamedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.IO.FileSystemWatcher.Renamed" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnRenamed%2A>wird aufgerufen, wenn eine Datei oder ein Verzeichnis innerhalb des überwachten Verzeichnisses umbenannt wird. Das zugehörige <xref:System.IO.RenamedEventArgs> -Argument enthält Informationen zum Umbenennungs Vorgang, z. b. den Typ der Änderung, den alten und den neuen Pfad und den alten und neuen Namen. Beachten Sie, dass die- <xref:System.IO.FileSystemEventArgs.Name> Eigenschaft für umbenannte Ereignisse NULL sein kann, wenn <xref:System.IO.FileSystemWatcher> keine übereinstimmenden alten und neuen Namens Ereignisse vom Betriebssystem erhält. 
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [behandeln und Auswerfen von Ereignissen](/dotnet/standard/events/).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Stellen Sie beim Überschreiben <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> in einer abgeleiteten Klasse sicher, dass Sie die-Methode der Basisklasse aufzurufen <see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" /> .</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string? Path { get; set; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="C#" Value="public string Path { get; set; }" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue("")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue("")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.RecommendedAsConfigurable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.RecommendedAsConfigurable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.IO.IODescription("FSW_Path")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.IO.IODescription("FSW_Path")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName Language="C#">[System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1">
          <AttributeName Language="C#">[System.ComponentModel.SettingsBindable(true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.SettingsBindable(true)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.IO.IODescription("The directory to monitor")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.IO.IODescription("The directory to monitor")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pfad des zu überwachenden Verzeichnisses ab oder legt diesen fest.</summary>
        <value>Der zu überwachende Pfad. Der Standardwert ist eine leere Zeichenfolge ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dabei handelt es sich um einen voll qualifizierten Pfad zu einem Verzeichnis. Wenn die- <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A> Eigenschaft ist `true` , ist dieses Verzeichnis das Stammverzeichnis, in dem das System auf Änderungen überwacht wird. andernfalls ist es das einzige Verzeichnis, das überwacht wird. Um eine bestimmte Datei zu beobachten, legen Sie die <xref:System.IO.FileSystemWatcher.Path%2A> -Eigenschaft auf das voll qualifizierte, korrekte Verzeichnis und die- <xref:System.IO.FileSystemWatcher.Filter%2A> Eigenschaft auf den Dateinamen fest.  
  
 Die- <xref:System.IO.FileSystemWatcher.Path%2A> Eigenschaft unterstützt Universal Naming Convention (UNC)-Pfade.  
  
> [!NOTE]
>  Diese Eigenschaft muss festgelegt werden, bevor die Komponente Änderungen überwachen kann.  
  
 Wenn ein Verzeichnis umbenannt wird, wird das <xref:System.IO.FileSystemWatcher> automatisch an das neu umbenannte Element angefügt. Wenn Sie z. b. die <xref:System.IO.FileSystemWatcher.Path%2A> -Eigenschaft auf "c:\Eigene Dokumente" festlegen und dann das Verzeichnis manuell in "c:\Your Documents" umbenennen, lauscht die Komponente weiterhin auf Änderungs Benachrichtigungen für das neu umbenannte Verzeichnis. Wenn Sie jedoch nach der- <xref:System.IO.FileSystemWatcher.Path%2A> Eigenschaft Fragen, enthält Sie den alten Pfad. Dies liegt daran, dass die Komponente bestimmt, welche Verzeichnisse auf der Grundlage des Handles überwacht werden, und nicht auf den Namen des Verzeichnisses. Das Umbenennen wirkt sich nicht auf das Handle aus. Wenn Sie also die Komponente zerstören und dann neu erstellen, ohne die Eigenschaft zu aktualisieren <xref:System.IO.FileSystemWatcher.Path%2A> , schlägt die Anwendung fehl, da das Verzeichnis nicht mehr vorhanden ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein erstellt <xref:System.IO.FileSystemWatcher> , um das zur Laufzeit angegebene Verzeichnis zu überwachen. Die Komponente wird so festgelegt, dass Sie Änderungen in `LastWrite` und `LastAccess` Uhrzeit, das Erstellen, löschen oder Umbenennen von Textdateien im Verzeichnis überwacht. Wenn eine Datei geändert, erstellt oder gelöscht wird, wird der Pfad zur Datei in der Konsole gedruckt. Wenn eine Datei umbenannt wird, werden die alten und neuen Pfade in der Konsole gedruckt.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der angegebene Pfad ist nicht vorhanden oder konnte nicht gefunden werden.  
  
 Oder  
  
 Der angegebene Pfad enthält Platzhalterzeichen.  
  
 Oder  
  
 Der angegebene Pfad enthält ungültige Zeichen.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberSignature Language="F#" Value="member this.Renamed : System.IO.RenamedEventHandler " Usage="member this.Renamed : System.IO.RenamedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.IO.IODescription("FSW_Renamed")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.IO.IODescription("FSW_Renamed")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.IO.IODescription("Occurs when a file/directory rename matches the filter")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.IO.IODescription("Occurs when a file/directory rename matches the filter")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn im angegebenen <see cref="P:System.IO.FileSystemWatcher.Path" /> eine Datei oder ein Verzeichnis umbenannt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das `Renamed` Ereignis ist ein Delegat mit <xref:System.IO.RenamedEventHandler> der folgenden Signatur:

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 Das- <xref:System.IO.RenamedEventArgs> Objekt enthält Informationen zum Umbenennungs Vorgang, z. b. den Typ der Umbenennung (die- <xref:System.IO.FileSystemEventArgs.ChangeType> Eigenschaft), den alten und neuen Namen sowie den alten und den neuen Pfad. Beachten Sie, dass die- <xref:System.IO.FileSystemEventArgs.Name> Eigenschaft für umbenannte Ereignisse NULL sein kann, wenn <xref:System.IO.FileSystemWatcher> keine übereinstimmenden alten und neuen Namens Ereignisse vom Betriebssystem erhält.

 Beim Umbenennen des Verzeichnisses, das Sie überwachen, wird keine Benachrichtigung erhoben. Benachrichtigungen werden nur für Einträge in dem Verzeichnis ausgelöst, das Sie überwachen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das- <xref:System.IO.FileSystemWatcher.Renamed> Ereignis verwendet, um den Dateipfad der Konsole anzuzeigen, wenn die überwachte Datei umbenannt wird.  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.IO.FileSystemWatcher.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.ComponentModel.ISite" /> für den <see cref="T:System.IO.FileSystemWatcher" /> ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.ComponentModel.ISite" /> für das <see cref="T:System.IO.FileSystemWatcher" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 -Standorte binden einen <xref:System.ComponentModel.Component> an einen <xref:System.ComponentModel.Design.IDesignerHost.Container%2A> und ermöglichen die Kommunikation zwischen Ihnen und ermöglichen es dem Container, seine Komponenten zu verwalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.DefaultValue(null)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DefaultValue(null)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.IO.IODescription("FSW_SynchronizingObject")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.IO.IODescription("FSW_SynchronizingObject")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinmac-3.0">
          <AttributeName Language="C#">[System.ComponentModel.Browsable(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.Browsable(false)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName Language="C#">[System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab, das zum Marshallen von Ereignishandleraufrufen verwendet wird, die aufgrund einer Verzeichnisänderung ausgegeben werden, oder legt dieses fest.</summary>
        <value>Das <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, das das Objekt zum Marshallen der Ereignishandleraufrufe darstellt, die aufgrund einer Verzeichnisänderung ausgegeben werden. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> `null` den Wert hat, werden Methoden, die die <xref:System.IO.FileSystemWatcher.Changed> <xref:System.IO.FileSystemWatcher.Created> Ereignisse,, und behandeln, <xref:System.IO.FileSystemWatcher.Deleted> <xref:System.IO.FileSystemWatcher.Renamed> in einem Thread aus dem Thread Pool des Systems aufgerufen. Weitere Informationen zu System Thread Pools finden Sie unter <xref:System.Threading.ThreadPool> .  
  
 Wenn die <xref:System.IO.FileSystemWatcher.Changed> <xref:System.IO.FileSystemWatcher.Created> -, <xref:System.IO.FileSystemWatcher.Deleted> -,-und- <xref:System.IO.FileSystemWatcher.Renamed> Ereignisse von einer Visual Windows Forms-Komponente behandelt werden, z. b. eine, kann der <xref:System.Windows.Forms.Button> Zugriff auf die Komponente über den System Thread Pool möglicherweise nicht funktionieren, oder es kann zu einer Ausnahme kommen. Vermeiden <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> Sie dies, indem Sie auf eine Windows Forms Komponente festlegen, die bewirkt, dass die Methoden, die das <xref:System.IO.FileSystemWatcher.Changed> -Ereignis, das <xref:System.IO.FileSystemWatcher.Created> <xref:System.IO.FileSystemWatcher.Deleted> -Ereignis und das-Ereignis behandeln, <xref:System.IO.FileSystemWatcher.Renamed> in demselben Thread aufgerufen werden, auf dem die Komponente erstellt wurde.  
  
 Wenn <xref:System.IO.FileSystemWatcher> [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in einem Windows Forms-Designer verwendet wird, wird <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> von automatisch auf das Steuerelement festgelegt, das das enthält <xref:System.IO.FileSystemWatcher> . Wenn Sie z. b. ein- <xref:System.IO.FileSystemWatcher> Objekt in einem Designer für Form1 (das von erbt) platzieren, <xref:System.Windows.Forms.Form> wird die- <xref:System.IO.FileSystemWatcher.SynchronizingObject%2A> Eigenschaft von <xref:System.IO.FileSystemWatcher> auf die Instanz von Form1 festgelegt.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Eine synchrone Methode, die eine Struktur mit spezifischen Informationen zur eingetretenen Änderung zurückgibt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged changeType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType">Die zu überwachenden <see cref="T:System.IO.WatcherChangeTypes" />.</param>
        <summary>Eine synchrone Methode, die eine Struktur mit spezifischen Informationen zur eingetretenen Änderung zurückgibt, sofern diese mit der Art der Änderung übereinstimmt, die überwacht werden soll.</summary>
        <returns>Ein <see cref="T:System.IO.WaitForChangedResult" /> mit spezifischen Informationen zur eingetretenen Änderung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wartet unbegrenzt, bis die erste Änderung stattfindet, und gibt dann zurück. Dies entspricht der Verwendung <xref:System.IO.FileSystemWatcher.WaitForChanged%2A> von, wobei der `timeout` -Parameter auf-1 festgelegt ist.  
  
> [!NOTE]
>  Diese Methode ermöglicht, dass ein Ereignishandler aufgerufen wird, um auf Dateiänderungen zu reagieren, auch wenn die- <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> Eigenschaft auf festgelegt ist `false` .  
  
 In manchen Systemen <xref:System.IO.FileSystemWatcher> meldet Änderungen an Dateien mithilfe des kurzen Dateinamen Formats 8,3. Beispielsweise könnte eine Änderung an "longfilename. LongExtension" als "LongFi ~" (longfi ~) gemeldet werden. Lon ".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes * int -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged (changeType, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType">Die zu überwachenden <see cref="T:System.IO.WatcherChangeTypes" />.</param>
        <param name="timeout">Die Wartezeit (in Millisekunden) bis zum Timeout.</param>
        <summary>Eine synchrone Methode, die eine Struktur mit spezifischen Informationen zur eingetretenen Änderung zurückgibt, sofern diese mit der Art der zu überwachenden Änderung übereinstimmt und die Zeit (in Millisekunden) bis zum Timeout nicht abgelaufen ist.</summary>
        <returns>Ein <see cref="T:System.IO.WaitForChangedResult" /> mit spezifischen Informationen zur eingetretenen Änderung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wartet, bis eine Änderung auftritt oder ein Timeout aufgetreten ist. Der Wert-1 für den- `timeout` Parameter bedeutet, dass unbegrenzt gewartet wird.  
  
> [!NOTE]
>  Diese Methode ermöglicht, dass ein Ereignishandler aufgerufen wird, um auf Dateiänderungen zu reagieren, auch wenn die- <xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A> Eigenschaft auf festgelegt ist `false` .  
  
 In manchen Systemen <xref:System.IO.FileSystemWatcher> meldet Änderungen an Dateien mithilfe des kurzen Dateinamen Formats 8,3. Beispielsweise könnte eine Änderung an "longfilename. LongExtension" als "LongFi ~" (longfi ~) gemeldet werden. Lon ".  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>
