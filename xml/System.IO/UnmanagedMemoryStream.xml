<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="UnmanagedMemoryStream.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5118ab17a373e7e3ec2e224596d6e7345bcbabc38.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">118ab17a373e7e3ec2e224596d6e7345bcbabc38</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IO.UnmanagedMemoryStream">
          <source>Provides access to unmanaged blocks of memory from managed code.</source>
          <target state="translated">Ermöglicht den Zugriff auf nicht verwaltete Speicherblöcke aus verwaltetem Code heraus.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.UnmanagedMemoryStream">
          <source>This class supports access to unmanaged memory using the existing stream-based model and does not require that the contents in the unmanaged memory be copied to the heap.</source>
          <target state="translated">Diese Klasse unterstützt den Zugriff auf nicht verwalteten Speicher, die mit dem vorhandenen streambasierte Modell und erfordert nicht, dass der Inhalt in den nicht verwalteten Speicher, die dem Heap kopiert werden.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.UnmanagedMemoryStream">
          <source>The following code example demonstrates how to read from and write to unmanaged memory using the <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> class.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Lesen und Schreiben in nicht verwalteten Speicher mithilfe der <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.UnmanagedMemoryStream">
          <source>A block of unmanaged memory is allocated and de-allocated using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">Ein nicht verwalteten Speicherblock ist reserviert und aufgehoben mithilfe der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="T:System.IO.UnmanagedMemoryStream">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.UnmanagedMemoryStream" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.IO.UnmanagedMemoryStream" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.UnmanagedMemoryStream" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.IO.UnmanagedMemoryStream" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor">
          <source>The user does not have the required permission.</source>
          <target state="translated">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor">
          <source>for accessing unmanaged memory.</source>
          <target state="translated">für den Zugriff auf nicht verwalteten Speicher.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)">
          <source>A pointer to an unmanaged memory location.</source>
          <target state="translated">Ein Zeiger auf eine nicht verwaltete Speicheradresse.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)">
          <source>The length of the memory to use.</source>
          <target state="translated">Die Länge des zu verwendenden Speichers.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.UnmanagedMemoryStream" /&gt;</ph> class using the specified location and memory length.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.IO.UnmanagedMemoryStream" /&gt;</ph>-Klasse mit der angegebenen Position und Speicherlänge.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)">
          <source>This constructor creates a new instance of the <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> class, and by default sets the <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.CanWrite%2A&gt;</ph> property to <ph id="ph3">`false`</ph> and the <ph id="ph4">&lt;xref:System.IO.UnmanagedMemoryStream.CanRead%2A&gt;</ph> property to <ph id="ph5">`true`</ph>.</source>
          <target state="translated">Dieser Konstruktor erstellt eine neue Instanz der der <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> -Klasse und legt fest, in der Standardeinstellung die <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.CanWrite%2A&gt;</ph> Eigenschaft <ph id="ph3">`false`</ph> und die <ph id="ph4">&lt;xref:System.IO.UnmanagedMemoryStream.CanRead%2A&gt;</ph> Eigenschaft <ph id="ph5">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream.Length%2A&gt;</ph> property is set to the value of the <ph id="ph2">`length`</ph> parameter and cannot be changed.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream.Length%2A&gt;</ph> auf den Wert der Eigenschaft festgelegt ist die <ph id="ph2">`length`</ph> Parameter und kann nicht geändert werden.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)">
          <source>The following code example demonstrates how to read from and write to unmanaged memory using the <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> class.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Lesen und Schreiben in nicht verwalteten Speicher mithilfe der <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)">
          <source>A block of unmanaged memory is allocated and de-allocated using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">Ein nicht verwalteten Speicherblock ist reserviert und aufgehoben mithilfe der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)">
          <source>The user does not have the required permission.</source>
          <target state="translated">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)">
          <source>The <ph id="ph1">&lt;paramref name="pointer" /&gt;</ph> value is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="pointer" /&gt;</ph>-Wert ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)">
          <source>The <ph id="ph1">&lt;paramref name="length" /&gt;</ph> value is less than zero.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="length" /&gt;</ph>-Wert ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)">
          <source>The <ph id="ph1">&lt;paramref name="length" /&gt;</ph> is large enough to cause an overflow.</source>
          <target state="translated">Die <ph id="ph1">&lt;paramref name="length" /&gt;</ph> ist groß genug, um einen Überlauf zu verursachen.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)">
          <source>for accessing unmanaged memory.</source>
          <target state="translated">für den Zugriff auf nicht verwalteten Speicher.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)">
          <source>The buffer to contain the unmanaged memory stream.</source>
          <target state="translated">Der Puffer, der den nicht verwalteten Speicherstream enthalten soll.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)">
          <source>The byte position in the buffer at which to start the unmanaged memory stream.</source>
          <target state="translated">Die Byteposition im Puffer, ab der der nicht verwaltete Speicherstream beginnen soll.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)">
          <source>The length of the unmanaged memory stream.</source>
          <target state="translated">Die Länge des nicht verwalteten Speicherstreams.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.UnmanagedMemoryStream" /&gt;</ph> class in a safe buffer with a specified offset and length.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.IO.UnmanagedMemoryStream" /&gt;</ph>-Klasse in einem sicheren Puffer mit einem angegebenen Offset und einer angegebenen Länge.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>A pointer to an unmanaged memory location.</source>
          <target state="translated">Ein Zeiger auf eine nicht verwaltete Speicheradresse.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The length of the memory to use.</source>
          <target state="translated">Die Länge des zu verwendenden Speichers.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The total amount of memory assigned to the stream.</source>
          <target state="translated">Die Gesamtgröße des dem Stream zugewiesenen Speichers.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.UnmanagedMemoryStream" /&gt;</ph> class using the specified location, memory length, total amount of memory, and file access values.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.IO.UnmanagedMemoryStream" /&gt;</ph>-Klasse mit der angegebenen Position, Speicherlänge, Gesamtspeichergröße und den Dateizugriffswerten.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The <ph id="ph1">`length`</ph> parameter defines the current amount of memory in use.</source>
          <target state="translated">Die <ph id="ph1">`length`</ph> Parameter definiert die aktuelle Menge an Arbeitsspeicher verwendet.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>If reading or appending data to the stream, the <ph id="ph1">`length`</ph> value should be equal to the amount of valid data in the stream to be read from or preserved.</source>
          <target state="translated">Beim Lesen oder Anfügen von Daten in den Stream der <ph id="ph1">`length`</ph> Wert muss gleich der Menge gültige Daten im Datenstrom gelesen werden soll, oder beibehalten.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>If writing to the stream, this value should be zero.</source>
          <target state="translated">Wenn in den Stream zu schreiben, sollte dieser Wert 0 (null) sein.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The <ph id="ph1">`capacity`</ph> parameter indicates the amount of total memory available.</source>
          <target state="translated">Die <ph id="ph1">`capacity`</ph> Parameter gibt den Umfang des verfügbaren Gesamtspeichers.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>This value can describe a region that is longer than the length specified, or indicate a region that can be appended to.</source>
          <target state="translated">Dieser Wert kann beschreiben eine Region, die länger als die angegebene Länge ist auch ein Anzeichen eine Region, die hinzugefügt werden kann.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>Any attempt to write beyond this value will fail.</source>
          <target state="translated">Jeder Versuch, diesen Wert hinaus schreiben schlägt fehl.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The <ph id="ph1">`access`</ph> parameter sets the <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.CanRead%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.IO.UnmanagedMemoryStream.CanWrite%2A&gt;</ph> properties.</source>
          <target state="translated">Die <ph id="ph1">`access`</ph> Parametersätze der <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.CanRead%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.IO.UnmanagedMemoryStream.CanWrite%2A&gt;</ph> Eigenschaften.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>Note that specifying <ph id="ph1">&lt;xref:System.IO.FileAccess.Write&gt;</ph> does not guarantee that the stream will be writable.</source>
          <target state="translated">Beachten Sie, dass die Angabe <ph id="ph1">&lt;xref:System.IO.FileAccess.Write&gt;</ph> garantiert nicht, dass der Stream geschrieben werden kann.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The access parameters allow the implementer to create an object whose implementation can match the actual stream that is exposed.</source>
          <target state="translated">Die Zugriffsparameter zulassen die Implementierung ein Objekt zu erstellen, deren Implementierung den tatsächlichen Stream verglichen werden kann, der verfügbar gemacht wird.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The following code example demonstrates how to read from and write to unmanaged memory using the <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> class.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Lesen und Schreiben in nicht verwalteten Speicher mithilfe der <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>A block of unmanaged memory is allocated and de-allocated using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">Ein nicht verwalteten Speicherblock ist reserviert und aufgehoben mithilfe der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The user does not have the required permission.</source>
          <target state="translated">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The <ph id="ph1">&lt;paramref name="pointer" /&gt;</ph> value is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="pointer" /&gt;</ph>-Wert ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The <ph id="ph1">&lt;paramref name="length" /&gt;</ph> value is less than zero.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="length" /&gt;</ph>-Wert ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The <ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> value is less than zero.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="capacity" /&gt;</ph>-Wert ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The <ph id="ph1">&lt;paramref name="length" /&gt;</ph> value is greater than the <ph id="ph2">&lt;paramref name="capacity" /&gt;</ph> value.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="length" /&gt;</ph>-Wert ist größer als der <ph id="ph2">&lt;paramref name="capacity" /&gt;</ph>-Wert.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>for accessing unmanaged memory.</source>
          <target state="translated">für den Zugriff auf nicht verwalteten Speicher.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The buffer to contain the unmanaged memory stream.</source>
          <target state="translated">Der Puffer, der den nicht verwalteten Speicherstream enthalten soll.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The byte position in the buffer at which to start the unmanaged memory stream.</source>
          <target state="translated">Die Byteposition im Puffer, ab der der nicht verwaltete Speicherstream beginnen soll.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The length of the unmanaged memory stream.</source>
          <target state="translated">Die Länge des nicht verwalteten Speicherstreams.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The mode of file access to the unmanaged memory stream.</source>
          <target state="translated">Der Modus des Dateizugriffs auf den nicht verwalteten Speicherstream.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.UnmanagedMemoryStream" /&gt;</ph> class in a safe buffer with a specified offset, length, and file access.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.IO.UnmanagedMemoryStream" /&gt;</ph>-Klasse in einem sicheren Puffer mit einem angegebenen Offset, einer angegebenen Länge und angegebenem Dateizugriff.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="P:System.IO.UnmanagedMemoryStream.CanRead">
          <source>Gets a value indicating whether a stream supports reading.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob ein Stream Lesevorgänge unterstützt.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.CanRead">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if the object was created by a constructor with an <ph id="ph2">&lt;paramref name="access" /&gt;</ph> parameter that did not include reading the stream and if the stream is closed; otherwise, <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>, wenn das Objekt von einem Konstruktor mit einem <ph id="ph2">&lt;paramref name="access" /&gt;</ph>-Parameter erstellt wurde, das Lesen des Streams nicht eingeschlossen war und der Stream geschlossen ist, andernfalls <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.CanRead">
          <source>This property indicates whether the current stream object supports reading.</source>
          <target state="translated">Diese Eigenschaft gibt an, ob das aktuelle Streamobjekt Lesevorgänge unterstützt.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.CanRead">
          <source>The following code example demonstrates how to read from and write to unmanaged memory using the <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> class.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Lesen und Schreiben in nicht verwalteten Speicher mithilfe der <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.CanRead">
          <source>A block of unmanaged memory is allocated and de-allocated using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">Ein nicht verwalteten Speicherblock ist reserviert und aufgehoben mithilfe der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.CanRead">
          <source>In this example, an <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> object is passed to a method which checks the <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.CanRead%2A&gt;</ph> property before attempting to display the contents to the console.</source>
          <target state="translated">In diesem Beispiel wird ein <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> Objekt wird an eine Methode, die überprüft, übergeben die <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.CanRead%2A&gt;</ph> Eigenschaft, bevor Sie versuchen, den Inhalt in der Konsole anzeigen.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="P:System.IO.UnmanagedMemoryStream.CanSeek">
          <source>Gets a value indicating whether a stream supports seeking.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob ein Stream Suchvorgänge unterstützt.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.CanSeek">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if the stream is closed; otherwise, <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>, wenn der Stream geschlossen ist, andernfalls <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.CanSeek">
          <source>This property indicates whether the current stream object supports seeking.</source>
          <target state="translated">Diese Eigenschaft gibt an, ob das aktuelle Streamobjekt Suchvorgänge unterstützt.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="P:System.IO.UnmanagedMemoryStream.CanWrite">
          <source>Gets a value indicating whether a stream supports writing.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob ein Stream Schreibvorgänge unterstützt.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.CanWrite">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if the object was created by a constructor with an <ph id="ph2">&lt;paramref name="access" /&gt;</ph> parameter value that supports writing or was created by a constructor that had no parameters, or if the stream is closed; otherwise, <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>, wenn das Objekt von einem Konstruktor mit einem <ph id="ph2">&lt;paramref name="access" /&gt;</ph>-Parameterwert erstellt wurde, der Schreibvorgänge unterstützt, oder wenn es von einem Konstruktor ohne Parameter erstellt wurde oder wenn der Stream geschlossen ist, andernfalls <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.CanWrite">
          <source>This property indicates whether the current stream object supports writing.</source>
          <target state="translated">Diese Eigenschaft gibt an, ob das aktuelle Streamobjekt Schreibvorgänge unterstützt.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.CanWrite">
          <source>The following code example demonstrates how to read from and write to unmanaged memory using the <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> class.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Lesen und Schreiben in nicht verwalteten Speicher mithilfe der <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.CanWrite">
          <source>A block of unmanaged memory is allocated and de-allocated using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">Ein nicht verwalteten Speicherblock ist reserviert und aufgehoben mithilfe der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.CanWrite">
          <source>In this example, an <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> object is passed to a method which checks the <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.CanWrite%2A&gt;</ph> property before attempting to write the data to the stream.</source>
          <target state="translated">In diesem Beispiel wird ein <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> Objekt wird an eine Methode, die überprüft, übergeben die <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.CanWrite%2A&gt;</ph> Eigenschaft, bevor Sie versuchen, die Daten in den Stream geschrieben.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="P:System.IO.UnmanagedMemoryStream.Capacity">
          <source>Gets the stream length (size) or the total amount of memory assigned to a stream (capacity).</source>
          <target state="translated">Ruft die Streamlänge (Größe) oder die Gesamtgröße des einem Stream zugewiesenen Speichers (Kapazität) ab.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.Capacity">
          <source>The size or capacity of the stream.</source>
          <target state="translated">Die Größe oder die Kapazität des Streams.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.Capacity">
          <source>This property returns the <ph id="ph1">`capacity`</ph> value provided to the constructor.</source>
          <target state="translated">Diese Eigenschaft gibt die <ph id="ph1">`capacity`</ph> Wert für den Konstruktor bereitgestellt.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.Capacity">
          <source>If no <ph id="ph1">`capacity`</ph> value was specified when the stream was initialized, this property returns the stream length.</source>
          <target state="translated">Wenn kein <ph id="ph1">`capacity`</ph> Wert wurde angegeben, wenn der Stream initialisiert wurde, gibt diese Eigenschaft die Länge des Streams.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="P:System.IO.UnmanagedMemoryStream.Capacity">
          <source>The stream is closed.</source>
          <target state="translated">Der Stream ist geschlossen.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to release only unmanaged resources.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <ph id="ph2">&lt;see langword="false" /&gt;</ph>, um ausschließlich nicht verwaltete Ressourcen freizugeben.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.IO.UnmanagedMemoryStream" /&gt;</ph> and optionally releases the managed resources.</source>
          <target state="translated">Gibt die von <ph id="ph1">&lt;see cref="T:System.IO.UnmanagedMemoryStream" /&gt;</ph> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)">
          <source>This method is called by the public <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Diese Methode wird aufgerufen, der öffentlich <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> Methode und die <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> invokes the protected <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.Dispose%2A&gt;</ph> method with the <ph id="ph3">`disposing`</ph> parameter set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> Ruft die geschützte <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.Dispose%2A&gt;</ph> Methode mit dem <ph id="ph3">`disposing`</ph> Parametersatz auf <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> invokes <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.Dispose%2A&gt;</ph> with <ph id="ph3">`disposing`</ph> set to <ph id="ph4">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> Ruft <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.Dispose%2A&gt;</ph> mit <ph id="ph3">`disposing`</ph> festgelegt <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)">
          <source>When the <ph id="ph1">`disposing`</ph> parameter is <ph id="ph2">`true`</ph>, this method releases all resources held by any managed objects that this <ph id="ph3">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> references.</source>
          <target state="translated">Wenn der <ph id="ph1">`disposing`</ph>-Parameter <ph id="ph2">`true`</ph> ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <ph id="ph3">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> verweist.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)">
          <source>This method invokes the <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph> method of each referenced object.</source>
          <target state="translated">Diese Methode ruft die <ph id="ph1">&lt;xref:System.ComponentModel.Component.Dispose%2A&gt;</ph>-Methode aller Objekte auf, auf die verwiesen wird.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> can be called multiple times by other objects.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> kann von anderen Objekten mehrmals aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" /&gt;</ph> be careful not to reference objects that have been previously disposed of in an earlier call to <ph id="ph2">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph>.</source>
          <target state="translated">Zum Überschreiben <ph id="ph1">&lt;see cref="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" /&gt;</ph> Achten Sie darauf, dass Sie nicht auf Objekte verweisen, die einen früheren Aufruf freigegeben wurden <ph id="ph2">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)">
          <source>For more information about how to implement <ph id="ph1">&lt;see cref="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" /&gt;</ph>, see <bpt id="p1">[</bpt>Implementing a Dispose Method<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Weitere Informationen zum Implementieren <ph id="ph1">&lt;see cref="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" /&gt;</ph>, finden Sie unter <bpt id="p1">[</bpt>Implementieren einer Dispose-Methode<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)">
          <source>For more information about <ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">&lt;see cref="M:System.ComponentModel.Component.Dispose" /&gt;</ph> und <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, finden Sie unter <bpt id="p1">[</bpt>Bereinigen von nicht verwalteten Ressourcen<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Flush">
          <source>Overrides the <ph id="ph1">&lt;see cref="M:System.IO.Stream.Flush" /&gt;</ph> method so that no action is performed.</source>
          <target state="translated">Überschreibt die <ph id="ph1">&lt;see cref="M:System.IO.Stream.Flush" /&gt;</ph>-Methode, sodass keine Aktion durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Flush">
          <source>This method performs no action for this class but is included as part of the <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> base class.</source>
          <target state="translated">Diese Methode führt keine Aktion für diese Klasse jedoch als Bestandteil von wird der <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> Basisklasse.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Flush">
          <source>Since any data is written to RAM, this method is redundant.</source>
          <target state="translated">Da alle Daten in den Arbeitsspeicher geschrieben werden, ist diese Methode redundant.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Flush">
          <source>The stream is closed.</source>
          <target state="translated">Der Stream ist geschlossen.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">Das Token zum überwachen von Abbruchanforderungen.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>The default value is <ph id="ph1">&lt;see cref="P:System.Threading.CancellationToken.None" /&gt;</ph>.</source>
          <target state="translated">Der Standardwert ist <ph id="ph1">&lt;see cref="P:System.Threading.CancellationToken.None" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>Overrides the <ph id="ph1">&lt;see cref="M:System.IO.Stream.FlushAsync(System.Threading.CancellationToken)" /&gt;</ph> method so that the operation is cancelled if specified, but no other action is performed.</source>
          <target state="translated">Überschreibt die <ph id="ph1">&lt;see cref="M:System.IO.Stream.FlushAsync(System.Threading.CancellationToken)" /&gt;</ph>-Methode. Der Vorgang wird abgebrochen, wenn dies angegeben wurde, ansonsten wird keine Aktion durchgeführt.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>Available starting in <ph id="ph1">[!INCLUDE[net_2015](~/includes/net-2015-md.md)]</ph></source>
          <target state="translated">Verfügbar ab <ph id="ph1">[!INCLUDE[net_2015](~/includes/net-2015-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous flush operation.</source>
          <target state="translated">Eine Aufgabe, die die asynchrone Leerung darstellt.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)">
          <source>If the operation isn’t cancelled, the <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> calls the <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.Flush%2A&gt;</ph> method, which means that no action performed.</source>
          <target state="translated">Wenn der Vorgang abgebrochen wird nicht, die <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> Aufrufe der <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.Flush%2A&gt;</ph> Methode, was bedeutet, dass keine Aktion durchgeführt.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="T:System.IO.UnmanagedMemoryStream">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.UnmanagedMemoryStream" /&gt;</ph> class in a safe buffer, or by using a pointer to an unmanaged memory location.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.IO.UnmanagedMemoryStream" /&gt;</ph>-Klasse in einem sicheren Puffer oder unter Verwendung eines Zeigers auf eine nicht verwaltete Speicheradresse.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>A pointer to an unmanaged memory location.</source>
          <target state="translated">Ein Zeiger auf eine nicht verwaltete Speicheradresse.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The length of the memory to use.</source>
          <target state="translated">Die Länge des zu verwendenden Speichers.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The total amount of memory assigned to the stream.</source>
          <target state="translated">Die Gesamtgröße des dem Stream zugewiesenen Speichers.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.IO.FileAccess" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.UnmanagedMemoryStream" /&gt;</ph> class by using a pointer to an unmanaged memory location.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.IO.UnmanagedMemoryStream" /&gt;</ph>-Klasse unter Verwendung eines Zeigers auf eine nicht verwaltete Speicheradresse.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>This method is equivalent to the <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream.%23ctor%2A&gt;</ph> constructor.</source>
          <target state="translated">Diese Methode entspricht der <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream.%23ctor%2A&gt;</ph> Konstruktor.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>It supports methods that need to initialize the pointer before setting stream variables and, therefore, cannot call the parameterized constructor.</source>
          <target state="translated">Es unterstützt Methoden, die den Zeiger zu initialisieren, vor dem Festlegen von Streamvariablen müssen und deshalb darf nicht den parametrisierten Konstruktor aufrufen.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>Such methods should use the default constructor, <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream.%23ctor&gt;</ph>, initialize the pointer, and then invoke the <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.Initialize%2A&gt;</ph> method.</source>
          <target state="translated">Solche Methoden sollten den Standardkonstruktor verwenden <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream.%23ctor&gt;</ph>, initialisieren Sie den Zeiger und rufen dann die <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.Initialize%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The user does not have the required permission.</source>
          <target state="translated">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The <ph id="ph1">&lt;paramref name="pointer" /&gt;</ph> value is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="pointer" /&gt;</ph>-Wert ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The <ph id="ph1">&lt;paramref name="length" /&gt;</ph> value is less than zero.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="length" /&gt;</ph>-Wert ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The <ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> value is less than zero.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="capacity" /&gt;</ph>-Wert ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The <ph id="ph1">&lt;paramref name="length" /&gt;</ph> value is large enough to cause an overflow.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="length" /&gt;</ph>-Wert ist groß genug, um einen Überlauf zu verursachen.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>for accessing unmanaged memory.</source>
          <target state="translated">für den Zugriff auf nicht verwalteten Speicher.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The buffer to contain the unmanaged memory stream.</source>
          <target state="translated">Der Puffer, der den nicht verwalteten Speicherstream enthalten soll.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The byte position in the buffer at which to start the unmanaged memory stream.</source>
          <target state="translated">Die Byteposition im Puffer, ab der der nicht verwaltete Speicherstream beginnen soll.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The length of the unmanaged memory stream.</source>
          <target state="translated">Die Länge des nicht verwalteten Speicherstreams.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>The mode of file access to the unmanaged memory stream.</source>
          <target state="translated">Der Modus des Dateizugriffs auf den nicht verwalteten Speicherstream.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.UnmanagedMemoryStream" /&gt;</ph> class in a safe buffer with a specified offset, length, and file access.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.IO.UnmanagedMemoryStream" /&gt;</ph>-Klasse in einem sicheren Puffer mit einem angegebenen Offset, einer angegebenen Länge und angegebenem Dateizugriff.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="P:System.IO.UnmanagedMemoryStream.Length">
          <source>Gets the length of the data in a stream.</source>
          <target state="translated">Ruft die Länge der Daten in einem Stream ab.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.Length">
          <source>The length of the data in the stream.</source>
          <target state="translated">Die Länge der Daten im Stream.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.Length">
          <source>If unchanged since the stream was initialized, this property returns the length value provided to the constructor.</source>
          <target state="translated">Wenn unverändert, da der Stream initialisiert wurde, gibt diese Eigenschaft den Wert für die Länge für den Konstruktor bereitgestellt.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.Length">
          <source>If changes to the stream have occurred, this property reflects any changes to the length of the data.</source>
          <target state="translated">Wenn Änderungen in den Stream aufgetreten sind, gibt diese Eigenschaft Änderungen auf die Länge der Daten wieder.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.Length">
          <source>The following code example demonstrates how to read from and write to unmanaged memory using the <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> class.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Lesen und Schreiben in nicht verwalteten Speicher mithilfe der <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.Length">
          <source>A block of unmanaged memory is allocated and de-allocated using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">Ein nicht verwalteten Speicherblock ist reserviert und aufgehoben mithilfe der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="P:System.IO.UnmanagedMemoryStream.Length">
          <source>The stream is closed.</source>
          <target state="translated">Der Stream ist geschlossen.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="P:System.IO.UnmanagedMemoryStream.Position">
          <source>Gets or sets the current position in a stream.</source>
          <target state="translated">Ruft die aktuelle Position in einem Stream ab oder legt diese fest.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.Position">
          <source>The current position in the stream.</source>
          <target state="translated">Die aktuelle Position in dem Stream.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.Position">
          <source>When a stream is initialized, this property is set to zero.</source>
          <target state="translated">Wenn ein Stream initialisiert wird, wird diese Eigenschaft auf 0 (null) festgelegt.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.Position">
          <source>Although you can set the position of the stream beyond the stream's capacity, you will not be able to access that area using the <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream.Read%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.Write%2A&gt;</ph> methods.</source>
          <target state="translated">Obwohl Sie die Position des Streams über den Stream Kapazität festlegen können, Sie ist nicht möglich, Bereich mit den Zugriff auf die <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream.Read%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.Write%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.Position">
          <source><ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream.Read%2A&gt;</ph> will return 0 and <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.Write%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream.Read%2A&gt;</ph> Gibt 0 zurück und <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.Write%2A&gt;</ph> löst eine <ph id="ph3">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.Position">
          <source>This support is primarily for design and code compatibility with basic stream operations.</source>
          <target state="translated">Diese Unterstützung wird in erster Linie für Entwurf und Code Kompatibilität mit grundlegenden FileStream-Vorgänge.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="P:System.IO.UnmanagedMemoryStream.Position">
          <source>The stream is closed.</source>
          <target state="translated">Der Stream ist geschlossen.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="P:System.IO.UnmanagedMemoryStream.Position">
          <source>The position is set to a value that is less than zero, or the position is larger than <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> or results in overflow when added to the current pointer.</source>
          <target state="translated">Die Position wurde auf einen Wert festgelegt, der kleiner als 0 ist, oder die Position ist größer als <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> oder führt beim Hinzufügen zum aktuellen Zeiger zu einem Überlauf.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="P:System.IO.UnmanagedMemoryStream.PositionPointer">
          <source>Gets or sets a byte pointer to a stream based on the current position in the stream.</source>
          <target state="translated">Ruft einen Bytezeiger auf einen Stream auf Grundlage der aktuellen Position im Stream ab oder legt diesen fest.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.PositionPointer">
          <source>A byte pointer.</source>
          <target state="translated">Ein Bytezeiger.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.PositionPointer">
          <source>To return a pointer to the entire stream, set the <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream.Position%2A&gt;</ph> property to zero, and then call this property.</source>
          <target state="translated">Um einen Zeiger auf den gesamten Stream zurückzugeben, legen die <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream.Position%2A&gt;</ph> Eigenschaft auf 0 (null), und rufen Sie diese Eigenschaft.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="P:System.IO.UnmanagedMemoryStream.PositionPointer">
          <source>The current position is larger than the capacity of the stream.</source>
          <target state="translated">Die aktuelle Position ist größer als die Kapazität des Streams.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="P:System.IO.UnmanagedMemoryStream.PositionPointer">
          <source>The position is being set is not a valid position in the current stream.</source>
          <target state="translated">Die festgelegte Position ist keine gültige Position im aktuellen Stream.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="P:System.IO.UnmanagedMemoryStream.PositionPointer">
          <source>The pointer is being set to a lower value than the starting position of the stream.</source>
          <target state="translated">Der Zeiger wird auf einen niedrigeren Wert festgelegt als die Startposition des Streams.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="P:System.IO.UnmanagedMemoryStream.PositionPointer">
          <source>The stream was initialized for use with a <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.SafeBuffer" /&gt;</ph>.</source>
          <target state="translated">Der Stream wurde zur Verwendung mit einem <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.SafeBuffer" /&gt;</ph> initialisiert.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="P:System.IO.UnmanagedMemoryStream.PositionPointer">
          <source>The <ph id="ph1">&lt;see cref="P:System.IO.UnmanagedMemoryStream.PositionPointer" /&gt;</ph> property is valid only for streams that are initialized with a <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> pointer.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.IO.UnmanagedMemoryStream.PositionPointer" /&gt;</ph>-Eigenschaft ist nur für Streams gültig, die mit einem <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph>-Zeiger initialisiert sind.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.PositionPointer">
          <source>for calling unmanaged code, such as calling native code with platform invoke or COM integration.</source>
          <target state="translated">Rufen Sie zum Aufrufen von nicht verwalteten Codes, wie das Aufrufen von systemeigenem Code mit dem Plattformaufruf oder COM-Integration.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.PositionPointer">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Sicherheitsaktion: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.PositionPointer">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.PositionPointer">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.UnmanagedMemoryStream.PositionPointer">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>When this method returns, contains the specified byte array with the values between <bpt id="p1">&lt;c&gt;</bpt>offset<ept id="p1">&lt;/c&gt;</ept> and (<bpt id="p2">&lt;c&gt;</bpt>offset<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>count<ept id="p3">&lt;/c&gt;</ept> - 1) replaced by the bytes read from the current source.</source>
          <target state="translated">Enthält, wenn diese Methode zurückgegeben wird, das angegebene Bytearray mit den Werten zwischen <bpt id="p1">&lt;c&gt;</bpt>offset<ept id="p1">&lt;/c&gt;</ept> und (<bpt id="p2">&lt;c&gt;</bpt>offset<ept id="p2">&lt;/c&gt;</ept><ph id="ph1"> + </ph><bpt id="p3">&lt;c&gt;</bpt>count<ept id="p3">&lt;/c&gt;</ept> –1), das von den Bytes ersetzt wird, die aus der aktuellen Quelle gelesen werden.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Dieser Parameter wird nicht initialisiert übergeben.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin storing the data read from the current stream.</source>
          <target state="translated">Der nullbasierte Byteoffset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept>, ab dem die aus dem aktuellen Stream gelesenen Daten gespeichert werden sollen.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The maximum number of bytes to read from the current stream.</source>
          <target state="translated">Die maximale Anzahl an Bytes, die aus dem aktuellen Stream gelesen werden sollen.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Reads the specified number of bytes into the specified array.</source>
          <target state="translated">Liest die angegebene Anzahl von Bytes in das angegebene Array.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The total number of bytes read into the buffer.</source>
          <target state="translated">Die Gesamtanzahl der in den Puffer gelesenen Bytes.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</source>
          <target state="translated">Dies kann weniger als die Anzahl der angeforderten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder 0, wenn das Ende des Streams erreicht ist.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`offset`</ph> parameter gives the offset of the byte in the <ph id="ph2">`array`</ph> parameter (the buffer index) at which to begin reading, and the <ph id="ph3">`count`</ph> parameter gives the maximum number of bytes to be read from this stream.</source>
          <target state="translated">Die <ph id="ph1">`offset`</ph> -Parameter gibt den Offset des Bytes in der <ph id="ph2">`array`</ph> Parameter (Pufferindex), ab dem gelesen werden soll und die <ph id="ph3">`count`</ph> Parameter gibt die maximale Anzahl von Bytes, die aus diesem Stream gelesen werden.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</source>
          <target state="translated">Der zurückgegebene Wert ist die tatsächliche Anzahl der gelesenen Bytes oder 0 (null), wenn das Ende des Streams erreicht ist.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If the read operation is successful, the current position of the stream is advanced by the number of bytes read.</source>
          <target state="translated">Wenn der Lesevorgang erfolgreich ist, wird die aktuelle Position im Stream um die Anzahl der gelesenen Bytes erweiterte.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If an exception occurs, the current position of the stream is unchanged.</source>
          <target state="translated">Wenn eine Ausnahme auftritt, ist die aktuelle Position im Stream nicht geändert.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream.Read%2A&gt;</ph> method returns zero only after reaching the end of the stream.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream.Read%2A&gt;</ph> Methode gibt 0 (null) erst nach dem Ende des Streams erreicht.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Otherwise, <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream.Read%2A&gt;</ph> always reads at least one byte from the stream before returning.</source>
          <target state="translated">Andernfalls <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream.Read%2A&gt;</ph> liest immer mindestens ein Byte aus dem Stream vor der Rückgabe.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>If no data is available from the stream upon a call to <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream.Read%2A&gt;</ph>, the method will block until at least one byte of data can be returned.</source>
          <target state="translated">Wenn keine Daten verfügbar, aus dem Stream bei einem Aufruf von sind <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream.Read%2A&gt;</ph>, die Methode blockiert, bis mindestens 1 Byte Daten zurückgegeben werden kann.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</source>
          <target state="translated">Eine Implementierung kann weniger Bytes als angefordert zurückgeben, selbst wenn das Ende des Streams nicht erreicht wurde.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The following code example demonstrates how to read from and write to unmanaged memory using the <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> class.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Lesen und Schreiben in nicht verwalteten Speicher mithilfe der <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>A block of unmanaged memory is allocated and de-allocated using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">Ein nicht verwalteten Speicherblock ist reserviert und aufgehoben mithilfe der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The stream is closed.</source>
          <target state="translated">Der Stream ist geschlossen.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The underlying memory does not support reading.</source>
          <target state="translated">Der zugrunde liegende Speicher unterstützt keine Lesevorgänge.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.IO.UnmanagedMemoryStream.CanRead" /&gt;</ph> property is set to <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.IO.UnmanagedMemoryStream.CanRead" /&gt;</ph>-Eigenschaft ist auf <ph id="ph2">&lt;see langword="false" /&gt;</ph> festgelegt.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> parameter is set to <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="buffer" /&gt;</ph>-Parameter ist auf <ph id="ph2">&lt;see langword="null" /&gt;</ph> festgelegt.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> parameter is less than zero.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="offset" /&gt;</ph>-Parameter ist kleiner als 0 (null).</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="count" /&gt;</ph> parameter is less than zero.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="count" /&gt;</ph>-Parameter ist kleiner als 0 (null).</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The length of the buffer array minus the <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> parameter is less than the <ph id="ph2">&lt;paramref name="count" /&gt;</ph> parameter.</source>
          <target state="translated">Die Länge des Pufferarrays minus dem <ph id="ph1">&lt;paramref name="offset" /&gt;</ph>-Parameter ist kleiner als der <ph id="ph2">&lt;paramref name="count" /&gt;</ph>-Parameter.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The buffer to write the data into.</source>
          <target state="translated">Der Puffer, in den die Daten geschrieben werden sollen.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin writing data from the stream.</source>
          <target state="translated">Der Byteoffset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept>, ab dem Daten aus dem Stream geschrieben werden sollen.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The maximum number of bytes to read.</source>
          <target state="translated">Die maximale Anzahl der zu lesenden Bytes.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">Das Token zum überwachen von Abbruchanforderungen.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The default value is <ph id="ph1">&lt;see cref="P:System.Threading.CancellationToken.None" /&gt;</ph>.</source>
          <target state="translated">Der Standardwert ist <ph id="ph1">&lt;see cref="P:System.Threading.CancellationToken.None" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Asynchronously reads the specified number of bytes into the specified array.</source>
          <target state="translated">Liest die angegebene Anzahl von Bytes asynchron in das angegebene Array.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Available starting in <ph id="ph1">[!INCLUDE[net_2015](~/includes/net-2015-md.md)]</ph></source>
          <target state="translated">Verfügbar ab <ph id="ph1">[!INCLUDE[net_2015](~/includes/net-2015-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous read operation.</source>
          <target state="translated">Eine Aufgabe, die den asynchronen Lesevorgang darstellt.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The value of the <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> parameter contains the total number of bytes read into the buffer.</source>
          <target state="translated">Der Wert des <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph>-Parameters enthält die Gesamtzahl der Bytes, die in den Puffer gelesen werden.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</source>
          <target state="translated">Der Ergebniswert kann niedriger als die Anzahl der angeforderten Bytes sein, wenn die Anzahl an derzeit verfügbaren Bytes kleiner ist als die angeforderte Anzahl, oder sie kann 0 (null) sein, wenn das Datenstromende erreicht ist.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>If an exception occurs during the read operation, it will be set as the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType&gt;</ph> of the property of the returned task.</source>
          <target state="translated">Wenn eine Ausnahme während des Lesevorgangs auftritt, wird es als Festlegen der <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType&gt;</ph> der Eigenschaft der zurückgegebenen Aufgabe.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.ReadByte">
          <source>Reads a byte from a stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.</source>
          <target state="translated">Liest ein Byte aus einem Stream und erhöht die Position im Stream um ein Byte, oder gibt -1 zurück, wenn das Ende des Streams erreicht ist.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.ReadByte">
          <source>The unsigned byte cast to an <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> object, or -1 if at the end of the stream.</source>
          <target state="translated">Das Byte ohne Vorzeichen, umgewandelt in ein <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>-Objekt, oder -1, wenn das Ende des Streams erreicht ist.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.ReadByte">
          <source>Use this method to return integer values from the stream.</source>
          <target state="translated">Verwenden Sie diese Methode, um ganzzahlige Werte aus dem Stream zurückzugeben.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.ReadByte">
          <source>The following code example demonstrates how to read from and write to unmanaged memory using the <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> class.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Lesen und Schreiben in nicht verwalteten Speicher mithilfe der <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.ReadByte">
          <source>A block of unmanaged memory is allocated and de-allocated using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">Ein nicht verwalteten Speicherblock ist reserviert und aufgehoben mithilfe der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.ReadByte">
          <source>In this example, an <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> object is passed to a method which checks the <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.CanRead%2A&gt;</ph> property before attempting to read and display the contents to the console.</source>
          <target state="translated">In diesem Beispiel ein <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> Objekt wird an eine Methode, die überprüft, übergeben die <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.CanRead%2A&gt;</ph> Eigenschaft vor dem Lesen und den Inhalt in der Konsole anzeigen.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.ReadByte">
          <source>The stream is closed.</source>
          <target state="translated">Der Stream ist geschlossen.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.ReadByte">
          <source>The underlying memory does not support reading.</source>
          <target state="translated">Der zugrunde liegende Speicher unterstützt keine Lesevorgänge.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.ReadByte">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.ReadByte">
          <source>The current position is at the end of the stream.</source>
          <target state="translated">Die aktuelle Position befindet sich am Ende des Streams.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The point relative to <bpt id="p1">&lt;c&gt;</bpt>origin<ept id="p1">&lt;/c&gt;</ept> to begin seeking from.</source>
          <target state="translated">Der Punkt im Vergleich zu <bpt id="p1">&lt;c&gt;</bpt>origin<ept id="p1">&lt;/c&gt;</ept>, ab dem gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Specifies the beginning, the end, or the current position as a reference point for <bpt id="p1">&lt;c&gt;</bpt>origin<ept id="p1">&lt;/c&gt;</ept>, using a value of type <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph>.</source>
          <target state="translated">Bestimmt den Anfang, das Ende oder die aktuelle Position als Bezugspunkt für <bpt id="p1">&lt;c&gt;</bpt>origin<ept id="p1">&lt;/c&gt;</ept> unter Verwendung eines Werts des Typs <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Sets the current position of the current stream to the given value.</source>
          <target state="translated">Legt die aktuelle Position des aktuellen Streams auf den angegebenen Wert fest.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The new position in the stream.</source>
          <target state="translated">Die neue Position im Stream.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>For more information about seeking, see <ph id="ph1">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zu suchen, finden Sie unter <ph id="ph1">&lt;xref:System.IO.FileStream.Seek%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>An attempt was made to seek before the beginning of the stream.</source>
          <target state="translated">Es wurde versucht, vor dem Anfang des Streams einen Suchvorgang durchzuführen.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> value is larger than the maximum size of the stream.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="offset" /&gt;</ph>-Wert ist größer als die maximale Größe des Streams.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source><ph id="ph1">&lt;paramref name="loc" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="loc" /&gt;</ph> ist ungültig.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The stream is closed.</source>
          <target state="translated">Der Stream ist geschlossen.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.SetLength(System.Int64)">
          <source>The length of the stream.</source>
          <target state="translated">Die Länge des Streams.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.SetLength(System.Int64)">
          <source>Sets the length of a stream to a specified value.</source>
          <target state="translated">Legt die Länge eines Streams auf einen angegebenen Wert fest.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.SetLength(System.Int64)">
          <source>If the given value is less than the current length of the stream, the stream is truncated.</source>
          <target state="translated">Wenn der angegebene Wert kleiner als die aktuelle Länge des Streams ist, wird der Stream abgeschnitten.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.SetLength(System.Int64)">
          <source>If the given value is larger than the current length of the stream, the stream is expanded.</source>
          <target state="translated">Wenn der angegebene Wert größer als die aktuelle Länge des Streams ist, wird der Stream erweitert.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.SetLength(System.Int64)">
          <source>If the stream is expanded, the contents of the stream between the old and the new lengths are undefined.</source>
          <target state="translated">Wenn der Stream erweitert wird, sind der Inhalt des Streams zwischen der alten und neuen Länge nicht definiert.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.SetLength(System.Int64)">
          <source>A stream must support both writing and seeking for <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream.SetLength%2A&gt;</ph> to work.</source>
          <target state="translated">Ein Stream muss Schreib- und Suchvorgänge für unterstützen <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream.SetLength%2A&gt;</ph> arbeiten.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.SetLength(System.Int64)">
          <source>An I/O error has occurred.</source>
          <target state="translated">Ein E/A-Fehler ist aufgetreten.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.SetLength(System.Int64)">
          <source>The stream is closed.</source>
          <target state="translated">Der Stream ist geschlossen.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.SetLength(System.Int64)">
          <source>The underlying memory does not support writing.</source>
          <target state="translated">Der zugrunde liegende Speicher unterstützt keine Schreibvorgänge.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.SetLength(System.Int64)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.SetLength(System.Int64)">
          <source>An attempt is made to write to the stream and the <ph id="ph1">&lt;see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /&gt;</ph> property is <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es wird versucht, in den Stream zu schreiben, und die <ph id="ph1">&lt;see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /&gt;</ph>-Eigenschaft ist <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.SetLength(System.Int64)">
          <source>The specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> exceeds the capacity of the stream.</source>
          <target state="translated">Der angegebene <ph id="ph1">&lt;paramref name="value" /&gt;</ph> übersteigt die Kapazität des Streams.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.SetLength(System.Int64)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.SetLength(System.Int64)">
          <source>The specified <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is negative.</source>
          <target state="translated">Der angegebene <ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist negativ.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The byte array from which to copy bytes to the current stream.</source>
          <target state="translated">Das Bytearray, aus dem Bytes in den aktuellen Stream kopiert werden sollen.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The offset in the buffer at which to begin copying bytes to the current stream.</source>
          <target state="translated">Der Offset im Puffer, ab dem Bytes in den aktuellen Stream kopiert werden sollen.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to write to the current stream.</source>
          <target state="translated">Die Anzahl der Bytes, die in den aktuellen Stream geschrieben werden sollen.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Writes a block of bytes to the current stream using data from a buffer.</source>
          <target state="translated">Schreibt einen Byteblock mit den Daten aus einem Puffer in den aktuellen Stream.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Writing occurs at the current position in the stream.</source>
          <target state="translated">Schreiben von tritt ein, an der aktuellen Position im Stream.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The following code example demonstrates how to read from and write to unmanaged memory using the <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> class.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Lesen und Schreiben in nicht verwalteten Speicher mithilfe der <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>A block of unmanaged memory is allocated and de-allocated using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">Ein nicht verwalteten Speicherblock ist reserviert und aufgehoben mithilfe der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The stream is closed.</source>
          <target state="translated">Der Stream ist geschlossen.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The underlying memory does not support writing.</source>
          <target state="translated">Der zugrunde liegende Speicher unterstützt keine Schreibvorgänge.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>An attempt is made to write to the stream and the <ph id="ph1">&lt;see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /&gt;</ph> property is <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es wird versucht, in den Stream zu schreiben, und die <ph id="ph1">&lt;see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /&gt;</ph>-Eigenschaft ist <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="count" /&gt;</ph> value is greater than the capacity of the stream.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="count" /&gt;</ph>-Wert ist größer als die Kapazität des Streams.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The position is at the end of the stream capacity.</source>
          <target state="translated">Die Position befindet sich am Ende der Streamkapazität.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>An I/O error occurs.</source>
          <target state="translated">Ein E/A-Fehler tritt auf.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>One of the specified parameters is less than zero.</source>
          <target state="translated">Einer der angegebenen Parameter ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> parameter minus the length of the <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> parameter is less than the <ph id="ph3">&lt;paramref name="count" /&gt;</ph> parameter.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="offset" /&gt;</ph>-Parameter minus der Länge des <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>-Parameters ist kleiner als der <ph id="ph3">&lt;paramref name="count" /&gt;</ph>-Parameter.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="buffer" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The buffer to write data from.</source>
          <target state="translated">Der Puffer, aus dem Daten geschrieben werden sollen.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> from which to begin copying bytes to the stream.</source>
          <target state="translated">Der nullbasierte Byteoffset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept>, ab dem Bytes in den Stream kopiert werden sollen.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">Die maximale Anzahl der zu schreibenden Bytes.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">Das Token zum überwachen von Abbruchanforderungen.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The default value is <ph id="ph1">&lt;see cref="P:System.Threading.CancellationToken.None" /&gt;</ph>.</source>
          <target state="translated">Der Standardwert ist <ph id="ph1">&lt;see cref="P:System.Threading.CancellationToken.None" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</source>
          <target state="translated">Schreibt eine Folge von Bytes asynchron in den aktuellen Stream, erhöht die aktuelle Position im Stream um die Anzahl der geschriebenen Bytes und überwacht Abbruchanforderungen.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Available starting in <ph id="ph1">[!INCLUDE[net_2015](~/includes/net-2015-md.md)]</ph></source>
          <target state="translated">Verfügbar ab <ph id="ph1">[!INCLUDE[net_2015](~/includes/net-2015-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous write operation.</source>
          <target state="translated">Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>If an exception occurs during the write operation, it will be set as the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType&gt;</ph> of the property of the returned task.</source>
          <target state="translated">Wenn eine Ausnahme während des Schreibvorgangs auftritt, wird es als Festlegen der <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType&gt;</ph> der Eigenschaft der zurückgegebenen Aufgabe.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)">
          <source>A byte value written to the stream.</source>
          <target state="translated">Ein Bytewert, der in den Stream geschrieben werden soll.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)">
          <source>Writes a byte to the current position in the file stream.</source>
          <target state="translated">Schreibt ein Byte an die aktuelle Position im Dateistream.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)">
          <source>The following code example demonstrates how to read from and write to unmanaged memory using the <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> class.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Lesen und Schreiben in nicht verwalteten Speicher mithilfe der <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)">
          <source>A block of unmanaged memory is allocated and de-allocated using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> class.</source>
          <target state="translated">Ein nicht verwalteten Speicherblock ist reserviert und aufgehoben mithilfe der <ph id="ph1">&lt;xref:System.Runtime.InteropServices.Marshal&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)">
          <source>In this example, an <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> object is passed to a method which checks the <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.CanWrite%2A&gt;</ph> property before attempting to write the data to the stream.</source>
          <target state="translated">In diesem Beispiel wird ein <ph id="ph1">&lt;xref:System.IO.UnmanagedMemoryStream&gt;</ph> Objekt wird an eine Methode, die überprüft, übergeben die <ph id="ph2">&lt;xref:System.IO.UnmanagedMemoryStream.CanWrite%2A&gt;</ph> Eigenschaft, bevor Sie versuchen, die Daten in den Stream geschrieben.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)">
          <source>The stream is closed.</source>
          <target state="translated">Der Stream ist geschlossen.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)">
          <source>The underlying memory does not support writing.</source>
          <target state="translated">Der zugrunde liegende Speicher unterstützt keine Schreibvorgänge.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)">
          <source>An attempt is made to write to the stream and the <ph id="ph1">&lt;see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /&gt;</ph> property is <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es wird versucht, in den Stream zu schreiben, und die <ph id="ph1">&lt;see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /&gt;</ph>-Eigenschaft ist <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)">
          <source>The current position is at the end of the capacity of the stream.</source>
          <target state="translated">Die aktuelle Position befindet sich am Ende der Kapazität des Streams.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)">
          <source>The supplied <ph id="ph1">&lt;paramref name="value" /&gt;</ph> causes the stream exceed its maximum capacity.</source>
          <target state="translated">Der angegebene <ph id="ph1">&lt;paramref name="value" /&gt;</ph> verursacht das Überschreiten der maximalen Kapazität des Streams.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>