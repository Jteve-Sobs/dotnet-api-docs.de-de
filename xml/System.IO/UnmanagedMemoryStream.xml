<Type Name="UnmanagedMemoryStream" FullName="System.IO.UnmanagedMemoryStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ffe6af5098b2b3390feda5f9cd059ecf3ef08b43" /><Meta Name="ms.sourcegitcommit" Value="ea104bc7868886a205b1df30baed6ca34ff70ecb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/20/2019" /><Meta Name="ms.locfileid" Value="68368947" /></Metadata><TypeSignature Language="C#" Value="public class UnmanagedMemoryStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UnmanagedMemoryStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.UnmanagedMemoryStream" />
  <TypeSignature Language="VB.NET" Value="Public Class UnmanagedMemoryStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnmanagedMemoryStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type UnmanagedMemoryStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.CLSCompliant(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="b48cf-101">Ermöglicht den Zugriff auf nicht verwaltete Speicherblöcke aus verwaltetem Code heraus.</span><span class="sxs-lookup"><span data-stu-id="b48cf-101">Provides access to unmanaged blocks of memory from managed code.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-102">Diese Klasse unterstützt den Zugriff auf nicht verwalteten Speicher mithilfe des vorhandenen streambasierten Modells und erfordert nicht, dass die Inhalte im nicht verwalteten Speicher in den Heap kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="b48cf-102">This class supports access to unmanaged memory using the existing stream-based model and does not require that the contents in the unmanaged memory be copied to the heap.</span></span>  
  
[!INCLUDE[note_unnecessary_dispose](~/includes/note-unnecessary-dispose.md)]
  
## Examples  
 <span data-ttu-id="b48cf-103">Im folgenden Codebeispiel wird veranschaulicht, wie mithilfe der <xref:System.IO.UnmanagedMemoryStream> -Klasse aus dem nicht verwalteten Speicher gelesen und in diesen geschrieben werden kann.</span><span class="sxs-lookup"><span data-stu-id="b48cf-103">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span>  <span data-ttu-id="b48cf-104">Ein Block von nicht verwaltetem Arbeitsspeicher wird mithilfe der-Klasse zugeordnet <xref:System.Runtime.InteropServices.Marshal> und die Zuordnung wird aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="b48cf-104">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream/cs/sample.cs#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b48cf-105">Initialisiert eine neue Instanz der <see cref="T:System.IO.UnmanagedMemoryStream" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="b48cf-105">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UnmanagedMemoryStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; UnmanagedMemoryStream();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b48cf-106">Initialisiert eine neue Instanz der <see cref="T:System.IO.UnmanagedMemoryStream" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="b48cf-106">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b48cf-107">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</span><span class="sxs-lookup"><span data-stu-id="b48cf-107">The user does not have the required permission.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode"><span data-ttu-id="b48cf-108">für den Zugriff auf nicht verwalteten Speicher.</span><span class="sxs-lookup"><span data-stu-id="b48cf-108">for accessing unmanaged memory.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryStream (byte* pointer, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8* pointer, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnmanagedMemoryStream(System::Byte* pointer, long length);" />
      <MemberSignature Language="F#" Value="new System.IO.UnmanagedMemoryStream : nativeptr&lt;byte&gt; * int64 -&gt; System.IO.UnmanagedMemoryStream" Usage="new System.IO.UnmanagedMemoryStream (pointer, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Byte*" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="b48cf-109">Ein Zeiger auf eine nicht verwaltete Speicheradresse.</span><span class="sxs-lookup"><span data-stu-id="b48cf-109">A pointer to an unmanaged memory location.</span></span></param>
        <param name="length"><span data-ttu-id="b48cf-110">Die Länge des zu verwendenden Speichers.</span><span class="sxs-lookup"><span data-stu-id="b48cf-110">The length of the memory to use.</span></span></param>
        <summary><span data-ttu-id="b48cf-111">Initialisiert eine neue Instanz der <see cref="T:System.IO.UnmanagedMemoryStream" />-Klasse mit der angegebenen Position und Speicherlänge.</span><span class="sxs-lookup"><span data-stu-id="b48cf-111">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class using the specified location and memory length.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-112">Dieser Konstruktor erstellt <xref:System.IO.UnmanagedMemoryStream> eine neue Instanz der-Klasse und legt standardmäßig die <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> -Eigenschaft auf `false` und die <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> -Eigenschaft `true`auf fest.</span><span class="sxs-lookup"><span data-stu-id="b48cf-112">This constructor creates a new instance of the <xref:System.IO.UnmanagedMemoryStream> class, and by default sets the <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> property to `false` and the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> property to `true`.</span></span> <span data-ttu-id="b48cf-113">Die <xref:System.IO.UnmanagedMemoryStream.Length%2A> -Eigenschaft wird auf den Wert `length` des-Parameters festgelegt und kann nicht geändert werden.</span><span class="sxs-lookup"><span data-stu-id="b48cf-113">The <xref:System.IO.UnmanagedMemoryStream.Length%2A> property is set to the value of the `length` parameter and cannot be changed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b48cf-114">Im folgenden Codebeispiel wird veranschaulicht, wie mithilfe der <xref:System.IO.UnmanagedMemoryStream> -Klasse aus dem nicht verwalteten Speicher gelesen und in diesen geschrieben werden kann.</span><span class="sxs-lookup"><span data-stu-id="b48cf-114">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="b48cf-115">Ein Block von nicht verwaltetem Arbeitsspeicher wird mithilfe der-Klasse zugeordnet <xref:System.Runtime.InteropServices.Marshal> und die Zuordnung wird aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="b48cf-115">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b48cf-116">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</span><span class="sxs-lookup"><span data-stu-id="b48cf-116">The user does not have the required permission.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b48cf-117">Der <paramref name="pointer" />-Wert ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b48cf-117">The <paramref name="pointer" /> value is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b48cf-118">Der <paramref name="length" />-Wert ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="b48cf-118">The <paramref name="length" /> value is less than zero.</span></span>  
  
<span data-ttu-id="b48cf-119">- oder -</span><span class="sxs-lookup"><span data-stu-id="b48cf-119">-or-</span></span> 
<span data-ttu-id="b48cf-120">Die <paramref name="length" /> ist groß genug, um einen Überlauf zu verursachen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-120">The <paramref name="length" /> is large enough to cause an overflow.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode"><span data-ttu-id="b48cf-121">für den Zugriff auf nicht verwalteten Speicher.</span><span class="sxs-lookup"><span data-stu-id="b48cf-121">for accessing unmanaged memory.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="b48cf-122">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="b48cf-122">requires full trust for the immediate caller.</span></span> <span data-ttu-id="b48cf-123">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="b48cf-123">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryStream (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.InteropServices.SafeBuffer buffer, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As SafeBuffer, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnmanagedMemoryStream(System::Runtime::InteropServices::SafeBuffer ^ buffer, long offset, long length);" />
      <MemberSignature Language="F#" Value="new System.IO.UnmanagedMemoryStream : System.Runtime.InteropServices.SafeBuffer * int64 * int64 -&gt; System.IO.UnmanagedMemoryStream" Usage="new System.IO.UnmanagedMemoryStream (buffer, offset, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="buffer" Type="System.Runtime.InteropServices.SafeBuffer" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int64" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b48cf-124">Der Puffer, der den nicht verwalteten Speicherstream enthalten soll.</span><span class="sxs-lookup"><span data-stu-id="b48cf-124">The buffer to contain the unmanaged memory stream.</span></span></param>
        <param name="offset"><span data-ttu-id="b48cf-125">Die Byteposition im Puffer, ab der der nicht verwaltete Speicherstream beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="b48cf-125">The byte position in the buffer at which to start the unmanaged memory stream.</span></span></param>
        <param name="length"><span data-ttu-id="b48cf-126">Die Länge des nicht verwalteten Speicherstreams.</span><span class="sxs-lookup"><span data-stu-id="b48cf-126">The length of the unmanaged memory stream.</span></span></param>
        <summary><span data-ttu-id="b48cf-127">Initialisiert eine neue Instanz der <see cref="T:System.IO.UnmanagedMemoryStream" />-Klasse in einem sicheren Puffer mit einem angegebenen Offset und einer angegebenen Länge.</span><span class="sxs-lookup"><span data-stu-id="b48cf-127">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer with a specified offset and length.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryStream (byte* pointer, long length, long capacity, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8* pointer, int64 length, int64 capacity, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnmanagedMemoryStream(System::Byte* pointer, long length, long capacity, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.UnmanagedMemoryStream : nativeptr&lt;byte&gt; * int64 * int64 * System.IO.FileAccess -&gt; System.IO.UnmanagedMemoryStream" Usage="new System.IO.UnmanagedMemoryStream (pointer, length, capacity, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Byte*" />
        <Parameter Name="length" Type="System.Int64" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="b48cf-128">Ein Zeiger auf eine nicht verwaltete Speicheradresse.</span><span class="sxs-lookup"><span data-stu-id="b48cf-128">A pointer to an unmanaged memory location.</span></span></param>
        <param name="length"><span data-ttu-id="b48cf-129">Die Länge des zu verwendenden Speichers.</span><span class="sxs-lookup"><span data-stu-id="b48cf-129">The length of the memory to use.</span></span></param>
        <param name="capacity"><span data-ttu-id="b48cf-130">Die Gesamtgröße des dem Stream zugewiesenen Speichers.</span><span class="sxs-lookup"><span data-stu-id="b48cf-130">The total amount of memory assigned to the stream.</span></span></param>
        <param name="access"><span data-ttu-id="b48cf-131">Einer der <see cref="T:System.IO.FileAccess" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="b48cf-131">One of the <see cref="T:System.IO.FileAccess" /> values.</span></span></param>
        <summary><span data-ttu-id="b48cf-132">Initialisiert eine neue Instanz der <see cref="T:System.IO.UnmanagedMemoryStream" />-Klasse mit der angegebenen Position, Speicherlänge, Gesamtspeichergröße und den Dateizugriffswerten.</span><span class="sxs-lookup"><span data-stu-id="b48cf-132">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class using the specified location, memory length, total amount of memory, and file access values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-133">Der `length` -Parameter definiert die aktuelle Menge an verwendem verwendeten Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="b48cf-133">The `length` parameter defines the current amount of memory in use.</span></span> <span data-ttu-id="b48cf-134">Beim Lesen oder Anfügen von Daten an den Stream sollte `length` der Wert gleich der Menge der gültigen Daten im Stream sein, die gelesen oder beibehalten werden sollen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-134">If reading or appending data to the stream, the `length` value should be equal to the amount of valid data in the stream to be read from or preserved.</span></span> <span data-ttu-id="b48cf-135">Beim Schreiben in den Stream sollte dieser Wert 0 (null) lauten.</span><span class="sxs-lookup"><span data-stu-id="b48cf-135">If writing to the stream, this value should be zero.</span></span>  
  
 <span data-ttu-id="b48cf-136">Der `capacity` -Parameter gibt die Menge des verfügbaren Gesamt Speichers an.</span><span class="sxs-lookup"><span data-stu-id="b48cf-136">The `capacity` parameter indicates the amount of total memory available.</span></span> <span data-ttu-id="b48cf-137">Dieser Wert kann einen Bereich beschreiben, der länger als die angegebene Länge ist, oder einen Bereich angeben, der an angefügt werden kann.</span><span class="sxs-lookup"><span data-stu-id="b48cf-137">This value can describe a region that is longer than the length specified, or indicate a region that can be appended to.</span></span> <span data-ttu-id="b48cf-138">Jeder Versuch, über diesen Wert hinaus zu schreiben, schlägt fehl.</span><span class="sxs-lookup"><span data-stu-id="b48cf-138">Any attempt to write beyond this value will fail.</span></span>  
  
 <span data-ttu-id="b48cf-139">Der `access` -Parameter legt <xref:System.IO.UnmanagedMemoryStream.CanRead%2A>die Eigenschaften <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> , und fest.</span><span class="sxs-lookup"><span data-stu-id="b48cf-139">The `access` parameter sets the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A>, and <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> properties.</span></span> <span data-ttu-id="b48cf-140">Beachten Sie, <xref:System.IO.FileAccess.Write> dass durch Angeben von nicht sichergestellt wird, dass der Datenstrom beschreibbar ist</span><span class="sxs-lookup"><span data-stu-id="b48cf-140">Note that specifying <xref:System.IO.FileAccess.Write> does not guarantee that the stream will be writable.</span></span> <span data-ttu-id="b48cf-141">Die Zugriffsparameter ermöglichen es dem Implementierer, ein Objekt zu erstellen, dessen Implementierung dem tatsächlich verfügbar gemachten Datenstrom entsprechen kann.</span><span class="sxs-lookup"><span data-stu-id="b48cf-141">The access parameters allow the implementer to create an object whose implementation can match the actual stream that is exposed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b48cf-142">Im folgenden Codebeispiel wird veranschaulicht, wie mithilfe der <xref:System.IO.UnmanagedMemoryStream> -Klasse aus dem nicht verwalteten Speicher gelesen und in diesen geschrieben werden kann.</span><span class="sxs-lookup"><span data-stu-id="b48cf-142">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span>  <span data-ttu-id="b48cf-143">Ein Block von nicht verwaltetem Arbeitsspeicher wird mithilfe der-Klasse zugeordnet <xref:System.Runtime.InteropServices.Marshal> und die Zuordnung wird aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="b48cf-143">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream/cs/sample.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b48cf-144">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</span><span class="sxs-lookup"><span data-stu-id="b48cf-144">The user does not have the required permission.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b48cf-145">Der <paramref name="pointer" />-Wert ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b48cf-145">The <paramref name="pointer" /> value is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b48cf-146">Der <paramref name="length" />-Wert ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="b48cf-146">The <paramref name="length" /> value is less than zero.</span></span>  
  
<span data-ttu-id="b48cf-147">- oder -</span><span class="sxs-lookup"><span data-stu-id="b48cf-147">-or-</span></span> 
<span data-ttu-id="b48cf-148">Der <paramref name="capacity" />-Wert ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="b48cf-148">The <paramref name="capacity" /> value is less than zero.</span></span>  
  
<span data-ttu-id="b48cf-149">- oder -</span><span class="sxs-lookup"><span data-stu-id="b48cf-149">-or-</span></span> 
<span data-ttu-id="b48cf-150">Der <paramref name="length" />-Wert ist größer als der <paramref name="capacity" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="b48cf-150">The <paramref name="length" /> value is greater than the <paramref name="capacity" /> value.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode"><span data-ttu-id="b48cf-151">für den Zugriff auf nicht verwalteten Speicher.</span><span class="sxs-lookup"><span data-stu-id="b48cf-151">for accessing unmanaged memory.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="b48cf-152">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="b48cf-152">requires full trust for the immediate caller.</span></span> <span data-ttu-id="b48cf-153">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="b48cf-153">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryStream (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.InteropServices.SafeBuffer buffer, int64 offset, int64 length, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As SafeBuffer, offset As Long, length As Long, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnmanagedMemoryStream(System::Runtime::InteropServices::SafeBuffer ^ buffer, long offset, long length, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.UnmanagedMemoryStream : System.Runtime.InteropServices.SafeBuffer * int64 * int64 * System.IO.FileAccess -&gt; System.IO.UnmanagedMemoryStream" Usage="new System.IO.UnmanagedMemoryStream (buffer, offset, length, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="buffer" Type="System.Runtime.InteropServices.SafeBuffer" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int64" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b48cf-154">Der Puffer, der den nicht verwalteten Speicherstream enthalten soll.</span><span class="sxs-lookup"><span data-stu-id="b48cf-154">The buffer to contain the unmanaged memory stream.</span></span></param>
        <param name="offset"><span data-ttu-id="b48cf-155">Die Byteposition im Puffer, ab der der nicht verwaltete Speicherstream beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="b48cf-155">The byte position in the buffer at which to start the unmanaged memory stream.</span></span></param>
        <param name="length"><span data-ttu-id="b48cf-156">Die Länge des nicht verwalteten Speicherstreams.</span><span class="sxs-lookup"><span data-stu-id="b48cf-156">The length of the unmanaged memory stream.</span></span></param>
        <param name="access"><span data-ttu-id="b48cf-157">Der Modus des Dateizugriffs auf den nicht verwalteten Speicherstream.</span><span class="sxs-lookup"><span data-stu-id="b48cf-157">The mode of file access to the unmanaged memory stream.</span></span></param>
        <summary><span data-ttu-id="b48cf-158">Initialisiert eine neue Instanz der <see cref="T:System.IO.UnmanagedMemoryStream" />-Klasse in einem sicheren Puffer mit einem angegebenen Offset, einer angegebenen Länge und angegebenem Dateizugriff.</span><span class="sxs-lookup"><span data-stu-id="b48cf-158">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer with a specified offset, length, and file access.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.UnmanagedMemoryStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b48cf-159">Ruft einen Wert ab, der angibt, ob ein Stream Lesevorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="b48cf-159">Gets a value indicating whether a stream supports reading.</span></span></summary>
        <value><span data-ttu-id="b48cf-160"><see langword="false" />, wenn das Objekt von einem Konstruktor mit einem <paramref name="access" />-Parameter erstellt wurde, das Lesen des Streams nicht eingeschlossen war und der Stream geschlossen ist, andernfalls <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="b48cf-160"><see langword="false" /> if the object was created by a constructor with an <paramref name="access" /> parameter that did not include reading the stream and if the stream is closed; otherwise, <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-161">Diese Eigenschaft gibt an, ob das aktuelle Streamobjekt Lesevorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="b48cf-161">This property indicates whether the current stream object supports reading.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b48cf-162">Im folgenden Codebeispiel wird veranschaulicht, wie mithilfe der <xref:System.IO.UnmanagedMemoryStream> -Klasse aus dem nicht verwalteten Speicher gelesen und in diesen geschrieben werden kann.</span><span class="sxs-lookup"><span data-stu-id="b48cf-162">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="b48cf-163">Ein Block von nicht verwaltetem Arbeitsspeicher wird mithilfe der-Klasse zugeordnet <xref:System.Runtime.InteropServices.Marshal> und die Zuordnung wird aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="b48cf-163">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="b48cf-164">In diesem Beispiel wird ein <xref:System.IO.UnmanagedMemoryStream> -Objekt an eine-Methode übermittelt, <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> die die-Eigenschaft überprüft, bevor versucht wird, den Inhalt der Konsole anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-164">In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> property before attempting to display the contents to the console.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.UnmanagedMemoryStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b48cf-165">Ruft einen Wert ab, der angibt, ob ein Stream Suchvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="b48cf-165">Gets a value indicating whether a stream supports seeking.</span></span></summary>
        <value><span data-ttu-id="b48cf-166"><see langword="false" />, wenn der Stream geschlossen ist, andernfalls <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="b48cf-166"><see langword="false" /> if the stream is closed; otherwise, <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-167">Diese Eigenschaft gibt an, ob das aktuelle Streamobjekt Suchvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="b48cf-167">This property indicates whether the current stream object supports seeking.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.UnmanagedMemoryStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b48cf-168">Ruft einen Wert ab, der angibt, ob ein Stream Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="b48cf-168">Gets a value indicating whether a stream supports writing.</span></span></summary>
        <value><span data-ttu-id="b48cf-169"><see langword="false" />, wenn das Objekt von einem Konstruktor mit einem <paramref name="access" />-Parameterwert erstellt wurde, der Schreibvorgänge unterstützt, oder wenn es von einem Konstruktor ohne Parameter erstellt wurde oder wenn der Stream geschlossen ist, andernfalls <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="b48cf-169"><see langword="false" /> if the object was created by a constructor with an <paramref name="access" /> parameter value that supports writing or was created by a constructor that had no parameters, or if the stream is closed; otherwise, <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-170">Diese Eigenschaft gibt an, ob das aktuelle Streamobjekt Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="b48cf-170">This property indicates whether the current stream object supports writing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b48cf-171">Im folgenden Codebeispiel wird veranschaulicht, wie mithilfe der <xref:System.IO.UnmanagedMemoryStream> -Klasse aus dem nicht verwalteten Speicher gelesen und in diesen geschrieben werden kann.</span><span class="sxs-lookup"><span data-stu-id="b48cf-171">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="b48cf-172">Ein Block von nicht verwaltetem Arbeitsspeicher wird mithilfe der-Klasse zugeordnet <xref:System.Runtime.InteropServices.Marshal> und die Zuordnung wird aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="b48cf-172">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="b48cf-173">In diesem Beispiel wird ein <xref:System.IO.UnmanagedMemoryStream> -Objekt an eine-Methode übermittelt, <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> die die-Eigenschaft überprüft, bevor versucht wird, die Daten in den Stream zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="b48cf-173">In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> property before attempting to write the data to the stream.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public long Capacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Capacity As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Capacity { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int64" Usage="System.IO.UnmanagedMemoryStream.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b48cf-174">Ruft die Streamlänge (Größe) oder die Gesamtgröße des einem Stream zugewiesenen Speichers (Kapazität) ab.</span><span class="sxs-lookup"><span data-stu-id="b48cf-174">Gets the stream length (size) or the total amount of memory assigned to a stream (capacity).</span></span></summary>
        <value><span data-ttu-id="b48cf-175">Die Größe oder die Kapazität des Streams.</span><span class="sxs-lookup"><span data-stu-id="b48cf-175">The size or capacity of the stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-176">Diese Eigenschaft gibt den `capacity` Wert zurück, der für den Konstruktor bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="b48cf-176">This property returns the `capacity` value provided to the constructor.</span></span> <span data-ttu-id="b48cf-177">Wenn kein `capacity` Wert angegeben wurde, als der Stream initialisiert wurde, gibt diese Eigenschaft die Streamlänge zurück.</span><span class="sxs-lookup"><span data-stu-id="b48cf-177">If no `capacity` value was specified when the stream was initialized, this property returns the stream length.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b48cf-178">Der Stream ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-178">The stream is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="unmanagedMemoryStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="b48cf-179"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="b48cf-179"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="b48cf-180">Gibt die von <see cref="T:System.IO.UnmanagedMemoryStream" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="b48cf-180">Releases the unmanaged resources used by the <see cref="T:System.IO.UnmanagedMemoryStream" /> and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-181">Diese Methode wird von der öffentlichen <xref:System.ComponentModel.Component.Dispose%2A> -Methode und der <xref:System.Object.Finalize%2A> -Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-181">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="b48cf-182"><xref:System.ComponentModel.Component.Dispose%2A>Ruft die geschützte <xref:System.IO.UnmanagedMemoryStream.Dispose%2A> Methode auf, `disposing` wobei der- `true`Parameter auf festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="b48cf-182"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.UnmanagedMemoryStream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="b48cf-183"><xref:System.Object.Finalize%2A>Ruft <xref:System.IO.UnmanagedMemoryStream.Dispose%2A> auf `disposing` , wobei `false`auf gesetzt ist.</span><span class="sxs-lookup"><span data-stu-id="b48cf-183"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.UnmanagedMemoryStream.Dispose%2A> with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="b48cf-184">Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.IO.UnmanagedMemoryStream> verweist.</span><span class="sxs-lookup"><span data-stu-id="b48cf-184">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.UnmanagedMemoryStream> references.</span></span> <span data-ttu-id="b48cf-185">Diese Methode ruft die <xref:System.ComponentModel.Component.Dispose%2A>-Methode aller Objekte auf, auf die verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="b48cf-185">This method invokes the <xref:System.ComponentModel.Component.Dispose%2A> method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="b48cf-186">
            <see cref="M:System.ComponentModel.Component.Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="b48cf-186">
            <see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="b48cf-187">Wenn Sie überschreiben, sollten Sie darauf achten, nicht auf Objekte zu verweisen, die zuvor in <see cref="M:System.ComponentModel.Component.Dispose" />einem früheren-Aufrufpunkt verworfen wurden. <see cref="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" /></span><span class="sxs-lookup"><span data-stu-id="b48cf-187">When overriding <see cref="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" /> be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />.</span></span> <span data-ttu-id="b48cf-188">Weitere Informationen zum Implementieren <see cref="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" />von finden Sie unter [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.</span><span class="sxs-lookup"><span data-stu-id="b48cf-188">For more information about how to implement <see cref="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="b48cf-189">Weitere Informationen zu und <see cref="M:System.ComponentModel.Component.Dispose" /> <see cref="M:System.Object.Finalize" />finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="b48cf-189">For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="unmanagedMemoryStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b48cf-190">Überschreibt die <see cref="M:System.IO.Stream.Flush" />-Methode, sodass keine Aktion durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="b48cf-190">Overrides the <see cref="M:System.IO.Stream.Flush" /> method so that no action is performed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-191">Diese Methode führt keine Aktion für diese Klasse aus, ist aber als Teil der <xref:System.IO.Stream> -Basisklasse enthalten.</span><span class="sxs-lookup"><span data-stu-id="b48cf-191">This method performs no action for this class but is included as part of the <xref:System.IO.Stream> base class.</span></span> <span data-ttu-id="b48cf-192">Da alle Daten in den Arbeitsspeicher geschrieben werden, ist diese Methode redundant.</span><span class="sxs-lookup"><span data-stu-id="b48cf-192">Since any data is written to RAM, this method is redundant.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b48cf-193">Der Stream ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-193">The stream is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="unmanagedMemoryStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="b48cf-194">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-194">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="b48cf-195">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />sein.</span><span class="sxs-lookup"><span data-stu-id="b48cf-195">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="b48cf-196">Überschreibt die <see cref="M:System.IO.Stream.FlushAsync(System.Threading.CancellationToken)" />-Methode. Der Vorgang wird abgebrochen, wenn dies angegeben wurde, ansonsten wird keine Aktion durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="b48cf-196">Overrides the <see cref="M:System.IO.Stream.FlushAsync(System.Threading.CancellationToken)" /> method so that the operation is cancelled if specified, but no other action is performed.</span></span>  
  
<span data-ttu-id="b48cf-197">Verfügbar ab .NET Framework 4.6</span><span class="sxs-lookup"><span data-stu-id="b48cf-197">Available starting in .NET Framework 4.6</span></span></summary>
        <returns><span data-ttu-id="b48cf-198">Eine Aufgabe, die die asynchrone Leerung darstellt.</span><span class="sxs-lookup"><span data-stu-id="b48cf-198">A task that represents the asynchronous flush operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-199">Wenn der Vorgang nicht abgebrochen wird <xref:System.IO.UnmanagedMemoryStream> , ruft <xref:System.IO.UnmanagedMemoryStream.Flush%2A> die die-Methode auf, was bedeutet, dass keine Aktion ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="b48cf-199">If the operation isn't cancelled, the <xref:System.IO.UnmanagedMemoryStream> calls the <xref:System.IO.UnmanagedMemoryStream.Flush%2A> method, which means that no action performed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Initialize">
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b48cf-200">Initialisiert eine neue Instanz der <see cref="T:System.IO.UnmanagedMemoryStream" />-Klasse in einem sicheren Puffer oder unter Verwendung eines Zeigers auf eine nicht verwaltete Speicheradresse.</span><span class="sxs-lookup"><span data-stu-id="b48cf-200">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer, or by using a pointer to an unmanaged memory location.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="protected void Initialize (byte* pointer, long length, long capacity, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Initialize(unsigned int8* pointer, int64 length, int64 capacity, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Initialize(System::Byte* pointer, long length, long capacity, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="member this.Initialize : nativeptr&lt;byte&gt; * int64 * int64 * System.IO.FileAccess -&gt; unit" Usage="unmanagedMemoryStream.Initialize (pointer, length, capacity, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.Byte*" />
        <Parameter Name="length" Type="System.Int64" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="b48cf-201">Ein Zeiger auf eine nicht verwaltete Speicheradresse.</span><span class="sxs-lookup"><span data-stu-id="b48cf-201">A pointer to an unmanaged memory location.</span></span></param>
        <param name="length"><span data-ttu-id="b48cf-202">Die Länge des zu verwendenden Speichers.</span><span class="sxs-lookup"><span data-stu-id="b48cf-202">The length of the memory to use.</span></span></param>
        <param name="capacity"><span data-ttu-id="b48cf-203">Die Gesamtgröße des dem Stream zugewiesenen Speichers.</span><span class="sxs-lookup"><span data-stu-id="b48cf-203">The total amount of memory assigned to the stream.</span></span></param>
        <param name="access"><span data-ttu-id="b48cf-204">Einer der <see cref="T:System.IO.FileAccess" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="b48cf-204">One of the <see cref="T:System.IO.FileAccess" /> values.</span></span></param>
        <summary><span data-ttu-id="b48cf-205">Initialisiert eine neue Instanz der <see cref="T:System.IO.UnmanagedMemoryStream" />-Klasse unter Verwendung eines Zeigers auf eine nicht verwaltete Speicheradresse.</span><span class="sxs-lookup"><span data-stu-id="b48cf-205">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class by using a pointer to an unmanaged memory location.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-206">Diese Methode entspricht dem <xref:System.IO.UnmanagedMemoryStream.%23ctor%2A> -Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="b48cf-206">This method is equivalent to the <xref:System.IO.UnmanagedMemoryStream.%23ctor%2A> constructor.</span></span> <span data-ttu-id="b48cf-207">Sie unterstützt Methoden, die den Zeiger vor dem Festlegen von Streamvariablen initialisieren müssen, und kann daher nicht den parametrisierten Konstruktor aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-207">It supports methods that need to initialize the pointer before setting stream variables and, therefore, cannot call the parameterized constructor.</span></span> <span data-ttu-id="b48cf-208">Diese Methoden sollten den Standardkonstruktor <xref:System.IO.UnmanagedMemoryStream.%23ctor>verwenden,, den Zeiger initialisieren und dann die <xref:System.IO.UnmanagedMemoryStream.Initialize%2A> -Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-208">Such methods should use the default constructor, <xref:System.IO.UnmanagedMemoryStream.%23ctor>, initialize the pointer, and then invoke the <xref:System.IO.UnmanagedMemoryStream.Initialize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="b48cf-209">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</span><span class="sxs-lookup"><span data-stu-id="b48cf-209">The user does not have the required permission.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b48cf-210">Der <paramref name="pointer" />-Wert ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b48cf-210">The <paramref name="pointer" /> value is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b48cf-211">Der <paramref name="length" />-Wert ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="b48cf-211">The <paramref name="length" /> value is less than zero.</span></span>  
  
<span data-ttu-id="b48cf-212">- oder -</span><span class="sxs-lookup"><span data-stu-id="b48cf-212">-or-</span></span> 
<span data-ttu-id="b48cf-213">Der <paramref name="capacity" />-Wert ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="b48cf-213">The <paramref name="capacity" /> value is less than zero.</span></span>  
  
<span data-ttu-id="b48cf-214">- oder -</span><span class="sxs-lookup"><span data-stu-id="b48cf-214">-or-</span></span> 
<span data-ttu-id="b48cf-215">Der <paramref name="length" />-Wert ist groß genug, um einen Überlauf zu verursachen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-215">The <paramref name="length" /> value is large enough to cause an overflow.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode"><span data-ttu-id="b48cf-216">für den Zugriff auf nicht verwalteten Speicher.</span><span class="sxs-lookup"><span data-stu-id="b48cf-216">for accessing unmanaged memory.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="b48cf-217">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="b48cf-217">requires full trust for the immediate caller.</span></span> <span data-ttu-id="b48cf-218">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="b48cf-218">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="protected void Initialize (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Initialize(class System.Runtime.InteropServices.SafeBuffer buffer, int64 offset, int64 length, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Initialize (buffer As SafeBuffer, offset As Long, length As Long, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Initialize(System::Runtime::InteropServices::SafeBuffer ^ buffer, long offset, long length, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="member this.Initialize : System.Runtime.InteropServices.SafeBuffer * int64 * int64 * System.IO.FileAccess -&gt; unit" Usage="unmanagedMemoryStream.Initialize (buffer, offset, length, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Runtime.InteropServices.SafeBuffer" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int64" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b48cf-219">Der Puffer, der den nicht verwalteten Speicherstream enthalten soll.</span><span class="sxs-lookup"><span data-stu-id="b48cf-219">The buffer to contain the unmanaged memory stream.</span></span></param>
        <param name="offset"><span data-ttu-id="b48cf-220">Die Byteposition im Puffer, ab der der nicht verwaltete Speicherstream beginnen soll.</span><span class="sxs-lookup"><span data-stu-id="b48cf-220">The byte position in the buffer at which to start the unmanaged memory stream.</span></span></param>
        <param name="length"><span data-ttu-id="b48cf-221">Die Länge des nicht verwalteten Speicherstreams.</span><span class="sxs-lookup"><span data-stu-id="b48cf-221">The length of the unmanaged memory stream.</span></span></param>
        <param name="access"><span data-ttu-id="b48cf-222">Der Modus des Dateizugriffs auf den nicht verwalteten Speicherstream.</span><span class="sxs-lookup"><span data-stu-id="b48cf-222">The mode of file access to the unmanaged memory stream.</span></span></param>
        <summary><span data-ttu-id="b48cf-223">Initialisiert eine neue Instanz der <see cref="T:System.IO.UnmanagedMemoryStream" />-Klasse in einem sicheren Puffer mit einem angegebenen Offset, einer angegebenen Länge und angegebenem Dateizugriff.</span><span class="sxs-lookup"><span data-stu-id="b48cf-223">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer with a specified offset, length, and file access.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.UnmanagedMemoryStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b48cf-224">Ruft die Länge der Daten in einem Stream ab.</span><span class="sxs-lookup"><span data-stu-id="b48cf-224">Gets the length of the data in a stream.</span></span></summary>
        <value><span data-ttu-id="b48cf-225">Die Länge der Daten im Stream.</span><span class="sxs-lookup"><span data-stu-id="b48cf-225">The length of the data in the stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-226">Wenn seit dem Initialisieren des Streams der Stream nicht geändert wurde, gibt diese Eigenschaft den für den Konstruktor bereitgestellten Längen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="b48cf-226">If unchanged since the stream was initialized, this property returns the length value provided to the constructor.</span></span> <span data-ttu-id="b48cf-227">Wenn Änderungen am Stream aufgetreten sind, gibt diese Eigenschaft alle Änderungen an der Länge der Daten wieder.</span><span class="sxs-lookup"><span data-stu-id="b48cf-227">If changes to the stream have occurred, this property reflects any changes to the length of the data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b48cf-228">Im folgenden Codebeispiel wird veranschaulicht, wie mithilfe der <xref:System.IO.UnmanagedMemoryStream> -Klasse aus dem nicht verwalteten Speicher gelesen und in diesen geschrieben werden kann.</span><span class="sxs-lookup"><span data-stu-id="b48cf-228">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="b48cf-229">Ein Block von nicht verwaltetem Arbeitsspeicher wird mithilfe der-Klasse zugeordnet <xref:System.Runtime.InteropServices.Marshal> und die Zuordnung wird aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="b48cf-229">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b48cf-230">Der Stream ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-230">The stream is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.UnmanagedMemoryStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b48cf-231">Ruft die aktuelle Position in einem Stream ab oder legt diese fest.</span><span class="sxs-lookup"><span data-stu-id="b48cf-231">Gets or sets the current position in a stream.</span></span></summary>
        <value><span data-ttu-id="b48cf-232">Die aktuelle Position in dem Stream.</span><span class="sxs-lookup"><span data-stu-id="b48cf-232">The current position in the stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-233">Wenn ein Stream initialisiert wird, wird diese Eigenschaft auf 0 (null) festgelegt.</span><span class="sxs-lookup"><span data-stu-id="b48cf-233">When a stream is initialized, this property is set to zero.</span></span>  
  
 <span data-ttu-id="b48cf-234">Obwohl Sie die Position des Streams über die Kapazität des Streams hinaus festlegen können, können Sie nicht mit der-Methode und <xref:System.IO.UnmanagedMemoryStream.Read%2A> <xref:System.IO.UnmanagedMemoryStream.Write%2A> der-Methode auf diesen Bereich zugreifen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-234">Although you can set the position of the stream beyond the stream's capacity, you will not be able to access that area using the <xref:System.IO.UnmanagedMemoryStream.Read%2A> and <xref:System.IO.UnmanagedMemoryStream.Write%2A> methods.</span></span> <span data-ttu-id="b48cf-235"><xref:System.IO.UnmanagedMemoryStream.Read%2A>gibt 0 zurück und <xref:System.IO.UnmanagedMemoryStream.Write%2A> löst eine <xref:System.NotSupportedException>aus.</span><span class="sxs-lookup"><span data-stu-id="b48cf-235"><xref:System.IO.UnmanagedMemoryStream.Read%2A> will return 0 and <xref:System.IO.UnmanagedMemoryStream.Write%2A> will throw a <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="b48cf-236">Diese Unterstützung ist hauptsächlich für die Entwurfs-und Code Kompatibilität mit grundlegenden Streamvorgängen vorgesehen</span><span class="sxs-lookup"><span data-stu-id="b48cf-236">This support is primarily for design and code compatibility with basic stream operations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b48cf-237">Der Stream ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-237">The stream is closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b48cf-238">Die Position wurde auf einen Wert festgelegt, der kleiner als 0 ist, oder die Position ist größer als <see cref="F:System.Int32.MaxValue" /> oder führt beim Hinzufügen zum aktuellen Zeiger zu einem Überlauf.</span><span class="sxs-lookup"><span data-stu-id="b48cf-238">The position is set to a value that is less than zero, or the position is larger than <see cref="F:System.Int32.MaxValue" /> or results in overflow when added to the current pointer.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="PositionPointer">
      <MemberSignature Language="C#" Value="public byte* PositionPointer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8* PositionPointer" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.PositionPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Byte* PositionPointer { System::Byte* get(); void set(System::Byte* value); };" />
      <MemberSignature Language="F#" Value="member this.PositionPointer : nativeptr&lt;byte&gt; with get, set" Usage="System.IO.UnmanagedMemoryStream.PositionPointer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;dotnet-uwp-10.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte*</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b48cf-239">Ruft einen Bytezeiger auf einen Stream auf Grundlage der aktuellen Position im Stream ab oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="b48cf-239">Gets or sets a byte pointer to a stream based on the current position in the stream.</span></span></summary>
        <value><span data-ttu-id="b48cf-240">Ein Bytezeiger.</span><span class="sxs-lookup"><span data-stu-id="b48cf-240">A byte pointer.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-241">Wenn Sie einen Zeiger auf den gesamten Stream zurückgeben möchten <xref:System.IO.UnmanagedMemoryStream.Position%2A> , legen Sie die-Eigenschaft auf NULL fest, und nennen Sie diese Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="b48cf-241">To return a pointer to the entire stream, set the <xref:System.IO.UnmanagedMemoryStream.Position%2A> property to zero, and then call this property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="b48cf-242">Die aktuelle Position ist größer als die Kapazität des Streams.</span><span class="sxs-lookup"><span data-stu-id="b48cf-242">The current position is larger than the capacity of the stream.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b48cf-243">Die festgelegte Position ist keine gültige Position im aktuellen Stream.</span><span class="sxs-lookup"><span data-stu-id="b48cf-243">The position is being set is not a valid position in the current stream.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b48cf-244">Der Zeiger wird auf einen niedrigeren Wert festgelegt als die Startposition des Streams.</span><span class="sxs-lookup"><span data-stu-id="b48cf-244">The pointer is being set to a lower value than the starting position of the stream.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b48cf-245">Der Stream wurde zur Verwendung mit einem <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> initialisiert.</span><span class="sxs-lookup"><span data-stu-id="b48cf-245">The stream was initialized for use with a <see cref="T:System.Runtime.InteropServices.SafeBuffer" />.</span></span> <span data-ttu-id="b48cf-246">Die <see cref="P:System.IO.UnmanagedMemoryStream.PositionPointer" />-Eigenschaft ist nur für Streams gültig, die mit einem <see cref="T:System.Byte" />-Zeiger initialisiert sind.</span><span class="sxs-lookup"><span data-stu-id="b48cf-246">The <see cref="P:System.IO.UnmanagedMemoryStream.PositionPointer" /> property is valid only for streams that are initialized with a <see cref="T:System.Byte" /> pointer.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="b48cf-247">zum Aufrufen von nicht verwaltetem Code, z. b. Aufrufen von nativem Code mit Platt Form Aufruf oder com-Integration</span><span class="sxs-lookup"><span data-stu-id="b48cf-247">for calling unmanaged code, such as calling native code with platform invoke or COM integration.</span></span> <span data-ttu-id="b48cf-248">Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="b48cf-248">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="b48cf-249">Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="b48cf-249">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="b48cf-250">Erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="b48cf-250">requires full trust for the immediate caller.</span></span> <span data-ttu-id="b48cf-251">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="b48cf-251">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; destination);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="unmanagedMemoryStream.Read destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="b48cf-252">Wenn diese Methode zurückkehrt, enthält diese Spanne alle Bytes aus dem nicht verwalteten Arbeitsspeicherstream.</span><span class="sxs-lookup"><span data-stu-id="b48cf-252">When this method returns, this span contains all the bytes from the unmanaged memory stream.</span></span></param>
        <summary><span data-ttu-id="b48cf-253">Liest alle Bytes dieses nicht verwalteten Arbeitsspeicherstreams in die angegebene Spanne von Bytes.</span><span class="sxs-lookup"><span data-stu-id="b48cf-253">Reads all the bytes of this unmanaged memory stream into the specified span of bytes.</span></span></summary>
        <returns><span data-ttu-id="b48cf-254">Die Gesamtzahl der in das Ziel gelesenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="b48cf-254">The total number of bytes read into the destination.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="unmanagedMemoryStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b48cf-255">Enthält nach dem Beenden dieser Methode das angegebene Bytearray mit den Werten zwischen <paramref name="offset" /> und (<paramref name="offset" /> + <paramref name="count" /> - 1) die durch die aus der aktuellen Quelle gelesenen Bytes ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="b48cf-255">When this method returns, contains the specified byte array with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1) replaced by the bytes read from the current source.</span></span> <span data-ttu-id="b48cf-256">Dieser Parameter wird nicht initialisiert übergeben.</span><span class="sxs-lookup"><span data-stu-id="b48cf-256">This parameter is passed uninitialized.</span></span></param>
        <param name="offset"><span data-ttu-id="b48cf-257">Der nullbasierte Byteoffset im <paramref name="buffer" />, ab dem die aus dem aktuellen Stream gelesenen Daten gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="b48cf-257">The zero-based byte offset in <paramref name="buffer" /> at which to begin storing the data read from the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="b48cf-258">Die maximale Anzahl an Bytes, die aus dem aktuellen Stream gelesen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-258">The maximum number of bytes to read from the current stream.</span></span></param>
        <summary><span data-ttu-id="b48cf-259">Liest die angegebene Anzahl von Bytes in das angegebene Array.</span><span class="sxs-lookup"><span data-stu-id="b48cf-259">Reads the specified number of bytes into the specified array.</span></span></summary>
        <returns><span data-ttu-id="b48cf-260">Die Gesamtanzahl der in den Puffer gelesenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="b48cf-260">The total number of bytes read into the buffer.</span></span> <span data-ttu-id="b48cf-261">Dies kann weniger als die Anzahl der angeforderten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder 0, wenn das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="b48cf-261">This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-262">Der `offset` -Parameter gibt den Offset des Bytes `array` im-Parameter (dem Puffer Index) an, ab dem gelesen werden soll, `count` und der-Parameter gibt die maximale Anzahl von Bytes an, die aus diesem Stream gelesen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-262">The `offset` parameter gives the offset of the byte in the `array` parameter (the buffer index) at which to begin reading, and the `count` parameter gives the maximum number of bytes to be read from this stream.</span></span> <span data-ttu-id="b48cf-263">Der zurückgegebene Wert ist die tatsächliche Anzahl von gelesenen Bytes, oder 0 (null), wenn das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="b48cf-263">The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</span></span> <span data-ttu-id="b48cf-264">Wenn der Lesevorgang erfolgreich ist, wird die aktuelle Position des Streams um die Anzahl der gelesenen Bytes erweitert.</span><span class="sxs-lookup"><span data-stu-id="b48cf-264">If the read operation is successful, the current position of the stream is advanced by the number of bytes read.</span></span> <span data-ttu-id="b48cf-265">Wenn eine Ausnahme auftritt, wird die aktuelle Position des Streams unverändert.</span><span class="sxs-lookup"><span data-stu-id="b48cf-265">If an exception occurs, the current position of the stream is unchanged.</span></span>  
  
 <span data-ttu-id="b48cf-266">Die <xref:System.IO.UnmanagedMemoryStream.Read%2A> Methode gibt 0 (null) nur zurück, nachdem das Ende des Streams erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="b48cf-266">The <xref:System.IO.UnmanagedMemoryStream.Read%2A> method returns zero only after reaching the end of the stream.</span></span> <span data-ttu-id="b48cf-267">Andernfalls liest vor der Rückgabe immermindestenseinByteausdemDatenstrom.<xref:System.IO.UnmanagedMemoryStream.Read%2A></span><span class="sxs-lookup"><span data-stu-id="b48cf-267">Otherwise, <xref:System.IO.UnmanagedMemoryStream.Read%2A> always reads at least one byte from the stream before returning.</span></span> <span data-ttu-id="b48cf-268">Wenn beim Abrufen <xref:System.IO.UnmanagedMemoryStream.Read%2A>von keine Daten aus dem Stream verfügbar sind, wird die-Methode blockiert, bis mindestens ein Byte mit Daten zurückgegeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="b48cf-268">If no data is available from the stream upon a call to <xref:System.IO.UnmanagedMemoryStream.Read%2A>, the method will block until at least one byte of data can be returned.</span></span> <span data-ttu-id="b48cf-269">Eine-Implementierung kann weniger Bytes zurückgeben als angefordert werden, auch wenn das Ende des Streams nicht erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="b48cf-269">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b48cf-270">Im folgenden Codebeispiel wird veranschaulicht, wie mithilfe der <xref:System.IO.UnmanagedMemoryStream> -Klasse aus dem nicht verwalteten Speicher gelesen und in diesen geschrieben werden kann.</span><span class="sxs-lookup"><span data-stu-id="b48cf-270">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span>  <span data-ttu-id="b48cf-271">Ein Block von nicht verwaltetem Arbeitsspeicher wird mithilfe der-Klasse zugeordnet <xref:System.Runtime.InteropServices.Marshal> und die Zuordnung wird aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="b48cf-271">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream/cs/sample.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b48cf-272">Der Stream ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-272">The stream is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b48cf-273">Der zugrunde liegende Speicher unterstützt keine Lesevorgänge.</span><span class="sxs-lookup"><span data-stu-id="b48cf-273">The underlying memory does not support reading.</span></span>  
  
<span data-ttu-id="b48cf-274">- oder -</span><span class="sxs-lookup"><span data-stu-id="b48cf-274">-or-</span></span> 
<span data-ttu-id="b48cf-275">Die <see cref="P:System.IO.UnmanagedMemoryStream.CanRead" />-Eigenschaft ist auf <see langword="false" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="b48cf-275">The <see cref="P:System.IO.UnmanagedMemoryStream.CanRead" /> property is set to <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b48cf-276">Der <paramref name="buffer" />-Parameter ist auf <see langword="null" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="b48cf-276">The <paramref name="buffer" /> parameter is set to <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b48cf-277">Die <paramref name="offset" />-Parameter ist kleiner als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="b48cf-277">The <paramref name="offset" /> parameter is less than zero.</span></span>  
  
<span data-ttu-id="b48cf-278">- oder -</span><span class="sxs-lookup"><span data-stu-id="b48cf-278">-or-</span></span> 
<span data-ttu-id="b48cf-279">Die <paramref name="count" />-Parameter ist kleiner als 0 (null).</span><span class="sxs-lookup"><span data-stu-id="b48cf-279">The <paramref name="count" /> parameter is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b48cf-280">Die Länge des Pufferarrays minus dem <paramref name="offset" />-Parameter ist kleiner als der <paramref name="count" />-Parameter.</span><span class="sxs-lookup"><span data-stu-id="b48cf-280">The length of the buffer array minus the <paramref name="offset" /> parameter is less than the <paramref name="count" /> parameter.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="unmanagedMemoryStream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b48cf-281">Wenn die asynchrone Methode beendet ist, enthält dieser Arbeitsspeicherbereich alle Bytes, die aus dem nicht verwalteten Arbeitsspeicherstream gelesen wurden.</span><span class="sxs-lookup"><span data-stu-id="b48cf-281">When the asynchronous method finishes, this memory region contains all the bytes read from the unmanaged memory stream.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="b48cf-282">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-282">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="b48cf-283">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />sein.</span><span class="sxs-lookup"><span data-stu-id="b48cf-283">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="b48cf-284">Liest die Bytes des nicht verwalteten Arbeitsspeicherstreams asynchron in den Arbeitsspeicherbereich.</span><span class="sxs-lookup"><span data-stu-id="b48cf-284">Asynchronously reads the unmanaged memory stream bytes into the memory region.</span></span></summary>
        <returns><span data-ttu-id="b48cf-285">Eine Aufgabe, die den asynchronen Lesevorgang darstellt und die Gesamtzahl der in den Puffer gelesenen Bytes umschließt.</span><span class="sxs-lookup"><span data-stu-id="b48cf-285">A task that represents the asynchronous read operation, and wraps the total number of bytes read into the buffer.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="unmanagedMemoryStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b48cf-286">Der Puffer, in den die Daten geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-286">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="b48cf-287">Der Byteoffset im <paramref name="buffer" />, ab dem Daten aus dem Stream geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="b48cf-287">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="b48cf-288">Die maximale Anzahl der zu lesenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="b48cf-288">The maximum number of bytes to read.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="b48cf-289">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-289">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="b48cf-290">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />sein.</span><span class="sxs-lookup"><span data-stu-id="b48cf-290">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="b48cf-291">Liest die angegebene Anzahl von Bytes asynchron in das angegebene Array.</span><span class="sxs-lookup"><span data-stu-id="b48cf-291">Asynchronously reads the specified number of bytes into the specified array.</span></span></summary>
        <returns><span data-ttu-id="b48cf-292">Eine Aufgabe, die den asynchronen Lesevorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="b48cf-292">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="b48cf-293">Der Wert des <paramref name="TResult" />-Parameters enthält die Gesamtzahl der Bytes, die in den Puffer gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="b48cf-293">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="b48cf-294">Der Ergebniswert kann niedriger als die Anzahl der angeforderten Bytes sein, wenn die Anzahl an derzeit verfügbaren Bytes kleiner ist als die angeforderte Anzahl, oder sie kann 0 (null) sein, wenn das Datenstromende erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="b48cf-294">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-295">Wenn während des Lesevorgangs eine Ausnahme auftritt, wird Sie als <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> der-Eigenschaft der zurückgegebenen Aufgabe festgelegt.</span><span class="sxs-lookup"><span data-stu-id="b48cf-295">If an exception occurs during the read operation, it will be set as the <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> of the property of the returned task.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="unmanagedMemoryStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b48cf-296">Liest ein Byte aus einem Stream und erhöht die Position im Stream um ein Byte, oder gibt -1 zurück, wenn das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="b48cf-296">Reads a byte from a stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.</span></span></summary>
        <returns><span data-ttu-id="b48cf-297">Das Byte ohne Vorzeichen, umgewandelt in ein <see cref="T:System.Int32" />-Objekt, oder -1, wenn das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="b48cf-297">The unsigned byte cast to an <see cref="T:System.Int32" /> object, or -1 if at the end of the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-298">Verwenden Sie diese Methode, um ganzzahlige Werte aus dem Stream zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="b48cf-298">Use this method to return integer values from the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b48cf-299">Im folgenden Codebeispiel wird veranschaulicht, wie mithilfe der <xref:System.IO.UnmanagedMemoryStream> -Klasse aus dem nicht verwalteten Speicher gelesen und in diesen geschrieben werden kann.</span><span class="sxs-lookup"><span data-stu-id="b48cf-299">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="b48cf-300">Ein Block von nicht verwaltetem Arbeitsspeicher wird mithilfe der-Klasse zugeordnet <xref:System.Runtime.InteropServices.Marshal> und die Zuordnung wird aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="b48cf-300">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="b48cf-301">In diesem Beispiel wird ein <xref:System.IO.UnmanagedMemoryStream> -Objekt an eine-Methode weitergegeben, <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> die die-Eigenschaft überprüft, bevor versucht wird, den Inhalt der Konsole zu lesen und anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-301">In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> property before attempting to read and display the contents to the console.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b48cf-302">Der Stream ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-302">The stream is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b48cf-303">Der zugrunde liegende Speicher unterstützt keine Lesevorgänge.</span><span class="sxs-lookup"><span data-stu-id="b48cf-303">The underlying memory does not support reading.</span></span>  
  
<span data-ttu-id="b48cf-304">- oder -</span><span class="sxs-lookup"><span data-stu-id="b48cf-304">-or-</span></span>
  
 <span data-ttu-id="b48cf-305">Die aktuelle Position befindet sich am Ende des Streams.</span><span class="sxs-lookup"><span data-stu-id="b48cf-305">The current position is at the end of the stream.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin loc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, loc As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin loc);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="unmanagedMemoryStream.Seek (offset, loc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="loc" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="b48cf-306">Der Punkt im Vergleich zu <c>origin</c>, ab dem gesucht werden soll.</span><span class="sxs-lookup"><span data-stu-id="b48cf-306">The point relative to <c>origin</c> to begin seeking from.</span></span></param>
        <param name="loc"><span data-ttu-id="b48cf-307">Bestimmt den Anfang, das Ende oder die aktuelle Position als Bezugspunkt für <c>origin</c> unter Verwendung eines Werts des Typs <see cref="T:System.IO.SeekOrigin" />.</span><span class="sxs-lookup"><span data-stu-id="b48cf-307">Specifies the beginning, the end, or the current position as a reference point for <c>origin</c>, using a value of type <see cref="T:System.IO.SeekOrigin" />.</span></span></param>
        <summary><span data-ttu-id="b48cf-308">Legt die aktuelle Position des aktuellen Streams auf den angegebenen Wert fest.</span><span class="sxs-lookup"><span data-stu-id="b48cf-308">Sets the current position of the current stream to the given value.</span></span></summary>
        <returns><span data-ttu-id="b48cf-309">Die neue Position im Stream.</span><span class="sxs-lookup"><span data-stu-id="b48cf-309">The new position in the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-310">Weitere Informationen zum Suchen finden <xref:System.IO.FileStream.Seek%2A>Sie unter.</span><span class="sxs-lookup"><span data-stu-id="b48cf-310">For more information about seeking, see <xref:System.IO.FileStream.Seek%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b48cf-311">Es wurde versucht, vor dem Anfang des Streams einen Suchvorgang durchzuführen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-311">An attempt was made to seek before the beginning of the stream.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b48cf-312">Der <paramref name="offset" />-Wert ist größer als die maximale Größe des Streams.</span><span class="sxs-lookup"><span data-stu-id="b48cf-312">The <paramref name="offset" /> value is larger than the maximum size of the stream.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b48cf-313"><paramref name="loc" /> ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="b48cf-313"><paramref name="loc" /> is invalid.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b48cf-314">Der Stream ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-314">The stream is closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="unmanagedMemoryStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b48cf-315">Die Länge des Streams.</span><span class="sxs-lookup"><span data-stu-id="b48cf-315">The length of the stream.</span></span></param>
        <summary><span data-ttu-id="b48cf-316">Legt die Länge eines Streams auf einen angegebenen Wert fest.</span><span class="sxs-lookup"><span data-stu-id="b48cf-316">Sets the length of a stream to a specified value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-317">Wenn der angegebene Wert kleiner als die aktuelle Länge des Streams ist, wird der Stream abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="b48cf-317">If the given value is less than the current length of the stream, the stream is truncated.</span></span> <span data-ttu-id="b48cf-318">Wenn der angegebene Wert größer als die aktuelle Länge des Streams ist, wird der Stream erweitert.</span><span class="sxs-lookup"><span data-stu-id="b48cf-318">If the given value is larger than the current length of the stream, the stream is expanded.</span></span> <span data-ttu-id="b48cf-319">Wenn der Stream erweitert wird, ist der Inhalt des Streams zwischen der alten und der neuen Länge nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="b48cf-319">If the stream is expanded, the contents of the stream between the old and the new lengths are undefined.</span></span>  
  
 <span data-ttu-id="b48cf-320">Ein Datenstrom muss sowohl das Schreiben als auch <xref:System.IO.UnmanagedMemoryStream.SetLength%2A> das Suchen nach unterstützen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-320">A stream must support both writing and seeking for <xref:System.IO.UnmanagedMemoryStream.SetLength%2A> to work.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b48cf-321">Ein E/A-Fehler ist aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="b48cf-321">An I/O error has occurred.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b48cf-322">Der Stream ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-322">The stream is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b48cf-323">Der zugrunde liegende Speicher unterstützt keine Schreibvorgänge.</span><span class="sxs-lookup"><span data-stu-id="b48cf-323">The underlying memory does not support writing.</span></span>  
  
<span data-ttu-id="b48cf-324">- oder -</span><span class="sxs-lookup"><span data-stu-id="b48cf-324">-or-</span></span> 
<span data-ttu-id="b48cf-325">Es wird versucht, in den Stream zu schreiben, und die <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" />-Eigenschaft ist <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="b48cf-325">An attempt is made to write to the stream and the <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /> property is <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b48cf-326">Der angegebene <paramref name="value" /> übersteigt die Kapazität des Streams.</span><span class="sxs-lookup"><span data-stu-id="b48cf-326">The specified <paramref name="value" /> exceeds the capacity of the stream.</span></span>  
  
<span data-ttu-id="b48cf-327">- oder -</span><span class="sxs-lookup"><span data-stu-id="b48cf-327">-or-</span></span> 
<span data-ttu-id="b48cf-328">Der angegebene <paramref name="value" /> ist negativ.</span><span class="sxs-lookup"><span data-stu-id="b48cf-328">The specified <paramref name="value" /> is negative.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (source As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="unmanagedMemoryStream.Write source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="b48cf-329">Die Spanne der Bytes, aus denen die Bytes in den aktuellen nicht verwalteten Arbeitsspeicherstream kopiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-329">The span of bytes from which to copy bytes to the current unmanaged memory stream.</span></span></param>
        <summary><span data-ttu-id="b48cf-330">Schreibt einen Block von Bytes in den aktuellen nicht verwalteten Arbeitsspeicherstream, wobei Daten aus der angegebenen Spanne von Bytes verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="b48cf-330">Writes a block of bytes to the current unmanaged memory stream using data from the provided span of bytes.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="unmanagedMemoryStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b48cf-331">Das Bytearray, aus dem Bytes in den aktuellen Stream kopiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-331">The byte array from which to copy bytes to the current stream.</span></span></param>
        <param name="offset"><span data-ttu-id="b48cf-332">Der Offset im Puffer, ab dem Bytes in den aktuellen Stream kopiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-332">The offset in the buffer at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="b48cf-333">Die Anzahl der Bytes, die in den aktuellen Stream geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-333">The number of bytes to write to the current stream.</span></span></param>
        <summary><span data-ttu-id="b48cf-334">Schreibt einen Byteblock mit den Daten aus einem Puffer in den aktuellen Stream.</span><span class="sxs-lookup"><span data-stu-id="b48cf-334">Writes a block of bytes to the current stream using data from a buffer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-335">Das Schreiben erfolgt an der aktuellen Position im Stream.</span><span class="sxs-lookup"><span data-stu-id="b48cf-335">Writing occurs at the current position in the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b48cf-336">Im folgenden Codebeispiel wird veranschaulicht, wie mithilfe der <xref:System.IO.UnmanagedMemoryStream> -Klasse aus dem nicht verwalteten Speicher gelesen und in diesen geschrieben werden kann.</span><span class="sxs-lookup"><span data-stu-id="b48cf-336">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span>  <span data-ttu-id="b48cf-337">Ein Block von nicht verwaltetem Arbeitsspeicher wird mithilfe der-Klasse zugeordnet <xref:System.Runtime.InteropServices.Marshal> und die Zuordnung wird aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="b48cf-337">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream/cs/sample.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b48cf-338">Der Stream ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-338">The stream is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b48cf-339">Der zugrunde liegende Speicher unterstützt keine Schreibvorgänge.</span><span class="sxs-lookup"><span data-stu-id="b48cf-339">The underlying memory does not support writing.</span></span>  
  
<span data-ttu-id="b48cf-340">- oder -</span><span class="sxs-lookup"><span data-stu-id="b48cf-340">-or-</span></span> 
<span data-ttu-id="b48cf-341">Es wird versucht, in den Stream zu schreiben, und die <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" />-Eigenschaft ist <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="b48cf-341">An attempt is made to write to the stream and the <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /> property is <see langword="false" />.</span></span>  
  
<span data-ttu-id="b48cf-342">- oder -</span><span class="sxs-lookup"><span data-stu-id="b48cf-342">-or-</span></span> 
<span data-ttu-id="b48cf-343">Der <paramref name="count" />-Wert ist größer als die Kapazität des Streams.</span><span class="sxs-lookup"><span data-stu-id="b48cf-343">The <paramref name="count" /> value is greater than the capacity of the stream.</span></span>  
  
<span data-ttu-id="b48cf-344">- oder -</span><span class="sxs-lookup"><span data-stu-id="b48cf-344">-or-</span></span> 
<span data-ttu-id="b48cf-345">Die Position befindet sich am Ende der Streamkapazität.</span><span class="sxs-lookup"><span data-stu-id="b48cf-345">The position is at the end of the stream capacity.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b48cf-346">Ein E/A-Fehler tritt auf.</span><span class="sxs-lookup"><span data-stu-id="b48cf-346">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b48cf-347">Einer der angegebenen Parameter ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="b48cf-347">One of the specified parameters is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b48cf-348">Der <paramref name="offset" />-Parameter minus der Länge des <paramref name="buffer" />-Parameters ist kleiner als der <paramref name="count" />-Parameter.</span><span class="sxs-lookup"><span data-stu-id="b48cf-348">The <paramref name="offset" /> parameter minus the length of the <paramref name="buffer" /> parameter is less than the <paramref name="count" /> parameter.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b48cf-349">Der <paramref name="buffer" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="b48cf-349">The <paramref name="buffer" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="unmanagedMemoryStream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b48cf-350">Der Puffer, aus dem Daten geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-350">The buffer to write data from.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="b48cf-351">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-351">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="b48cf-352">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />sein.</span><span class="sxs-lookup"><span data-stu-id="b48cf-352">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="b48cf-353">Schreibt eine Spanne von Bytes asynchron in den aktuellen Stream, erhöht die aktuelle Position innerhalb dieses Streams um die Anzahl der geschriebenen Bytes und überwacht Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-353">Asynchronously writes a span of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="b48cf-354">Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="b48cf-354">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="unmanagedMemoryStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b48cf-355">Der Puffer, aus dem Daten geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-355">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="b48cf-356">Der nullbasierte Byteoffset im <paramref name="buffer" />, ab dem Bytes in den Stream kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="b48cf-356">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="b48cf-357">Die maximale Anzahl der zu schreibenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="b48cf-357">The maximum number of bytes to write.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="b48cf-358">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-358">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="b48cf-359">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />sein.</span><span class="sxs-lookup"><span data-stu-id="b48cf-359">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="b48cf-360">Schreibt beim Überschreiben in einer abgeleiteten Klasse eine Folge von Bytes asynchron in den aktuellen Stream und erhöht die aktuelle Position im Stream um die Anzahl der geschriebenen Bytes und überwacht Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-360">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="b48cf-361">Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="b48cf-361">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b48cf-362">Wenn beim Schreibvorgang eine Ausnahme auftritt, wird Sie als <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> der-Eigenschaft der zurückgegebenen Aufgabe festgelegt.</span><span class="sxs-lookup"><span data-stu-id="b48cf-362">If an exception occurs during the write operation, it will be set as the <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> of the property of the returned task.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="unmanagedMemoryStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b48cf-363">Ein Bytewert, der in den Stream geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="b48cf-363">A byte value written to the stream.</span></span></param>
        <summary><span data-ttu-id="b48cf-364">Schreibt ein Byte an die aktuelle Position im Dateistream.</span><span class="sxs-lookup"><span data-stu-id="b48cf-364">Writes a byte to the current position in the file stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b48cf-365">Im folgenden Codebeispiel wird veranschaulicht, wie mithilfe der <xref:System.IO.UnmanagedMemoryStream> -Klasse aus dem nicht verwalteten Speicher gelesen und in diesen geschrieben werden kann.</span><span class="sxs-lookup"><span data-stu-id="b48cf-365">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="b48cf-366">Ein Block von nicht verwaltetem Arbeitsspeicher wird mithilfe der-Klasse zugeordnet <xref:System.Runtime.InteropServices.Marshal> und die Zuordnung wird aufgehoben.</span><span class="sxs-lookup"><span data-stu-id="b48cf-366">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="b48cf-367">In diesem Beispiel wird ein <xref:System.IO.UnmanagedMemoryStream> -Objekt an eine-Methode übermittelt, <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> die die-Eigenschaft überprüft, bevor versucht wird, die Daten in den Stream zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="b48cf-367">In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> property before attempting to write the data to the stream.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b48cf-368">Der Stream ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="b48cf-368">The stream is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b48cf-369">Der zugrunde liegende Speicher unterstützt keine Schreibvorgänge.</span><span class="sxs-lookup"><span data-stu-id="b48cf-369">The underlying memory does not support writing.</span></span>  
  
<span data-ttu-id="b48cf-370">- oder -</span><span class="sxs-lookup"><span data-stu-id="b48cf-370">-or-</span></span> 
<span data-ttu-id="b48cf-371">Es wird versucht, in den Stream zu schreiben, und die <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" />-Eigenschaft ist <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="b48cf-371">An attempt is made to write to the stream and the <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /> property is <see langword="false" />.</span></span>  
  
<span data-ttu-id="b48cf-372">- oder -</span><span class="sxs-lookup"><span data-stu-id="b48cf-372">-or-</span></span> 
<span data-ttu-id="b48cf-373">Die aktuelle Position befindet sich am Ende der Kapazität des Streams.</span><span class="sxs-lookup"><span data-stu-id="b48cf-373">The current position is at the end of the capacity of the stream.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b48cf-374">Der angegebene <paramref name="value" /> verursacht das Überschreiten der maximalen Kapazität des Streams.</span><span class="sxs-lookup"><span data-stu-id="b48cf-374">The supplied <paramref name="value" /> causes the stream exceed its maximum capacity.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
