<Type Name="UnmanagedMemoryStream" FullName="System.IO.UnmanagedMemoryStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8a1edec5c6ce73a141a1907946387ff5086563a6" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32695204" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UnmanagedMemoryStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UnmanagedMemoryStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.UnmanagedMemoryStream" />
  <TypeSignature Language="VB.NET" Value="Public Class UnmanagedMemoryStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnmanagedMemoryStream : System::IO::Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="41d7d-101">Ermöglicht den Zugriff auf nicht verwaltete Speicherblöcke aus verwaltetem Code heraus.</span>
      <span class="sxs-lookup">
        <span data-stu-id="41d7d-101">Provides access to unmanaged blocks of memory from managed code.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-102">Diese Klasse unterstützt den Zugriff auf nicht verwalteten Speicher, die mit dem vorhandenen streambasierte Modell und erfordert nicht, dass der Inhalt in den nicht verwalteten Speicher, die dem Heap kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="41d7d-102">This class supports access to unmanaged memory using the existing stream-based model and does not require that the contents in the unmanaged memory be copied to the heap.</span></span>  
  
[!INCLUDE[note_unnecessary_dispose](~/includes/note-unnecessary-dispose.md)]
  
## Examples  
 <span data-ttu-id="41d7d-103">Im folgenden Codebeispiel wird veranschaulicht, wie zum Lesen und Schreiben in nicht verwalteten Speicher mithilfe der <xref:System.IO.UnmanagedMemoryStream> Klasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-103">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span>  <span data-ttu-id="41d7d-104">Ein nicht verwalteten Speicherblock ist reserviert und aufgehoben mithilfe der <xref:System.Runtime.InteropServices.Marshal> Klasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-104">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream/cs/sample.cs#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="41d7d-105">Initialisiert eine neue Instanz der <see cref="T:System.IO.UnmanagedMemoryStream" />-Klasse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-105">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected UnmanagedMemoryStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; UnmanagedMemoryStream();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="41d7d-106">Initialisiert eine neue Instanz der <see cref="T:System.IO.UnmanagedMemoryStream" />-Klasse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-106">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="41d7d-107">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-107">The user does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode">
          <span data-ttu-id="41d7d-108">für den Zugriff auf nicht verwalteten Speicher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-108">for accessing unmanaged memory.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryStream (byte* pointer, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8* pointer, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnmanagedMemoryStream(System::Byte* pointer, long length);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Byte*" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="pointer">
          <span data-ttu-id="41d7d-109">Ein Zeiger auf eine nicht verwaltete Speicheradresse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-109">A pointer to an unmanaged memory location.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="41d7d-110">Die Länge des zu verwendenden Speichers.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-110">The length of the memory to use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="41d7d-111">Initialisiert eine neue Instanz der <see cref="T:System.IO.UnmanagedMemoryStream" />-Klasse mit der angegebenen Position und Speicherlänge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-111">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class using the specified location and memory length.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-112">Dieser Konstruktor erstellt eine neue Instanz der der <xref:System.IO.UnmanagedMemoryStream> -Klasse und legt fest, in der Standardeinstellung die <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> Eigenschaft `false` und die <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> Eigenschaft `true`.</span><span class="sxs-lookup"><span data-stu-id="41d7d-112">This constructor creates a new instance of the <xref:System.IO.UnmanagedMemoryStream> class, and by default sets the <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> property to `false` and the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> property to `true`.</span></span> <span data-ttu-id="41d7d-113">Die <xref:System.IO.UnmanagedMemoryStream.Length%2A> auf den Wert der Eigenschaft festgelegt ist die `length` Parameter und kann nicht geändert werden.</span><span class="sxs-lookup"><span data-stu-id="41d7d-113">The <xref:System.IO.UnmanagedMemoryStream.Length%2A> property is set to the value of the `length` parameter and cannot be changed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="41d7d-114">Im folgenden Codebeispiel wird veranschaulicht, wie zum Lesen und Schreiben in nicht verwalteten Speicher mithilfe der <xref:System.IO.UnmanagedMemoryStream> Klasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-114">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="41d7d-115">Ein nicht verwalteten Speicherblock ist reserviert und aufgehoben mithilfe der <xref:System.Runtime.InteropServices.Marshal> Klasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-115">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="41d7d-116">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-116">The user does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="41d7d-117">Der <paramref name="pointer" />-Wert ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-117">The <paramref name="pointer" /> value is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="41d7d-118">Der <paramref name="length" />-Wert ist kleiner als 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-118">The <paramref name="length" /> value is less than zero.</span>
          </span>
          <span data-ttu-id="41d7d-119">\- oder –</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-119">\- or -</span>
          </span>
          <span data-ttu-id="41d7d-120">Die <paramref name="length" /> ist groß genug, um einen Überlauf zu verursachen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-120">The <paramref name="length" /> is large enough to cause an overflow.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode">
          <span data-ttu-id="41d7d-121">für den Zugriff auf nicht verwalteten Speicher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-121">for accessing unmanaged memory.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="41d7d-122">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-122">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="41d7d-123">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-123">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryStream (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.InteropServices.SafeBuffer buffer, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As SafeBuffer, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnmanagedMemoryStream(System::Runtime::InteropServices::SafeBuffer ^ buffer, long offset, long length);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="buffer" Type="System.Runtime.InteropServices.SafeBuffer" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="41d7d-124">Der Puffer, der den nicht verwalteten Speicherstream enthalten soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-124">The buffer to contain the unmanaged memory stream.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="41d7d-125">Die Byteposition im Puffer, ab der der nicht verwaltete Speicherstream beginnen soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-125">The byte position in the buffer at which to start the unmanaged memory stream.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="41d7d-126">Die Länge des nicht verwalteten Speicherstreams.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-126">The length of the unmanaged memory stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="41d7d-127">Initialisiert eine neue Instanz der <see cref="T:System.IO.UnmanagedMemoryStream" />-Klasse in einem sicheren Puffer mit einem angegebenen Offset und einer angegebenen Länge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-127">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer with a specified offset and length.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryStream (byte* pointer, long length, long capacity, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8* pointer, int64 length, int64 capacity, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.#ctor(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnmanagedMemoryStream(System::Byte* pointer, long length, long capacity, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Byte*" />
        <Parameter Name="length" Type="System.Int64" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="pointer">
          <span data-ttu-id="41d7d-128">Ein Zeiger auf eine nicht verwaltete Speicheradresse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-128">A pointer to an unmanaged memory location.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="41d7d-129">Die Länge des zu verwendenden Speichers.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-129">The length of the memory to use.</span>
          </span>
        </param>
        <param name="capacity">
          <span data-ttu-id="41d7d-130">Die Gesamtgröße des dem Stream zugewiesenen Speichers.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-130">The total amount of memory assigned to the stream.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="41d7d-131">Einer der <see cref="T:System.IO.FileAccess" />-Werte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-131">One of the <see cref="T:System.IO.FileAccess" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="41d7d-132">Initialisiert eine neue Instanz der <see cref="T:System.IO.UnmanagedMemoryStream" />-Klasse mit der angegebenen Position, Speicherlänge, Gesamtspeichergröße und den Dateizugriffswerten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-132">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class using the specified location, memory length, total amount of memory, and file access values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-133">Die `length` Parameter definiert die aktuelle Menge an Arbeitsspeicher verwendet.</span><span class="sxs-lookup"><span data-stu-id="41d7d-133">The `length` parameter defines the current amount of memory in use.</span></span> <span data-ttu-id="41d7d-134">Beim Lesen oder Anfügen von Daten in den Stream der `length` Wert muss gleich der Menge gültige Daten im Datenstrom gelesen werden soll, oder beibehalten.</span><span class="sxs-lookup"><span data-stu-id="41d7d-134">If reading or appending data to the stream, the `length` value should be equal to the amount of valid data in the stream to be read from or preserved.</span></span> <span data-ttu-id="41d7d-135">Wenn in den Stream zu schreiben, sollte dieser Wert 0 (null) sein.</span><span class="sxs-lookup"><span data-stu-id="41d7d-135">If writing to the stream, this value should be zero.</span></span>  
  
 <span data-ttu-id="41d7d-136">Die `capacity` Parameter gibt den Umfang des verfügbaren Gesamtspeichers.</span><span class="sxs-lookup"><span data-stu-id="41d7d-136">The `capacity` parameter indicates the amount of total memory available.</span></span> <span data-ttu-id="41d7d-137">Dieser Wert kann beschreiben eine Region, die länger als die angegebene Länge ist auch ein Anzeichen eine Region, die hinzugefügt werden kann.</span><span class="sxs-lookup"><span data-stu-id="41d7d-137">This value can describe a region that is longer than the length specified, or indicate a region that can be appended to.</span></span> <span data-ttu-id="41d7d-138">Jeder Versuch, diesen Wert hinaus schreiben schlägt fehl.</span><span class="sxs-lookup"><span data-stu-id="41d7d-138">Any attempt to write beyond this value will fail.</span></span>  
  
 <span data-ttu-id="41d7d-139">Die `access` Parametersätze der <xref:System.IO.UnmanagedMemoryStream.CanRead%2A>, und <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="41d7d-139">The `access` parameter sets the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A>, and <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> properties.</span></span> <span data-ttu-id="41d7d-140">Beachten Sie, dass die Angabe <xref:System.IO.FileAccess.Write> garantiert nicht, dass der Stream geschrieben werden kann.</span><span class="sxs-lookup"><span data-stu-id="41d7d-140">Note that specifying <xref:System.IO.FileAccess.Write> does not guarantee that the stream will be writable.</span></span> <span data-ttu-id="41d7d-141">Die Zugriffsparameter zulassen die Implementierung ein Objekt zu erstellen, deren Implementierung den tatsächlichen Stream verglichen werden kann, der verfügbar gemacht wird.</span><span class="sxs-lookup"><span data-stu-id="41d7d-141">The access parameters allow the implementer to create an object whose implementation can match the actual stream that is exposed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="41d7d-142">Im folgenden Codebeispiel wird veranschaulicht, wie zum Lesen und Schreiben in nicht verwalteten Speicher mithilfe der <xref:System.IO.UnmanagedMemoryStream> Klasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-142">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span>  <span data-ttu-id="41d7d-143">Ein nicht verwalteten Speicherblock ist reserviert und aufgehoben mithilfe der <xref:System.Runtime.InteropServices.Marshal> Klasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-143">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream/cs/sample.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="41d7d-144">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-144">The user does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="41d7d-145">Der <paramref name="pointer" />-Wert ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-145">The <paramref name="pointer" /> value is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="41d7d-146">Der <paramref name="length" />-Wert ist kleiner als 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-146">The <paramref name="length" /> value is less than zero.</span>
          </span>
          <span data-ttu-id="41d7d-147">\- oder –</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-147">\- or -</span>
          </span>
          <span data-ttu-id="41d7d-148">Der <paramref name="capacity" />-Wert ist kleiner als 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-148">The <paramref name="capacity" /> value is less than zero.</span>
          </span>
          <span data-ttu-id="41d7d-149">\- oder –</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-149">\- or -</span>
          </span>
          <span data-ttu-id="41d7d-150">Der <paramref name="length" />-Wert ist größer als der <paramref name="capacity" />-Wert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-150">The <paramref name="length" /> value is greater than the <paramref name="capacity" /> value.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode">
          <span data-ttu-id="41d7d-151">für den Zugriff auf nicht verwalteten Speicher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-151">for accessing unmanaged memory.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="41d7d-152">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-152">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="41d7d-153">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-153">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnmanagedMemoryStream (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.InteropServices.SafeBuffer buffer, int64 offset, int64 length, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.#ctor(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As SafeBuffer, offset As Long, length As Long, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnmanagedMemoryStream(System::Runtime::InteropServices::SafeBuffer ^ buffer, long offset, long length, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="buffer" Type="System.Runtime.InteropServices.SafeBuffer" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="41d7d-154">Der Puffer, der den nicht verwalteten Speicherstream enthalten soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-154">The buffer to contain the unmanaged memory stream.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="41d7d-155">Die Byteposition im Puffer, ab der der nicht verwaltete Speicherstream beginnen soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-155">The byte position in the buffer at which to start the unmanaged memory stream.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="41d7d-156">Die Länge des nicht verwalteten Speicherstreams.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-156">The length of the unmanaged memory stream.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="41d7d-157">Der Modus des Dateizugriffs auf den nicht verwalteten Speicherstream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-157">The mode of file access to the unmanaged memory stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="41d7d-158">Initialisiert eine neue Instanz der <see cref="T:System.IO.UnmanagedMemoryStream" />-Klasse in einem sicheren Puffer mit einem angegebenen Offset, einer angegebenen Länge und angegebenem Dateizugriff.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-158">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer with a specified offset, length, and file access.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="41d7d-159">Ruft einen Wert ab, der angibt, ob ein Stream Lesevorgänge unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-159">Gets a value indicating whether a stream supports reading.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="41d7d-160">
            <see langword="false" />, wenn das Objekt von einem Konstruktor mit einem <paramref name="access" />-Parameter erstellt wurde, das Lesen des Streams nicht eingeschlossen war und der Stream geschlossen ist, andernfalls <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-160">
              <see langword="false" /> if the object was created by a constructor with an <paramref name="access" /> parameter that did not include reading the stream and if the stream is closed; otherwise, <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-161">Diese Eigenschaft gibt an, ob das aktuelle Streamobjekt Lesevorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="41d7d-161">This property indicates whether the current stream object supports reading.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="41d7d-162">Im folgenden Codebeispiel wird veranschaulicht, wie zum Lesen und Schreiben in nicht verwalteten Speicher mithilfe der <xref:System.IO.UnmanagedMemoryStream> Klasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-162">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="41d7d-163">Ein nicht verwalteten Speicherblock ist reserviert und aufgehoben mithilfe der <xref:System.Runtime.InteropServices.Marshal> Klasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-163">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="41d7d-164">In diesem Beispiel wird ein <xref:System.IO.UnmanagedMemoryStream> Objekt wird an eine Methode, die überprüft, übergeben die <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> Eigenschaft, bevor Sie versuchen, den Inhalt in der Konsole anzeigen.</span><span class="sxs-lookup"><span data-stu-id="41d7d-164">In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> property before attempting to display the contents to the console.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="41d7d-165">Ruft einen Wert ab, der angibt, ob ein Stream Suchvorgänge unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-165">Gets a value indicating whether a stream supports seeking.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="41d7d-166">
            <see langword="false" />, wenn der Stream geschlossen ist, andernfalls <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-166">
              <see langword="false" /> if the stream is closed; otherwise, <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-167">Diese Eigenschaft gibt an, ob das aktuelle Streamobjekt Suchvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="41d7d-167">This property indicates whether the current stream object supports seeking.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="41d7d-168">Ruft einen Wert ab, der angibt, ob ein Stream Schreibvorgänge unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-168">Gets a value indicating whether a stream supports writing.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="41d7d-169">
            <see langword="false" />, wenn das Objekt von einem Konstruktor mit einem <paramref name="access" />-Parameterwert erstellt wurde, der Schreibvorgänge unterstützt, oder wenn es von einem Konstruktor ohne Parameter erstellt wurde oder wenn der Stream geschlossen ist, andernfalls <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-169">
              <see langword="false" /> if the object was created by a constructor with an <paramref name="access" /> parameter value that supports writing or was created by a constructor that had no parameters, or if the stream is closed; otherwise, <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-170">Diese Eigenschaft gibt an, ob das aktuelle Streamobjekt Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="41d7d-170">This property indicates whether the current stream object supports writing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="41d7d-171">Im folgenden Codebeispiel wird veranschaulicht, wie zum Lesen und Schreiben in nicht verwalteten Speicher mithilfe der <xref:System.IO.UnmanagedMemoryStream> Klasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-171">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="41d7d-172">Ein nicht verwalteten Speicherblock ist reserviert und aufgehoben mithilfe der <xref:System.Runtime.InteropServices.Marshal> Klasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-172">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="41d7d-173">In diesem Beispiel wird ein <xref:System.IO.UnmanagedMemoryStream> Objekt wird an eine Methode, die überprüft, übergeben die <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> Eigenschaft, bevor Sie versuchen, die Daten in den Stream geschrieben.</span><span class="sxs-lookup"><span data-stu-id="41d7d-173">In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> property before attempting to write the data to the stream.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public long Capacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Capacity As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Capacity { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="41d7d-174">Ruft die Streamlänge (Größe) oder die Gesamtgröße des einem Stream zugewiesenen Speichers (Kapazität) ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-174">Gets the stream length (size) or the total amount of memory assigned to a stream (capacity).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="41d7d-175">Die Größe oder die Kapazität des Streams.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-175">The size or capacity of the stream.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-176">Diese Eigenschaft gibt die `capacity` Wert für den Konstruktor bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="41d7d-176">This property returns the `capacity` value provided to the constructor.</span></span> <span data-ttu-id="41d7d-177">Wenn kein `capacity` Wert wurde angegeben, wenn der Stream initialisiert wurde, gibt diese Eigenschaft die Länge des Streams.</span><span class="sxs-lookup"><span data-stu-id="41d7d-177">If no `capacity` value was specified when the stream was initialized, this property returns the stream length.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="41d7d-178">Der Stream ist geschlossen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-178">The stream is closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="41d7d-179">
            <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-179">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="41d7d-180">Gibt die von <see cref="T:System.IO.UnmanagedMemoryStream" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-180">Releases the unmanaged resources used by the <see cref="T:System.IO.UnmanagedMemoryStream" /> and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-181">Diese Methode wird aufgerufen, der öffentlich <xref:System.ComponentModel.Component.Dispose%2A> Methode und die <xref:System.Object.Finalize%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="41d7d-181">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="41d7d-182"><xref:System.ComponentModel.Component.Dispose%2A> Ruft die geschützte <xref:System.IO.UnmanagedMemoryStream.Dispose%2A> Methode mit dem `disposing` Parametersatz auf `true`.</span><span class="sxs-lookup"><span data-stu-id="41d7d-182"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.UnmanagedMemoryStream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="41d7d-183"><xref:System.Object.Finalize%2A> Ruft <xref:System.IO.UnmanagedMemoryStream.Dispose%2A> mit `disposing` festgelegt `false`.</span><span class="sxs-lookup"><span data-stu-id="41d7d-183"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.UnmanagedMemoryStream.Dispose%2A> with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="41d7d-184">Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.IO.UnmanagedMemoryStream> verweist.</span><span class="sxs-lookup"><span data-stu-id="41d7d-184">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.UnmanagedMemoryStream> references.</span></span> <span data-ttu-id="41d7d-185">Diese Methode ruft die <xref:System.ComponentModel.Component.Dispose%2A>-Methode aller Objekte auf, auf die verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="41d7d-185">This method invokes the <xref:System.ComponentModel.Component.Dispose%2A> method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="41d7d-186">
              <see cref="M:System.ComponentModel.Component.Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden.</span>
            <span class="sxs-lookup">
              <span data-stu-id="41d7d-186">
                <see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects.</span>
            </span>
            <span data-ttu-id="41d7d-187">Zum Überschreiben <see cref="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" /> Achten Sie darauf, dass Sie nicht auf Objekte verweisen, die einen früheren Aufruf freigegeben wurden <see cref="M:System.ComponentModel.Component.Dispose" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="41d7d-187">When overriding <see cref="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" /> be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />.</span>
            </span>
            <span data-ttu-id="41d7d-188">Weitere Informationen zum Implementieren <see cref="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).</span>
            <span class="sxs-lookup">
              <span data-stu-id="41d7d-188">For more information about how to implement <see cref="M:System.IO.UnmanagedMemoryStream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span>
            </span>
            <span data-ttu-id="41d7d-189">Weitere Informationen zu <see cref="M:System.ComponentModel.Component.Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</span>
            <span class="sxs-lookup">
              <span data-stu-id="41d7d-189">For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="41d7d-190">Überschreibt die <see cref="M:System.IO.Stream.Flush" />-Methode, sodass keine Aktion durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-190">Overrides the <see cref="M:System.IO.Stream.Flush" /> method so that no action is performed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-191">Diese Methode führt keine Aktion für diese Klasse jedoch als Bestandteil von wird der <xref:System.IO.Stream> Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-191">This method performs no action for this class but is included as part of the <xref:System.IO.Stream> base class.</span></span> <span data-ttu-id="41d7d-192">Da alle Daten in den Arbeitsspeicher geschrieben werden, ist diese Methode redundant.</span><span class="sxs-lookup"><span data-stu-id="41d7d-192">Since any data is written to RAM, this method is redundant.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="41d7d-193">Der Stream ist geschlossen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-193">The stream is closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">
          <span data-ttu-id="41d7d-194">Das Token zum überwachen von Abbruchanforderungen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-194">The token to monitor for cancellation requests.</span>
          </span>
          <span data-ttu-id="41d7d-195">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-195">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="41d7d-196">Überschreibt die <see cref="M:System.IO.Stream.FlushAsync(System.Threading.CancellationToken)" />-Methode. Der Vorgang wird abgebrochen, wenn dies angegeben wurde, ansonsten wird keine Aktion durchgeführt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-196">Overrides the <see cref="M:System.IO.Stream.FlushAsync(System.Threading.CancellationToken)" /> method so that the operation is cancelled if specified, but no other action is performed.</span>
          </span>
          <span data-ttu-id="41d7d-197">Verfügbar ab .NET Framework 4.6</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-197">Available starting in .NET Framework 4.6</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="41d7d-198">Eine Aufgabe, die die asynchrone Leerung darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-198">A task that represents the asynchronous flush operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-199">Wenn der Vorgang abgebrochen wird nicht, die <xref:System.IO.UnmanagedMemoryStream> Aufrufe der <xref:System.IO.UnmanagedMemoryStream.Flush%2A> Methode, was bedeutet, dass keine Aktion durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="41d7d-199">If the operation isn’t cancelled, the <xref:System.IO.UnmanagedMemoryStream> calls the <xref:System.IO.UnmanagedMemoryStream.Flush%2A> method, which means that no action performed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Initialize">
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="41d7d-200">Initialisiert eine neue Instanz der <see cref="T:System.IO.UnmanagedMemoryStream" />-Klasse in einem sicheren Puffer oder unter Verwendung eines Zeigers auf eine nicht verwaltete Speicheradresse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-200">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer, or by using a pointer to an unmanaged memory location.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="protected void Initialize (byte* pointer, long length, long capacity, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Initialize(unsigned int8* pointer, int64 length, int64 capacity, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Initialize(System.Byte*,System.Int64,System.Int64,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Initialize(System::Byte* pointer, long length, long capacity, System::IO::FileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.Byte*" />
        <Parameter Name="length" Type="System.Int64" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="pointer">
          <span data-ttu-id="41d7d-201">Ein Zeiger auf eine nicht verwaltete Speicheradresse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-201">A pointer to an unmanaged memory location.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="41d7d-202">Die Länge des zu verwendenden Speichers.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-202">The length of the memory to use.</span>
          </span>
        </param>
        <param name="capacity">
          <span data-ttu-id="41d7d-203">Die Gesamtgröße des dem Stream zugewiesenen Speichers.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-203">The total amount of memory assigned to the stream.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="41d7d-204">Einer der <see cref="T:System.IO.FileAccess" />-Werte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-204">One of the <see cref="T:System.IO.FileAccess" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="41d7d-205">Initialisiert eine neue Instanz der <see cref="T:System.IO.UnmanagedMemoryStream" />-Klasse unter Verwendung eines Zeigers auf eine nicht verwaltete Speicheradresse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-205">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class by using a pointer to an unmanaged memory location.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-206">Diese Methode entspricht der <xref:System.IO.UnmanagedMemoryStream.%23ctor%2A> Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="41d7d-206">This method is equivalent to the <xref:System.IO.UnmanagedMemoryStream.%23ctor%2A> constructor.</span></span> <span data-ttu-id="41d7d-207">Es unterstützt Methoden, die den Zeiger zu initialisieren, vor dem Festlegen von Streamvariablen müssen und deshalb darf nicht den parametrisierten Konstruktor aufrufen.</span><span class="sxs-lookup"><span data-stu-id="41d7d-207">It supports methods that need to initialize the pointer before setting stream variables and, therefore, cannot call the parameterized constructor.</span></span> <span data-ttu-id="41d7d-208">Solche Methoden sollten den Standardkonstruktor verwenden <xref:System.IO.UnmanagedMemoryStream.%23ctor>, initialisieren Sie den Zeiger und rufen dann die <xref:System.IO.UnmanagedMemoryStream.Initialize%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="41d7d-208">Such methods should use the default constructor, <xref:System.IO.UnmanagedMemoryStream.%23ctor>, initialize the pointer, and then invoke the <xref:System.IO.UnmanagedMemoryStream.Initialize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="41d7d-209">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-209">The user does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="41d7d-210">Der <paramref name="pointer" />-Wert ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-210">The <paramref name="pointer" /> value is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="41d7d-211">Der <paramref name="length" />-Wert ist kleiner als 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-211">The <paramref name="length" /> value is less than zero.</span>
          </span>
          <span data-ttu-id="41d7d-212">\- oder –</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-212">\- or -</span>
          </span>
          <span data-ttu-id="41d7d-213">Der <paramref name="capacity" />-Wert ist kleiner als 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-213">The <paramref name="capacity" /> value is less than zero.</span>
          </span>
          <span data-ttu-id="41d7d-214">\- oder –</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-214">\- or -</span>
          </span>
          <span data-ttu-id="41d7d-215">Der <paramref name="length" />-Wert ist groß genug, um einen Überlauf zu verursachen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-215">The <paramref name="length" /> value is large enough to cause an overflow.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode">
          <span data-ttu-id="41d7d-216">für den Zugriff auf nicht verwalteten Speicher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-216">for accessing unmanaged memory.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="41d7d-217">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-217">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="41d7d-218">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-218">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="protected void Initialize (System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Initialize(class System.Runtime.InteropServices.SafeBuffer buffer, int64 offset, int64 length, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Initialize(System.Runtime.InteropServices.SafeBuffer,System.Int64,System.Int64,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Initialize (buffer As SafeBuffer, offset As Long, length As Long, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Initialize(System::Runtime::InteropServices::SafeBuffer ^ buffer, long offset, long length, System::IO::FileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Runtime.InteropServices.SafeBuffer" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="41d7d-219">Der Puffer, der den nicht verwalteten Speicherstream enthalten soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-219">The buffer to contain the unmanaged memory stream.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="41d7d-220">Die Byteposition im Puffer, ab der der nicht verwaltete Speicherstream beginnen soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-220">The byte position in the buffer at which to start the unmanaged memory stream.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="41d7d-221">Die Länge des nicht verwalteten Speicherstreams.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-221">The length of the unmanaged memory stream.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="41d7d-222">Der Modus des Dateizugriffs auf den nicht verwalteten Speicherstream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-222">The mode of file access to the unmanaged memory stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="41d7d-223">Initialisiert eine neue Instanz der <see cref="T:System.IO.UnmanagedMemoryStream" />-Klasse in einem sicheren Puffer mit einem angegebenen Offset, einer angegebenen Länge und angegebenem Dateizugriff.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-223">Initializes a new instance of the <see cref="T:System.IO.UnmanagedMemoryStream" /> class in a safe buffer with a specified offset, length, and file access.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="41d7d-224">Ruft die Länge der Daten in einem Stream ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-224">Gets the length of the data in a stream.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="41d7d-225">Die Länge der Daten im Stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-225">The length of the data in the stream.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-226">Wenn unverändert, da der Stream initialisiert wurde, gibt diese Eigenschaft den Wert für die Länge für den Konstruktor bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="41d7d-226">If unchanged since the stream was initialized, this property returns the length value provided to the constructor.</span></span> <span data-ttu-id="41d7d-227">Wenn Änderungen in den Stream aufgetreten sind, gibt diese Eigenschaft Änderungen auf die Länge der Daten wieder.</span><span class="sxs-lookup"><span data-stu-id="41d7d-227">If changes to the stream have occurred, this property reflects any changes to the length of the data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="41d7d-228">Im folgenden Codebeispiel wird veranschaulicht, wie zum Lesen und Schreiben in nicht verwalteten Speicher mithilfe der <xref:System.IO.UnmanagedMemoryStream> Klasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-228">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="41d7d-229">Ein nicht verwalteten Speicherblock ist reserviert und aufgehoben mithilfe der <xref:System.Runtime.InteropServices.Marshal> Klasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-229">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="41d7d-230">Der Stream ist geschlossen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-230">The stream is closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="41d7d-231">Ruft die aktuelle Position in einem Stream ab oder legt diese fest.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-231">Gets or sets the current position in a stream.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="41d7d-232">Die aktuelle Position in dem Stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-232">The current position in the stream.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-233">Wenn ein Stream initialisiert wird, wird diese Eigenschaft auf 0 (null) festgelegt.</span><span class="sxs-lookup"><span data-stu-id="41d7d-233">When a stream is initialized, this property is set to zero.</span></span>  
  
 <span data-ttu-id="41d7d-234">Obwohl Sie die Position des Streams über den Stream Kapazität festlegen können, Sie ist nicht möglich, Bereich mit den Zugriff auf die <xref:System.IO.UnmanagedMemoryStream.Read%2A> und <xref:System.IO.UnmanagedMemoryStream.Write%2A> Methoden.</span><span class="sxs-lookup"><span data-stu-id="41d7d-234">Although you can set the position of the stream beyond the stream's capacity, you will not be able to access that area using the <xref:System.IO.UnmanagedMemoryStream.Read%2A> and <xref:System.IO.UnmanagedMemoryStream.Write%2A> methods.</span></span> <span data-ttu-id="41d7d-235"><xref:System.IO.UnmanagedMemoryStream.Read%2A> Gibt 0 zurück und <xref:System.IO.UnmanagedMemoryStream.Write%2A> löst eine <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="41d7d-235"><xref:System.IO.UnmanagedMemoryStream.Read%2A> will return 0 and <xref:System.IO.UnmanagedMemoryStream.Write%2A> will throw a <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="41d7d-236">Diese Unterstützung wird in erster Linie für Entwurf und Code Kompatibilität mit grundlegenden FileStream-Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="41d7d-236">This support is primarily for design and code compatibility with basic stream operations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="41d7d-237">Der Stream ist geschlossen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-237">The stream is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="41d7d-238">Die Position wurde auf einen Wert festgelegt, der kleiner als 0 ist, oder die Position ist größer als <see cref="F:System.Int32.MaxValue" /> oder führt beim Hinzufügen zum aktuellen Zeiger zu einem Überlauf.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-238">The position is set to a value that is less than zero, or the position is larger than <see cref="F:System.Int32.MaxValue" /> or results in overflow when added to the current pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="PositionPointer">
      <MemberSignature Language="C#" Value="public byte* PositionPointer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8* PositionPointer" />
      <MemberSignature Language="DocId" Value="P:System.IO.UnmanagedMemoryStream.PositionPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Byte* PositionPointer { System::Byte* get(); void set(System::Byte* value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte*</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="41d7d-239">Ruft einen Bytezeiger auf einen Stream auf Grundlage der aktuellen Position im Stream ab oder legt diesen fest.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-239">Gets or sets a byte pointer to a stream based on the current position in the stream.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="41d7d-240">Ein Bytezeiger.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-240">A byte pointer.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-241">Um einen Zeiger auf den gesamten Stream zurückzugeben, legen die <xref:System.IO.UnmanagedMemoryStream.Position%2A> Eigenschaft auf 0 (null), und rufen Sie diese Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="41d7d-241">To return a pointer to the entire stream, set the <xref:System.IO.UnmanagedMemoryStream.Position%2A> property to zero, and then call this property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="41d7d-242">Die aktuelle Position ist größer als die Kapazität des Streams.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-242">The current position is larger than the capacity of the stream.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="41d7d-243">Die festgelegte Position ist keine gültige Position im aktuellen Stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-243">The position is being set is not a valid position in the current stream.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="41d7d-244">Der Zeiger wird auf einen niedrigeren Wert festgelegt als die Startposition des Streams.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-244">The pointer is being set to a lower value than the starting position of the stream.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="41d7d-245">Der Stream wurde zur Verwendung mit einem <see cref="T:System.Runtime.InteropServices.SafeBuffer" /> initialisiert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-245">The stream was initialized for use with a <see cref="T:System.Runtime.InteropServices.SafeBuffer" />.</span>
          </span>
          <span data-ttu-id="41d7d-246">Die <see cref="P:System.IO.UnmanagedMemoryStream.PositionPointer" />-Eigenschaft ist nur für Streams gültig, die mit einem <see cref="T:System.Byte" />-Zeiger initialisiert sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-246">The <see cref="P:System.IO.UnmanagedMemoryStream.PositionPointer" /> property is valid only for streams that are initialized with a <see cref="T:System.Byte" /> pointer.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="41d7d-247">Rufen Sie zum Aufrufen von nicht verwalteten Codes, wie das Aufrufen von systemeigenem Code mit dem Plattformaufruf oder COM-Integration.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-247">for calling unmanaged code, such as calling native code with platform invoke or COM integration.</span>
          </span>
          <span data-ttu-id="41d7d-248">Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-248">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="41d7d-249">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-249">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="41d7d-250">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-250">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="41d7d-251">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-251">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="41d7d-252">Enthält, wenn diese Methode zurückgegeben wird, das angegebene Bytearray mit den Werten zwischen <c>offset</c> und (<c>offset</c> + <c>count</c> –1), das von den Bytes ersetzt wird, die aus der aktuellen Quelle gelesen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-252">When this method returns, contains the specified byte array with the values between <c>offset</c> and (<c>offset</c> + <c>count</c> - 1) replaced by the bytes read from the current source.</span>
          </span>
          <span data-ttu-id="41d7d-253">Dieser Parameter wird nicht initialisiert übergeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-253">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="41d7d-254">Der nullbasierte Byteoffset in <c>buffer</c>, ab dem die aus dem aktuellen Stream gelesenen Daten gespeichert werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-254">The zero-based byte offset in <c>buffer</c> at which to begin storing the data read from the current stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="41d7d-255">Die maximale Anzahl an Bytes, die aus dem aktuellen Stream gelesen werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-255">The maximum number of bytes to read from the current stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="41d7d-256">Liest die angegebene Anzahl von Bytes in das angegebene Array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-256">Reads the specified number of bytes into the specified array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="41d7d-257">Die Gesamtanzahl der in den Puffer gelesenen Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-257">The total number of bytes read into the buffer.</span>
          </span>
          <span data-ttu-id="41d7d-258">Dies kann weniger als die Anzahl der angeforderten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder 0, wenn das Ende des Streams erreicht ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-258">This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-259">Die `offset` -Parameter gibt den Offset des Bytes in der `array` Parameter (Pufferindex), ab dem gelesen werden soll und die `count` Parameter gibt die maximale Anzahl von Bytes, die aus diesem Stream gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="41d7d-259">The `offset` parameter gives the offset of the byte in the `array` parameter (the buffer index) at which to begin reading, and the `count` parameter gives the maximum number of bytes to be read from this stream.</span></span> <span data-ttu-id="41d7d-260">Der zurückgegebene Wert ist die tatsächliche Anzahl der gelesenen Bytes oder 0 (null), wenn das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="41d7d-260">The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</span></span> <span data-ttu-id="41d7d-261">Wenn der Lesevorgang erfolgreich ist, wird die aktuelle Position im Stream um die Anzahl der gelesenen Bytes erweiterte.</span><span class="sxs-lookup"><span data-stu-id="41d7d-261">If the read operation is successful, the current position of the stream is advanced by the number of bytes read.</span></span> <span data-ttu-id="41d7d-262">Wenn eine Ausnahme auftritt, ist die aktuelle Position im Stream nicht geändert.</span><span class="sxs-lookup"><span data-stu-id="41d7d-262">If an exception occurs, the current position of the stream is unchanged.</span></span>  
  
 <span data-ttu-id="41d7d-263">Die <xref:System.IO.UnmanagedMemoryStream.Read%2A> Methode gibt 0 (null) erst nach dem Ende des Streams erreicht.</span><span class="sxs-lookup"><span data-stu-id="41d7d-263">The <xref:System.IO.UnmanagedMemoryStream.Read%2A> method returns zero only after reaching the end of the stream.</span></span> <span data-ttu-id="41d7d-264">Andernfalls <xref:System.IO.UnmanagedMemoryStream.Read%2A> liest immer mindestens ein Byte aus dem Stream vor der Rückgabe.</span><span class="sxs-lookup"><span data-stu-id="41d7d-264">Otherwise, <xref:System.IO.UnmanagedMemoryStream.Read%2A> always reads at least one byte from the stream before returning.</span></span> <span data-ttu-id="41d7d-265">Wenn keine Daten verfügbar, aus dem Stream bei einem Aufruf von sind <xref:System.IO.UnmanagedMemoryStream.Read%2A>, die Methode blockiert, bis mindestens 1 Byte Daten zurückgegeben werden kann.</span><span class="sxs-lookup"><span data-stu-id="41d7d-265">If no data is available from the stream upon a call to <xref:System.IO.UnmanagedMemoryStream.Read%2A>, the method will block until at least one byte of data can be returned.</span></span> <span data-ttu-id="41d7d-266">Eine Implementierung kann weniger Bytes als angefordert zurückgeben, selbst wenn das Ende des Streams nicht erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="41d7d-266">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="41d7d-267">Im folgenden Codebeispiel wird veranschaulicht, wie zum Lesen und Schreiben in nicht verwalteten Speicher mithilfe der <xref:System.IO.UnmanagedMemoryStream> Klasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-267">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span>  <span data-ttu-id="41d7d-268">Ein nicht verwalteten Speicherblock ist reserviert und aufgehoben mithilfe der <xref:System.Runtime.InteropServices.Marshal> Klasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-268">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream/cs/sample.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="41d7d-269">Der Stream ist geschlossen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-269">The stream is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="41d7d-270">Der zugrunde liegende Speicher unterstützt keine Lesevorgänge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-270">The underlying memory does not support reading.</span>
          </span>
          <span data-ttu-id="41d7d-271">\- oder –</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-271">\- or -</span>
          </span>
          <span data-ttu-id="41d7d-272">Die <see cref="P:System.IO.UnmanagedMemoryStream.CanRead" />-Eigenschaft ist auf <see langword="false" /> festgelegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-272">The <see cref="P:System.IO.UnmanagedMemoryStream.CanRead" /> property is set to <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="41d7d-273">Der <paramref name="buffer" />-Parameter ist auf <see langword="null" /> festgelegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-273">The <paramref name="buffer" /> parameter is set to <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="41d7d-274">Der <paramref name="offset" />-Parameter ist kleiner als 0 (null).</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-274">The <paramref name="offset" /> parameter is less than zero.</span>
          </span>
          <span data-ttu-id="41d7d-275">\- oder –</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-275">\- or -</span>
          </span>
          <span data-ttu-id="41d7d-276">Der <paramref name="count" />-Parameter ist kleiner als 0 (null).</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-276">The <paramref name="count" /> parameter is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="41d7d-277">Die Länge des Pufferarrays minus dem <paramref name="offset" />-Parameter ist kleiner als der <paramref name="count" />-Parameter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-277">The length of the buffer array minus the <paramref name="offset" /> parameter is less than the <paramref name="count" /> parameter.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="41d7d-278">Der Puffer, in den die Daten geschrieben werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-278">The buffer to write the data into.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="41d7d-279">Der Byteoffset in <c>buffer</c>, ab dem Daten aus dem Stream geschrieben werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-279">The byte offset in <c>buffer</c> at which to begin writing data from the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="41d7d-280">Die maximale Anzahl der zu lesenden Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-280">The maximum number of bytes to read.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="41d7d-281">Das Token zum überwachen von Abbruchanforderungen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-281">The token to monitor for cancellation requests.</span>
          </span>
          <span data-ttu-id="41d7d-282">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-282">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="41d7d-283">Liest die angegebene Anzahl von Bytes asynchron in das angegebene Array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-283">Asynchronously reads the specified number of bytes into the specified array.</span>
          </span>
          <span data-ttu-id="41d7d-284">Verfügbar ab .NET Framework 4.6</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-284">Available starting in .NET Framework 4.6</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="41d7d-285">Eine Aufgabe, die den asynchronen Lesevorgang darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-285">A task that represents the asynchronous read operation.</span>
          </span>
          <span data-ttu-id="41d7d-286">Der Wert des <paramref name="TResult" />-Parameters enthält die Gesamtzahl der Bytes, die in den Puffer gelesen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-286">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span>
          </span>
          <span data-ttu-id="41d7d-287">Der Ergebniswert kann niedriger als die Anzahl der angeforderten Bytes sein, wenn die Anzahl an derzeit verfügbaren Bytes kleiner ist als die angeforderte Anzahl, oder sie kann 0 (null) sein, wenn das Datenstromende erreicht ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-287">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-288">Wenn eine Ausnahme während des Lesevorgangs auftritt, wird es als Festlegen der <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> der Eigenschaft der zurückgegebenen Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="41d7d-288">If an exception occurs during the read operation, it will be set as the <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> of the property of the returned task.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="41d7d-289">Liest ein Byte aus einem Stream und erhöht die Position im Stream um ein Byte, oder gibt -1 zurück, wenn das Ende des Streams erreicht ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-289">Reads a byte from a stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="41d7d-290">Das Byte ohne Vorzeichen, umgewandelt in ein <see cref="T:System.Int32" />-Objekt, oder -1, wenn das Ende des Streams erreicht ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-290">The unsigned byte cast to an <see cref="T:System.Int32" /> object, or -1 if at the end of the stream.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-291">Verwenden Sie diese Methode, um ganzzahlige Werte aus dem Stream zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="41d7d-291">Use this method to return integer values from the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="41d7d-292">Im folgenden Codebeispiel wird veranschaulicht, wie zum Lesen und Schreiben in nicht verwalteten Speicher mithilfe der <xref:System.IO.UnmanagedMemoryStream> Klasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-292">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="41d7d-293">Ein nicht verwalteten Speicherblock ist reserviert und aufgehoben mithilfe der <xref:System.Runtime.InteropServices.Marshal> Klasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-293">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="41d7d-294">In diesem Beispiel ein <xref:System.IO.UnmanagedMemoryStream> Objekt wird an eine Methode, die überprüft, übergeben die <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> Eigenschaft vor dem Lesen und den Inhalt in der Konsole anzeigen.</span><span class="sxs-lookup"><span data-stu-id="41d7d-294">In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanRead%2A> property before attempting to read and display the contents to the console.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="41d7d-295">Der Stream ist geschlossen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-295">The stream is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="41d7d-296">Der zugrunde liegende Speicher unterstützt keine Lesevorgänge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-296">The underlying memory does not support reading.</span>
          </span>
          <span data-ttu-id="41d7d-297">\- oder –</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-297">\- or -</span>
          </span>
          <span data-ttu-id="41d7d-298">Die aktuelle Position befindet sich am Ende des Streams.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-298">The current position is at the end of the stream.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin loc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, loc As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin loc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="loc" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">
          <span data-ttu-id="41d7d-299">Der Punkt im Vergleich zu <c>origin</c>, ab dem gesucht werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-299">The point relative to <c>origin</c> to begin seeking from.</span>
          </span>
        </param>
        <param name="loc">
          <span data-ttu-id="41d7d-300">Bestimmt den Anfang, das Ende oder die aktuelle Position als Bezugspunkt für <c>origin</c> unter Verwendung eines Werts des Typs <see cref="T:System.IO.SeekOrigin" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-300">Specifies the beginning, the end, or the current position as a reference point for <c>origin</c>, using a value of type <see cref="T:System.IO.SeekOrigin" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="41d7d-301">Legt die aktuelle Position des aktuellen Streams auf den angegebenen Wert fest.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-301">Sets the current position of the current stream to the given value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="41d7d-302">Die neue Position im Stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-302">The new position in the stream.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-303">Weitere Informationen zu suchen, finden Sie unter <xref:System.IO.FileStream.Seek%2A>.</span><span class="sxs-lookup"><span data-stu-id="41d7d-303">For more information about seeking, see <xref:System.IO.FileStream.Seek%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="41d7d-304">Es wurde versucht, vor dem Anfang des Streams einen Suchvorgang durchzuführen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-304">An attempt was made to seek before the beginning of the stream.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="41d7d-305">Der <paramref name="offset" />-Wert ist größer als die maximale Größe des Streams.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-305">The <paramref name="offset" /> value is larger than the maximum size of the stream.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="41d7d-306">
            <paramref name="loc" /> ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-306">
              <paramref name="loc" /> is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="41d7d-307">Der Stream ist geschlossen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-307">The stream is closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="41d7d-308">Die Länge des Streams.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-308">The length of the stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="41d7d-309">Legt die Länge eines Streams auf einen angegebenen Wert fest.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-309">Sets the length of a stream to a specified value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-310">Wenn der angegebene Wert kleiner als die aktuelle Länge des Streams ist, wird der Stream abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="41d7d-310">If the given value is less than the current length of the stream, the stream is truncated.</span></span> <span data-ttu-id="41d7d-311">Wenn der angegebene Wert größer als die aktuelle Länge des Streams ist, wird der Stream erweitert.</span><span class="sxs-lookup"><span data-stu-id="41d7d-311">If the given value is larger than the current length of the stream, the stream is expanded.</span></span> <span data-ttu-id="41d7d-312">Wenn der Stream erweitert wird, sind der Inhalt des Streams zwischen der alten und neuen Länge nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="41d7d-312">If the stream is expanded, the contents of the stream between the old and the new lengths are undefined.</span></span>  
  
 <span data-ttu-id="41d7d-313">Ein Stream muss Schreib- und Suchvorgänge für unterstützen <xref:System.IO.UnmanagedMemoryStream.SetLength%2A> arbeiten.</span><span class="sxs-lookup"><span data-stu-id="41d7d-313">A stream must support both writing and seeking for <xref:System.IO.UnmanagedMemoryStream.SetLength%2A> to work.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="41d7d-314">Ein E/A-Fehler ist aufgetreten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-314">An I/O error has occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="41d7d-315">Der Stream ist geschlossen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-315">The stream is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="41d7d-316">Der zugrunde liegende Speicher unterstützt keine Schreibvorgänge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-316">The underlying memory does not support writing.</span>
          </span>
          <span data-ttu-id="41d7d-317">\- oder –</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-317">\- or -</span>
          </span>
          <span data-ttu-id="41d7d-318">Es wird versucht, in den Stream zu schreiben, und die <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" />-Eigenschaft ist <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-318">An attempt is made to write to the stream and the <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /> property is <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="41d7d-319">Der angegebene <paramref name="value" /> übersteigt die Kapazität des Streams.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-319">The specified <paramref name="value" /> exceeds the capacity of the stream.</span>
          </span>
          <span data-ttu-id="41d7d-320">\- oder –</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-320">\- or -</span>
          </span>
          <span data-ttu-id="41d7d-321">Der angegebene <paramref name="value" /> ist negativ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-321">The specified <paramref name="value" /> is negative.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (source As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="41d7d-322">Das Bytearray, aus dem Bytes in den aktuellen Stream kopiert werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-322">The byte array from which to copy bytes to the current stream.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="41d7d-323">Der Offset im Puffer, ab dem Bytes in den aktuellen Stream kopiert werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-323">The offset in the buffer at which to begin copying bytes to the current stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="41d7d-324">Die Anzahl der Bytes, die in den aktuellen Stream geschrieben werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-324">The number of bytes to write to the current stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="41d7d-325">Schreibt einen Byteblock mit den Daten aus einem Puffer in den aktuellen Stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-325">Writes a block of bytes to the current stream using data from a buffer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-326">Schreiben von tritt ein, an der aktuellen Position im Stream.</span><span class="sxs-lookup"><span data-stu-id="41d7d-326">Writing occurs at the current position in the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="41d7d-327">Im folgenden Codebeispiel wird veranschaulicht, wie zum Lesen und Schreiben in nicht verwalteten Speicher mithilfe der <xref:System.IO.UnmanagedMemoryStream> Klasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-327">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span>  <span data-ttu-id="41d7d-328">Ein nicht verwalteten Speicherblock ist reserviert und aufgehoben mithilfe der <xref:System.Runtime.InteropServices.Marshal> Klasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-328">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream/cs/sample.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="41d7d-329">Der Stream ist geschlossen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-329">The stream is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="41d7d-330">Der zugrunde liegende Speicher unterstützt keine Schreibvorgänge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-330">The underlying memory does not support writing.</span>
          </span>
          <span data-ttu-id="41d7d-331">\- oder –</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-331">\- or -</span>
          </span>
          <span data-ttu-id="41d7d-332">Es wird versucht, in den Stream zu schreiben, und die <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" />-Eigenschaft ist <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-332">An attempt is made to write to the stream and the <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /> property is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="41d7d-333">\- oder –</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-333">\- or -</span>
          </span>
          <span data-ttu-id="41d7d-334">Der <paramref name="count" />-Wert ist größer als die Kapazität des Streams.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-334">The <paramref name="count" /> value is greater than the capacity of the stream.</span>
          </span>
          <span data-ttu-id="41d7d-335">\- oder –</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-335">\- or -</span>
          </span>
          <span data-ttu-id="41d7d-336">Die Position befindet sich am Ende der Streamkapazität.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-336">The position is at the end of the stream capacity.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="41d7d-337">Ein E/A-Fehler tritt auf.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-337">An I/O error occurs.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="41d7d-338">Einer der angegebenen Parameter ist kleiner als 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-338">One of the specified parameters is less than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="41d7d-339">Der <paramref name="offset" />-Parameter minus der Länge des <paramref name="buffer" />-Parameters ist kleiner als der <paramref name="count" />-Parameter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-339">The <paramref name="offset" /> parameter minus the length of the <paramref name="buffer" /> parameter is less than the <paramref name="count" /> parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="41d7d-340">Der <paramref name="buffer" />-Parameter ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-340">The <paramref name="buffer" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="41d7d-341">Der Puffer, aus dem Daten geschrieben werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-341">The buffer to write data from.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="41d7d-342">Der nullbasierte Byteoffset in <c>buffer</c>, ab dem Bytes in den Stream kopiert werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-342">The zero-based byte offset in <c>buffer</c> from which to begin copying bytes to the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="41d7d-343">Die maximale Anzahl der zu schreibenden Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-343">The maximum number of bytes to write.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="41d7d-344">Das Token zum überwachen von Abbruchanforderungen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-344">The token to monitor for cancellation requests.</span>
          </span>
          <span data-ttu-id="41d7d-345">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-345">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="41d7d-346">Schreibt eine Folge von Bytes asynchron in den aktuellen Stream, erhöht die aktuelle Position im Stream um die Anzahl der geschriebenen Bytes und überwacht Abbruchanforderungen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-346">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span>
          </span>
          <span data-ttu-id="41d7d-347">Verfügbar ab .NET Framework 4.6</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-347">Available starting in .NET Framework 4.6</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="41d7d-348">Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-348">A task that represents the asynchronous write operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41d7d-349">Wenn eine Ausnahme während des Schreibvorgangs auftritt, wird es als Festlegen der <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> der Eigenschaft der zurückgegebenen Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="41d7d-349">If an exception occurs during the write operation, it will be set as the <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> of the property of the returned task.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.UnmanagedMemoryStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.UnmanagedMemoryStream</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="41d7d-350">Ein Bytewert, der in den Stream geschrieben werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-350">A byte value written to the stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="41d7d-351">Schreibt ein Byte an die aktuelle Position im Dateistream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-351">Writes a byte to the current position in the file stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="41d7d-352">Im folgenden Codebeispiel wird veranschaulicht, wie zum Lesen und Schreiben in nicht verwalteten Speicher mithilfe der <xref:System.IO.UnmanagedMemoryStream> Klasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-352">The following code example demonstrates how to read from and write to unmanaged memory using the <xref:System.IO.UnmanagedMemoryStream> class.</span></span> <span data-ttu-id="41d7d-353">Ein nicht verwalteten Speicherblock ist reserviert und aufgehoben mithilfe der <xref:System.Runtime.InteropServices.Marshal> Klasse.</span><span class="sxs-lookup"><span data-stu-id="41d7d-353">A block of unmanaged memory is allocated and de-allocated using the <xref:System.Runtime.InteropServices.Marshal> class.</span></span> <span data-ttu-id="41d7d-354">In diesem Beispiel wird ein <xref:System.IO.UnmanagedMemoryStream> Objekt wird an eine Methode, die überprüft, übergeben die <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> Eigenschaft, bevor Sie versuchen, die Daten in den Stream geschrieben.</span><span class="sxs-lookup"><span data-stu-id="41d7d-354">In this example, an <xref:System.IO.UnmanagedMemoryStream> object is passed to a method which checks the <xref:System.IO.UnmanagedMemoryStream.CanWrite%2A> property before attempting to write the data to the stream.</span></span>  
  
 [!code-csharp[System.IO.UnmanagedMemoryStream_Example#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UnmanagedMemoryStream_Example/cs/program.cs#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="41d7d-355">Der Stream ist geschlossen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-355">The stream is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="41d7d-356">Der zugrunde liegende Speicher unterstützt keine Schreibvorgänge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-356">The underlying memory does not support writing.</span>
          </span>
          <span data-ttu-id="41d7d-357">\- oder –</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-357">\- or -</span>
          </span>
          <span data-ttu-id="41d7d-358">Es wird versucht, in den Stream zu schreiben, und die <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" />-Eigenschaft ist <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-358">An attempt is made to write to the stream and the <see cref="P:System.IO.UnmanagedMemoryStream.CanWrite" /> property is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="41d7d-359">\- oder –</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-359">\- or -</span>
          </span>
          <span data-ttu-id="41d7d-360">Die aktuelle Position befindet sich am Ende der Kapazität des Streams.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-360">The current position is at the end of the capacity of the stream.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="41d7d-361">Der angegebene <paramref name="value" /> verursacht das Überschreiten der maximalen Kapazität des Streams.</span>
          <span class="sxs-lookup">
            <span data-stu-id="41d7d-361">The supplied <paramref name="value" /> causes the stream exceed its maximum capacity.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>