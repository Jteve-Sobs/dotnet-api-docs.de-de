<Type Name="File" FullName="System.IO.File">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="33ff20675af33b874a1f85321d5e07899d6d1ef4" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/13/2018" />
    <Meta Name="ms.locfileid" Value="35417276" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class File" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit File extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.File" />
  <TypeSignature Language="VB.NET" Value="Public Class File" />
  <TypeSignature Language="C++ CLI" Value="public ref class File abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt statische Methoden zum Erstellen, Kopieren, Löschen, Verschieben und Öffnen einer Datei bereit und unterstützt das Erstellen von <see cref="T:System.IO.FileStream" />-Objekten.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.IO.File> Klasse für normale Vorgänge wie kopieren, verschieben, umbenennen, erstellen, öffnen, löschen und das Anfügen an eine einzelne Datei zu einem Zeitpunkt. Sie können auch die <xref:System.IO.File> Klasse zum Abrufen und Festlegen von Dateiattributen oder <xref:System.DateTime> Zugriff auf Informationen im Zusammenhang mit der Erstellung und das Schreiben einer Datei. Wenn Sie Vorgänge für mehrere Dateien ausführen möchten, finden Sie unter <xref:System.IO.Directory.GetFiles%2A?displayProperty=nameWithType> oder <xref:System.IO.DirectoryInfo.GetFiles%2A?displayProperty=nameWithType>.  
  
 Anzahl der <xref:System.IO.File> Methoden andere e/a-Typen zurückgeben, beim Erstellen oder Öffnen von Dateien. Sie können diese anderen Typen verwenden, um Dateien weiter bearbeiten. Weitere Informationen finden Sie unter bestimmten <xref:System.IO.File> Elemente wie z. B. <xref:System.IO.File.OpenText%2A>, <xref:System.IO.File.CreateText%2A>, oder <xref:System.IO.File.Create%2A>.  
  
 Da alle <xref:System.IO.File> Methoden sind statisch, ist es möglicherweise effizienter, zu verwenden eine <xref:System.IO.File> -Methode, anstatt eine entsprechende <xref:System.IO.FileInfo> -Instanzmethode, wenn Sie nur eine Aktion ausführen möchten. Alle <xref:System.IO.File> Methoden erfordern, den Pfad zur Datei, die Sie bearbeiten.  
  
 Die statischen Methoden von der <xref:System.IO.File> Klasse sicherheitsüberprüfungen für alle Methoden durchzuführen. Wenn Sie ein Objekt mehrmals wiederverwenden möchten, sollten Sie mit der entsprechenden Instanzmethode der <xref:System.IO.FileInfo> stattdessen, da die sicherheitsüberprüfung wird nicht immer erforderlich sein.  
  
 Standardmäßig erhält die vollständigen Lese-/Schreibzugriff an neue Dateien für alle Benutzer.  
  
 Die folgende Tabelle beschreibt die Enumerationen, mit denen das Verhalten der verschiedenen anpassen <xref:System.IO.File> Methoden.  
  
|Enumeration|Beschreibung |  
|-----------------|-----------------|  
|<xref:System.IO.FileAccess>|Verweigert den Lese- und Schreibzugriff auf eine Datei.|  
|<xref:System.IO.FileShare>|Gibt die Ebene des gewährten Zugriffs für eine Datei, die bereits verwendet wird.|  
|<xref:System.IO.FileMode>|Gibt an, ob der Inhalt einer vorhandenen Datei beibehalten oder überschrieben werden, und gibt an, ob die Anforderungen zum Erstellen einer vorhandenen Datei einen Ausnahmefehler verursachen.|  
  
> [!NOTE]
>  Bei Membern, die einen Pfad als Eingabezeichenfolge akzeptieren, dass der Pfad muss wohlgeformt sein oder eine Ausnahme ausgelöst. Wenn ein Pfad vollqualifizierte ist aber mit einem Leerzeichen beginnt, wird der Pfad z. B. nicht in Methoden der Klasse gekürzt. Aus diesem Grund der Pfad ist falsch formatiert, und eine Ausnahme ausgelöst. Auf ähnliche Weise kann keinen Pfad oder eine Kombination von Pfaden zweimal vollqualifiziert sein. So löst z. B. "c:\temp c:\windows" auch eine Ausnahme in den meisten Fällen. Stellen Sie sicher, dass die Pfade wohlgeformt sind, wenn Sie Methoden verwenden, die eine Pfadzeichenfolge akzeptieren.  
  
 Bei Membern, die einen Pfad zu akzeptieren, kann der Pfad in einer Datei oder einfach ein Verzeichnis verweisen. Der angegebene Pfad kann auch auf einen relativen oder einen Pfad (UNC = Universal Naming Convention) für den Namen eines Servers und der freigabeeinstellungen verweisen. Beispielsweise sind alle folgenden Pfade zulässig:  
  
-   "" c: "\\\MyDir\\\MyFile.txt" in C#- oder "c:\MyDir\MyFile.txt" in Visual Basic.  
  
-   "" c: "\\\MyDir" in C#- oder "c:\MyDir" in Visual Basic.  
  
-   "" MyDir "\\\MySubdir" in C#- oder "MyDir\MySubDir" in Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" in C#- oder "\\\MyServer\MyShare" in Visual Basic.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.IO.File> Klasse, um zu überprüfen, ob eine Datei vorhanden ist, und abhängig vom Ergebnis, entweder erstellen eine neue Datei schreiben, oder öffnen Sie die vorhandene Datei und daraus zu lesen. Erstellen Sie vor dem Ausführen des Codes, eine `c:\temp` Ordner.  
  
 [!code-cpp[File Class Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Class Example/CPP/file class example.cpp#1)]
 [!code-csharp[File Class Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Class Example/CS/file class example.cs#1)]
 [!code-vb[File Class Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Class Example/VB/file class example.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.DriveInfo" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AppendAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt Zeilen an eine Datei an und schließt dann die Datei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendAllLines">
      <MemberSignature Language="C#" Value="public static void AppendAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLines(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AppendAllLines (path As String, contents As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, an die Zeilen angefügt werden sollen. Wenn die Datei nicht bereits vorhanden ist, wird sie erstellt.</param>
        <param name="contents">Die Zeilen, die an die Datei angefügt werden sollen.</param>
        <summary>Fügt Zeilen an eine Datei an und schließt dann die Datei. Wenn die angegebene Datei nicht vorhanden ist, erstellt diese Methode eine Datei, schreibt die angegebenen Zeilen in die Datei und schließt die Datei dann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode erstellt die Datei aus, wenn es nicht vorhanden ist, aber keine neue Verzeichnisse erstellt. Daher ist der Wert von der `path` Parameter muss die vorhandene Verzeichnisse enthalten.  
  
   
  
## Examples  
 Im folgenden Beispiel schreibt ausgewählte Zeilen aus einer Beispiel-Datendatei in eine Datei und fügt dann weitere Zeilen an. Das Verzeichnis mit dem Namen `temp` auf Laufwerk C muss vorhanden sein, damit das Beispiel erfolgreich abgeschlossen.  
  
 [!code-csharp[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.writeallappendall/cs/program.cs#1)]
 [!code-vb[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.writeallappendall/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder mindestens ein ungültiges Zeichen gemäß der Definition durch die <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode.</exception>
        <exception cref="T:System.ArgumentNullException">Entweder <paramref name="path" /> oder <paramref name="contents" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (z. B. ist das Verzeichnis nicht vorhanden oder befindet sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch <paramref name="path" /> angegebene Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> überschreitet die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer ist nicht zum Schreiben in die Datei berechtigt.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> gibt eine schreibgeschützte Datei an.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  <paramref name="path" /> ist ein Verzeichnis.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLines">
      <MemberSignature Language="C#" Value="public static void AppendAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLines(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, an die Zeilen angefügt werden sollen. Wenn die Datei nicht bereits vorhanden ist, wird sie erstellt.</param>
        <param name="contents">Die Zeilen, die an die Datei angefügt werden sollen.</param>
        <param name="encoding">Die zu verwendende Zeichencodierung.</param>
        <summary>Fügt Zeilen unter Verwendung einer angegebenen Codierung an eine Datei an und schließt dann die Datei. Wenn die angegebene Datei nicht vorhanden ist, erstellt diese Methode eine Datei, schreibt die angegebenen Zeilen in die Datei und schließt die Datei dann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode erstellt die Datei aus, wenn es nicht vorhanden ist, aber keine neue Verzeichnisse erstellt. Daher ist der Wert von der `path` Parameter muss die vorhandene Verzeichnisse enthalten.  
  
 Sie können diese Methode verwenden, eine Datei zu erstellen, die Folgendes enthält:  
  
-   Die Ergebnisse einer [LINQ to Objects](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) Abfragen in den Zeilen einer Datei mit abgerufenen die <xref:System.IO.File.ReadLines%2A> Methode.  
  
-   Der Inhalt einer Auflistung, die implementiert eine <xref:System.Collections.Generic.IEnumerable%601> von Zeichenfolgen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder mindestens ein ungültiges Zeichen gemäß der Definition durch die <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode.</exception>
        <exception cref="T:System.ArgumentNullException">Entweder <paramref name="path" />, <paramref name="contents" /> oder <paramref name="encoding" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (z. B. ist das Verzeichnis nicht vorhanden oder befindet sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch <paramref name="path" /> angegebene Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> überschreitet die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> gibt eine schreibgeschützte Datei an.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  <paramref name="path" /> ist ein Verzeichnis.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt die angegebene Zeichenfolge an die Datei an und erstellt die Datei, wenn sie nicht bereits vorhanden ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendAllText">
      <MemberSignature Language="C#" Value="public static void AppendAllText (string path, string contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllText(string path, string contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllText(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AppendAllText (path As String, contents As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllText(System::String ^ path, System::String ^ contents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, an die die angegebene Zeichenfolge angefügt werden soll.</param>
        <param name="contents">Die Zeichenfolge, die an die Datei angefügt werden soll.</param>
        <summary>Öffnet eine Datei, fügt die angegebene Zeichenfolge an die Datei an und schließt dann die Datei. Wenn die Datei nicht vorhanden ist, erstellt diese Methode eine Datei, schreibt die angegebene Zeichenfolge in die Datei und schließt die Datei dann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Zeichenfolge und einen Dateipfad an, diese Methode öffnet die angegebene Datei, fügt die Zeichenfolge an das Ende der Datei, und schließt dann die Datei. Das Dateihandle ist, die von dieser Methode geschlossen werden garantiert, selbst wenn Ausnahmen ausgelöst werden.  
  
 Die Methode erstellt die Datei aus, wenn es nicht vorhanden ist, aber keine neue Verzeichnisse erstellt. Daher ist der Wert von der `path` Parameter muss die vorhandene Verzeichnisse enthalten.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.IO.File.AppendAllText%2A> -Methode zum Hinzufügen von zusätzlichen Texts am Ende einer Datei. In diesem Beispiel wird eine Datei erstellt, wenn es nicht bereits vorhanden ist, und Text wird hinzugefügt. Das Verzeichnis jedoch mit dem Namen `temp` auf Laufwerk C muss vorhanden sein, damit das Beispiel erfolgreich abgeschlossen.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (z. B. ist das Verzeichnis nicht vorhanden oder befindet sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> hat eine schreibgeschützte Datei angegeben.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  <paramref name="path" /> hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Zugriff zum Schreiben in eine Datei oder ein Verzeichnis oder zum Löschen einer Datei oder eines Verzeichnisses. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendAllText">
      <MemberSignature Language="C#" Value="public static void AppendAllText (string path, string contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllText(string path, string contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllText(System.String,System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllText(System::String ^ path, System::String ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, an die die angegebene Zeichenfolge angefügt werden soll.</param>
        <param name="contents">Die Zeichenfolge, die an die Datei angefügt werden soll.</param>
        <param name="encoding">Die zu verwendende Zeichencodierung.</param>
        <summary>Fügt die angegebene Zeichenfolge an die Datei an und erstellt die Datei, wenn sie nicht bereits vorhanden ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Zeichenfolge und einen Dateipfad an, diese Methode öffnet die angegebene Datei fügt die Zeichenfolge, die an das Ende der Datei mit der angegebenen Codierung und schließt dann die Datei. Das Dateihandle ist, die von dieser Methode geschlossen werden garantiert, selbst wenn Ausnahmen ausgelöst werden.  
  
 Die Methode erstellt die Datei aus, wenn es nicht vorhanden ist, aber keine neue Verzeichnisse erstellt. Daher ist der Wert von der `path` Parameter muss die vorhandene Verzeichnisse enthalten.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.IO.File.AppendAllText%2A> -Methode zum Hinzufügen von zusätzlichen Texts am Ende einer Datei. In diesem Beispiel wird eine Datei erstellt, wenn es nicht bereits vorhanden ist, und Text wird hinzugefügt. Das Verzeichnis jedoch mit dem Namen `temp` auf Laufwerk C muss vorhanden sein, damit das Beispiel erfolgreich abgeschlossen.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (z. B. ist das Verzeichnis nicht vorhanden oder befindet sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> hat eine schreibgeschützte Datei angegeben.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  <paramref name="path" /> hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Zugriff zum Schreiben in eine Datei oder ein Verzeichnis oder zum Löschen einer Datei oder eines Verzeichnisses. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllTextAsync (string path, string contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllTextAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllTextAsync (string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllTextAsync(System.String,System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter AppendText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter AppendText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AppendText (path As String) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ AppendText(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad zu der Datei, an die angefügt wird.</param>
        <summary>Erstellt einen <see cref="T:System.IO.StreamWriter" />, der UTF-8 codierten Text an eine vorhandene Datei anfügt oder an eine neue Datei, wenn die angegebene Datei nicht vorhanden ist.</summary>
        <returns>Ein Streamwriter, der UTF-8 codierten Text an die angegebene Datei oder eine neue Datei anfügt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht der <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%29> Überladung des Konstruktors. Wenn die Datei durch angegeben `path` nicht vorhanden ist, wird er erstellt. Wenn die Datei vorhanden ist, Schreibvorgänge der <xref:System.IO.StreamWriter> Anfügen von Text in die Datei. Zusätzliche Threads sind zulässig, um die Datei zu lesen, während er geöffnet ist.  
  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Der Parameter `path` unterscheidet nicht zwischen Groß- und Kleinschreibung.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird Text in eine Datei geschrieben. Die Methode erstellt eine neue Datei, wenn die Datei nicht vorhanden. Das Verzeichnis jedoch mit dem Namen `temp` auf Laufwerk C muss vorhanden sein, damit das Beispiel erfolgreich abgeschlossen.  
  
 [!code-cpp[File_AppendText#1](~/samples/snippets/cpp/VS_Snippets_CLR/File_AppendText/CPP/file_appendtext.cpp#1)]
 [!code-csharp[File_AppendText#1](~/samples/snippets/csharp/VS_Snippets_CLR/File_AppendText/CS/file_appendtext.cs#1)]
 [!code-vb[File_AppendText#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File_AppendText/VB/file_appendtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (z. B. ist das Verzeichnis nicht vorhanden oder befindet sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Anfügen an die angegebene Datei. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert eine vorhandene Datei in eine neue Datei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (string sourceFileName, string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(string sourceFileName, string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Copy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceFileName As String, destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(System::String ^ sourceFileName, System::String ^ destFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Die zu kopierende Datei.</param>
        <param name="destFileName">Der Name der Zieldatei. Dies darf kein Verzeichnis und keine vorhandene Datei sein.</param>
        <summary>Kopiert eine vorhandene Datei in eine neue Datei. Das Überschreiben einer gleichnamigen Datei ist nicht zulässig.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht der <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29> methodenüberladung mit der `overwrite` Parametersatz auf `false`.  
  
 Die `sourceFileName` und `destFileName` Parameter können relativer oder absoluter Pfadinformationen angeben. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter der <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType> Methode. Diese Methode unterstützt die Platzhalterzeichen in den Parametern nicht.  
  
 Die Attribute der ursprünglichen Datei werden in die kopierte Datei beibehalten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird kopiert Dateien in den Sicherungsordner C:\archives\2008. Er verwendet die zwei Überladungen der <xref:System.IO.File.Copy%2A> Methode wie folgt:  
  
-   Zunächst wird die <xref:System.IO.File.Copy%28System.String%2CSystem.String%29?displayProperty=nameWithType> -methodenüberladung Textdateien (.txt) zu kopieren. Im Code wird veranschaulicht, dass diese Überladung ist es nicht zulässt, Überschreiben von Dateien, die bereits kopiert wurden.  
  
-   Es verwendet dann die <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> methodenüberladung zum Kopieren von Bildern (JPG-Dateien). Im Code wird veranschaulicht, dass diese Überladung werden das Überschreiben von Dateien, die bereits kopiert wurden.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> oder <paramref name="destFileName" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.  Oder:  <paramref name="sourceFileName" /> oder <paramref name="destFileName" /> gibt ein Verzeichnis an.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceFileName" /> oder <paramref name="destFileName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder der Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der in <paramref name="sourceFileName" /> oder <paramref name="destFileName" /> angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="sourceFileName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="destFileName" /> ist vorhanden.  Oder:  Ein E/A-Fehler ist aufgetreten.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="sourceFileName" /> oder <paramref name="destFileName" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen von <paramref name="sourceFileName" /> der und Schreiben in <paramref name="destFileName" />. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="M:System.IO.Directory.Move(System.String,System.String)" />
        <altmember cref="M:System.IO.File.Move(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (string sourceFileName, string destFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(string sourceFileName, string destFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Copy(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceFileName As String, destFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(System::String ^ sourceFileName, System::String ^ destFileName, bool overwrite);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Die zu kopierende Datei.</param>
        <param name="destFileName">Der Name der Zieldatei. Dabei darf es sich nicht um ein Verzeichnis handeln.</param>
        <param name="overwrite">
          <see langword="true" />, wenn die Zieldatei überschrieben werden kann, andernfalls <see langword="false" />.</param>
        <summary>Kopiert eine vorhandene Datei in eine neue Datei. Das Überschreiben einer gleichnamigen Datei ist zulässig.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `sourceFileName` und `destFileName` Parameter können relativer oder absoluter Pfadinformationen angeben. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Diese Methode unterstützt die Platzhalterzeichen in den Parametern nicht.  
  
 Die Attribute der ursprünglichen Datei werden in die kopierte Datei beibehalten.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird kopiert Dateien in den Sicherungsordner C:\archives\2008. Er verwendet die zwei Überladungen der <xref:System.IO.File.Copy%2A> Methode wie folgt:  
  
-   Zunächst wird die <xref:System.IO.File.Copy%28System.String%2CSystem.String%29?displayProperty=nameWithType> -methodenüberladung Textdateien (.txt) zu kopieren. Im Code wird veranschaulicht, dass diese Überladung ist es nicht zulässt, Überschreiben von Dateien, die bereits kopiert wurden.  
  
 Es verwendet dann die <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> methodenüberladung zum Kopieren von Bildern (JPG-Dateien). Im Code wird veranschaulicht, dass diese Überladung werden das Überschreiben von Dateien, die bereits kopiert wurden.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.  Oder: <paramref name="destFileName" /> ist schreibgeschützt.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> oder <paramref name="destFileName" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.  Oder:  <paramref name="sourceFileName" /> oder <paramref name="destFileName" /> gibt ein Verzeichnis an.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceFileName" /> oder <paramref name="destFileName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder der Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der in <paramref name="sourceFileName" /> oder <paramref name="destFileName" /> angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="sourceFileName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="destFileName" /> ist vorhanden, und <paramref name="overwrite" /> lautet <see langword="false" />.  Oder:  Ein E/A-Fehler ist aufgetreten.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="sourceFileName" /> oder <paramref name="destFileName" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen von <paramref name="sourceFileName" /> der und Schreiben in <paramref name="destFileName" />. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="M:System.IO.Directory.Move(System.String,System.String)" />
        <altmember cref="M:System.IO.File.Move(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Datei im angegebenen Pfad.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad und der Name der zu erstellenden Datei.</param>
        <summary>Erstellt oder überschreibt eine Datei im angegebenen Pfad.</summary>
        <returns>Ein <see cref="T:System.IO.FileStream" />, der Lese- und Schreibzugriff auf die in <paramref name="path" /> angegebene Datei bereitstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.FileStream> mit dieser Methode erstellte Objekt hat den Standardwert <xref:System.IO.FileShare> Wert <xref:System.IO.FileShare.None>; kein anderer Prozess oder Code erreichen die erstellte Datei, bis die ursprüngliche Dateihandle geschlossen wird.  
  
 Diese Methode entspricht der <xref:System.IO.File.Create%28System.String%2CSystem.Int32%29> methodenüberladung, die mit der Standardpuffergröße.  
  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Wenn die angegebene Datei nicht vorhanden ist, wird er erstellt. Wenn es vorhanden ist, und es nicht schreibgeschützt ist, wird der Inhalt überschrieben.  
  
 Standardmäßig erhält die vollständigen Lese-/Schreibzugriff an neue Dateien für alle Benutzer. Die Datei mit Lese-/Schreibzugriff geöffnet wird, und muss geschlossen werden, bevor es von einer anderen Anwendung geöffnet werden kann.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Datei im angegebenen Pfad, schreibt einige Informationen in die Datei und liest Daten aus der Datei.  
  
 [!code-cpp[File Create1#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Create1/CPP/file create1.cpp#1)]
 [!code-csharp[File Create1#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Create1/CS/file create1.cs#1)]
 [!code-vb[File Create1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Create1/VB/file create1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.  Oder:  <paramref name="path" /> hat eine schreibgeschützte Datei angegeben.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Erstellen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Berechtigung zum Lesen und Schreiben in die Datei beschrieben, die von der <paramref name="path" /> Parameter. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, bufferSize As Integer) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Der Name der Datei.</param>
        <param name="bufferSize">Die Anzahl der für Lese- und Schreibvorgänge in die Datei gepufferten Bytes.</param>
        <summary>Erstellt oder überschreibt die angegebene Datei.</summary>
        <returns>Ein <see cref="T:System.IO.FileStream" /> mit der angegebenen Puffergröße, der Lese-/Schreibzugriff auf die in <paramref name="path" /> angegebene Datei bereitstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.FileStream> mit dieser Methode erstellte Objekt hat den Standardwert <xref:System.IO.FileShare> Wert <xref:System.IO.FileShare.None>; kein anderer Prozess oder Code erreichen die erstellte Datei, bis die ursprüngliche Dateihandle geschlossen wird.  
  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Diese Methode entspricht der <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> Überladung des Konstruktors. Wenn die angegebene Datei nicht vorhanden ist, wird er erstellt. Wenn es vorhanden ist, und es nicht schreibgeschützt ist, wird der Inhalt überschrieben.  
  
 Standardmäßig erhält die vollständigen Lese-/Schreibzugriff an neue Dateien für alle Benutzer. Die Datei mit Lese-/Schreibzugriff geöffnet wird, und muss geschlossen werden, bevor es von einer anderen Anwendung geöffnet werden kann.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Datei mit der angegebenen Puffergröße.  
  
 [!code-cpp[File Create2#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Create2/CPP/file create2.cpp#1)]
 [!code-csharp[File Create2#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Create2/CS/file create2.cs#1)]
 [!code-vb[File Create2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Create2/VB/file create2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.  Oder:  <paramref name="path" /> hat eine schreibgeschützte Datei angegeben.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Erstellen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Berechtigung zum Lesen und Schreiben in die Datei beschrieben, die von der <paramref name="path" /> Parameter. Sicherheitsaktion: Anforderung. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, bufferSize As Integer, options As FileOptions) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize, System::IO::FileOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Der Name der Datei.</param>
        <param name="bufferSize">Die Anzahl der für Lese- und Schreibvorgänge in die Datei gepufferten Bytes.</param>
        <param name="options">Einer der <see cref="T:System.IO.FileOptions" />-Werte, der beschreibt, wie die Datei erstellt oder überschrieben werden soll.</param>
        <summary>Erstellt oder überschreibt die angegebene Datei und gibt eine Puffergröße sowie einen <see cref="T:System.IO.FileOptions" />-Wert an, der beschreibt, wie die Datei erstellt oder überschrieben werden soll.</summary>
        <returns>Eine neue Datei mit der angegebenen Puffergröße.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Diese Methode entspricht der <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> Überladung des Konstruktors. Wenn die angegebene Datei nicht vorhanden ist, wird er erstellt. Wenn es vorhanden ist, und es nicht schreibgeschützt ist, wird der Inhalt überschrieben.  
  
 Standardmäßig erhält die vollständigen Lese-/Schreibzugriff an neue Dateien für alle Benutzer. Die Datei mit Lese-/Schreibzugriff geöffnet wird, und muss geschlossen werden, bevor es von einer anderen Anwendung geöffnet werden kann.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.  Oder:  <paramref name="path" /> hat eine schreibgeschützte Datei angegeben.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Erstellen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Berechtigung zum Lesen und Schreiben in die Datei beschrieben, die von der <paramref name="path" /> Parameter. Sicherheitsaktion: Anforderung. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Der Name der Datei.</param>
        <param name="bufferSize">Die Anzahl der für Lese- und Schreibvorgänge in die Datei gepufferten Bytes.</param>
        <param name="options">Einer der <see cref="T:System.IO.FileOptions" />-Werte, der beschreibt, wie die Datei erstellt oder überschrieben werden soll.</param>
        <param name="fileSecurity">Einer der <see cref="T:System.Security.AccessControl.FileSecurity" />-Werte, der die Zugriffssteuerung und die Überwachungssicherheit für die Datei bestimmt.</param>
        <summary>Erstellt oder überschreibt die angegebene Datei mit der angegebenen Puffergröße, den Ordneroptionen und der Dateisicherheit.</summary>
        <returns>Eine neue Datei mit der angegebenen Puffergröße, den Ordneroptionen und der Dateisicherheit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Diese Methode entspricht der <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> Überladung des Konstruktors. Wenn die angegebene Datei nicht vorhanden ist, wird er erstellt. Wenn es vorhanden ist, und es nicht schreibgeschützt ist, wird der Inhalt überschrieben.  
  
 Standardmäßig erhält die vollständigen Lese-/Schreibzugriff an neue Dateien für alle Benutzer. Die Datei mit Lese-/Schreibzugriff geöffnet wird, und muss geschlossen werden, bevor es von einer anderen Anwendung geöffnet werden kann.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.  Oder:  <paramref name="path" /> hat eine schreibgeschützte Datei angegeben.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Erstellen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Berechtigung zum Lesen und Schreiben in die Datei beschrieben, die von der <paramref name="path" /> Parameter. Sicherheitsaktion: Anforderung. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter CreateText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter CreateText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.CreateText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateText (path As String) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ CreateText(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, die zum Schreiben geöffnet werden soll.</param>
        <summary>Erstellt oder öffnet eine Datei zum Schreiben von UTF-8 codiertem Text. Wenn die Datei bereits vorhanden ist, werden deren Inhalte überschrieben.</summary>
        <returns>Ein <see cref="T:System.IO.StreamWriter" />, der unter Verwendung der UTF-8-Codierung in die angegebene Datei schreibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht der <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%29> Konstruktorüberladung mit der `append` Parametersatz auf `false`. Wenn die Datei durch angegeben `path` nicht vorhanden ist, wird er erstellt. Wenn die Datei vorhanden ist, wird ihr Inhalt überschrieben. Zusätzliche Threads sind zulässig, um die Datei zu lesen, während er geöffnet ist.  
  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Datei für Text, schreiben und lesen.  
  
 [!code-cpp[File CreateText#1](~/samples/snippets/cpp/VS_Snippets_CLR/File CreateText/CPP/file createtext.cpp#1)]
 [!code-csharp[File CreateText#1](~/samples/snippets/csharp/VS_Snippets_CLR/File CreateText/CS/file createtext.cs#1)]
 [!code-vb[File CreateText#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File CreateText/VB/file createtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B.auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public static void Decrypt (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Decrypt(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Decrypt(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Decrypt (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Decrypt(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ein Pfad, der eine zu entschlüsselnde Datei beschreibt.</param>
        <summary>Entschlüsselt eine Datei, die vom aktuellen Konto mit der <see cref="M:System.IO.File.Encrypt(System.String)" />-Methode verschlüsselt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.File.Decrypt%2A> Methode können Sie eine Datei entschlüsseln, die mit verschlüsselt war die <xref:System.IO.File.Encrypt%2A> Methode.  Die <xref:System.IO.File.Decrypt%2A> Methode kann nur Dateien entschlüsseln, die mit dem aktuellen Benutzerkonto verschlüsselt wurden.  
  
 Die <xref:System.IO.File.Decrypt%2A> Methode erfordert den exklusiven Zugriff auf die Datei entschlüsselt wird, und löst eine Ausnahme aus, wenn es sich bei einem anderen Prozess auf die Datei verwendet wird. Wenn die Datei nicht verschlüsselt ist, <xref:System.IO.File.Decrypt%2A> gibt einen Wert ungleich NULL, womit Erfolg zurück.  
  
 Sowohl die <xref:System.IO.File.Encrypt%2A> Methode und die <xref:System.IO.File.Decrypt%2A> Methode verwenden, der Kryptografiedienstanbieter (CSP), auf dem Computer und die Verschlüsselungsschlüssel des Prozesses, der beim Aufrufen der Methode wird installiert.  
  
 Das aktuelle Dateisystem muss formatiert sein wie NTFS-Berechtigungen und das aktuelle Betriebssystem Windows NT oder höher.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.IO.File.Encrypt%2A> Methode und die <xref:System.IO.File.Decrypt%2A> Methode zum Verschlüsseln und Entschlüsseln von Dateien. Die Datei muss vorhanden sein, das Beispiel funktioniert.  
  
 [!code-cpp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.File.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Es wurde ein ungültiges Laufwerk angegeben.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch den <paramref name="path" />-Parameter beschriebene Datei konnte nicht gefunden werden.</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten. Beispielsweise ist die verschlüsselte Datei bereits geöffnet.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <exception cref="T:System.NotSupportedException">Das Dateisystem ist nicht NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der <paramref name="path" />-Parameter hat eine schreibgeschützte Datei angegeben.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  Der <paramref name="path" />-Parameter hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Berechtigung zum Lesen und Schreiben in die Datei beschrieben, die von der <paramref name="path" /> Parameter. Sicherheitsaktion: Anforderung. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Name der zu löschenden Datei. Platzhalterzeichen werden nicht unterstützt.</param>
        <summary>Löscht die angegebene Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Geben Sie einen Dateinamen mit relativen oder absoluten Pfadinformationen für die `path` Parameter. Platzhalterzeichen können nicht enthalten sein. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Wenn der zu löschenden Datei nicht vorhanden ist, wird keine Ausnahme ausgelöst.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel werden Gruppen von Dateien zu diesem Sicherungsordner C:\archives\2008 kopiert und löscht sie anschließend aus dem Quellordner.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Die angegebene Datei wird verwendet.  Oder: Es liegt ein geöffnetes Handle für die Datei vor, und das Betriebssystem ist Windows XP oder früher. Dieses geöffnete Handle kann vom Auflisten von Verzeichnissen und Dateien stammen. Weitere Informationen finden Sie unter [Vorgehensweise: Auflisten von Verzeichnissen und Dateien](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.  Oder:  Die Datei ist eine ausführbare Datei, die verwendet wird.  Oder:  <paramref name="path" /> ist ein Verzeichnis.  Oder:  <paramref name="path" /> hat eine schreibgeschützte Datei angegeben.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Der angegebene Speicher wird gelöscht. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public static void Encrypt (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Encrypt(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Encrypt(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Encrypt (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Encrypt(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ein Pfad, der eine zu verschlüsselnde Datei beschreibt.</param>
        <summary>Verschlüsselt eine Datei, sodass sie nur mit dem Konto, mit dem die Datei verschlüsselt wurde, entschlüsselt werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.File.Encrypt%2A> Methode können Sie eine Datei zu verschlüsseln, sodass nur der Aufruf dieser Methode verwendete Konto entschlüsselt werden kann. Verwenden der <xref:System.IO.File.Decrypt%2A> Methode zum Verschlüsseln einer Datei verschlüsselt die <xref:System.IO.File.Encrypt%2A> Methode.  
  
 Die <xref:System.IO.File.Encrypt%2A> Methode erfordert den exklusiven Zugriff auf die zu verschlüsselnde Datei, und schlägt fehl, wenn ein anderer Prozess auf die Datei verwendet wird.  
  
 Sowohl die <xref:System.IO.File.Encrypt%2A> Methode und die <xref:System.IO.File.Decrypt%2A> Methode verwenden, der Kryptografiedienstanbieter (CSP), auf dem Computer und die Verschlüsselungsschlüssel des Prozesses, der beim Aufrufen der Methode wird installiert.  
  
 Diese Methode ist nicht in allen Versionen von Windows verfügbar. Beispielsweise ist es nicht auf Home Edition verfügbar.  
  
 Das aktuelle Dateisystem muss als NTFS formatiert sein.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.IO.File.Encrypt%2A> Methode und die <xref:System.IO.File.Decrypt%2A> Methode zum Verschlüsseln und Entschlüsseln von Dateien. Die Datei muss vorhanden sein, das Beispiel funktioniert.  
  
 [!code-cpp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.File.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Es wurde ein ungültiges Laufwerk angegeben.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch den <paramref name="path" />-Parameter beschriebene Datei konnte nicht gefunden werden.</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <exception cref="T:System.NotSupportedException">Das Dateisystem ist nicht NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der <paramref name="path" />-Parameter hat eine schreibgeschützte Datei angegeben.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  Der <paramref name="path" />-Parameter hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Berechtigung zum Lesen und Schreiben in die Datei beschrieben, die von der <paramref name="path" /> Parameter. Sicherheitsaktion: Anforderung. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die zu überprüfende Datei.</param>
        <summary>Bestimmt, ob die angegebene Datei vorhanden ist.</summary>
        <returns>
          <see langword="true" />, wenn der Aufrufer über die erforderlichen Berechtigungen verfügt und <paramref name="path" /> den Namen einer vorhandenen Datei enthält, andernfalls <see langword="false" />. Diese Methode gibt auch <see langword="false" /> zurück, wenn für <paramref name="path" /><see langword="null" />, ein ungültiger Pfad oder eine Zeichenfolge der Länge 0 (null) festgelegt ist. Wenn ein Aufrufer nicht über ausreichende Berechtigungen zum Lesen der angegebenen Datei verfügt, wird keine Ausnahme ausgelöst, und die Methode gibt <see langword="false" /> zurück, unabhängig vom Vorhandensein von <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.File.Exists%2A> Methode sollte nicht für die Überprüfung des Pfads verwendet werden, diese Methode wird lediglich überprüft, wenn die Datei im angegebenen `path` vorhanden ist. Übergeben einen ungültigen Pfad zur <xref:System.IO.File.Exists%2A> gibt `false`. Um zu überprüfen, ob der Pfad keine ungültigen Zeichen enthält, rufen Sie die <xref:System.IO.Path.GetInvalidPathChars%2A> Methode, um die Zeichen abzurufen, die für das Dateisystem ungültig sind. Sie können auch erstellen, einen regulären Ausdruck zum Testen, ob der Pfad für Ihre Umgebung gültig ist. Beispiele von zulässigen Pfaden finden Sie in <xref:System.IO.File>.  
  
 Um festzustellen, ob ein Verzeichnis vorhanden ist, finden Sie unter <xref:System.IO.Directory.Exists%2A?displayProperty=nameWithType>.  
  
 Beachten Sie, dass ein anderer Prozess potenziell etwas mit der Datei zwischen der Zeit können Sie aufrufen, werden die <xref:System.IO.File.Exists%2A> Methode, und führen Sie ein anderer Vorgang auf den Dateiservern, wie z. B. <xref:System.IO.File.Delete%2A>.  
  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Wenn `path` beschreibt ein Verzeichnis ist, gibt diese Methode `false`. Nachgestellte Leerzeichen entfernt sind die `path` Parameter, bevor Sie bestimmen, ob die Datei vorhanden ist.  
  
 Die <xref:System.IO.File.Exists%2A> -Methode zurückkehrt `false` Wenn ein Fehler auftritt, bei dem Versuch, um festzustellen, ob die angegebene Datei vorhanden ist. Dies kann auftreten, in Situationen, in denen Auslösen von Ausnahmen, z. B. ein Dateiname ungültige Zeichen oder zu viele Zeichen, d. h. einen fehlerhaften oder fehlenden Datenträger übergeben oder wenn der Aufrufer nicht über die Berechtigung zum Lesen der Datei.  
  
   
  
## Examples  
 Im folgende Beispiel wird bestimmt, ob eine Datei vorhanden ist.  
  
 [!code-csharp[File Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Exists/CS/program.cs#1)]
 [!code-vb[File Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Exists/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen aus der angegebenen Datei. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="M:System.IO.Directory.Exists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Security.AccessControl.FileSecurity" />-Objekt ab, das die ACL-Einträge für eine angegebene Datei kapselt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.IO.FileInfo.GetAccessControl%2A> Methoden zum Abrufen des Zugriffs Zugriffssteuerungseinträgen (List, ACL) für eine angegebene Datei.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.FileSecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.FileSecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAccessControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad zu einer Datei, die ein <see cref="T:System.Security.AccessControl.FileSecurity" />-Objekt enthält, das die ACL-Informationen der Datei beschreibt.</param>
        <summary>Ruft ein <see cref="T:System.Security.AccessControl.FileSecurity" />-Objekt ab, das die ACL-Einträge für eine angegebene Datei kapselt.</summary>
        <returns>Ein <see cref="T:System.Security.AccessControl.FileSecurity" />-Objekt, das die Zugriffssteuerungsregeln für die vom <paramref name="path" />-Parameter beschriebene Datei kapselt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.IO.File.GetAccessControl%2A> Methode, um das die Einträge in der Zugriffssteuerungsliste (ACL) für eine Datei abzurufen.  
  
 Eine ACL beschreibt einzelne Benutzer und/oder Gruppen besitzen oder verfügen nicht über, Rechte für bestimmte Aktionen für die angegebene Datei. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 In Umgebungen mit NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> werden dem Benutzer erteilt, wenn der Benutzer hat <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> -Rechte für den übergeordneten Ordner. Verweigern <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Verweigern <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> für das übergeordnete Verzeichnis.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.IO.File.GetAccessControl%2A> und <xref:System.IO.File.SetAccessControl%2A> Methoden zum Hinzufügen und entfernen Sie den Zugriff steuern Zugriffssteuerungsliste Eintrag aus einer Datei.  Sie müssen ein gültiges Benutzer- oder Gruppenkonto angeben, um dieses Beispiel auszuführen.  
  
 [!code-cpp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Die Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der <paramref name="path" />-Parameter hat eine schreibgeschützte Datei angegeben.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  Der <paramref name="path" />-Parameter hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Für die Berechtigung zum Lesen von Access Control List. Sicherheitsaktion: Anforderung. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.FileSecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.FileSecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String, includeSections As AccessControlSections) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::String ^ path, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad zu einer Datei, die ein <see cref="T:System.Security.AccessControl.FileSecurity" />-Objekt enthält, das die ACL-Informationen der Datei beschreibt.</param>
        <param name="includeSections">Einer der <see cref="T:System.Security.AccessControl.AccessControlSections" />-Werte, der den Typ der zu empfangenden ACL-Informationen angibt.</param>
        <summary>Ruft ein <see cref="T:System.Security.AccessControl.FileSecurity" />-Objekt ab, das die angegebenen Typen von ACL-Einträgen für eine bestimmte Datei kapselt.</summary>
        <returns>Ein <see cref="T:System.Security.AccessControl.FileSecurity" />-Objekt, das die Zugriffssteuerungsregeln für die vom <paramref name="path" />-Parameter beschriebene Datei kapselt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.IO.File.GetAccessControl%2A> Methode, um das die Einträge in der Zugriffssteuerungsliste (ACL) für eine Datei abzurufen.  
  
 Eine ACL beschreibt einzelne Benutzer und/oder Gruppen besitzen oder verfügen nicht über, Rechte für bestimmte Aktionen für die angegebene Datei. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 In Umgebungen mit NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> werden dem Benutzer erteilt, wenn der Benutzer hat <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> -Rechte für den übergeordneten Ordner. Verweigern <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Verweigern <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> für das übergeordnete Verzeichnis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Die Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der <paramref name="path" />-Parameter hat eine schreibgeschützte Datei angegeben.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  Der <paramref name="path" />-Parameter hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Für die Berechtigung zum Lesen von Access Control List. Sicherheitsaktion: Anforderung. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.IO.FileAttributes GetAttributes (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.IO.FileAttributes GetAttributes(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAttributes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (path As String) As FileAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileAttributes GetAttributes(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAttributes</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad zur Datei.</param>
        <summary>Ruft die <see cref="T:System.IO.FileAttributes" /> der Datei in dem Pfad ab.</summary>
        <returns>Die <see cref="T:System.IO.FileAttributes" /> der Datei in dem Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die `GetAttributes` und `SetAttributes` Methoden durch Anwenden der `Archive` und `Hidden` Attribute in einer Datei.  
  
 [!code-cpp[File GetAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetAttributes/CPP/file getattributes.cpp#1)]
 [!code-csharp[File GetAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetAttributes/CS/file getattributes.cs#1)]
 [!code-vb[File GetAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetAttributes/VB/file getattributes.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist leer, enthält nur Leerzeichen oder ungültige Zeichen.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> stellt eine Datei dar und ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk), oder die Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> stellt eine Datei dar und ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk), oder die Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.IO.IOException">Diese Datei wird von einem anderen Prozess verwendet.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Lesen von Dateien Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. für das die Informationen über Erstellungsdatum und -zeitpunkt abgerufen werden sollen.</param>
        <summary>Gibt das Erstellungsdatum und den Erstellungszeitpunkt für die angegebene Datei bzw. das angegebene Verzeichnis zurück.</summary>
        <returns>Eine <see cref="T:System.DateTime" />-Struktur, die auf das Erstellungsdatum und den Erstellungszeitpunkt für das angegebene Verzeichnis oder die angegebene Datei festgelegt wird. Dieser Wert wird in Ortszeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode möglicherweise einen fehlerhaften Wert zurück, da sie systemeigene Funktionen verwendet, deren Werte möglicherweise nicht kontinuierlich vom Betriebssystem aktualisiert werden.  
  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Wenn in die Datei beschrieben die `path` Parameter ist nicht vorhanden, gibt diese Methode 0:00 Uhr, 1. Januar 1601 n. Chr. (C.E.) Coordinated Universal Time (UTC), in die lokale Zeit angepasst.  
  
 NTFS-formatierten Laufwerken möglicherweise Informationen zu einer Datei, z. B. die Erstellungszeit der Datei für einen kurzen Zeitraum zwischengespeichert. Daher kann es erforderlich sein zum Zeitpunkt der Erstellung einer Datei explizit festgelegt werden, wenn Sie überschrieben oder eine vorhandene Datei ersetzen.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt `GetCreationTime`.  
  
 [!code-vb[System.IO.File.GetCreationTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.getcreationtime/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen aus der angegebenen Datei. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetCreationTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTimeUtc(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. für das die Informationen über Erstellungsdatum und -zeitpunkt abgerufen werden sollen.</param>
        <summary>Gibt das Erstellungsdatum und den Erstellungszeitpunkt der angegebenen Datei bzw. des angegebenen Verzeichnisses im UTC-Format (Coordinated Universal Time) zurück.</summary>
        <returns>Eine <see cref="T:System.DateTime" />-Struktur, die auf das Erstellungsdatum und den Erstellungszeitpunkt für das angegebene Verzeichnis oder die angegebene Datei festgelegt wird. Der Wert wird in UTC-Zeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode möglicherweise einen fehlerhaften Wert zurück, da sie systemeigene Funktionen verwendet, deren Werte möglicherweise nicht kontinuierlich vom Betriebssystem aktualisiert werden.  
  
 Wenn in die Datei beschrieben die `path` Parameter ist nicht vorhanden, gibt diese Methode 0:00 Uhr, 1. Januar 1601 n. Chr. Die Coordinated Universal Time (UTC).  
  
 NTFS-formatierten Laufwerken möglicherweise Informationen zu einer Datei, z. B. die Erstellungszeit der Datei für einen kurzen Zeitraum zwischengespeichert. Daher kann es erforderlich sein zum Zeitpunkt der Erstellung einer Datei explizit festgelegt werden, wenn Sie überschrieben oder eine vorhandene Datei ersetzen.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.IO.File.GetCreationTimeUtc%2A> Methode.  
  
 [!code-vb[System.IO.File.GetCreationTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.getcreationtime/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen aus der angegebenen Datei. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. das die Informationen über Zugriffsdatum und -zeitpunkt abgerufen werden sollen.</param>
        <summary>Gibt das Datum und die Uhrzeit des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis zurück.</summary>
        <returns>Eine <see cref="T:System.DateTime" />-Struktur, die auf das Datum und die Uhrzeit des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis festgelegt wird. Dieser Wert wird in Ortszeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode möglicherweise einen fehlerhaften Wert zurück, da sie systemeigene Funktionen verwendet, deren Werte möglicherweise nicht kontinuierlich vom Betriebssystem aktualisiert werden.  
  
 Wenn in die Datei beschrieben die `path` Parameter ist nicht vorhanden, gibt diese Methode 0:00 Uhr, 1. Januar 1601 n. Chr. (C.E.) Coordinated Universal Time (UTC), in die lokale Zeit angepasst.  
  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt `GetLastAccessTime`.  
  
 [!code-cpp[File GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetLastAccess/CPP/file getlastaccess.cpp#1)]
 [!code-csharp[File GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetLastAccess/CS/file getlastaccess.cs#1)]
 [!code-vb[File GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetLastAccess/VB/file getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen aus der angegebenen Datei. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastAccessTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTimeUtc(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. das die Informationen über Zugriffsdatum und -zeitpunkt abgerufen werden sollen.</param>
        <summary>Gibt das Datum und den Zeitpunkt im UTC-Format (Coordinated Universal Time) des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis zurück.</summary>
        <returns>Eine <see cref="T:System.DateTime" />-Struktur, die auf das Datum und die Uhrzeit des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis festgelegt wird. Der Wert wird in UTC-Zeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode möglicherweise einen fehlerhaften Wert zurück, da sie systemeigene Funktionen verwendet, deren Werte möglicherweise nicht kontinuierlich vom Betriebssystem aktualisiert werden.  
  
 Wenn in die Datei beschrieben die `path` Parameter ist nicht vorhanden, gibt diese Methode 0:00 Uhr, 1. Januar 1601 n. Chr. Die Coordinated Universal Time (UTC).  
  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen aus der angegebenen Datei. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. für das die Informationen über Schreibdatum und -zeitpunkt abgerufen werden sollen.</param>
        <summary>Gibt das Datum und die Uhrzeit des letzten Schreibvorgangs in die angegebene Datei bzw. das angegebene Verzeichnis zurück.</summary>
        <returns>Eine <see cref="T:System.DateTime" />-Struktur, die auf das Datum und die Uhrzeit des letzten Schreibvorgangs in die angegebene Datei bzw. das angegebene Verzeichnis festgelegt wird. Dieser Wert wird in Ortszeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode möglicherweise einen fehlerhaften Wert zurück, da sie systemeigene Funktionen verwendet, deren Werte möglicherweise nicht kontinuierlich vom Betriebssystem aktualisiert werden. Jedes Betriebssystem verwaltet den Zeitpunkt des letzten Schreibzugriffs gemäß ihren eigenen Regeln. Um die Leistung zu verbessern, ein älteres Betriebssystem möglicherweise nicht den letzten Schreibvorgang Zeit-Wert auf die genaue Uhrzeit des letzten Schreibvorgangs festgelegt, aber möglicherweise legen Sie es auf eine Annäherung stattdessen.  
  
 Wenn in die Datei beschrieben die `path` Parameter ist nicht vorhanden, gibt diese Methode 0:00 Uhr, 1. Januar 1601 n. Chr. (C.E.) Coordinated Universal Time (UTC), in die lokale Zeit angepasst.  
  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt `GetLastWriteTime`.  
  
 [!code-cpp[File GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetLastWrite/CPP/file getlastwrite.cpp#1)]
 [!code-csharp[File GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetLastWrite/CS/file getlastwrite.cs#1)]
 [!code-vb[File GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetLastWrite/VB/file getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen aus der angegebenen Datei. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastWriteTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTimeUtc(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. für das die Informationen über Schreibdatum und -zeitpunkt abgerufen werden sollen.</param>
        <summary>Gibt das Datum und den Zeitpunkt des letzten Schreibzugriffs auf die angegebenen Datei bzw. das angegebene Verzeichnis im UTC-Format (Coordinated Universal Time) zurück.</summary>
        <returns>Eine <see cref="T:System.DateTime" />-Struktur, die auf das Datum und die Uhrzeit des letzten Schreibvorgangs in die angegebene Datei bzw. das angegebene Verzeichnis festgelegt wird. Der Wert wird in UTC-Zeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode möglicherweise einen fehlerhaften Wert zurück, da sie systemeigene Funktionen verwendet, deren Werte möglicherweise nicht kontinuierlich vom Betriebssystem aktualisiert werden. Jedes Betriebssystem verwaltet den Zeitpunkt des letzten Schreibzugriffs gemäß ihren eigenen Regeln. Um die Leistung zu verbessern, ein älteres Betriebssystem möglicherweise nicht den letzten Schreibvorgang Zeit-Wert auf die genaue Uhrzeit des letzten Schreibvorgangs festgelegt, aber möglicherweise legen Sie es auf eine Annäherung stattdessen.  
  
 Wenn in die Datei beschrieben die `path` Parameter ist nicht vorhanden, gibt diese Methode 0:00 Uhr, 1. Januar 1601 n. Chr. Die Coordinated Universal Time (UTC).  
  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen aus der angegebenen Datei. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceFileName, string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceFileName, string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Move(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceFileName As String, destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceFileName, System::String ^ destFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Der Name der zu verschiebenden Datei. Kann einen absoluten oder relativen Pfad enthalten.</param>
        <param name="destFileName">Der neue Pfad und Name für die Datei.</param>
        <summary>Verschiebt eine angegebene Datei an einen neuen Speicherort und ermöglicht das Angeben eines neuen Dateinamens.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode funktioniert über Volumes hinweg, und es wird keine Ausnahme ausgelöst, wenn der Quell- und Zielserver identisch sind. Beachten Sie, dass wenn Sie versuchen, eine Datei zu ersetzen, indem Sie eine Datei mit demselben Namen in dieses Verzeichnis verschieben, Sie erhalten eine <xref:System.IO.IOException>. Die Move-Methode können Sie eine vorhandene Datei überschrieben.  
  
 Die `sourceFileName` und `destFileName` Argumente können Informationen der relative oder absolute Pfad enthalten. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Wenn Sie versuchen, eine Datei über Volumes hinweg zu verschieben, und diese Datei verwendet wird, die Datei wird an das Ziel kopiert, aber nicht aus der Quelle gelöscht.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Datei erstellt.  
  
 [!code-cpp[File Move#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Move/CPP/file move.cpp#1)]
 [!code-csharp[File Move#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Move/CS/file move.cs#1)]
 [!code-vb[File Move#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Move/VB/file move.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Die Zieldatei ist bereits vorhanden.  Oder:  <paramref name="sourceFileName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceFileName" /> oder <paramref name="destFileName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> oder <paramref name="destFileName" /> ist eine Zeichenfolge der Länge 0, besteht nur aus Leerraum oder enthält durch <see cref="F:System.IO.Path.InvalidPathChars" /> definierte ungültige Zeichen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der in <paramref name="sourceFileName" /> oder <paramref name="destFileName" /> angegebene Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="sourceFileName" /> oder <paramref name="destFileName" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen von <paramref name="sourceFileName" /> der und Schreiben in <paramref name="destFileName" />. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet einen <see cref="T:System.IO.FileStream" /> für den angegebenen Pfad.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Die zu öffnende Datei.</param>
        <param name="mode">Ein <see cref="T:System.IO.FileMode" />-Wert, der angibt, ob eine Datei erstellt wird, wenn sie nicht vorhanden ist, und bestimmt, ob der Inhalt vorhandener Dateien beibehalten oder überschrieben wird.</param>
        <summary>Öffnet einen <see cref="T:System.IO.FileStream" /> für den angegebenen Pfad mit Lese- und Schreibzugriff, der nicht weitergegeben werden kann.</summary>
        <returns>Ein im angegebenen Modus und Pfad geöffneter, nicht freigegebener <see cref="T:System.IO.FileStream" /> mit Lese- und Schreibzugriff.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine temporäre Datei und schreibt Text in die Datei. Im Beispiel wird dann die Datei mithilfe von System.IO.FileMode.Open geöffnet; d. h., wenn die Datei nicht bereits vorhanden war, würde es nicht erstellt werden.  
  
 [!code-cpp[File Open1#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open1/CPP/file open1.cpp#1)]
 [!code-csharp[File Open1#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open1/CS/file open1.cs#1)]
 [!code-vb[File Open1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open1/VB/file open1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> hat eine schreibgeschützte Datei angegeben.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  <paramref name="path" /> hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.  Oder:  <paramref name="mode" /> ist <see cref="F:System.IO.FileMode.Create" />, und bei der angegebenen Datei handelt es sich um eine ausgeblendete Datei.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> gibt einen ungültigen Wert an.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die in <paramref name="path" /> angegebene Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen und Schreiben in die angegebene Datei. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode, access As FileAccess) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Die zu öffnende Datei.</param>
        <param name="mode">Ein <see cref="T:System.IO.FileMode" />-Wert, der angibt, ob eine Datei erstellt wird, wenn sie nicht vorhanden ist, und bestimmt, ob der Inhalt vorhandener Dateien beibehalten oder überschrieben wird.</param>
        <param name="access">Ein <see cref="T:System.IO.FileAccess" />-Wert, der die Vorgänge angibt, die für die Datei ausgeführt werden können.</param>
        <summary>Öffnet einen <see cref="T:System.IO.FileStream" /> unter dem angegebenen Pfad mit dem angegebenen Modus und Zugriff, der nicht weitergegeben werden kann.</summary>
        <returns>Ein <see cref="T:System.IO.FileStream" /> ohne Freigabe, der Zugriff im angegebenen Modus mit angegebenem Zugriff auf die angegebene Datei bereitstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel öffnet eine Datei mit Lesezugriff.  
  
 [!code-cpp[file open2#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open2/CPP/file open2.cpp#1)]
 [!code-csharp[file open2#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open2/CS/file open2.cs#1)]
 [!code-vb[file open2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open2/VB/file open2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.  Oder:  <paramref name="access" /> hat <see langword="Read" /> und <paramref name="mode" /> hat <see langword="Create" />, <see langword="CreateNew" />, <see langword="Truncate" /> oder <see langword="Append" /> angegeben.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> gibt eine schreibgeschützte Datei an, und <paramref name="access" /> ist nicht <see langword="Read" />.  Oder:  <paramref name="path" /> hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.  Oder:  <paramref name="mode" /> ist <see cref="F:System.IO.FileMode.Create" />, und bei der angegebenen Datei handelt es sich um eine ausgeblendete Datei.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> oder <paramref name="access" /> geben einen ungültigen Wert an.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die in <paramref name="path" /> angegebene Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen und Schreiben in die angegebene Datei. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode, access As FileAccess, share As FileShare) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Die zu öffnende Datei.</param>
        <param name="mode">Ein <see cref="T:System.IO.FileMode" />-Wert, der angibt, ob eine Datei erstellt wird, wenn sie nicht vorhanden ist, und bestimmt, ob der Inhalt vorhandener Dateien beibehalten oder überschrieben wird.</param>
        <param name="access">Ein <see cref="T:System.IO.FileAccess" />-Wert, der die Vorgänge angibt, die für die Datei ausgeführt werden können.</param>
        <param name="share">Ein <see cref="T:System.IO.FileShare" />-Wert, der die Art des Zugriffs angibt, die andere Threads auf die Datei haben.</param>
        <summary>Öffnet einen <see cref="T:System.IO.FileStream" /> auf dem angegebenen Pfad, der über den angegebenen Modus mit Lese-, Schreib- oder Lese-/Schreibzugriff und die angegebene Freigabeoption verfügt.</summary>
        <returns>Ein <see cref="T:System.IO.FileStream" /> auf dem angegebenen Pfad, der über den angegebenen Modus mit Lese-, Schreib- oder Lese-/Schreibzugriff und die angegebene Freigabeoption verfügt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel öffnet eine Datei mit Lesezugriff und Dateifreigabe.  
  
 [!code-cpp[file open3#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open3/CPP/file open3.cpp#1)]
 [!code-csharp[file open3#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open3/CS/file open3.cs#1)]
 [!code-vb[file open3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open3/VB/file open3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.  Oder:  <paramref name="access" /> hat <see langword="Read" /> und <paramref name="mode" /> hat <see langword="Create" />, <see langword="CreateNew" />, <see langword="Truncate" /> oder <see langword="Append" /> angegeben.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> gibt eine schreibgeschützte Datei an, und <paramref name="access" /> ist nicht <see langword="Read" />.  Oder:  <paramref name="path" /> hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.  Oder:  <paramref name="mode" /> ist <see cref="F:System.IO.FileMode.Create" />, und bei der angegebenen Datei handelt es sich um eine ausgeblendete Datei.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Für <paramref name="mode" />, <paramref name="access" /> oder <paramref name="share" /> ist ein ungültiger Wert angegeben.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die in <paramref name="path" /> angegebene Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen und Schreiben in die angegebene Datei. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenRead">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream OpenRead (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream OpenRead(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenRead(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRead (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ OpenRead(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, die zum Lesen geöffnet werden soll.</param>
        <summary>Öffnet eine vorhandene Datei zum Lesen.</summary>
        <returns>Ein schreibgeschützter <see cref="T:System.IO.FileStream" /> für den angegebenen Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht der <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%29> Konstruktorüberladung mit eine <xref:System.IO.FileMode> Wert <xref:System.IO.FileMode.Open>, eine <xref:System.IO.FileAccess> Wert <xref:System.IO.FileAccess.Read> und ein <xref:System.IO.FileShare> Wert <xref:System.IO.FileShare.Read>.  
  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Datei zum Lesen geöffnet.  
  
 [!code-cpp[file openread#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenRead/CPP/file openread.cpp#1)]
 [!code-csharp[file openread#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenRead/CS/file openread.cs#1)]
 [!code-vb[file openread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenRead/VB/file openread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die in <paramref name="path" /> angegebene Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen aus der angegebenen Datei. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamReader OpenText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenText (path As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenText(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, die zum Lesen geöffnet werden soll.</param>
        <summary>Öffnet eine vorhandene UTF-8-codierte Textdatei zum Lesen.</summary>
        <returns>Ein <see cref="T:System.IO.StreamReader" /> für den angegebenen Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht der <xref:System.IO.StreamReader.%23ctor%28System.String%29> Überladung des Konstruktors.  
  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Textdatei zum Lesen geöffnet.  
  
 [!code-cpp[file opentext#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenText/CPP/file opentext.cpp#1)]
 [!code-csharp[file opentext#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenText/CS/file opentext.cs#1)]
 [!code-vb[file opentext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenText/VB/file opentext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die in <paramref name="path" /> angegebene Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen aus der angegebenen Datei. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenWrite">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream OpenWrite (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream OpenWrite(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenWrite(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenWrite (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ OpenWrite(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, die zum Schreiben geöffnet werden soll.</param>
        <summary>Öffnet eine vorhandene Datei oder erstellt eine neue Datei zum Schreiben.</summary>
        <returns>Ein nicht freigegebenes <see cref="T:System.IO.FileStream" />-Objekt am angegebenen Pfad mit <see cref="F:System.IO.FileAccess.Write" />-Zugriff.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht der <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%29> Konstruktorüberladung mit Dateimodus <xref:System.IO.FileMode.OpenOrCreate>, den Zugriff auf festgelegt <xref:System.IO.FileAccess.Write>, und dem Share Modus <xref:System.IO.FileShare.None>.  
  
 Die <xref:System.IO.File.OpenWrite%2A> -Methode öffnet eine Datei aus, wenn eine bereits für den Dateipfad vorhanden, oder eine neue Datei erstellt, sofern noch nicht vorhanden. Für eine vorhandene Datei fügt es den neuen Text nicht an den vorhandenen Text. Stattdessen wird die vorhandenen Zeichen durch die neuen Zeichen überschrieben. Wenn Sie eine längere Zeichenfolge (z. B. "This is einen Test der OpenWrite-Methode") mit einer kürzeren Zeichenfolge (z. B. "zweite ausführen") überschreiben, die Datei enthält eine Mischung aus Zeichenfolgen ("zweiter Ausführungstest der OpenWrite-Methode").  
  
 Die `path` Parameter kann ein relativer oder absoluter Pfadinformationen angeben. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, verwenden die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode.  
  
 Das zurückgegebene <xref:System.IO.FileStream> unterstützt keine Lesevorgänge. Verwenden Sie zum Öffnen einer Datei zum Lesen und Schreiben von <xref:System.IO.File.Open%2A>.

 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Datei zum Lesen und Schreiben geöffnet.  
  
 [!code-cpp[file openwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenWrite/CPP/file openwrite.cpp#1)]
 [!code-csharp[file openwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenWrite/CS/file openwrite.cs#1)]
 [!code-vb[file openwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenWrite/VB/file openwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.  Oder: <paramref name="path" /> hat eine schreibgeschützte Datei oder ein Verzeichnis angegeben.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public static byte[] ReadAllBytes (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ReadAllBytes(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllBytes (path As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, die zum Lesen geöffnet werden soll.</param>
        <summary>Öffnet eine Binärdatei, liest den Inhalt der Datei in ein Bytearray ein und schließt dann die Datei.</summary>
        <returns>Ein Bytearray mit dem Inhalt der Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn einen Dateipfad an, diese Methode, öffnet die Datei liest den Inhalt der Datei in ein Bytearray und schließt dann die Datei.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  <paramref name="path" /> hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die in <paramref name="path" /> angegebene Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Zugriff zum Lesen aus einer Datei oder einem Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;byte[]&gt; ReadAllBytesAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;unsigned int8[]&gt; ReadAllBytesAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllBytesAsync(System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Byte[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet eine Textdatei, liest alle Zeilen der Datei in ein Zeichenfolgenarray ein und schließt dann die Datei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllLines">
      <MemberSignature Language="C#" Value="public static string[] ReadAllLines (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] ReadAllLines(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLines(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllLines (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ ReadAllLines(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, die zum Lesen geöffnet werden soll.</param>
        <summary>Öffnet eine Textdatei, liest alle Zeilen der Datei und schließt dann die Datei.</summary>
        <returns>Ein Zeichenfolgenarray, das alle Zeilen der Datei enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode öffnet eine Datei, liest alle Zeilen der Datei, und jede Zeile als ein Element eines Zeichenfolgenarrays hinzugefügt. Danach wird die Datei geschlossen. Eine Linie ist definiert als eine Folge von Zeichen, gefolgt von einem Wagenrücklauf ("\r"), ein Zeilenvorschub ("\n") oder ein Wagenrücklauf unmittelbar gefolgt von einer Zeile feed. Die resultierende Zeichenfolge enthält keine abschließende Carriage return, Wagenrücklauf und/oder Zeilenvorschub.  
  
 Diese Methode versucht, die Codierung einer Datei, die basierend auf dem Vorhandensein der Bytereihenfolge-Marken automatisch zu erkennen. Die Codierungsformate UTF-8 und UTF-32 (big-Endian und little-Endian) erkannt werden kann.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.IO.File.ReadAllLines%2A> Methode, um den Inhalt einer Datei anzuzeigen. In diesem Beispiel wird eine Datei erstellt, wenn es nicht bereits vorhanden ist, und Text wird hinzugefügt.  
  
 [!code-csharp[System.IO.File.AllLines#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllLines#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> hat eine schreibgeschützte Datei angegeben.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  <paramref name="path" /> hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die in <paramref name="path" /> angegebene Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Zugriff zum Lesen aus einer Datei oder einem Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLines">
      <MemberSignature Language="C#" Value="public static string[] ReadAllLines (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] ReadAllLines(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLines(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ ReadAllLines(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, die zum Lesen geöffnet werden soll.</param>
        <param name="encoding">Die auf den Inhalt der Datei angewendete Codierung.</param>
        <summary>Öffnet eine Datei, liest alle Zeilen der Datei mit der angegebenen Codierung und schließt dann die Datei.</summary>
        <returns>Ein Zeichenfolgenarray, das alle Zeilen der Datei enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode öffnet eine Datei, liest alle Zeilen der Datei und fügt dann jede Zeile als ein Element eines Zeichenfolgenarrays hinzu. Danach wird die Datei geschlossen. Eine Linie ist definiert als eine Folge von Zeichen, gefolgt von einem Wagenrücklauf ("\r"), ein Zeilenvorschub ("\n") oder ein Wagenrücklauf unmittelbar gefolgt von einer Zeile feed. Die resultierende Zeichenfolge enthält keine abschließende Carriage return, Wagenrücklauf und/oder Zeilenvorschub.  
  
 Diese Methode versucht, die Codierung einer Datei, die basierend auf dem Vorhandensein der Bytereihenfolge-Marken automatisch zu erkennen. Die Codierungsformate UTF-8 und UTF-32 (big-Endian und little-Endian) erkannt werden kann.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.IO.File.ReadAllLines%2A> Methode, um den Inhalt einer Datei anzuzeigen. In diesem Beispiel wird eine Datei erstellt, wenn es nicht bereits vorhanden ist, und Text wird hinzugefügt.  
  
 [!code-csharp[System.IO.File.AllLines_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/cs/AllText_Encoding.cs#00)]
 [!code-vb[System.IO.File.AllLines_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/vb/AllText_Encoding.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> hat eine schreibgeschützte Datei angegeben.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  <paramref name="path" /> hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die in <paramref name="path" /> angegebene Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Zugriff zum Lesen aus einer Datei oder einem Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string[]&gt; ReadAllLinesAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string[]&gt; ReadAllLinesAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLinesAsync(System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string[]&gt; ReadAllLinesAsync (string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string[]&gt; ReadAllLinesAsync(string path, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLinesAsync(System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet eine Textdatei, liest alle Zeilen der Datei in eine Zeichenfolge ein und schließt dann die Datei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllText (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, die zum Lesen geöffnet werden soll.</param>
        <summary>Öffnet eine Textdatei, liest alle Zeilen der Datei und schließt dann die Datei.</summary>
        <returns>Eine Zeichenfolge, die alle Zeilen der Datei enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode öffnet eine Datei, liest alle Zeilen der Datei, und fügt jeder Zeile als ein Element einer Zeichenfolge. Danach wird die Datei geschlossen. Eine Linie ist definiert als eine Folge von Zeichen, gefolgt von einem Wagenrücklauf ("\r"), ein Zeilenvorschub ("\n") oder ein Wagenrücklauf unmittelbar gefolgt von einer Zeile feed. Die resultierende Zeichenfolge enthält keine abschließende Carriage return, Wagenrücklauf und/oder Zeilenvorschub.  
  
 Diese Methode versucht, die Codierung einer Datei, die basierend auf dem Vorhandensein der Bytereihenfolge-Marken automatisch zu erkennen. Die Codierungsformate UTF-8 und UTF-32 (big-Endian und little-Endian) erkannt werden kann.  
  
 Verwenden der <xref:System.IO.File.ReadAllText%28System.String%2CSystem.Text.Encoding%29> -methodenüberladung beim Lesen von Dateien, die importierte Text enthalten können, da unbekannte Zeichen nicht korrekt gelesen werden kann.  
  
 Das Dateihandle ist, die von dieser Methode geschlossen werden garantiert, selbst wenn Ausnahmen ausgelöst werden.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.IO.File.ReadAllText%2A> Methode, um den Inhalt einer Datei anzuzeigen. In diesem Beispiel wird eine Datei erstellt, wenn es nicht bereits vorhanden ist, und Text wird hinzugefügt.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> hat eine schreibgeschützte Datei angegeben.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  <paramref name="path" /> hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die in <paramref name="path" /> angegebene Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Zugriff zum Lesen aus einer Datei oder einem Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, die zum Lesen geöffnet werden soll.</param>
        <param name="encoding">Die auf den Inhalt der Datei angewendete Codierung.</param>
        <summary>Öffnet eine Datei, liest alle Zeilen der Datei mit der angegebenen Codierung und schließt dann die Datei.</summary>
        <returns>Eine Zeichenfolge, die alle Zeilen der Datei enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode öffnet eine Datei, liest alle Zeilen der Datei, und fügt jeder Zeile als ein Element einer Zeichenfolge. Danach wird die Datei geschlossen. Eine Linie ist definiert als eine Folge von Zeichen, gefolgt von einem Wagenrücklauf ("\r"), ein Zeilenvorschub ("\n") oder ein Wagenrücklauf unmittelbar gefolgt von einer Zeile feed. Die resultierende Zeichenfolge enthält keine abschließende Carriage return, Wagenrücklauf und/oder Zeilenvorschub.  
  
 Diese Methode versucht, die Codierung einer Datei, die basierend auf dem Vorhandensein der Bytereihenfolge-Marken automatisch zu erkennen. Die Codierungsformate UTF-8 und UTF-32 (big-Endian und little-Endian) erkannt werden kann.  
  
 Das Dateihandle ist, die von dieser Methode geschlossen werden garantiert, selbst wenn Ausnahmen ausgelöst werden.  
  
 Um die codierungseinstellungen verwenden wie für Ihr Betriebssystem konfiguriert werden, geben die <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> -Eigenschaft für die `encoding` Parameter.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.IO.File.ReadAllText%2A> Methode, um den Inhalt einer Datei anzuzeigen. In diesem Beispiel wird eine Datei erstellt, wenn es nicht bereits vorhanden ist, und Text wird hinzugefügt.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> hat eine schreibgeschützte Datei angegeben.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  <paramref name="path" /> hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die in <paramref name="path" /> angegebene Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Zugriff zum Lesen aus einer Datei oder einem Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string&gt; ReadAllTextAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string&gt; ReadAllTextAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllTextAsync(System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string&gt; ReadAllTextAsync (string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string&gt; ReadAllTextAsync(string path, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllTextAsync(System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest die Zeilen einer Datei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadLines">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; ReadLines (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; ReadLines(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadLines(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadLines (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ ReadLines(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die zu lesende Datei.</param>
        <summary>Liest die Zeilen einer Datei.</summary>
        <returns>Alle Zeilen der Datei oder die Zeilen, die das Ergebnis einer Abfrage sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.File.ReadLines%2A> und <xref:System.IO.File.ReadAllLines%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.File.ReadLines%2A>, können Sie anfangen, die Auflistung von Zeichenfolgen aufzulisten, bevor die ganze Auflistung zurückgegeben werden; bei Verwendung von <xref:System.IO.File.ReadAllLines%2A>, Sie müssen warten, für das gesamte Array von Zeichenfolgen sein. zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund werden, wenn Sie arbeiten mit sehr großen Dateien <xref:System.IO.File.ReadLines%2A> kann effizienter sein.  
  
 Sie können die <xref:System.IO.File.ReadLines%2A>-Funktion für folgende Aufgaben verwenden:  
  
-   Führen Sie [LINQ to Objects](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) Abfragen für eine Datei auf einen gefilterten Satz ihrer Zeilen zu erhalten.  
  
-   Schreiben Sie die zurückgegebene Auflistung von Zeilen in eine Datei mit der <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29?displayProperty=nameWithType> -Methode, oder fügen Sie sie an eine vorhandene Datei mit der <xref:System.IO.File.AppendAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29?displayProperty=nameWithType> Methode.  
  
-   Erstellen Sie eine sofort aufgefüllte Instanz einer Auflistung, die akzeptiert ein <xref:System.Collections.Generic.IEnumerable%601> Auflistung von Zeichenfolgen für ihren Konstruktor wie z. B. eine <xref:System.Collections.Generic.IList%601> oder ein <xref:System.Collections.Generic.Queue%601>.  
  
 Diese Methode verwendet <xref:System.Text.Encoding.UTF8%2A> für Codierungswert.  
  
   
  
## Examples  
 Das folgende Beispiel liest die Zeilen einer Datei, um Zeilen zu suchen, die angegebene Zeichenfolgen enthalten.  
  
 [!code-csharp[System.IO.File.ReadLines#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.readlines/cs/program.cs#1)]
 [!code-vb[System.IO.File.ReadLines#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.readlines/vb/program.vb#1)]  
  
 Im folgenden Beispiel wird die <xref:System.IO.File.ReadLines%2A> Methode in einer LINQ-Abfrage, die alle Verzeichnisse für Dateien auflistet, die eine Erweiterung ".txt" aufweisen, liest jede Zeile der Datei und Zeile angezeigt, wenn sie die Zeichenfolge "Microsoft" enthält.  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), besteht nur aus Leerraum oder enthält mindestens eines der von der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode definierten ungültigen Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch <paramref name="path" /> angegebene Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> überschreitet die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> gibt eine schreibgeschützte Datei an.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  <paramref name="path" /> ist ein Verzeichnis.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLines">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; ReadLines (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; ReadLines(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadLines(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ ReadLines(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Die zu lesende Datei.</param>
        <param name="encoding">Die auf den Inhalt der Datei angewendete Codierung.</param>
        <summary>Liest die Zeilen einer Datei mit einer angegebenen Codierung.</summary>
        <returns>Alle Zeilen der Datei oder die Zeilen, die das Ergebnis einer Abfrage sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um anzugeben, dass die Datei eine Codierung zur Wiederherstellung gelesen werden.  
  
 Die <xref:System.IO.File.ReadLines%2A> und <xref:System.IO.File.ReadAllLines%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.File.ReadLines%2A>, können Sie anfangen, die Auflistung von Zeichenfolgen aufzulisten, bevor die ganze Auflistung zurückgegeben wird. Bei Verwendung von <xref:System.IO.File.ReadAllLines%2A>, Sie müssen warten, für das gesamte Array von Zeichenfolgen zurückgegeben werden, bevor Sie das Array zugreifen können. Aus diesem Grund werden, wenn Sie arbeiten mit sehr großen Dateien <xref:System.IO.File.ReadLines%2A> kann effizienter sein.  
  
 Sie können die <xref:System.IO.File.ReadLines%2A>-Funktion für folgende Aufgaben verwenden:  
  
-   Führen Sie [LINQ to Objects](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) Abfragen für eine Datei auf einen gefilterten Satz ihrer Zeilen zu erhalten.  
  
-   Schreiben Sie die zurückgegebene Auflistung von Zeilen in eine Datei mit der <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29?displayProperty=nameWithType> -Methode, oder fügen Sie sie an eine vorhandene Datei mit der <xref:System.IO.File.AppendAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29?displayProperty=nameWithType> Methode.  
  
-   Erstellen Sie eine sofort aufgefüllte Instanz einer Auflistung, die akzeptiert ein <xref:System.Collections.Generic.IEnumerable%601> Auflistung von Zeichenfolgen für ihren Konstruktor wie z. B. eine <xref:System.Collections.Generic.IList%601> oder ein <xref:System.Collections.Generic.Queue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), besteht nur aus Leerraum oder enthält mindestens eines der von der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode definierten ungültige Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch <paramref name="path" /> angegebene Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> überschreitet die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> gibt eine schreibgeschützte Datei an.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  <paramref name="path" /> ist ein Verzeichnis.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ersetzt den Inhalt einer angegebenen Datei mit dem Inhalt einer anderen Datei, löscht die ursprüngliche Datei und erstellt eine Sicherung der ersetzten Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.File.Replace%2A> Methoden ersetzen Sie den Inhalt einer angegebenen Datei mit dem Inhalt einer anderen Datei.  Außerdem erstellen Sie eine Sicherungskopie der Datei, die ersetzt wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static void Replace (string sourceFileName, string destinationFileName, string destinationBackupFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Replace (sourceFileName As String, destinationFileName As String, destinationBackupFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Replace(System::String ^ sourceFileName, System::String ^ destinationFileName, System::String ^ destinationBackupFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Der Name einer Datei, die die von <c>destinationFileName</c> angegebene Datei ersetzt.</param>
        <param name="destinationFileName">Der Name der Datei, die ersetzt wird.</param>
        <param name="destinationBackupFileName">Der Name der Sicherungsdatei.</param>
        <summary>Ersetzt den Inhalt einer angegebenen Datei mit dem Inhalt einer anderen Datei, löscht die ursprüngliche Datei und erstellt eine Sicherung der ersetzten Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.File.Replace%2A> Methode ersetzt den Inhalt einer angegebenen Datei mit dem Inhalt einer anderen Datei.  Es erstellt auch eine Sicherung der Datei, die ersetzt wurde.  
  
 Wenn die `sourceFileName` und `destinationFileName` sind auf unterschiedlichen Volumes wird diese Methode eine Ausnahme ausgelöst. Wenn die `destinationBackupFileName` ist auf ein anderes Volume aus der Quelldatei, die Sicherungsdatei gelöscht werden.  
  
 Übergeben Sie `null` auf die `destinationBackupFileName` Parameter an, wenn Sie nicht, erstellen Sie eine Sicherung der ersetzten Datei möchten.  

 Wenn die `destinationBackupFileName` ist bereits vorhanden. wird Sie überschrieben, mit dem Inhalt der `destinationFileName` Datei.
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.IO.File.Replace%2A> Methode, um die alte Datei durch eine andere Datei, und erstellen Sie eine Sicherung der ersetzten Datei.  
  
 [!code-cpp[IO.File.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Replace/CS/sample.cs#1)]
 [!code-vb[IO.File.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Format des mit dem <paramref name="destinationFileName" />-Parameter beschriebenen Pfads war ungültig.  Oder:  Der durch den <paramref name="destinationBackupFileName" />-Parameter beschriebene Pfad hat ein ungültiges Format.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="destinationFileName" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Es wurde ein ungültiges Laufwerk angegeben.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch das aktuelle <see cref="T:System.IO.FileInfo" />-Objekt beschriebene Datei konnte nicht gefunden werden.  Oder:  Die durch den <paramref name="destinationBackupFileName" />-Parameter beschriebene Datei konnte nicht gefunden werden.</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.  \- oder:  Die Parameter <paramref name="sourceFileName" /> und <paramref name="destinationFileName" /> geben dieselbe Datei an.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das Betriebssystem ist Windows 98 Second Edition oder früher, und das Dateisystem ist nicht NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der <paramref name="sourceFileName" />-Parameter bzw. der <paramref name="destinationFileName" />-Parameter gibt an, dass eine Datei schreibgeschützt ist.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  Die Quell- oder Zielparameter geben ein Verzeichnis anstelle einer Datei an.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Für die Berechtigung zum Schreiben in Datei beschrieben, die von der <paramref name="destinationBackupFileName" /> Parameter an, wenn ein solcher festgelegt wurde. Sicherheitsaktion: Anforderung. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static void Replace (string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Replace(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Replace (sourceFileName As String, destinationFileName As String, destinationBackupFileName As String, ignoreMetadataErrors As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Replace(System::String ^ sourceFileName, System::String ^ destinationFileName, System::String ^ destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
        <Parameter Name="ignoreMetadataErrors" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Der Name einer Datei, die die von <c>destinationFileName</c> angegebene Datei ersetzt.</param>
        <param name="destinationFileName">Der Name der Datei, die ersetzt wird.</param>
        <param name="destinationBackupFileName">Der Name der Sicherungsdatei.</param>
        <param name="ignoreMetadataErrors">
          <see langword="true" />, um Fehler beim Zusammenführen der ersetzten Datei und der Ersetzungsdatei zu ignorieren (z. B. Attribute und Zugriffssteuerungslisten), andernfalls <see langword="false" />.</param>
        <summary>Ersetzt den Inhalt einer angegebenen Datei mit dem Inhalt einer anderen Datei, löscht die ursprüngliche Datei, erstellt eine Sicherung der ersetzten Datei und ignoriert optional Fehler beim Merge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.File.Replace%2A> Methode ersetzt den Inhalt einer angegebenen Datei mit dem Inhalt einer anderen Datei.  Es erstellt auch eine Sicherung der Datei, die ersetzt wurde.  
  
 Wenn die `sourceFileName` und `destinationFileName` sind auf unterschiedlichen Volumes wird diese Methode eine Ausnahme ausgelöst. Wenn die `destinationBackupFileName` ist auf ein anderes Volume aus der Quelldatei, die Sicherungsdatei gelöscht werden.  
  
 Übergeben Sie `null` auf die `destinationBackupFileName` Parameter an, wenn Sie nicht, erstellen Sie eine Sicherung der ersetzten Datei möchten.  

 Wenn die `destinationBackupFileName` ist bereits vorhanden. wird Sie überschrieben, mit dem Inhalt der `destinationFileName` Datei.
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.IO.File.Replace%2A> Methode, um die alte Datei durch eine andere Datei, und erstellen Sie eine Sicherung der ersetzten Datei.  
  
 [!code-cpp[IO.File.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Replace/CS/sample.cs#1)]
 [!code-vb[IO.File.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Format des mit dem <paramref name="destinationFileName" />-Parameter beschriebenen Pfads war ungültig.  Oder:  Der durch den <paramref name="destinationBackupFileName" />-Parameter beschriebene Pfad hat ein ungültiges Format.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="destinationFileName" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Es wurde ein ungültiges Laufwerk angegeben.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch das aktuelle <see cref="T:System.IO.FileInfo" />-Objekt beschriebene Datei konnte nicht gefunden werden.  Oder:  Die durch den <paramref name="destinationBackupFileName" />-Parameter beschriebene Datei konnte nicht gefunden werden.</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.  \- oder:  Die Parameter <paramref name="sourceFileName" /> und <paramref name="destinationFileName" /> geben dieselbe Datei an.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das Betriebssystem ist Windows 98 Second Edition oder früher, und das Dateisystem ist nicht NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der <paramref name="sourceFileName" />-Parameter bzw. der <paramref name="destinationFileName" />-Parameter gibt an, dass eine Datei schreibgeschützt ist.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  Die Quell- oder Zielparameter geben ein Verzeichnis anstelle einer Datei an.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Für die Berechtigung zum Schreiben in Datei beschrieben, die von der <paramref name="destinationBackupFileName" /> Parameter an, wenn ein solcher festgelegt wurde. Sicherheitsaktion: Anforderung. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetAccessControl(System.String,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAccessControl(System::String ^ path, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Eine Datei, der Einträge von Zugriffssteuerungslisten hinzugefügt oder aus dieser entfernt werden sollen.</param>
        <param name="fileSecurity">Ein <see cref="T:System.Security.AccessControl.FileSecurity" />-Objekt, das einen ACL-Eintrag beschreibt, der auf die vom <c>path</c>-Parameter beschriebene Datei angewendet werden soll.</param>
        <summary>Wendet von einem <see cref="T:System.Security.AccessControl.FileSecurity" />-Objekt beschriebene Einträge von Zugriffssteuerungslisten (Access Control List, ACL) auf die angegebene Datei an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.File.SetAccessControl%2A> Methode gilt Einträge Access Control List (ACL) für eine Datei, die nicht geerbte Zugriffssteuerungsliste darstellt.  
  
> [!CAUTION]
>  Die ACL angegeben, für die `fileSecurity` Parameter ersetzt die vorhandene Zugriffssteuerungsliste für die Datei. Um Berechtigungen für einen neuen Benutzer hinzuzufügen, verwenden die <xref:System.IO.File.GetAccessControl%2A> Methode zum Abrufen der vorhandenen ACL, ändern und verwenden Sie dann <xref:System.IO.File.SetAccessControl%2A> , wieder in der Datei anzuwenden.  
  
 Eine ACL beschreibt einzelne Benutzer und/oder Gruppen besitzen oder verfügen nicht über, Rechte für bestimmte Aktionen für die angegebene Datei. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Die <xref:System.IO.File.SetAccessControl%2A> Methode speichert nur <xref:System.Security.AccessControl.FileSecurity> Objekte, die nach der Erstellung des Objekts geändert wurden.  Wenn ein <xref:System.Security.AccessControl.FileSecurity> Objekt wurde nicht verändert, wird nicht in einer Datei beibehalten werden.  Es ist daher nicht möglich, zum Abrufen einer <xref:System.Security.AccessControl.FileSecurity> Objekt aus einer Datei, und wenden Sie das gleiche Objekt in eine andere Datei erneut an.  
  
 ACL-Informationen aus einer Datei in einen anderen zu kopieren:  
  
1.  Verwenden der <xref:System.IO.File.GetAccessControl%2A> Methode zum Abrufen der <xref:System.Security.AccessControl.FileSecurity> Objekt aus der Quelldatei.  
  
2.  Erstellen Sie ein neues <xref:System.Security.AccessControl.FileSecurity> Objekt für die Zieldatei.  
  
3.  Verwenden der <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> oder <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> Methode der Quelle <xref:System.Security.AccessControl.FileSecurity> Objekt, das die ACL-Informationen abzurufen.  
  
4.  Verwenden der <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> oder <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> Methode, um die Informationen zu kopieren, die in Schritt 3 in das Ziel abgerufenen <xref:System.Security.AccessControl.FileSecurity> Objekt.  
  
5.  Legen Sie das Ziel <xref:System.Security.AccessControl.FileSecurity> Objekt, das die Ziel-Datei mithilfe der <xref:System.IO.File.SetAccessControl%2A> Methode.  
  
 In Umgebungen mit NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> werden dem Benutzer erteilt, wenn der Benutzer hat <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> -Rechte für den übergeordneten Ordner. Verweigern <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Verweigern <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> für das übergeordnete Verzeichnis.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.IO.File.GetAccessControl%2A> und <xref:System.IO.File.SetAccessControl%2A> Methoden zum Hinzufügen und entfernen Sie den Zugriff steuern Zugriffssteuerungsliste Eintrag aus einer Datei.  Sie müssen ein gültiges Benutzer- oder Gruppenkonto angeben, um dieses Beispiel auszuführen.  
  
 [!code-cpp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Die Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der <paramref name="path" />-Parameter hat eine schreibgeschützte Datei angegeben.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  Der <paramref name="path" />-Parameter hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="fileSecurity" />-Parameter ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Für die Berechtigung zum Zugriff auf die Datei. Sicherheitsaktion: Anforderung. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.Change" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetAttributes">
      <MemberSignature Language="C#" Value="public static void SetAttributes (string path, System.IO.FileAttributes fileAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAttributes(string path, valuetype System.IO.FileAttributes fileAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetAttributes(System.String,System.IO.FileAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttributes(System::String ^ path, System::IO::FileAttributes fileAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileAttributes" Type="System.IO.FileAttributes" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad zur Datei.</param>
        <param name="fileAttributes">Eine bitweise Kombination der Enumerationswerte.</param>
        <summary>Legt die angegebenen <see cref="T:System.IO.FileAttributes" /> der Datei im angegebenen Pfad fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Bestimmte Dateiattribute, z. B. <xref:System.IO.FileAttributes.Hidden> und <xref:System.IO.FileAttributes.ReadOnly>, kombiniert werden können. Andere Attribute – z. B. <xref:System.IO.FileAttributes.Normal>, müssen allein verwendet werden.  
  
 Es ist nicht möglich, so ändern Sie den Komprimierungsstatus einer <xref:System.IO.File> -Objekt unter Verwendung der <xref:System.IO.File.SetAttributes%2A> Methode.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die `GetAttributes` und `SetAttributes` Methoden durch Anwenden der `Archive` und `Hidden` Attribute in einer Datei.  
  
 [!code-cpp[File GetAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetAttributes/CPP/file getattributes.cpp#1)]
 [!code-csharp[File GetAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetAttributes/CS/file getattributes.cs#1)]
 [!code-vb[File GetAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetAttributes/VB/file getattributes.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist leer, besteht nur aus Leerraum, enthält ungültige Zeichen, oder das Dateiattribut ist ungültig.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> hat eine schreibgeschützte Datei angegeben.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  <paramref name="path" /> hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Lesen und Schreiben von Dateien Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetCreationTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTime (path As String, creationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTime(System::String ^ path, DateTime creationTime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, für die die Informationen über Erstellungsdatum und -zeitpunkt festgelegt werden sollen.</param>
        <param name="creationTime">Eine <see cref="T:System.DateTime" />, die den festzulegenden Wert für Erstellungsdatum und -zeitpunkt von <c>path</c> enthält. Dieser Wert wird in Ortszeit angegeben.</param>
        <summary>Legt das Datum und die Uhrzeit fest, zu der die Datei erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 NTFS-formatierten Laufwerken können Datei Meta-Informationen, z. B. die Erstellungszeit der Datei für einen kurzen Zeitraum zwischengespeichert. Daher kann es erforderlich sein zum Zeitpunkt der Erstellung einer Datei explizit festgelegt werden, wenn Sie überschrieben oder eine vorhandene Datei ersetzen.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.IOException">Beim Ausführen des Vorgangs ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> gibt einen Wert an, der außerhalb des für diesen Vorgang zulässigen Bereichs für Datum oder Zeit oder beidem liegt.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTimeUtc (path As String, creationTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTimeUtc(System::String ^ path, DateTime creationTimeUtc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, für die die Informationen über Erstellungsdatum und -zeitpunkt festgelegt werden sollen.</param>
        <param name="creationTimeUtc">Eine <see cref="T:System.DateTime" />, die den festzulegenden Wert für Erstellungsdatum und -zeitpunkt von <c>path</c> enthält. Der Wert wird in UTC-Zeit angegeben.</param>
        <summary>Legt das Datum und die Uhrzeit der Erstellung der Datei im UTC-Format (Coordinated Universal Time) fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 NTFS-formatierten Laufwerken können Datei Meta-Informationen, z. B. die Erstellungszeit der Datei für einen kurzen Zeitraum zwischengespeichert. Daher kann es erforderlich sein zum Zeitpunkt der Erstellung einer Datei explizit festgelegt werden, wenn Sie überschrieben oder eine vorhandene Datei ersetzen.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.IOException">Beim Ausführen des Vorgangs ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> gibt einen Wert an, der außerhalb des für diesen Vorgang zulässigen Bereichs für Datum oder Zeit oder beidem liegt.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTime (path As String, lastAccessTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTime(System::String ^ path, DateTime lastAccessTime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, für die die Informationen über Zugriffsdatum und -zeitpunkt festgelegt werden sollen.</param>
        <param name="lastAccessTime">Eine <see cref="T:System.DateTime" />, die den festzulegenden Wert für Datum und Zeitpunkt des letzten Zugriffs auf <c>path</c> enthält. Dieser Wert wird in Ortszeit angegeben.</param>
        <summary>Legt das Datum und die Uhrzeit des letzten Zugriffs auf die angegebene Datei fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel überprüft das Dateisystem für die angegebene Datei, und erstellen diese bei Bedarf, und legt dann und ruft die Uhrzeit des letzten Zugriffs.  
  
 [!code-cpp[file setlastaccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/File SetLastAccess/CPP/file setlastaccess.cpp#1)]
 [!code-csharp[file setlastaccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/File SetLastAccess/CS/file setlastaccess.cs#1)]
 [!code-vb[file setlastaccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File SetLastAccess/VB/file setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTime" /> gibt einen Wert an, der außerhalb des für diesen Vorgang zulässigen Bereichs für Datum oder Zeit liegt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTimeUtc (path As String, lastAccessTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTimeUtc(System::String ^ path, DateTime lastAccessTimeUtc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, für die die Informationen über Zugriffsdatum und -zeitpunkt festgelegt werden sollen.</param>
        <param name="lastAccessTimeUtc">Eine <see cref="T:System.DateTime" />, die den festzulegenden Wert für Datum und Zeitpunkt des letzten Zugriffs auf <c>path</c> enthält. Der Wert wird in UTC-Zeit angegeben.</param>
        <summary>Legt das Datum und den Zeitpunkt des letzten Zugriffs auf die angegebene Datei im UTC-Format (Coordinated Universal Time) fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTimeUtc" /> gibt einen Wert an, der außerhalb des für diesen Vorgang zulässigen Bereichs für Datum oder Zeit liegt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTime (path As String, lastWriteTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTime(System::String ^ path, DateTime lastWriteTime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, für die die Informationen über Datum und Uhrzeit festgelegt werden sollen.</param>
        <param name="lastWriteTime">Eine <see cref="T:System.DateTime" />, die den festzulegenden Wert für Datum und Uhrzeit des letzten Schreibvorgangs von <c>path</c> enthält. Dieser Wert wird in Ortszeit angegeben.</param>
        <summary>Legt das Datum und die Uhrzeit des letzten Schreibvorgangs in die angegebene Datei fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgende Beispiel überprüft das Dateisystem für die angegebene Datei und erstellt die Datei bei Bedarf, und legt dann und ruft den Zeitpunkt des letzten Schreibzugriffs der Datei.  
  
 [!code-cpp[file setlastwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File SetLastWrite/CPP/file setlastwrite.cpp#1)]
 [!code-csharp[file setlastwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File SetLastWrite/CS/file setlastwrite.cs#1)]
 [!code-vb[file setlastwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File SetLastWrite/VB/file setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTime" /> gibt einen Wert an, der außerhalb des für diesen Vorgang zulässigen Bereichs für Datum oder Zeit liegt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTimeUtc (path As String, lastWriteTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTimeUtc(System::String ^ path, DateTime lastWriteTimeUtc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, für die die Informationen über Datum und Uhrzeit festgelegt werden sollen.</param>
        <param name="lastWriteTimeUtc">Eine <see cref="T:System.DateTime" />, die den festzulegenden Wert für Datum und Uhrzeit des letzten Schreibvorgangs von <c>path</c> enthält. Der Wert wird in UTC-Zeit angegeben.</param>
        <summary>Legt das Datum und den Zeitpunkt des letzten Schreibzugriffs auf die angegebene Datei im UTC-Format (Coordinated Universal Time) fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad Angaben zur zulässig ist. Ein relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie [allgemeine e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTimeUtc" /> gibt einen Wert an, der außerhalb des für diesen Vorgang zulässigen Bereichs für Datum oder Zeit liegt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public static void WriteAllBytes (string path, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllBytes(string path, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllBytes(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllBytes (path As String, bytes As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllBytes(System::String ^ path, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, in die geschrieben werden soll.</param>
        <param name="bytes">Die Bytes, die in die Datei geschrieben werden sollen.</param>
        <summary>Erstellt eine neue Datei, schreibt das angegebene Bytearray in die Datei und schließt die Datei dann. Ist die Zieldatei bereits vorhanden, wird sie überschrieben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erhält ein Bytearray und ein Dateipfad, diese Methode öffnet die angegebene Datei schreibt den Inhalt des Bytearrays in die Datei und schließt dann die Datei.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />, oder das Bytearray ist leer.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> hat eine schreibgeschützte Datei angegeben.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  <paramref name="path" /> hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Zugriff zum Schreiben in eine Datei oder ein Verzeichnis oder zum Löschen einer Datei oder eines Verzeichnisses. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllBytesAsync (string path, byte[] bytes, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllBytesAsync(string path, unsigned int8[] bytes, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllBytesAsync(System.String,System.Byte[],System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="bytes">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue Datei, schreibt mindestens eine Zeichenfolge in die Datei und schließt dann die Datei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllLines (path As String, contents As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, in die geschrieben werden soll.</param>
        <param name="contents">Die Zeilen, die in die Datei geschrieben werden sollen.</param>
        <summary>Erstellt eine neue Datei, schreibt eine Auflistung von Zeichenfolgen in die Datei und schließt dann die Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Standardverhalten der <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> Methode besteht darin, Daten mithilfe von UTF-8-Codierung ohne eine bytereihenfolgemarkierung (BOM) geschrieben. Verwenden Sie bei Bedarf einen UTF-8-Bezeichner, z. B. eine Byte Order Mark, am Anfang einer Datei enthalten die <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29> methodenüberladung mit <xref:System.Text.Encoding.UTF8%2A> Codierung.  
  
 Ist die Zieldatei bereits vorhanden, wird sie überschrieben.  
  
 Verwenden Sie diese Methode, die Inhalte für eine Auflistungsklasse erstellt wird, erfordert eine <xref:System.Collections.Generic.IEnumerable%601> in seinem Konstruktor wie z. B. eine <xref:System.Collections.Generic.List%601.%23ctor%2A>, <xref:System.Collections.Generic.HashSet%601.%23ctor%2A>, oder eine <xref:System.Collections.Generic.SortedSet%601.%23ctor%2A> Klasse.  
  
   
  
## Examples  
 Im folgende Beispiel werden ausgewählte Zeilen aus einer Beispiel-Datendatei in eine Datei geschrieben.  
  
 [!code-csharp[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.writeallappendall/cs/program.cs#1)]
 [!code-vb[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.writeallappendall/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), besteht nur aus Leerraum oder enthält mindestens eines der von der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode definierten ungültigen Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException">Entweder <paramref name="path" /> oder <paramref name="contents" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> überschreitet die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> gibt eine schreibgeschützte Datei an.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  <paramref name="path" /> ist ein Verzeichnis.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, string[] contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, string[] contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllLines (path As String, contents As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, cli::array &lt;System::String ^&gt; ^ contents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, in die geschrieben werden soll.</param>
        <param name="contents">Das Zeichenfolgenarray, das in die Datei geschrieben werden soll.</param>
        <summary>Erstellt eine neue Datei, schreibt das angegebene Zeichenfolgenarray in die Datei und schließt die Datei dann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ist die Zieldatei bereits vorhanden, wird sie überschrieben.  
  
 Das Standardverhalten der <xref:System.IO.File.WriteAllLines%2A> Methode besteht darin, Daten mithilfe von UTF-8-Codierung ohne eine bytereihenfolgemarkierung (BOM) zu schreiben. Verwenden Sie bei Bedarf einen UTF-8-Bezeichner, z. B. eine Byte Order Mark, am Anfang einer Datei enthalten die <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.String%5B%5D%2CSystem.Text.Encoding%29> methodenüberladung mit <xref:System.Text.Encoding.UTF8%2A> Codierung.  
  
 Wenn ein Array von Zeichenfolgen und einen Dateipfad an, diese Methode öffnet die angegebene Datei, schreibt das Zeichenfolgenarray in die Datei, und schließt dann die Datei.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.IO.File.WriteAllLines%2A> Methode, um Text in eine Datei schreiben. In diesem Beispiel wird eine Datei erstellt, wenn es nicht bereits vorhanden ist, und Text wird hinzugefügt.  
  
 [!code-csharp[System.IO.File.AllLines#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllLines#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Entweder <paramref name="path" /> oder <paramref name="contents" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder der Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> hat eine schreibgeschützte Datei angegeben.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  <paramref name="path" /> hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Zugriff zum Schreiben in eine Datei oder ein Verzeichnis oder zum Löschen einer Datei oder eines Verzeichnisses. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, in die geschrieben werden soll.</param>
        <param name="contents">Die Zeilen, die in die Datei geschrieben werden sollen.</param>
        <param name="encoding">Die zu verwendende Zeichencodierung.</param>
        <summary>Erstellt eine neue Datei unter Verwendung der angegebenen Codierung, schreibt eine Auflistung von Zeichenfolgen in die Datei und schließt dann die Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ist die Zieldatei bereits vorhanden, wird sie überschrieben.  
  
 Sie können diese Methode verwenden, eine Datei zu erstellen, die Folgendes enthält:  
  
-   Die Ergebnisse einer [LINQ to Objects](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) Abfragen in den Zeilen einer Datei mit abgerufenen die <xref:System.IO.File.ReadLines%2A> Methode.  
  
-   Der Inhalt einer Auflistung, die implementiert eine <xref:System.Collections.Generic.IEnumerable%601> von Zeichenfolgen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), besteht nur aus Leerraum oder enthält mindestens eines der von der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode definierten ungültigen Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException">Entweder <paramref name="path" />, <paramref name="contents" /> oder <paramref name="encoding" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> überschreitet die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> gibt eine schreibgeschützte Datei an.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  <paramref name="path" /> ist ein Verzeichnis.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, string[] contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, string[] contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.String[],System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, cli::array &lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String[]" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, in die geschrieben werden soll.</param>
        <param name="contents">Das Zeichenfolgenarray, das in die Datei geschrieben werden soll.</param>
        <param name="encoding">Ein <see cref="T:System.Text.Encoding" />-Objekt, das die Zeichencodierung darstellt, die auf das Zeichenfolgenarray angewendet wird.</param>
        <summary>Erstellt eine neue Datei, schreibt das angegebene Zeichenfolgenarray unter Verwendung der angegebenen Codierung in die Datei und schließt dann die Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ist die Zieldatei bereits vorhanden, wird sie überschrieben.  
  
 Wenn ein Array von Zeichenfolgen und einen Dateipfad, diese Methode öffnet die angegebene Datei schreibt das Zeichenfolgenarray in die Datei mit der angegebenen Codierung und schließt dann die Datei.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.IO.File.WriteAllLines%2A> Methode, um Text in eine Datei schreiben. In diesem Beispiel wird eine Datei erstellt, wenn es nicht bereits vorhanden ist, und Text wird hinzugefügt.  
  
 [!code-csharp[System.IO.File.AllLines_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/cs/AllText_Encoding.cs#00)]
 [!code-vb[System.IO.File.AllLines_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/vb/AllText_Encoding.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">Entweder <paramref name="path" /> oder <paramref name="contents" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder der Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> hat eine schreibgeschützte Datei angegeben.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  <paramref name="path" /> hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Zugriff zum Schreiben in eine Datei oder ein Verzeichnis oder zum Löschen einer Datei oder eines Verzeichnisses. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue Datei, schreibt den Inhalt in die Datei und schließt die Datei dann. Ist die Zieldatei bereits vorhanden, wird sie überschrieben.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string path, string contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string path, string contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllText(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllText (path As String, contents As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ path, System::String ^ contents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, in die geschrieben werden soll.</param>
        <param name="contents">Die Zeichenfolge, die in die Datei geschrieben werden soll.</param>
        <summary>Erstellt eine neue Datei, schreibt die angegebene Zeichenfolge in die Datei und schließt die Datei dann. Ist die Zieldatei bereits vorhanden, wird sie überschrieben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet UTF-8-Codierung ohne eine Bytereihenfolge-Marke (BOM), verwenden die <xref:System.Text.Encoding.GetPreamble%2A> Methode gibt ein leeres Bytearray zurück. Verwenden Sie bei Bedarf einen UTF-8-Bezeichner, z. B. eine Byte Order Mark, am Anfang einer Datei enthalten die <xref:System.IO.File.WriteAllText%28System.String%2CSystem.String%2CSystem.Text.Encoding%29> methodenüberladung mit <xref:System.Text.Encoding.UTF8%2A> Codierung.  
  
 Wenn eine Zeichenfolge und einen Dateipfad an, diese Methode öffnet die angegebene Datei schreibt die Zeichenfolge in die Datei und schließt dann die Datei.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.IO.File.WriteAllText%2A> Methode, um Text in eine Datei schreiben. In diesem Beispiel wird eine Datei erstellt, wenn es nicht bereits vorhanden ist, und Text wird hinzugefügt.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" /> oder <paramref name="contents" /> ist leer.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> hat eine schreibgeschützte Datei angegeben.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  <paramref name="path" /> hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Zugriff zum Schreiben in eine Datei oder ein Verzeichnis oder zum Löschen einer Datei oder eines Verzeichnisses. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string path, string contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string path, string contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllText(System.String,System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ path, System::String ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei, in die geschrieben werden soll.</param>
        <param name="contents">Die Zeichenfolge, die in die Datei geschrieben werden soll.</param>
        <param name="encoding">Die auf die Zeichenfolge anzuwendende Codierung.</param>
        <summary>Erstellt eine neue Datei, schreibt die angegebene Zeichenfolge mit der angegebenen Codierung in die Datei und schließt die Datei dann. Ist die Zieldatei bereits vorhanden, wird sie überschrieben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Zeichenfolge und einen Dateipfad an, diese Methode öffnet die angegebene Datei schreibt die Zeichenfolge in die Datei mit der angegebenen Codierung und schließt dann die Datei. Das Dateihandle ist, die von dieser Methode geschlossen werden garantiert, selbst wenn Ausnahmen ausgelöst werden.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.IO.File.WriteAllText%2A> Methode, um Text in eine Datei schreiben. In diesem Beispiel wird eine Datei erstellt, wenn es nicht bereits vorhanden ist, und Text wird hinzugefügt.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" /> oder <paramref name="contents" /> ist leer.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> hat eine schreibgeschützte Datei angegeben.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  <paramref name="path" /> hat ein Verzeichnis angegeben.  Oder:  Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Zugriff zum Schreiben in eine Datei oder ein Verzeichnis oder zum Löschen einer Datei oder eines Verzeichnisses. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllTextAsync (string path, string contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllTextAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllTextAsync (string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllTextAsync(System.String,System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>