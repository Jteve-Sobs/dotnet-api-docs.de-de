<Type Name="Stream" FullName="System.IO.Stream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="097d2ca3663946d99f5df2ac75cb347443cca016" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70343399" /></Metadata><TypeSignature Language="C#" Value="public abstract class Stream : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Stream extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Stream" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Stream&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Stream abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type Stream = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="79bf5-101">Stellt eine allgemeine Ansicht einer Folge von Bytes bereit.</span><span class="sxs-lookup"><span data-stu-id="79bf5-101">Provides a generic view of a sequence of bytes.</span></span> <span data-ttu-id="79bf5-102">Dies ist eine abstrakte Klasse.</span><span class="sxs-lookup"><span data-stu-id="79bf5-102">This is an abstract class.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-103"><xref:System.IO.Stream>ist die abstrakte Basisklasse aller Streams.</span><span class="sxs-lookup"><span data-stu-id="79bf5-103"><xref:System.IO.Stream> is the abstract base class of all streams.</span></span> <span data-ttu-id="79bf5-104">Ein Stream (Datenstream) ist eine Abstraktion einer Folge von Bytes, beispielsweise eine Datei, ein Eingabe-/Ausgabegerät, eine Pipe für die Kommunikation zwischen Prozessen oder ein TCP/IP-Socket.</span><span class="sxs-lookup"><span data-stu-id="79bf5-104">A stream is an abstraction of a sequence of bytes, such as a file, an input/output device, an inter-process communication pipe, or a TCP/IP socket.</span></span> <span data-ttu-id="79bf5-105">Die <xref:System.IO.Stream> -Klasse und die abgeleiteten Klassen stellen eine generische Ansicht dieser unterschiedlichen Eingabe-und Ausgabetypen bereit und isolieren den Programmierer von den spezifischen Details des Betriebssystems und der zugrunde liegenden Geräte.</span><span class="sxs-lookup"><span data-stu-id="79bf5-105">The <xref:System.IO.Stream> class and its derived classes provide a generic view of these different types of input and output, and isolate the programmer from the specific details of the operating system and the underlying devices.</span></span>  
  
 <span data-ttu-id="79bf5-106">Streams umfassen drei grundlegende Vorgänge:</span><span class="sxs-lookup"><span data-stu-id="79bf5-106">Streams involve three fundamental operations:</span></span>  
  
-   <span data-ttu-id="79bf5-107">Sie können Datenströme lesen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-107">You can read from streams.</span></span> <span data-ttu-id="79bf5-108">Beim Lesen handelt es sich um die Übertragung von Daten aus einem Stream in eine Datenstruktur, z. b. ein Bytearray.</span><span class="sxs-lookup"><span data-stu-id="79bf5-108">Reading is the transfer of data from a stream into a data structure, such as an array of bytes.</span></span>  
  
-   <span data-ttu-id="79bf5-109">Sie können in Streams schreiben.</span><span class="sxs-lookup"><span data-stu-id="79bf5-109">You can write to streams.</span></span> <span data-ttu-id="79bf5-110">Beim Schreiben handelt es sich um die Übertragung von Daten aus einer Datenstruktur in einen Stream.</span><span class="sxs-lookup"><span data-stu-id="79bf5-110">Writing is the transfer of data from a data structure into a stream.</span></span>  
  
-   <span data-ttu-id="79bf5-111">Streams können Suchvorgänge unterstützen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-111">Streams can support seeking.</span></span> <span data-ttu-id="79bf5-112">Suchen bezieht sich auf das Abfragen und Ändern der aktuellen Position innerhalb eines Streams.</span><span class="sxs-lookup"><span data-stu-id="79bf5-112">Seeking refers to querying and modifying the current position within a stream.</span></span> <span data-ttu-id="79bf5-113">Die Suchfunktion hängt von der Art des Sicherungs Speicher eines Streams ab.</span><span class="sxs-lookup"><span data-stu-id="79bf5-113">Seek capability depends on the kind of backing store a stream has.</span></span> <span data-ttu-id="79bf5-114">Netzwerkdaten Ströme haben beispielsweise kein einheitliches Konzept einer aktuellen Position und unterstützen daher in der Regel keine Suchvorgänge.</span><span class="sxs-lookup"><span data-stu-id="79bf5-114">For example, network streams have no unified concept of a current position, and therefore typically do not support seeking.</span></span>  
  
 <span data-ttu-id="79bf5-115">Einige der gängigsten Streams, die von <xref:System.IO.Stream> erben, sind <xref:System.IO.FileStream>, und. <xref:System.IO.MemoryStream></span><span class="sxs-lookup"><span data-stu-id="79bf5-115">Some of the more commonly used streams that inherit from <xref:System.IO.Stream> are <xref:System.IO.FileStream>, and <xref:System.IO.MemoryStream>.</span></span>  
  
 <span data-ttu-id="79bf5-116">Abhängig von der zugrunde liegenden Datenquelle oder dem Repository unterstützen Datenströme möglicherweise nur einige dieser Funktionen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-116">Depending on the underlying data source or repository, streams might support only some of these capabilities.</span></span> <span data-ttu-id="79bf5-117">Sie können einen Stream für seine Funktionen Abfragen, indem Sie <xref:System.IO.Stream.CanRead%2A>die <xref:System.IO.Stream.CanWrite%2A>Eigenschaften, <xref:System.IO.Stream.CanSeek%2A> und der <xref:System.IO.Stream> -Klasse verwenden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-117">You can query a stream for its capabilities by using the <xref:System.IO.Stream.CanRead%2A>, <xref:System.IO.Stream.CanWrite%2A>, and <xref:System.IO.Stream.CanSeek%2A> properties of the <xref:System.IO.Stream> class.</span></span>  
  
 <span data-ttu-id="79bf5-118">Die <xref:System.IO.Stream.Read%2A> - <xref:System.IO.Stream.Write%2A> Methode und die-Methode lesen und schreiben Daten in einer Vielzahl von Formaten.</span><span class="sxs-lookup"><span data-stu-id="79bf5-118">The <xref:System.IO.Stream.Read%2A> and <xref:System.IO.Stream.Write%2A> methods read and write data in a variety of formats.</span></span> <span data-ttu-id="79bf5-119">Verwenden Sie für Streams, die Suchvorgänge <xref:System.IO.Stream.Seek%2A> unter <xref:System.IO.Stream.SetLength%2A> stützen, die Methoden <xref:System.IO.Stream.Length%2A> und sowie die <xref:System.IO.Stream.Position%2A> Eigenschaften und, um die aktuelle Position und Länge eines Streams abzufragen und zu ändern.</span><span class="sxs-lookup"><span data-stu-id="79bf5-119">For streams that support seeking, use the <xref:System.IO.Stream.Seek%2A> and <xref:System.IO.Stream.SetLength%2A> methods and the <xref:System.IO.Stream.Position%2A> and <xref:System.IO.Stream.Length%2A> properties to query and modify the current position and length of a stream.</span></span>  
  
 <span data-ttu-id="79bf5-120">Dieser Typ implementiert die <xref:System.IDisposable>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="79bf5-120">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="79bf5-121">Nach Abschluss der Verwendung sollten Sie den Typ entweder direkt oder indirekt löschen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-121">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="79bf5-122">Zum direkten Löschen des Typs rufen Sie seine <xref:System.IDisposable.Dispose%2A>-Methode in einem `try`/`catch`-Block auf.</span><span class="sxs-lookup"><span data-stu-id="79bf5-122">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="79bf5-123">Zum indirekten Löschen verwenden Sie ein Sprachkonstrukt wie `using` (in C#) oder `Using` (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="79bf5-123">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="79bf5-124">Weitere Informationen finden Sie im Abschnitt „Verwenden eines Objekts, das IDisposable implementiert“ des Themas „Die <xref:System.IDisposable>-Schnittstelle“.</span><span class="sxs-lookup"><span data-stu-id="79bf5-124">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="79bf5-125">Wenn Sie ein <xref:System.IO.Stream> -Objekt verwerfen, werden alle gepufferten Daten geleert <xref:System.IO.Stream.Flush%2A> , und im Wesentlichen wird die-Methode für Sie aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-125">Disposing a <xref:System.IO.Stream> object flushes any buffered data, and essentially calls the <xref:System.IO.Stream.Flush%2A> method for you.</span></span> <span data-ttu-id="79bf5-126"><xref:System.IO.Stream.Dispose%2A>gibt auch Betriebssystemressourcen frei, z. b. Datei Handles, Netzwerkverbindungen oder Speicher, die für die interne Pufferung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-126"><xref:System.IO.Stream.Dispose%2A> also releases operating system resources such as file handles, network connections, or memory used for any internal buffering.</span></span> <span data-ttu-id="79bf5-127">Die <xref:System.IO.BufferedStream> -Klasse ermöglicht das Einschließen eines gepufferten Streams um einen anderen Stream, um die Lese-und Schreibleistung zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="79bf5-127">The <xref:System.IO.BufferedStream> class provides the capability of wrapping a buffered stream around another stream in order to improve read and write performance.</span></span>  
  
 <span data-ttu-id="79bf5-128">Ab enthält die <xref:System.IO.Stream> -Klasse Async-Methoden, um asynchrone Vorgänge zu vereinfachen. [!INCLUDE[net_v45](~/includes/net-v45-md.md)]</span><span class="sxs-lookup"><span data-stu-id="79bf5-128">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], the <xref:System.IO.Stream> class includes async methods to simplify asynchronous operations.</span></span> <span data-ttu-id="79bf5-129">Eine Async-Methode `Async` enthält in Ihrem Namen, <xref:System.IO.Stream.ReadAsync%2A>z. <xref:System.IO.Stream.WriteAsync%2A>b <xref:System.IO.Stream.CopyToAsync%2A>., <xref:System.IO.Stream.FlushAsync%2A>, und.</span><span class="sxs-lookup"><span data-stu-id="79bf5-129">An async method contains `Async` in its name, such as <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.Stream.FlushAsync%2A>.</span></span> <span data-ttu-id="79bf5-130">Mit diesen Methoden können Sie ressourcenintensive e/a-Vorgänge durchführen, ohne den Haupt Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-130">These methods enable you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="79bf5-131">Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-131">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="79bf5-132">Die Async-Methoden werden in Verbindung mit den `async` Schlüssel `await` Wörtern und in Visual Basic C#und verwendet.</span><span class="sxs-lookup"><span data-stu-id="79bf5-132">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="79bf5-133">Wenn Sie in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -APP <xref:System.IO.Stream> verwendet wird, umfasst zwei <xref:System.IO.WindowsRuntimeStreamExtensions.AsInputStream%2A> Erweiterungs <xref:System.IO.WindowsRuntimeStreamExtensions.AsOutputStream%2A>Methoden: und.</span><span class="sxs-lookup"><span data-stu-id="79bf5-133">When used in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app, <xref:System.IO.Stream> includes two extension methods: <xref:System.IO.WindowsRuntimeStreamExtensions.AsInputStream%2A> and <xref:System.IO.WindowsRuntimeStreamExtensions.AsOutputStream%2A>.</span></span> <span data-ttu-id="79bf5-134">Mit diesen Methoden wird <xref:System.IO.Stream> ein-Objekt [!INCLUDE[wrt](~/includes/wrt-md.md)]in einen Datenstrom in konvertiert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-134">These methods convert a <xref:System.IO.Stream> object to a stream in the [!INCLUDE[wrt](~/includes/wrt-md.md)].</span></span> <span data-ttu-id="79bf5-135">Mithilfe der-Methode [!INCLUDE[wrt](~/includes/wrt-md.md)] und der <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead%2A> -Methode können Sie <xref:System.IO.Stream> auch einen Stream in ein <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite%2A> -Objekt konvertieren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-135">You can also convert a stream in the [!INCLUDE[wrt](~/includes/wrt-md.md)] to a <xref:System.IO.Stream> object by using the <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead%2A> and <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite%2A> methods.</span></span> <span data-ttu-id="79bf5-136">Weitere Informationen finden Sie unter [Vorgehensweise: Konvertieren zwischen .NET Framework-Streams und Windows-Runtime-Streams](~/docs/standard/io/how-to-convert-between-dotnet-streams-and-winrt-streams.md)</span><span class="sxs-lookup"><span data-stu-id="79bf5-136">For more information, see [How to: Convert Between .NET Framework Streams and Windows Runtime Streams](~/docs/standard/io/how-to-convert-between-dotnet-streams-and-winrt-streams.md)</span></span>  
  
 <span data-ttu-id="79bf5-137">Einige Streamimplementierungen führen eine lokale Pufferung der zugrunde liegenden Daten durch, um die Leistung zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="79bf5-137">Some stream implementations perform local buffering of the underlying data to improve performance.</span></span> <span data-ttu-id="79bf5-138">Für solche Streams können Sie die-Methode <xref:System.IO.Stream.Flush%2A> oder <xref:System.IO.Stream.FlushAsync%2A> die-Methode verwenden, um alle internen Puffer zu löschen und sicherzustellen, dass alle Daten in die zugrunde liegende Datenquelle oder das Repository geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-138">For such streams, you can use the <xref:System.IO.Stream.Flush%2A> or <xref:System.IO.Stream.FlushAsync%2A> method to clear any internal buffers and ensure that all data has been written to the underlying data source or repository.</span></span>  
  
 <span data-ttu-id="79bf5-139">Wenn Sie einen Stream ohne Sicherungs Speicher (auch als Bitbucket bezeichnet) benötigen, verwenden Sie das <xref:System.IO.Stream.Null> -Feld, um eine Instanz eines Streams abzurufen, der für diesen Zweck entworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="79bf5-139">If you need a stream with no backing store (also known as a bit bucket), use the <xref:System.IO.Stream.Null> field to retrieve an instance of a stream that is designed for this purpose.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79bf5-140">Im folgenden Beispiel wird veranschaulicht, wie zwei <xref:System.IO.FileStream> -Objekte verwendet werden, um die Dateien asynchron aus einem Verzeichnis in ein anderes Verzeichnis zu kopieren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-140">The following example demonstrates how to use two <xref:System.IO.FileStream> objects to asynchronously copy the files from one directory to another directory.</span></span> <span data-ttu-id="79bf5-141">Die <xref:System.IO.FileStream> -Klasse wird aus der <xref:System.IO.Stream> -Klasse abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="79bf5-141">The <xref:System.IO.FileStream> class derives from the <xref:System.IO.Stream> class.</span></span> <span data-ttu-id="79bf5-142">Beachten Sie, dass der <xref:System.Web.UI.WebControls.Button.Click> -Ereignishandler für das <xref:System.Windows.Controls.Button> -Steuerelement mit dem `async` -Modifizierer markiert wird, da er eine asynchrone Methode aufruft.</span><span class="sxs-lookup"><span data-stu-id="79bf5-142">Notice that the <xref:System.Web.UI.WebControls.Button.Click> event handler for the <xref:System.Windows.Controls.Button> control is marked with the `async` modifier because it calls an asynchronous method.</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#1](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example.cs#1)]
 [!code-vb[Asynchronous_File_IO_async#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><span data-ttu-id="79bf5-143">Wenn Sie eine abgeleitete Klasse von <see cref="T:System.IO.Stream" />implementieren, müssen Sie-Implementierungen für <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> die <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> -Methode und die-Methode bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-143">When you implement a derived class of <see cref="T:System.IO.Stream" />, you must provide implementations for the <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> methods.</span></span> <span data-ttu-id="79bf5-144">Die asynchronen Methoden <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />, <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />und <see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" /> verwenden die synchronen Methoden <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> und <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> in ihren Implementierungen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-144">The asynchronous methods <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />, <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />, and <see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" /> use the synchronous methods <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> in their implementations.</span></span> <span data-ttu-id="79bf5-145">Daher funktionieren Ihre Implementierungen von <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> und <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> ordnungsgemäß mit den asynchronen Methoden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-145">Therefore, your implementations of <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> will work correctly with the asynchronous methods.</span></span> <span data-ttu-id="79bf5-146">Die Standard Implementierungen von <see cref="M:System.IO.Stream.ReadByte" /> und <see cref="M:System.IO.Stream.WriteByte(System.Byte)" /> erstellen ein neues Bytearray mit einem Element und rufen dann Ihre Implementierungen von <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> und <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />auf.</span><span class="sxs-lookup"><span data-stu-id="79bf5-146">The default implementations of <see cref="M:System.IO.Stream.ReadByte" /> and <see cref="M:System.IO.Stream.WriteByte(System.Byte)" /> create a new single-element byte array, and then call your implementations of <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> and <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />.</span></span> <span data-ttu-id="79bf5-147">Wenn Sie von <see cref="T:System.IO.Stream" />ableiten, empfiehlt es sich, diese Methoden zu überschreiben, um auf den internen Puffer zuzugreifen, falls vorhanden, um die Leistung zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="79bf5-147">When you derive from <see cref="T:System.IO.Stream" />, we recommend that you override these methods to access your internal buffer, if you have one, for substantially better performance.</span></span> <span data-ttu-id="79bf5-148">Sie müssen auch Implementierungen von <see cref="P:System.IO.Stream.CanRead" />, <see cref="P:System.IO.Stream.CanSeek" />, <see cref="P:System.IO.Stream.CanWrite" /> <see cref="M:System.IO.Stream.Flush" />,, <see cref="P:System.IO.Stream.Length" />, <see cref="P:System.IO.Stream.Position" />, <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />und bereitstellen.<see cref="M:System.IO.Stream.SetLength(System.Int64)" /></span><span class="sxs-lookup"><span data-stu-id="79bf5-148">You must also provide implementations of <see cref="P:System.IO.Stream.CanRead" />, <see cref="P:System.IO.Stream.CanSeek" />, <see cref="P:System.IO.Stream.CanWrite" />, <see cref="M:System.IO.Stream.Flush" />, <see cref="P:System.IO.Stream.Length" />, <see cref="P:System.IO.Stream.Position" />, <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />, and <see cref="M:System.IO.Stream.SetLength(System.Int64)" />.</span></span>  
  
<span data-ttu-id="79bf5-149">Überschreiben Sie die <see cref="M:System.IO.Stream.Close" /> -Methode nicht, sondern platzieren Sie <see cref="T:System.IO.Stream" /> die gesamte Bereinigungs <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> Logik in der-Methode.</span><span class="sxs-lookup"><span data-stu-id="79bf5-149">Do not override the <see cref="M:System.IO.Stream.Close" /> method, instead, put all the <see cref="T:System.IO.Stream" /> cleanup logic in the <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> method.</span></span> <span data-ttu-id="79bf5-150">Weitere Informationen finden Sie unter [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.</span><span class="sxs-lookup"><span data-stu-id="79bf5-150">For more information, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span></para></block>
    <altmember cref="T:System.IO.FileStream" />
    <altmember cref="T:System.IO.MemoryStream" />
    <altmember cref="T:System.IO.BufferedStream" />
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="79bf5-151">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-151">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-convert-between-dotnet-streams-and-winrt-streams.md"><span data-ttu-id="79bf5-152">Gewusst wie: Konvertieren zwischen .NET Framework-Streams und Windows-Runtime-Streams</span><span class="sxs-lookup"><span data-stu-id="79bf5-152">How to: Convert Between .NET Framework Streams and Windows Runtime Streams</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Stream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Stream();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79bf5-153">Initialisiert eine neue Instanz der <see cref="T:System.IO.Stream" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="79bf5-153">Initializes a new instance of the <see cref="T:System.IO.Stream" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-154"><xref:System.IO.Stream>ist die abstrakte Basisklasse aller Streams.</span><span class="sxs-lookup"><span data-stu-id="79bf5-154"><xref:System.IO.Stream> is the abstract base class of all streams.</span></span>  
  
 <span data-ttu-id="79bf5-155">Einige der gängigsten Streams, die von <xref:System.IO.Stream> erben, sind <xref:System.IO.FileStream>, und. <xref:System.IO.MemoryStream></span><span class="sxs-lookup"><span data-stu-id="79bf5-155">Some of the more commonly used streams that inherit from <xref:System.IO.Stream> are <xref:System.IO.FileStream>, and <xref:System.IO.MemoryStream>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="stream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="79bf5-156">Der Puffer, in den die Daten gelesen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-156">The buffer to read the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="79bf5-157">Der Byteoffset im <paramref name="buffer" />, ab dem aus dem Stream gelesene Daten geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-157">The byte offset in <paramref name="buffer" /> at which to begin writing data read from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="79bf5-158">Die maximale Anzahl der zu lesenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="79bf5-158">The maximum number of bytes to read.</span></span></param>
        <param name="callback"><span data-ttu-id="79bf5-159">Ein optionaler asynchroner Rückruf, der nach Abschluss des Lesevorgangs aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="79bf5-159">An optional asynchronous callback, to be called when the read is complete.</span></span></param>
        <param name="state"><span data-ttu-id="79bf5-160">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Leseanforderung von anderen Anforderungen unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="79bf5-160">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span></span></param>
        <summary><span data-ttu-id="79bf5-161">Beginnt einen asynchronen Lesevorgang.</span><span class="sxs-lookup"><span data-stu-id="79bf5-161">Begins an asynchronous read operation.</span></span> <span data-ttu-id="79bf5-162">(Verwenden Sie stattdessen <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />.)</span><span class="sxs-lookup"><span data-stu-id="79bf5-162">(Consider using <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="79bf5-163">Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Lesevorgang darstellt, der möglicherweise noch aussteht.</span><span class="sxs-lookup"><span data-stu-id="79bf5-163">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous read, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-164">In .NET Framework 4 und vorherigen Versionen müssen Sie Methoden wie <xref:System.IO.Stream.BeginRead%2A> und <xref:System.IO.Stream.EndRead%2A> verwenden, um asynchrone E/A-Vorgänge zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-164">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous I/O operations.</span></span> <span data-ttu-id="79bf5-165">Diese Methoden sind [!INCLUDE[net_v45](~/includes/net-v45-md.md)] weiterhin in verfügbar, um Legacy Code zu unterstützen. die neuen Async-Methoden, <xref:System.IO.Stream.ReadAsync%2A>wie z <xref:System.IO.Stream.WriteAsync%2A>. b. <xref:System.IO.Stream.FlushAsync%2A>,, <xref:System.IO.Stream.CopyToAsync%2A>und, unterstützen Sie jedoch bei der einfacheren Implementierung asynchroner e/a-Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="79bf5-165">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.Stream.FlushAsync%2A>, help you implement asynchronous I/O operations more easily.</span></span>  
  
 <span data-ttu-id="79bf5-166">Die Standard Implementierung von `BeginRead` in einem Stream ruft die <xref:System.IO.Stream.Read%2A> Methode synchron auf, was bedeutet, `Read` dass für einige Streams blockieren kann.</span><span class="sxs-lookup"><span data-stu-id="79bf5-166">The default implementation of `BeginRead` on a stream calls the <xref:System.IO.Stream.Read%2A> method synchronously, which means that `Read` might block on some streams.</span></span> <span data-ttu-id="79bf5-167">Instanzen von Klassen wie `FileStream` und `NetworkStream` unterstützen jedoch vollständig asynchrone Vorgänge, wenn die Instanzen asynchron geöffnet wurden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-167">However, instances of classes such as `FileStream` and `NetworkStream` fully support asynchronous operations if the instances have been opened asynchronously.</span></span> <span data-ttu-id="79bf5-168">Daher `BeginRead` werden Aufrufe von nicht in diesen Streams blockiert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-168">Therefore, calls to `BeginRead` will not block on those streams.</span></span> <span data-ttu-id="79bf5-169">Sie können ( `BeginRead` z. b. mithilfe von asynchronen Delegaten) überschreiben, um asynchrones Verhalten bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-169">You can override `BeginRead` (by using async delegates, for example) to provide asynchronous behavior.</span></span>  
  
 <span data-ttu-id="79bf5-170">Übergeben Sie `IAsyncResult` den Rückgabewert an <xref:System.IO.Stream.EndRead%2A> die-Methode des Streams, um zu bestimmen, wie viele Bytes gelesen wurden, und um die zum Lesen verwendeten Betriebssystemressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="79bf5-170">Pass the `IAsyncResult` return value to the <xref:System.IO.Stream.EndRead%2A> method of the stream to determine how many bytes were read and to release operating system resources used for reading.</span></span> <span data-ttu-id="79bf5-171"><xref:System.IO.Stream.EndRead%2A>muss für jeden Aufruf von <xref:System.IO.Stream.BeginRead%2A>einmal aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-171"><xref:System.IO.Stream.EndRead%2A> must be called once for every call to <xref:System.IO.Stream.BeginRead%2A>.</span></span> <span data-ttu-id="79bf5-172">Hierfür können Sie den gleichen Code verwenden, der oder in einem `BeginRead` Rückruf aufgerufen hat, der an `BeginRead`übermittelt wurde.</span><span class="sxs-lookup"><span data-stu-id="79bf5-172">You can do this either by using the same code that called `BeginRead` or in a callback passed to `BeginRead`.</span></span>  
  
 <span data-ttu-id="79bf5-173">Die aktuelle Position im Stream wird aktualisiert, wenn der asynchrone Lese-oder Schreibvorgang ausgegeben wird, und nicht, wenn der e/a-Vorgang abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-173">The current position in the stream is updated when the asynchronous read or write is issued, not when the I/O operation completes.</span></span>  
  
 <span data-ttu-id="79bf5-174">Durch mehrere gleichzeitige asynchrone Anforderungen wird die Reihenfolge der Anforderungs Vervollständigung unsicher.</span><span class="sxs-lookup"><span data-stu-id="79bf5-174">Multiple simultaneous asynchronous requests render the request completion order uncertain.</span></span>  
  
 <span data-ttu-id="79bf5-175">Verwenden Sie <xref:System.IO.Stream.CanRead%2A> die-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt</span><span class="sxs-lookup"><span data-stu-id="79bf5-175">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="79bf5-176">Wenn ein Stream geschlossen wird oder Sie ein ungültiges Argument übergeben, werden Ausnahmen sofort von `BeginRead`ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="79bf5-176">If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from `BeginRead`.</span></span> <span data-ttu-id="79bf5-177">Fehler, die während einer asynchronen Lese Anforderung auftreten, z. b. ein Datenträger Fehler während der e/a-Anforderung, treten im Thread Pool Thread auf `EndRead`und lösen Ausnahmen aus, wenn aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-177">Errors that occur during an asynchronous read request, such as a disk failure during the I/O request, occur on the thread pool thread and throw exceptions when calling `EndRead`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79bf5-178">Es wurde versucht, einen asynchronen Lesevorgang über das Ende des Streams hinaus durchzuführen, oder es ist ein Datenträgerfehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="79bf5-178">Attempted an asynchronous read past the end of the stream, or a disk error occurs.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79bf5-179">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="79bf5-179">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-180">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="79bf5-180">Methods were called after the stream was closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79bf5-181">Die aktuelle <see langword="Stream" />-Implementierung unterstützt den Lesevorgang nicht.</span><span class="sxs-lookup"><span data-stu-id="79bf5-181">The current <see langword="Stream" /> implementation does not support the read operation.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="79bf5-182">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-182">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="79bf5-183">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="79bf5-183">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="79bf5-184">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="79bf5-184">How to: Write Text to a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md"><span data-ttu-id="79bf5-185">Asynchrone Datei-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-185">Asynchronous File I/O</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="stream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="79bf5-186">Der Puffer, aus dem Daten geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-186">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="79bf5-187">Der Byteoffset im <paramref name="buffer" />, ab dem geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="79bf5-187">The byte offset in <paramref name="buffer" /> from which to begin writing.</span></span></param>
        <param name="count"><span data-ttu-id="79bf5-188">Die maximale Anzahl der zu schreibenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="79bf5-188">The maximum number of bytes to write.</span></span></param>
        <param name="callback"><span data-ttu-id="79bf5-189">Ein optionaler asynchroner Rückruf, der nach Abschluss des Schreibvorgangs aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-189">An optional asynchronous callback, to be called when the write is complete.</span></span></param>
        <param name="state"><span data-ttu-id="79bf5-190">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Schreibanforderung von anderen Anforderungen unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="79bf5-190">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span></span></param>
        <summary><span data-ttu-id="79bf5-191">Beginnt einen asynchronen Schreibvorgang.</span><span class="sxs-lookup"><span data-stu-id="79bf5-191">Begins an asynchronous write operation.</span></span> <span data-ttu-id="79bf5-192">(Verwenden Sie stattdessen <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />.)</span><span class="sxs-lookup"><span data-stu-id="79bf5-192">(Consider using <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="79bf5-193">Ein <see langword="IAsyncResult" />, das den asynchronen Schreibvorgang darstellt, der möglicherweise noch aussteht.</span><span class="sxs-lookup"><span data-stu-id="79bf5-193">An <see langword="IAsyncResult" /> that represents the asynchronous write, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-194">In .NET Framework 4 und vorherigen Versionen müssen Sie Methoden wie <xref:System.IO.Stream.BeginWrite%2A> und <xref:System.IO.Stream.EndWrite%2A> verwenden, um asynchrone E/A-Vorgänge zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-194">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous I/O operations.</span></span> <span data-ttu-id="79bf5-195">Diese Methoden sind [!INCLUDE[net_v45](~/includes/net-v45-md.md)] weiterhin in verfügbar, um Legacy Code zu unterstützen. die neuen Async-Methoden, <xref:System.IO.Stream.ReadAsync%2A>wie z <xref:System.IO.Stream.WriteAsync%2A>. b. <xref:System.IO.Stream.FlushAsync%2A>,, <xref:System.IO.Stream.CopyToAsync%2A>und, unterstützen Sie jedoch bei der einfacheren Implementierung asynchroner e/a-Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="79bf5-195">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.Stream.FlushAsync%2A>, help you implement asynchronous I/O operations more easily.</span></span>  
  
 <span data-ttu-id="79bf5-196">Die Standard Implementierung von `BeginWrite` in einem Stream ruft die <xref:System.IO.Stream.Write%2A> Methode synchron auf, was bedeutet, `Write` dass für einige Streams blockieren kann.</span><span class="sxs-lookup"><span data-stu-id="79bf5-196">The default implementation of `BeginWrite` on a stream calls the <xref:System.IO.Stream.Write%2A> method synchronously, which means that `Write` might block on some streams.</span></span> <span data-ttu-id="79bf5-197">Instanzen von Klassen wie `FileStream` und `NetworkStream` unterstützen jedoch vollständig asynchrone Vorgänge, wenn die Instanzen asynchron geöffnet wurden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-197">However, instances of classes such as `FileStream` and `NetworkStream` fully support asynchronous operations if the instances have been opened asynchronously.</span></span> <span data-ttu-id="79bf5-198">Daher `BeginWrite` werden Aufrufe von nicht in diesen Streams blockiert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-198">Therefore, calls to `BeginWrite` will not block on those streams.</span></span> <span data-ttu-id="79bf5-199">Sie können ( `BeginWrite` z. b. mithilfe von asynchronen Delegaten) überschreiben, um asynchrones Verhalten bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-199">You can override `BeginWrite` (by using async delegates, for example) to provide asynchronous behavior.</span></span>  
  
 <span data-ttu-id="79bf5-200">Übergeben Sie `IAsyncResult` den von der aktuellen Methode zurück <xref:System.IO.Stream.EndWrite%2A> gegebenen an, um sicherzustellen, dass der Schreibvorgang abgeschlossen ist und Ressourcen entsprechend freigibt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-200">Pass the `IAsyncResult` returned by the current method to <xref:System.IO.Stream.EndWrite%2A> to ensure that the write completes and frees resources appropriately.</span></span> <span data-ttu-id="79bf5-201"><xref:System.IO.Stream.EndWrite%2A>muss für jeden Aufruf von <xref:System.IO.Stream.BeginWrite%2A>einmal aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-201"><xref:System.IO.Stream.EndWrite%2A> must be called once for every call to <xref:System.IO.Stream.BeginWrite%2A>.</span></span> <span data-ttu-id="79bf5-202">Hierfür können Sie den gleichen Code verwenden, der oder in einem `BeginWrite` Rückruf aufgerufen hat, der an `BeginWrite`übermittelt wurde.</span><span class="sxs-lookup"><span data-stu-id="79bf5-202">You can do this either by using the same code that called `BeginWrite` or in a callback passed to `BeginWrite`.</span></span> <span data-ttu-id="79bf5-203">Wenn ein Fehler während eines asynchronen Schreibzugriffs auftritt, wird keine Ausnahme ausgelöst, solange `EndWrite` nicht mit der `IAsyncResult` von dieser Methode zurückgegebenen aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-203">If an error occurs during an asynchronous write, an exception will not be thrown until `EndWrite` is called with the `IAsyncResult` returned by this method.</span></span>  
  
 <span data-ttu-id="79bf5-204">Wenn ein Datenstrom beschreibbar ist, wird der Stream durch Schreiben am Ende des Streams erweitert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-204">If a stream is writable, writing at the end of the stream expands the stream.</span></span>  
  
 <span data-ttu-id="79bf5-205">Die aktuelle Position im Stream wird aktualisiert, wenn Sie den asynchronen Lese-oder Schreibvorgang ausgeben, nicht, wenn der e/a-Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="79bf5-205">The current position in the stream is updated when you issue the asynchronous read or write, not when the I/O operation completes.</span></span> <span data-ttu-id="79bf5-206">Durch mehrere gleichzeitige asynchrone Anforderungen wird die Reihenfolge der Anforderungs Vervollständigung unsicher.</span><span class="sxs-lookup"><span data-stu-id="79bf5-206">Multiple simultaneous asynchronous requests render the request completion order uncertain.</span></span>  
  
 <span data-ttu-id="79bf5-207">Verwenden Sie <xref:System.IO.Stream.CanWrite%2A> die-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt</span><span class="sxs-lookup"><span data-stu-id="79bf5-207">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
 <span data-ttu-id="79bf5-208">Wenn ein Stream geschlossen wird oder Sie ein ungültiges Argument übergeben, werden Ausnahmen sofort von `BeginWrite`ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="79bf5-208">If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from `BeginWrite`.</span></span> <span data-ttu-id="79bf5-209">Fehler, die während einer asynchronen Schreib Anforderung auftreten, z. b. ein Datenträger Fehler während der e/a-Anforderung, treten im Thread Pool Thread auf `EndWrite`und lösen Ausnahmen aus, wenn aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-209">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, occur on the thread pool thread and throw exceptions when calling `EndWrite`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79bf5-210">Es wurde versucht, einen asynchronen Schreibvorgang über das Ende des Streams hinaus durchzuführen, oder es ist ein Datenträgerfehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="79bf5-210">Attempted an asynchronous write past the end of the stream, or a disk error occurs.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79bf5-211">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="79bf5-211">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-212">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="79bf5-212">Methods were called after the stream was closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79bf5-213">Die aktuelle <see langword="Stream" />-Implementierung unterstützt den Schreibvorgang nicht.</span><span class="sxs-lookup"><span data-stu-id="79bf5-213">The current <see langword="Stream" /> implementation does not support the write operation.</span></span></exception>
        <altmember cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />
        <altmember cref="P:System.IO.Stream.CanWrite" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="79bf5-214">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-214">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="79bf5-215">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="79bf5-215">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="79bf5-216">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="79bf5-216">How to: Write Text to a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md"><span data-ttu-id="79bf5-217">Asynchrone Datei-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-217">Asynchronous File I/O</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public abstract bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.Stream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79bf5-218">Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob der aktuelle Stream Lesevorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-218">When overridden in a derived class, gets a value indicating whether the current stream supports reading.</span></span></summary>
        <value><span data-ttu-id="79bf5-219"><see langword="true" />, wenn der Stream Lesevorgänge unterstützt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="79bf5-219"><see langword="true" /> if the stream supports reading; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-220">Wenn eine von abgeleitete <xref:System.IO.Stream> Klasse Lesevorgänge nicht unterstützt, lösen <xref:System.IO.Stream.Read%2A>Aufrufe <xref:System.IO.Stream.ReadByte%2A>der Methoden <xref:System.IO.Stream.BeginRead%2A> , und eine <xref:System.NotSupportedException>aus.</span><span class="sxs-lookup"><span data-stu-id="79bf5-220">If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.Stream.Read%2A>, <xref:System.IO.Stream.ReadByte%2A>, and <xref:System.IO.Stream.BeginRead%2A> methods throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="79bf5-221">Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="79bf5-221">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79bf5-222">Im folgenden finden Sie ein Beispiel für die `CanRead` Verwendung der-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="79bf5-222">The following is an example of using the `CanRead` property.</span></span>  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="79bf5-223">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-223">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="79bf5-224">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="79bf5-224">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="79bf5-225">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="79bf5-225">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public abstract bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.Stream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79bf5-226">Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob der aktuelle Stream Suchvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-226">When overridden in a derived class, gets a value indicating whether the current stream supports seeking.</span></span></summary>
        <value><span data-ttu-id="79bf5-227"><see langword="true" />, wenn der Stream Suchvorgänge unterstützt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="79bf5-227"><see langword="true" /> if the stream supports seeking; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-228"><xref:System.IO.Stream> Wenn eine von abgeleitete Klasse keine Suchvorgänge unterstützt, werden <xref:System.IO.Stream.SetLength%2A>bei Aufrufen von <xref:System.IO.Stream.Seek%2A> <xref:System.IO.Stream.Length%2A>,, <xref:System.NotSupportedException> <xref:System.IO.Stream.Position%2A>und eine ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="79bf5-228">If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.Stream.Length%2A>, <xref:System.IO.Stream.SetLength%2A>, <xref:System.IO.Stream.Position%2A>, and <xref:System.IO.Stream.Seek%2A> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="79bf5-229">Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="79bf5-229">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="79bf5-230">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-230">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="79bf5-231">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="79bf5-231">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="79bf5-232">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="79bf5-232">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public virtual bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanTimeout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanTimeout : bool" Usage="System.IO.Stream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79bf5-233">Ruft einen Wert ab, der bestimmt, ob für den aktuellen Stream ein Timeout möglich ist.</span><span class="sxs-lookup"><span data-stu-id="79bf5-233">Gets a value that determines whether the current stream can time out.</span></span></summary>
        <value><span data-ttu-id="79bf5-234">Ein Wert, der bestimmt, ob für den aktuellen Stream ein Timeout möglich ist.</span><span class="sxs-lookup"><span data-stu-id="79bf5-234">A value that determines whether the current stream can time out.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-235">Die <xref:System.IO.Stream.CanTimeout%2A>-Eigenschaft gibt immer `false` zurück.</span><span class="sxs-lookup"><span data-stu-id="79bf5-235">The <xref:System.IO.Stream.CanTimeout%2A> property always returns `false`.</span></span> <span data-ttu-id="79bf5-236">Für <xref:System.Net.Sockets.NetworkStream>einige Streamimplementierungen ist ein anderes Verhalten erforderlich, z. b., bei dem die Netzwerk Konnektivität unterbrochen wird oder verloren geht.</span><span class="sxs-lookup"><span data-stu-id="79bf5-236">Some stream implementations require different behavior, such as <xref:System.Net.Sockets.NetworkStream>, which times out if network connectivity is interrupted or lost.</span></span> <span data-ttu-id="79bf5-237">Wenn Sie einen Stream implementieren, der in der Lage sein muss, ein Timeout zu haben, sollte diese Eigenschaft über `true`schrieben werden, um zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="79bf5-237">If you are implementing a stream that must be able to time out, this property should be overridden to return `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.Stream.ReadTimeout" />
        <altmember cref="P:System.IO.Stream.WriteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public abstract bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.Stream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79bf5-238">Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob der aktuelle Stream Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-238">When overridden in a derived class, gets a value indicating whether the current stream supports writing.</span></span></summary>
        <value><span data-ttu-id="79bf5-239"><see langword="true" />, wenn der Stream Schreibvorgänge unterstützt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="79bf5-239"><see langword="true" /> if the stream supports writing; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-240">Wenn <xref:System.IO.Stream> eine von abgeleitete Klasse Schreibvorgänge nicht unterstützt, wird ein <xref:System.IO.Stream.BeginWrite%2A>-oder <xref:System.IO.Stream.WriteByte%2A> <xref:System.NotSupportedException>- <xref:System.IO.Stream.Write%2A>Aufrufe ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="79bf5-240">If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.Stream.Write%2A>, <xref:System.IO.Stream.BeginWrite%2A>, or <xref:System.IO.Stream.WriteByte%2A> throws a <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="79bf5-241">In solchen Fällen <xref:System.IO.Stream.Flush%2A> wird in der Regel als leere Methode implementiert, um eine vollständige Kompatibilität <xref:System.IO.Stream> mit anderen Typen sicherzustellen, da ein Schreib geschützter Stream ungültig ist.</span><span class="sxs-lookup"><span data-stu-id="79bf5-241">In such cases, <xref:System.IO.Stream.Flush%2A> is typically implemented as an empty method to ensure full compatibility with other <xref:System.IO.Stream> types since it's valid to flush a read-only stream.</span></span>
  
 <span data-ttu-id="79bf5-242">Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="79bf5-242">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79bf5-243">Im folgenden finden Sie ein Beispiel für die `CanWrite` Verwendung der-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="79bf5-243">The following is an example of using the `CanWrite` property.</span></span>  
  
 [!code-cpp[Classic Stream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic Stream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="79bf5-244">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-244">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="79bf5-245">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="79bf5-245">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="79bf5-246">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="79bf5-246">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="stream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79bf5-247">Schließt den aktuellen Stream und gibt alle dem aktuellen Stream zugeordneten Ressourcen frei (z. B. Sockets und Dateihandles).</span><span class="sxs-lookup"><span data-stu-id="79bf5-247">Closes the current stream and releases any resources (such as sockets and file handles) associated with the current stream.</span></span> <span data-ttu-id="79bf5-248">Anstatt diese Methode aufzurufen, stellen Sie sicher, dass der Stream ordnungsgemäß freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-248">Instead of calling this method, ensure that the stream is properly disposed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-249">Diese Methode ruft <xref:System.IO.Stream.Dispose%2A>auf, `true` um anzugeben, dass alle Ressourcen freigegeben werden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-249">This method calls <xref:System.IO.Stream.Dispose%2A>, specifying `true` to release all resources.</span></span> <span data-ttu-id="79bf5-250">Sie müssen die <xref:System.IO.Stream.Close%2A> -Methode nicht speziell aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-250">You do not have to specifically call the <xref:System.IO.Stream.Close%2A> method.</span></span> <span data-ttu-id="79bf5-251">Stellen Sie stattdessen sicher, <xref:System.IO.Stream> dass jedes Objekt ordnungsgemäß freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-251">Instead, ensure that every <xref:System.IO.Stream> object is properly disposed.</span></span> <span data-ttu-id="79bf5-252">Sie können Objekte <xref:System.IO.Stream> in einem `using` Block (oder `Using` einem Block in Visual Basic) deklarieren, um sicherzustellen, dass der Stream und alle zugehörigen Ressourcen verworfen werden, oder Sie <xref:System.IO.Stream.Dispose%2A> können die Methode explizit aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-252">You can declare <xref:System.IO.Stream> objects within a `using` block (or `Using` block in Visual Basic) to ensure that the stream and all of its resources are disposed, or you can explicitly call the <xref:System.IO.Stream.Dispose%2A> method.</span></span>  
  
 <span data-ttu-id="79bf5-253">Das Leeren des Streams leert den zugrunde liegenden Encoder nicht, es sei denn, <xref:System.IO.Stream.Flush%2A> Sie `Close`haben explizit eine Implementierung von oder aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-253">Flushing the stream will not flush its underlying encoder unless you explicitly call an implementation of <xref:System.IO.Stream.Flush%2A> or `Close`.</span></span> <span data-ttu-id="79bf5-254">Wenn <xref:System.IO.StreamWriter.AutoFlush%2A> auf`true` festgelegt wird, werden Daten aus dem Puffer in den Stream geleert, aber der Codierungs Zustand wird nicht geleert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-254">Setting <xref:System.IO.StreamWriter.AutoFlush%2A> to `true` means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</span></span> <span data-ttu-id="79bf5-255">Dies ermöglicht es dem Encoder, seinen Zustand (partielle Zeichen) beizubehalten, damit der nächste Zeichenblock ordnungsgemäß codiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="79bf5-255">This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</span></span> <span data-ttu-id="79bf5-256">Dieses Szenario wirkt sich auf UTF8 und UTF7 aus, bei denen bestimmte Zeichen nur codiert werden können, nachdem der Encoder die angrenzenden Zeichen oder Zeichen empfangen hat.</span><span class="sxs-lookup"><span data-stu-id="79bf5-256">This scenario affects UTF8 and UTF7 where certain characters can be encoded only after the encoder receives the adjacent character or characters.</span></span>  
  
 <span data-ttu-id="79bf5-257">Wenn versucht wird, den Stream zu ändern, nachdem der Stream geschlossen wurde <xref:System.ObjectDisposedException>, wird möglicherweise eine ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="79bf5-257">Attempts to manipulate the stream after the stream has been closed might throw an <xref:System.ObjectDisposedException>.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="79bf5-258">Überschreiben Sie die <see cref="M:System.IO.Stream.Close" /> -Methode in abgeleiteten Klassen nicht, sondern platzieren Sie die gesamte <see langword="Stream" /> Bereinigungs Logik <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> in der-Methode.</span><span class="sxs-lookup"><span data-stu-id="79bf5-258">In derived classes, do not override the <see cref="M:System.IO.Stream.Close" /> method, instead, put all of the <see langword="Stream" /> cleanup logic in the <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> method.</span></span> <span data-ttu-id="79bf5-259">Weitere Informationen finden Sie unter [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.</span><span class="sxs-lookup"><span data-stu-id="79bf5-259">For more information, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span></para></block>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="79bf5-260">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-260">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="79bf5-261">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="79bf5-261">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="79bf5-262">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="79bf5-262">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="79bf5-263">Liest alle Bytes aus dem aktuellen Stream und schreibt sie in einen anderen Datenstrom.</span><span class="sxs-lookup"><span data-stu-id="79bf5-263">Reads the bytes from the current stream and writes them to another stream.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.IO.Stream destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.IO.Stream destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyTo(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(System::IO::Stream ^ destination);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.IO.Stream -&gt; unit" Usage="stream.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="79bf5-264">Der Stream, in den der Inhalt des aktuellen Stream kopiert wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-264">The stream to which the contents of the current stream will be copied.</span></span></param>
        <summary><span data-ttu-id="79bf5-265">Liest alle Bytes aus dem aktuellen Stream und schreibt sie in einen anderen Datenstrom.</span><span class="sxs-lookup"><span data-stu-id="79bf5-265">Reads the bytes from the current stream and writes them to another stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-266">Der Kopiervorgang beginnt an der aktuellen Position im aktuellen Stream und setzt die Position des zielstreams nicht zurück, nachdem der Kopiervorgang beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="79bf5-266">Copying begins at the current position in the current stream, and does not reset the position of the destination stream after the copy operation is complete.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79bf5-267">Im folgenden Beispiel wird der Inhalt eines <xref:System.IO.FileStream> in einen <xref:System.IO.MemoryStream>kopiert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-267">The following example copies the contents of a <xref:System.IO.FileStream> to a <xref:System.IO.MemoryStream>.</span></span>  
  
 [!code-csharp[System.IO.Stream.CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.stream.copyto/cs/program.cs#1)]
 [!code-vb[System.IO.Stream.CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.stream.copyto/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79bf5-268"><paramref name="destination" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79bf5-268"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79bf5-269">Lesevorgänge werden vom aktuellen Stream nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-269">The current stream does not support reading.</span></span>  
  
<span data-ttu-id="79bf5-270">- oder -</span><span class="sxs-lookup"><span data-stu-id="79bf5-270">-or-</span></span> 
 <span data-ttu-id="79bf5-271"><paramref name="destination" /> unterstützt das Schreiben nicht.</span><span class="sxs-lookup"><span data-stu-id="79bf5-271"><paramref name="destination" /> does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-272">Entweder der aktuelle Stream oder <paramref name="destination" /> wurde geschlossen, bevor die <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" />-Methode aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="79bf5-272">Either the current stream or <paramref name="destination" /> were closed before the <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> method was called.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79bf5-273">E/A-Fehler</span><span class="sxs-lookup"><span data-stu-id="79bf5-273">An I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.IO.Stream destination, int bufferSize);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Stream, bufferSize As Integer)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(System::IO::Stream ^ destination, int bufferSize);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.IO.Stream * int -&gt; unit" Usage="stream.CopyTo (destination, bufferSize)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public virtual void CopyTo (System.IO.Stream destination, int bufferSize);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CopyTo (destination As Stream, bufferSize As Integer)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(System::IO::Stream ^ destination, int bufferSize);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : System.IO.Stream * int -&gt; unit&#xA;override this.CopyTo : System.IO.Stream * int -&gt; unit" Usage="stream.CopyTo (destination, bufferSize)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="79bf5-274">Der Stream, in den der Inhalt des aktuellen Stream kopiert wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-274">The stream to which the contents of the current stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="79bf5-275">Die Größe des Puffers.</span><span class="sxs-lookup"><span data-stu-id="79bf5-275">The size of the buffer.</span></span> <span data-ttu-id="79bf5-276">Dieser Wert muss größer als 0 sein.</span><span class="sxs-lookup"><span data-stu-id="79bf5-276">This value must be greater than zero.</span></span> <span data-ttu-id="79bf5-277">Die Standardgröße ist 81920.</span><span class="sxs-lookup"><span data-stu-id="79bf5-277">The default size is 81920.</span></span></param>
        <summary><span data-ttu-id="79bf5-278">Liest alles Bytes aus dem aktuellen Datenstrom und schreibt sie unter Verwendung einer angegebenen Puffergröße in einen anderen Datenstrom.</span><span class="sxs-lookup"><span data-stu-id="79bf5-278">Reads the bytes from the current stream and writes them to another stream, using a specified buffer size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-279">Der Kopiervorgang beginnt an der aktuellen Position im aktuellen Stream und setzt die Position des zielstreams nicht zurück, nachdem der Kopiervorgang beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="79bf5-279">Copying begins at the current position in the current stream, and does not reset the position of the destination stream after the copy operation is complete.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79bf5-280"><paramref name="destination" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79bf5-280"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="79bf5-281"><paramref name="bufferSize" /> ist negativ oder 0 (null).</span><span class="sxs-lookup"><span data-stu-id="79bf5-281"><paramref name="bufferSize" /> is negative or zero.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79bf5-282">Lesevorgänge werden vom aktuellen Stream nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-282">The current stream does not support reading.</span></span>  
  
<span data-ttu-id="79bf5-283">- oder -</span><span class="sxs-lookup"><span data-stu-id="79bf5-283">-or-</span></span> 
 <span data-ttu-id="79bf5-284"><paramref name="destination" /> unterstützt das Schreiben nicht.</span><span class="sxs-lookup"><span data-stu-id="79bf5-284"><paramref name="destination" /> does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-285">Entweder der aktuelle Stream oder <paramref name="destination" /> wurde geschlossen, bevor die <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" />-Methode aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="79bf5-285">Either the current stream or <paramref name="destination" /> were closed before the <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> method was called.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79bf5-286">E/A-Fehler</span><span class="sxs-lookup"><span data-stu-id="79bf5-286">An I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyToAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="79bf5-287">Liest die Bytes asynchron aus dem aktuellen Stream und schreibt sie in einen anderen Stream.</span><span class="sxs-lookup"><span data-stu-id="79bf5-287">Asynchronously reads the bytes from the current stream and writes them to another stream.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyToAsync (destination As Stream) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="79bf5-288">Der Stream, in den der Inhalt des aktuellen Stream kopiert wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-288">The stream to which the contents of the current stream will be copied.</span></span></param>
        <summary><span data-ttu-id="79bf5-289">Liest die Bytes asynchron aus dem aktuellen Stream und schreibt sie in einen anderen Stream.</span><span class="sxs-lookup"><span data-stu-id="79bf5-289">Asynchronously reads the bytes from the current stream and writes them to another stream.</span></span></summary>
        <returns><span data-ttu-id="79bf5-290">Eine Aufgabe, die den asynchronen Kopiervorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-290">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-291">Mit <xref:System.IO.Stream.CopyToAsync%2A> der-Methode können Sie ressourcenintensive e/a-Vorgänge durchführen, ohne den Haupt Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-291">The <xref:System.IO.Stream.CopyToAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="79bf5-292">Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-292">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="79bf5-293">Die Async-Methoden werden in Verbindung mit den `async` Schlüssel `await` Wörtern und in Visual Basic C#und verwendet.</span><span class="sxs-lookup"><span data-stu-id="79bf5-293">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="79bf5-294">Der Kopiervorgang beginnt an der aktuellen Position im aktuellen Stream.</span><span class="sxs-lookup"><span data-stu-id="79bf5-294">Copying begins at the current position in the current stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79bf5-295">Im folgenden Beispiel wird veranschaulicht, wie zwei <xref:System.IO.FileStream> -Objekte verwendet werden, um die Dateien asynchron aus einem Verzeichnis in ein anderes zu kopieren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-295">The following example demonstrates how to use two <xref:System.IO.FileStream> objects to asynchronously copy the files from one directory to another.</span></span> <span data-ttu-id="79bf5-296">Die <xref:System.IO.FileStream> -Klasse wird aus der <xref:System.IO.Stream> -Klasse abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="79bf5-296">The <xref:System.IO.FileStream> class derives from the <xref:System.IO.Stream> class.</span></span>  <span data-ttu-id="79bf5-297">Beachten Sie, <xref:System.Web.UI.WebControls.Button.Click> dass der Ereignishandler <xref:System.Windows.Controls.Button> für das-Steuerelement `async` mit dem-Modifizierer markiert ist, da er eine asynchrone Methode aufruft.</span><span class="sxs-lookup"><span data-stu-id="79bf5-297">Notice that the <xref:System.Web.UI.WebControls.Button.Click> event handler for the <xref:System.Windows.Controls.Button> control is marked with the `async` modifier because it calls an asynchronous method</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#1](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example.cs#1)]
 [!code-vb[Asynchronous_File_IO_async#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79bf5-298"><paramref name="destination" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79bf5-298"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-299">Entweder der aktuelle Stream oder der Zielstream wird freigegeben.</span><span class="sxs-lookup"><span data-stu-id="79bf5-299">Either the current stream or the destination stream is disposed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79bf5-300">Der aktuelle Stream unterstützt kein Lesen oder Zielstream unterstützt keine Schreibvorgänge.</span><span class="sxs-lookup"><span data-stu-id="79bf5-300">The current stream does not support reading, or the destination stream does not support writing.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyToAsync (destination As Stream, bufferSize As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream * int -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="79bf5-301">Der Stream, in den der Inhalt des aktuellen Stream kopiert wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-301">The stream to which the contents of the current stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="79bf5-302">Die Größe des Cookies in Bytes.</span><span class="sxs-lookup"><span data-stu-id="79bf5-302">The size, in bytes, of the buffer.</span></span> <span data-ttu-id="79bf5-303">Dieser Wert muss größer als 0 sein.</span><span class="sxs-lookup"><span data-stu-id="79bf5-303">This value must be greater than zero.</span></span> <span data-ttu-id="79bf5-304">Die Standardgröße ist 81920.</span><span class="sxs-lookup"><span data-stu-id="79bf5-304">The default size is 81920.</span></span></param>
        <summary><span data-ttu-id="79bf5-305">Liest die Bytes asynchron aus dem aktuellen Stream und schreibt sie unter Verwendung einer angegebenen Puffergröße in einen anderen Stream.</span><span class="sxs-lookup"><span data-stu-id="79bf5-305">Asynchronously reads the bytes from the current stream and writes them to another stream, using a specified buffer size.</span></span></summary>
        <returns><span data-ttu-id="79bf5-306">Eine Aufgabe, die den asynchronen Kopiervorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-306">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-307">Mit <xref:System.IO.Stream.CopyToAsync%2A> der-Methode können Sie ressourcenintensive e/a-Vorgänge durchführen, ohne den Haupt Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-307">The <xref:System.IO.Stream.CopyToAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="79bf5-308">Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-308">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="79bf5-309">Die Async-Methoden werden in Verbindung mit den `async` Schlüssel `await` Wörtern und in Visual Basic C#und verwendet.</span><span class="sxs-lookup"><span data-stu-id="79bf5-309">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="79bf5-310">Der Kopiervorgang beginnt an der aktuellen Position im aktuellen Stream.</span><span class="sxs-lookup"><span data-stu-id="79bf5-310">Copying begins at the current position in the current stream.</span></span>  
  
 <span data-ttu-id="79bf5-311">Ein Beispiel für das Kopieren zwischen zwei Streams finden Sie unter <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> Überladung.</span><span class="sxs-lookup"><span data-stu-id="79bf5-311">For an example of copying between two streams, see the <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79bf5-312"><paramref name="destination" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79bf5-312"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="79bf5-313"><paramref name="buffersize" /> ist negativ oder 0 (null).</span><span class="sxs-lookup"><span data-stu-id="79bf5-313"><paramref name="buffersize" /> is negative or zero.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-314">Entweder der aktuelle Stream oder der Zielstream wird freigegeben.</span><span class="sxs-lookup"><span data-stu-id="79bf5-314">Either the current stream or the destination stream is disposed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79bf5-315">Der aktuelle Stream unterstützt kein Lesen oder Zielstream unterstützt keine Schreibvorgänge.</span><span class="sxs-lookup"><span data-stu-id="79bf5-315">The current stream does not support reading, or the destination stream does not support writing.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.CopyToAsync : System.IO.Stream * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="79bf5-316">Der Stream, in den der Inhalt des aktuellen Stream kopiert wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-316">The stream to which the contents of the current stream will be copied.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="79bf5-317">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-317">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="79bf5-318">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />sein.</span><span class="sxs-lookup"><span data-stu-id="79bf5-318">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="79bf5-319">Liest die Bytes asynchron aus dem aktuellen Stream und schreibt sie unter Verwendung eines angegebenen Abbruchtokens in einen anderen Stream.</span><span class="sxs-lookup"><span data-stu-id="79bf5-319">Asynchronously reads the bytes from the current stream and writes them to another stream, using a specified cancellation token.</span></span></summary>
        <returns><span data-ttu-id="79bf5-320">Eine Aufgabe, die den asynchronen Kopiervorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-320">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-321">Mit <xref:System.IO.Stream.CopyToAsync%2A> der-Methode können Sie ressourcenintensive e/a-Vorgänge durchführen, ohne den Haupt Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-321">The <xref:System.IO.Stream.CopyToAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="79bf5-322">Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-322">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="79bf5-323">Die Async-Methoden werden in Verbindung mit den `async` Schlüssel `await` Wörtern und in Visual Basic C#und verwendet.</span><span class="sxs-lookup"><span data-stu-id="79bf5-323">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="79bf5-324">Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die <xref:System.Threading.Tasks.TaskStatus.Canceled> zurückgegebene Aufgabe <xref:System.Threading.Tasks.Task.Status%2A> den Wert für die-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="79bf5-324">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="79bf5-325">Der Kopiervorgang beginnt an der aktuellen Position im aktuellen Stream.</span><span class="sxs-lookup"><span data-stu-id="79bf5-325">Copying begins at the current position in the current stream.</span></span>  
  
 <span data-ttu-id="79bf5-326">Ein Beispiel für das Kopieren zwischen zwei Streams finden Sie unter <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> Überladung.</span><span class="sxs-lookup"><span data-stu-id="79bf5-326">For an example of copying between two streams, see the <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.CopyToAsync (destination, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="79bf5-327">Der Stream, in den der Inhalt des aktuellen Stream kopiert wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-327">The stream to which the contents of the current stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="79bf5-328">Die Größe des Cookies in Bytes.</span><span class="sxs-lookup"><span data-stu-id="79bf5-328">The size, in bytes, of the buffer.</span></span> <span data-ttu-id="79bf5-329">Dieser Wert muss größer als 0 sein.</span><span class="sxs-lookup"><span data-stu-id="79bf5-329">This value must be greater than zero.</span></span> <span data-ttu-id="79bf5-330">Die Standardgröße ist 81920.</span><span class="sxs-lookup"><span data-stu-id="79bf5-330">The default size is 81920.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="79bf5-331">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-331">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="79bf5-332">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />sein.</span><span class="sxs-lookup"><span data-stu-id="79bf5-332">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="79bf5-333">Liest die Bytes asynchron aus dem aktuellen Stream und schreibt sie unter Verwendung einer angegebenen Puffergröße und eines Abbruchtokens in einen anderen Stream.</span><span class="sxs-lookup"><span data-stu-id="79bf5-333">Asynchronously reads the bytes from the current stream and writes them to another stream, using a specified buffer size and cancellation token.</span></span></summary>
        <returns><span data-ttu-id="79bf5-334">Eine Aufgabe, die den asynchronen Kopiervorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-334">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-335">Mit <xref:System.IO.Stream.CopyToAsync%2A> der-Methode können Sie ressourcenintensive e/a-Vorgänge durchführen, ohne den Haupt Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-335">The <xref:System.IO.Stream.CopyToAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="79bf5-336">Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-336">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="79bf5-337">Die Async-Methoden werden in Verbindung mit den `async` Schlüssel `await` Wörtern und in Visual Basic C#und verwendet.</span><span class="sxs-lookup"><span data-stu-id="79bf5-337">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="79bf5-338">Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die <xref:System.Threading.Tasks.TaskStatus.Canceled> zurückgegebene Aufgabe <xref:System.Threading.Tasks.Task.Status%2A> den Wert für die-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="79bf5-338">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="79bf5-339">Der Kopiervorgang beginnt an der aktuellen Position im aktuellen Stream.</span><span class="sxs-lookup"><span data-stu-id="79bf5-339">Copying begins at the current position in the current stream.</span></span>  
  
 <span data-ttu-id="79bf5-340">Ein Beispiel für das Kopieren zwischen zwei Streams finden Sie unter <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> Überladung.</span><span class="sxs-lookup"><span data-stu-id="79bf5-340">For an example of copying between two streams, see the <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79bf5-341"><paramref name="destination" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79bf5-341"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="79bf5-342"><paramref name="buffersize" /> ist negativ oder 0 (null).</span><span class="sxs-lookup"><span data-stu-id="79bf5-342"><paramref name="buffersize" /> is negative or zero.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-343">Entweder der aktuelle Stream oder der Zielstream wird freigegeben.</span><span class="sxs-lookup"><span data-stu-id="79bf5-343">Either the current stream or the destination stream is disposed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79bf5-344">Der aktuelle Stream unterstützt kein Lesen oder Zielstream unterstützt keine Schreibvorgänge.</span><span class="sxs-lookup"><span data-stu-id="79bf5-344">The current stream does not support reading, or the destination stream does not support writing.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWaitHandle">
      <MemberSignature Language="C#" Value="protected virtual System.Threading.WaitHandle CreateWaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Threading.WaitHandle CreateWaitHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CreateWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateWaitHandle () As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Threading::WaitHandle ^ CreateWaitHandle();" />
      <MemberSignature Language="F#" Value="abstract member CreateWaitHandle : unit -&gt; System.Threading.WaitHandle&#xA;override this.CreateWaitHandle : unit -&gt; System.Threading.WaitHandle" Usage="stream.CreateWaitHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("CreateWaitHandle will be removed eventually.  Please use "new ManualResetEvent(false)" instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79bf5-345">Reserviert ein <see cref="T:System.Threading.WaitHandle" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-345">Allocates a <see cref="T:System.Threading.WaitHandle" /> object.</span></span></summary>
        <returns><span data-ttu-id="79bf5-346">Ein Verweis auf das reservierte <see langword="WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="79bf5-346">A reference to the allocated <see langword="WaitHandle" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-347">Wenn die aktuelle Methode zum ersten Mal aufgerufen wird, erstellt Sie `WaitHandle` ein-Objekt und gibt es zurück.</span><span class="sxs-lookup"><span data-stu-id="79bf5-347">When called for the first time, the current method creates a `WaitHandle` object and returns it.</span></span> <span data-ttu-id="79bf5-348">Bei nachfolgenden Aufrufen `CreateWaitHandle` wird ein Verweis auf ein neues Wait-Handle zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="79bf5-348">On subsequent calls, `CreateWaitHandle` returns a reference to a new wait handle.</span></span>  
  
 <span data-ttu-id="79bf5-349">Verwenden Sie diese Methode, wenn Sie die asynchronen Methoden implementieren und eine Möglichkeit benötigen, <xref:System.IO.Stream.EndRead%2A> in <xref:System.IO.Stream.EndWrite%2A> oder zu blockieren, bis der asynchrone Vorgang beendet ist.</span><span class="sxs-lookup"><span data-stu-id="79bf5-349">Use this method if you implement the asynchronous methods and require a way of blocking in <xref:System.IO.Stream.EndRead%2A> or <xref:System.IO.Stream.EndWrite%2A> until the asynchronous operation is complete.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="79bf5-350">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-350">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="79bf5-351">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="79bf5-351">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="79bf5-352">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="79bf5-352">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="79bf5-353">Gibt alle vom <see cref="T:System.IO.Stream" />-Objekt verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="79bf5-353">Releases all resources used by the <see cref="T:System.IO.Stream" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="stream.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79bf5-354">Gibt alle vom <see cref="T:System.IO.Stream" /> verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="79bf5-354">Releases all resources used by the <see cref="T:System.IO.Stream" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-355">Diese Methode löscht den Stream, indem alle Änderungen in den Sicherungs Speicher geschrieben und der Stream zum Freigeben von Ressourcen geschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-355">This method disposes the stream, by writing any changes to the backing store and closing the stream to release resources.</span></span>  
  
 <span data-ttu-id="79bf5-356">Durch Aufrufen `Dispose` von können die Ressourcen ,dievonverwendetwerden,fürandereZweckeneuzugeordnetwerden.<xref:System.IO.Stream></span><span class="sxs-lookup"><span data-stu-id="79bf5-356">Calling `Dispose` allows the resources used by the <xref:System.IO.Stream> to be reallocated for other purposes.</span></span> <span data-ttu-id="79bf5-357">Weitere Informationen zu finden `Dispose`Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="79bf5-357">For more information about `Dispose`, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="79bf5-358">Platzieren Sie alle Bereinigungs Logik für das Daten <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />Strom Objekt in.</span><span class="sxs-lookup"><span data-stu-id="79bf5-358">Place all cleanup logic for your stream object in <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />.</span></span> <span data-ttu-id="79bf5-359">Nicht außer Kraft <see cref="M:System.IO.Stream.Close" />setzen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-359">Do not override <see cref="M:System.IO.Stream.Close" />.</span></span>  
  
<span data-ttu-id="79bf5-360">Beachten Sie, dass die Implementierung dieser Methode aufgrund von abwärts Kompatibilitätsanforderungen von der empfohlenen Anleitung für das Lösch Muster abweicht.</span><span class="sxs-lookup"><span data-stu-id="79bf5-360">Note that because of backward compatibility requirements, this method's implementation differs from the recommended guidance for the Dispose pattern.</span></span>  <span data-ttu-id="79bf5-361">Diese Methode ruft <see cref="M:System.IO.Stream.Close" />auf, wodurch aufgerufen <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-361">This method calls <see cref="M:System.IO.Stream.Close" />, which then calls <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="stream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="79bf5-362"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="79bf5-362"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="79bf5-363">Gibt die von <see cref="T:System.IO.Stream" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="79bf5-363">Releases the unmanaged resources used by the <see cref="T:System.IO.Stream" /> and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-364">Sie sollten alle Ressourcen freigeben, indem `true` Sie `disposing`für angeben.</span><span class="sxs-lookup"><span data-stu-id="79bf5-364">You should release all resources by specifying `true` for `disposing`.</span></span> <span data-ttu-id="79bf5-365">Wenn `disposing`den Wert hat,kannderStreamauchsicherstellen,dassDatenindenzugrundeliegendenPuffergeleertwerden,undaufanderefinalisierbareObjektezugreifen.`true`</span><span class="sxs-lookup"><span data-stu-id="79bf5-365">When `disposing` is `true`, the stream can also ensure data is flushed to the underlying buffer, and access other finalizable objects.</span></span>  <span data-ttu-id="79bf5-366">Dies ist möglicherweise nicht möglich, wenn der Aufruf von einem Finalizer aufgrund fehlender Reihenfolge zwischen Finalizern erfolgt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-366">This may not be possible when called from a finalizer due a lack of ordering among finalizers.</span></span>  
  
 <span data-ttu-id="79bf5-367">Wenn Ihr Stream ein Betriebssystem Handle für die Kommunikation mit seiner Quelle verwendet, sollten Sie zu diesem Zweck eine <xref:System.Runtime.InteropServices.SafeHandle> Unterklasse von verwenden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-367">If your stream is using an operating system handle to communicate with its source, consider using a subclass of <xref:System.Runtime.InteropServices.SafeHandle> for this purpose.</span></span>  
  
 <span data-ttu-id="79bf5-368">Diese Methode wird von der öffentlichen <xref:System.ComponentModel.Component.Dispose%2A> -Methode und der <xref:System.Object.Finalize%2A> -Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-368">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="79bf5-369"><xref:System.ComponentModel.Component.Dispose%2A>Ruft die geschützte <xref:System.IO.Stream.Dispose%2A> Methode auf, `disposing` wobei der- `true`Parameter auf festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="79bf5-369"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.Stream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="79bf5-370"><xref:System.Object.Finalize%2A>Ruft <xref:System.IO.Stream.Dispose%2A> auf `disposing` , wobei `false`auf gesetzt ist.</span><span class="sxs-lookup"><span data-stu-id="79bf5-370"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.Stream.Dispose%2A> with `disposing` set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="79bf5-371">Überschreiben Sie die <see cref="M:System.IO.Stream.Close" /> -Methode in abgeleiteten Klassen nicht, sondern fügen Sie stattdessen die gesamte streambereinigungs Logik in die <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> -Methode ein.</span><span class="sxs-lookup"><span data-stu-id="79bf5-371">In derived classes, do not override the <see cref="M:System.IO.Stream.Close" /> method, instead, put all of the Stream cleanup logic in the <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> method.</span></span>  
  
 <span data-ttu-id="79bf5-372"><see cref="M:System.ComponentModel.Component.Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-372"><see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="79bf5-373">Beim Überschreiben von <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> müssen Sie darauf achten, nicht auf Objekte zu verweisen, die durch einen früheren Aufruf von <see cref="M:System.ComponentModel.Component.Dispose" /> freigegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-373">When overriding <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />.</span></span> <span data-ttu-id="79bf5-374">Weitere Informationen zum Implementieren <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />von finden Sie unter [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.</span><span class="sxs-lookup"><span data-stu-id="79bf5-374">For more information about how to implement <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="79bf5-375">Weitere Informationen zu und <see cref="M:System.ComponentModel.Component.Dispose" /> <see cref="M:System.Object.Finalize" />finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="79bf5-375">For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="abstract member DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask&#xA;override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="stream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IAsyncDisposable.DisposeAsync</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79bf5-376">Gibt die nicht verwalteten Ressourcen, die von der <see cref="T:System.IO.Stream" /> verwendet werden, asynchron frei.</span><span class="sxs-lookup"><span data-stu-id="79bf5-376">Asynchronously releases the unmanaged resources used by the <see cref="T:System.IO.Stream" />.</span></span></summary>
        <returns><span data-ttu-id="79bf5-377">Eine Aufgabe, die den asynchronen Löschvorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-377">A task that represents the asynchronous dispose operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-378">Die <xref:System.IO.Stream.DisposeAsync%2A> -Methode ermöglicht es Ihnen, einen ressourcenintensiven Löschvorgang auszuführen, ohne den Haupt Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-378">The <xref:System.IO.Stream.DisposeAsync%2A> method enables you to perform a resource-intensive dispose operation without blocking the main thread.</span></span> <span data-ttu-id="79bf5-379">Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-379">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="79bf5-380">Die Async-Methoden werden in Verbindung mit den `async` Schlüssel `await` Wörtern und in Visual Basic C#und verwendet.</span><span class="sxs-lookup"><span data-stu-id="79bf5-380">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span> 
 
 <span data-ttu-id="79bf5-381">Diese Methode löscht den Datenstrom, indem alle Änderungen an den Sicherungs Speicher geschrieben und der Stream zum Freigeben von Ressourcen geschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-381">This method disposes the stream by writing any changes to the backing store and closing the stream to release resources.</span></span>   
  
 <span data-ttu-id="79bf5-382">Durch Aufrufen `DisposeAsync` von können die Ressourcen ,dievonverwendetwerden,fürandereZweckeneuzugeordnetwerden.<xref:System.IO.Stream></span><span class="sxs-lookup"><span data-stu-id="79bf5-382">Calling `DisposeAsync` allows the resources used by the <xref:System.IO.Stream> to be reallocated for other purposes.</span></span> <span data-ttu-id="79bf5-383">Weitere Informationen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="79bf5-383">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public virtual int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndRead : IAsyncResult -&gt; int&#xA;override this.EndRead : IAsyncResult -&gt; int" Usage="stream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="79bf5-384">Der Verweis auf die ausstehende asynchrone Anforderung, die beendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="79bf5-384">The reference to the pending asynchronous request to finish.</span></span></param>
        <summary><span data-ttu-id="79bf5-385">Wartet, bis der ausstehende asynchrone Lesevorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="79bf5-385">Waits for the pending asynchronous read to complete.</span></span> <span data-ttu-id="79bf5-386">(Verwenden Sie stattdessen <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />.)</span><span class="sxs-lookup"><span data-stu-id="79bf5-386">(Consider using <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="79bf5-387">Die Anzahl der aus dem Stream gelesenen Bytes. Diese Anzahl kann zwischen 0 und der Anzahl der angeforderten Bytes liegen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-387">The number of bytes read from the stream, between zero (0) and the number of bytes you requested.</span></span> <span data-ttu-id="79bf5-388">Streams geben nur am Ende des Streams 0 zurück, andernfalls sollten sie blockieren, bis mindestens 1 Byte verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="79bf5-388">Streams return zero (0) only at the end of the stream, otherwise, they should block until at least one byte is available.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-389">In .NET Framework 4 und vorherigen Versionen müssen Sie Methoden wie <xref:System.IO.Stream.BeginRead%2A> und <xref:System.IO.Stream.EndRead%2A> verwenden, um asynchrone E/A-Vorgänge zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-389">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous I/O operations.</span></span> <span data-ttu-id="79bf5-390">Diese Methoden sind [!INCLUDE[net_v45](~/includes/net-v45-md.md)] weiterhin in verfügbar, um Legacy Code zu unterstützen. die neuen Async-Methoden, <xref:System.IO.Stream.ReadAsync%2A>wie z <xref:System.IO.Stream.WriteAsync%2A>. b. <xref:System.IO.Stream.FlushAsync%2A>,, <xref:System.IO.Stream.CopyToAsync%2A>und, unterstützen Sie jedoch bei der einfacheren Implementierung asynchroner e/a-Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="79bf5-390">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.Stream.FlushAsync%2A>, help you implement asynchronous I/O operations more easily.</span></span>  
  
 <span data-ttu-id="79bf5-391">Ruft `EndRead` auf, um zu bestimmen, wie viele Bytes aus dem Stream gelesen wurden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-391">Call `EndRead` to determine how many bytes were read from the stream.</span></span>  
  
 <span data-ttu-id="79bf5-392">`EndRead`kann bei jedem <xref:System.IAsyncResult> von <xref:System.IO.Stream.BeginRead%2A>einmal aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-392">`EndRead` can be called once on every <xref:System.IAsyncResult> from <xref:System.IO.Stream.BeginRead%2A>.</span></span>  
  
 <span data-ttu-id="79bf5-393">Diese Methode blockiert, bis die E/A-Operation abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="79bf5-393">This method blocks until the I/O operation has completed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79bf5-394"><paramref name="asyncResult" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79bf5-394"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79bf5-395">Ein Handle für den ausstehenden Lesevorgang ist nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="79bf5-395">A handle to the pending read operation is not available.</span></span>  
  
 <span data-ttu-id="79bf5-396">- oder -</span><span class="sxs-lookup"><span data-stu-id="79bf5-396">-or-</span></span>  
  
 <span data-ttu-id="79bf5-397">Die anstehende Operation unterstützt keine Lesevorgänge.</span><span class="sxs-lookup"><span data-stu-id="79bf5-397">The pending operation does not support reading.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79bf5-398"><paramref name="asyncResult" /> basiert nicht auf einer <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />-Methode im aktuellen Stream.</span><span class="sxs-lookup"><span data-stu-id="79bf5-398"><paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79bf5-399">Der Stream ist geschlossen, oder ein interner Fehler ist aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="79bf5-399">The stream is closed or an internal error has occurred.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="79bf5-400">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-400">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="79bf5-401">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="79bf5-401">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="79bf5-402">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="79bf5-402">How to: Write Text to a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md"><span data-ttu-id="79bf5-403">Asynchrone Datei-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-403">Asynchronous File I/O</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public virtual void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndWrite : IAsyncResult -&gt; unit&#xA;override this.EndWrite : IAsyncResult -&gt; unit" Usage="stream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="79bf5-404">Ein Verweis auf die ausstehende asynchrone E/A-Anforderung.</span><span class="sxs-lookup"><span data-stu-id="79bf5-404">A reference to the outstanding asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="79bf5-405">Beendet einen asynchronen Schreibvorgang.</span><span class="sxs-lookup"><span data-stu-id="79bf5-405">Ends an asynchronous write operation.</span></span> <span data-ttu-id="79bf5-406">(Verwenden Sie stattdessen <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />.)</span><span class="sxs-lookup"><span data-stu-id="79bf5-406">(Consider using <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> instead.)</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-407">In .NET Framework 4 und vorherigen Versionen müssen Sie Methoden wie <xref:System.IO.Stream.BeginWrite%2A> und <xref:System.IO.Stream.EndWrite%2A> verwenden, um asynchrone E/A-Vorgänge zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-407">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous I/O operations.</span></span> <span data-ttu-id="79bf5-408">Diese Methoden sind [!INCLUDE[net_v45](~/includes/net-v45-md.md)] weiterhin in verfügbar, um Legacy Code zu unterstützen. die neuen Async-Methoden, <xref:System.IO.Stream.ReadAsync%2A>wie z <xref:System.IO.Stream.WriteAsync%2A>. b. <xref:System.IO.Stream.FlushAsync%2A>,, <xref:System.IO.Stream.CopyToAsync%2A>und, unterstützen Sie jedoch bei der einfacheren Implementierung asynchroner e/a-Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="79bf5-408">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.Stream.FlushAsync%2A>, help you implement asynchronous I/O operations more easily.</span></span>  
  
 <span data-ttu-id="79bf5-409">`EndWrite`muss bei jedem <xref:System.IAsyncResult> von <xref:System.IO.Stream.BeginWrite%2A>genau einmal aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-409">`EndWrite` must be called exactly once on every <xref:System.IAsyncResult> from <xref:System.IO.Stream.BeginWrite%2A>.</span></span>  
  
 <span data-ttu-id="79bf5-410">Diese Methode blockiert, bis die E/A-Operation abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="79bf5-410">This method blocks until the I/O operation has completed.</span></span> <span data-ttu-id="79bf5-411">Fehler, die während einer asynchronen Schreib Anforderung auftreten, z. b. ein Datenträger Fehler während der e/a-Anforderung, treten im Thread Pool Thread auf und werden `EndWrite`bei einem-Rückruf sichtbar.</span><span class="sxs-lookup"><span data-stu-id="79bf5-411">Errors that occur during an asynchronous write request, such as a disk failure during the I/O request, occur on the thread pool thread and become visible upon a call to `EndWrite`.</span></span> <span data-ttu-id="79bf5-412">Ausnahmen, die vom Thread Pool Thread ausgelöst werden, sind beim Aufrufen `EndWrite`von nicht sichtbar.</span><span class="sxs-lookup"><span data-stu-id="79bf5-412">Exceptions thrown by the thread pool thread will not be visible when calling `EndWrite`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79bf5-413"><paramref name="asyncResult" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79bf5-413"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79bf5-414">Ein Handle für den ausstehenden Schreibvorgang ist nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="79bf5-414">A handle to the pending write operation is not available.</span></span>  
  
 <span data-ttu-id="79bf5-415">- oder -</span><span class="sxs-lookup"><span data-stu-id="79bf5-415">-or-</span></span>  
  
 <span data-ttu-id="79bf5-416">Die anstehende Operation unterstützt keine Schreibvorgänge.</span><span class="sxs-lookup"><span data-stu-id="79bf5-416">The pending operation does not support writing.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79bf5-417"><paramref name="asyncResult" /> basiert nicht auf einer <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />-Methode im aktuellen Stream.</span><span class="sxs-lookup"><span data-stu-id="79bf5-417"><paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79bf5-418">Der Stream ist geschlossen, oder ein interner Fehler ist aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="79bf5-418">The stream is closed or an internal error has occurred.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="79bf5-419">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-419">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="79bf5-420">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="79bf5-420">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="79bf5-421">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="79bf5-421">How to: Write Text to a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md"><span data-ttu-id="79bf5-422">Asynchrone Datei-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-422">Asynchronous File I/O</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public abstract void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Flush();" />
      <MemberSignature Language="F#" Value="abstract member Flush : unit -&gt; unit" Usage="stream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79bf5-423">Löscht beim Überschreiben in einer abgeleiteten Klasse alle Puffer für diesen Stream und veranlasst die Ausgabe aller gepufferten Daten an das zugrunde liegende Gerät.</span><span class="sxs-lookup"><span data-stu-id="79bf5-423">When overridden in a derived class, clears all buffers for this stream and causes any buffered data to be written to the underlying device.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-424">Über `Flush` schreiben Sie in Streams, die einen Puffer implementieren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-424">Override `Flush` on streams that implement a buffer.</span></span> <span data-ttu-id="79bf5-425">Verwenden Sie diese Methode, um alle Informationen aus einem zugrunde liegenden Puffer in das Ziel zu verschieben, den Puffer zu löschen oder beides.</span><span class="sxs-lookup"><span data-stu-id="79bf5-425">Use this method to move any information from an underlying buffer to its destination, clear the buffer, or both.</span></span> <span data-ttu-id="79bf5-426">Abhängig vom Zustand des Objekts müssen Sie möglicherweise die aktuelle Position innerhalb des Streams ändern (z. b. wenn der zugrunde liegende Stream Suchvorgänge unterstützt).</span><span class="sxs-lookup"><span data-stu-id="79bf5-426">Depending upon the state of the object, you might have to modify the current position within the stream (for example, if the underlying stream supports seeking).</span></span> <span data-ttu-id="79bf5-427">Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.</span><span class="sxs-lookup"><span data-stu-id="79bf5-427">For additional information see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  

 <span data-ttu-id="79bf5-428">In einer von <xref:System.IO.Stream> abgeleiteten Klasse, die Schreibvorgänge nicht unterstützt, wird in der Regel als leere Methode implementiert, <xref:System.IO.Stream> um die vollständige Kompatibilität mit anderen Typen sicherzustellen, <xref:System.IO.Stream.Flush%2A> da ein Schreib geschützter Stream ungültig ist.</span><span class="sxs-lookup"><span data-stu-id="79bf5-428">In a class derived from <xref:System.IO.Stream> that doesn't support writing, <xref:System.IO.Stream.Flush%2A> is typically implemented as an empty method to ensure full compatibility with other <xref:System.IO.Stream> types since it's valid to flush a read-only stream.</span></span>

 <span data-ttu-id="79bf5-429">Wenn Sie die <xref:System.IO.StreamWriter> - <xref:System.IO.BinaryWriter> Klasse oder die-Klasse verwenden, <xref:System.IO.Stream> sollten Sie das Basisobjekt nicht leeren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-429">When using the <xref:System.IO.StreamWriter> or <xref:System.IO.BinaryWriter> class, do not flush the base <xref:System.IO.Stream> object.</span></span> <span data-ttu-id="79bf5-430">Verwenden Sie stattdessen die-oder <xref:System.IO.Stream.Flush%2A> <xref:System.IO.Stream.Close%2A> -Methode der-Klasse, die sicherstellt, dass die Daten zuerst in den zugrunde liegenden Stream geleert und dann in die Datei geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-430">Instead, use the class's <xref:System.IO.Stream.Flush%2A> or <xref:System.IO.Stream.Close%2A> method, which makes sure that the data is flushed to the underlying stream first and then written to the file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79bf5-431">Ein E/A-Fehler tritt auf.</span><span class="sxs-lookup"><span data-stu-id="79bf5-431">An I/O error occurs.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="79bf5-432">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-432">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="79bf5-433">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="79bf5-433">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="79bf5-434">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="79bf5-434">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FlushAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="79bf5-435">Löscht sämtliche Puffer für diesen Stream asynchron und veranlasst die Ausgabe aller gepufferten Daten an das zugrunde liegende Gerät.</span><span class="sxs-lookup"><span data-stu-id="79bf5-435">Asynchronously clears all buffers for this stream and causes any buffered data to be written to the underlying device.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="stream.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79bf5-436">Löscht sämtliche Puffer für diesen Stream asynchron und veranlasst die Ausgabe aller gepufferten Daten an das zugrunde liegende Gerät.</span><span class="sxs-lookup"><span data-stu-id="79bf5-436">Asynchronously clears all buffers for this stream and causes any buffered data to be written to the underlying device.</span></span></summary>
        <returns><span data-ttu-id="79bf5-437">Eine Aufgabe, die die asynchrone Leerung darstellt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-437">A task that represents the asynchronous flush operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-438">Wenn eine abgeleitete Klasse, z <xref:System.IO.Compression.DeflateStream> . <xref:System.IO.Compression.GZipStream>b. oder, den Puffer <xref:System.IO.Stream.Flush%2A> in der Implementierung der-Methode nicht leert, wird der Puffer von der <xref:System.IO.Stream.FlushAsync%2A> -Methode nicht geleert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-438">If a derived class, such as <xref:System.IO.Compression.DeflateStream> or <xref:System.IO.Compression.GZipStream>, does not flush the buffer in its implementation of the <xref:System.IO.Stream.Flush%2A> method, the <xref:System.IO.Stream.FlushAsync%2A> method will not flush the buffer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-439">Der Stream wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-439">The stream has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="79bf5-440">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-440">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="79bf5-441">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />sein.</span><span class="sxs-lookup"><span data-stu-id="79bf5-441">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="79bf5-442">Löscht alle Puffer für diesen Stream asynchron und veranlasst die Ausgabe aller gepufferten Daten an das zugrunde liegende Gerät und überwacht Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-442">Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="79bf5-443">Eine Aufgabe, die die asynchrone Leerung darstellt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-443">A task that represents the asynchronous flush operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-444">Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die <xref:System.Threading.Tasks.TaskStatus.Canceled> zurückgegebene Aufgabe <xref:System.Threading.Tasks.Task.Status%2A> den Wert für die-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="79bf5-444">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="79bf5-445">Wenn eine abgeleitete Klasse, z <xref:System.IO.Compression.DeflateStream> . <xref:System.IO.Compression.GZipStream>b. oder, den Puffer <xref:System.IO.Stream.Flush%2A> in der Implementierung der-Methode nicht leert, wird der Puffer von der <xref:System.IO.Stream.FlushAsync%2A> -Methode nicht geleert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-445">If a derived class, such as <xref:System.IO.Compression.DeflateStream> or <xref:System.IO.Compression.GZipStream>, does not flush the buffer in its implementation of the <xref:System.IO.Stream.Flush%2A> method, the <xref:System.IO.Stream.FlushAsync%2A> method will not flush the buffer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-446">Der Stream wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-446">The stream has been disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md"><span data-ttu-id="79bf5-447">Abbruch</span><span class="sxs-lookup"><span data-stu-id="79bf5-447">Cancellation</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public abstract long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.Length" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.Stream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79bf5-448">Ruft beim Überschreiben in einer abgeleiteten Klasse die Länge des Streams in Bytes ab.</span><span class="sxs-lookup"><span data-stu-id="79bf5-448">When overridden in a derived class, gets the length in bytes of the stream.</span></span></summary>
        <value><span data-ttu-id="79bf5-449">Ein Long-Wert, der die Länge des Streams in Bytes darstellt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-449">A long value representing the length of the stream in bytes.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79bf5-450">Eine aus <see langword="Stream" /> abgeleitete Klasse unterstützt keine Suchvorgänge.</span><span class="sxs-lookup"><span data-stu-id="79bf5-450">A class derived from <see langword="Stream" /> does not support seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-451">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="79bf5-451">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="79bf5-452">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-452">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="79bf5-453">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="79bf5-453">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="79bf5-454">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="79bf5-454">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.Stream Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.Stream Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.Stream.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As Stream " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::Stream ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.IO.Stream" Usage="System.IO.Stream.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79bf5-455">Ein <see langword="Stream" /> ohne Sicherungsspeicher.</span><span class="sxs-lookup"><span data-stu-id="79bf5-455">A <see langword="Stream" /> with no backing store.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-456">Verwenden `Null` Sie, um die Ausgabe an einen Stream umzuleiten, der keine Betriebssystemressourcen beansprucht.</span><span class="sxs-lookup"><span data-stu-id="79bf5-456">Use `Null` to redirect output to a stream that will not consume any operating system resources.</span></span> <span data-ttu-id="79bf5-457">Wenn die Methoden von `Stream` , die Schreibvorgänge bereitstellen `Null`, für aufgerufen werden, gibt der Aufruf einfach zurück, und es werden keine Daten geschrieben.</span><span class="sxs-lookup"><span data-stu-id="79bf5-457">When the methods of `Stream` that provide writing are invoked on `Null`, the call simply returns, and no data is written.</span></span> <span data-ttu-id="79bf5-458">`Null`implementiert auch eine `Read` Methode, die NULL zurückgibt, ohne Daten zu lesen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-458">`Null` also implements a `Read` method that returns zero without reading data.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="79bf5-459">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-459">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="79bf5-460">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="79bf5-460">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="79bf5-461">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="79bf5-461">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ObjectInvariant">
      <MemberSignature Language="C#" Value="protected virtual void ObjectInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ObjectInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ObjectInvariant" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ObjectInvariant ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ObjectInvariant();" />
      <MemberSignature Language="F#" Value="abstract member ObjectInvariant : unit -&gt; unit&#xA;override this.ObjectInvariant : unit -&gt; unit" Usage="stream.ObjectInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Do not call or override this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79bf5-462">Bietet Unterstützung für einen <see cref="T:System.Diagnostics.Contracts.Contract" />.</span><span class="sxs-lookup"><span data-stu-id="79bf5-462">Provides support for a <see cref="T:System.Diagnostics.Contracts.Contract" />.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public abstract long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.Position" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.Stream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79bf5-463">Ruft beim Überschreiben in einer abgeleiteten Klasse die Position im aktuellen Stream ab oder legt diese fest.</span><span class="sxs-lookup"><span data-stu-id="79bf5-463">When overridden in a derived class, gets or sets the position within the current stream.</span></span></summary>
        <value><span data-ttu-id="79bf5-464">Die aktuelle Position innerhalb des Streams.</span><span class="sxs-lookup"><span data-stu-id="79bf5-464">The current position within the stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-465">Der Stream muss das Suchen oder Festlegen der Position unterstützen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-465">The stream must support seeking to get or set the position.</span></span> <span data-ttu-id="79bf5-466">Mithilfe der <xref:System.IO.Stream.CanSeek%2A> -Eigenschaft können Sie ermitteln, ob der Stream Suchvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-466">Use the <xref:System.IO.Stream.CanSeek%2A> property to determine whether the stream supports seeking.</span></span>  
  
 <span data-ttu-id="79bf5-467">Das Suchen nach einem beliebigen Speicherort über die Länge des Streams wird unterstützt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-467">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 <span data-ttu-id="79bf5-468">Die `Position` -Eigenschaft verfolgt nicht die Anzahl der Bytes aus dem Datenstrom, die verbraucht, ausgelassen oder beides sind.</span><span class="sxs-lookup"><span data-stu-id="79bf5-468">The `Position` property does not keep track of the number of bytes from the stream that have been consumed, skipped, or both.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79bf5-469">Ein E/A-Fehler tritt auf.</span><span class="sxs-lookup"><span data-stu-id="79bf5-469">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79bf5-470">Vom Stream wird Suchen nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-470">The stream does not support seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-471">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="79bf5-471">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="79bf5-472">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-472">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="79bf5-473">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="79bf5-473">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="79bf5-474">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="79bf5-474">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public virtual int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member Read : Span&lt;byte&gt; -&gt; int&#xA;override this.Read : Span&lt;byte&gt; -&gt; int" Usage="stream.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="79bf5-475">Ein Bereich im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="79bf5-475">A region of memory.</span></span> <span data-ttu-id="79bf5-476">Bei der Rückgabe dieser Methode werden die Inhalte dieses Bereichs durch die aus der aktuellen Quelle gelesenen Bytes ersetzt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-476">When this method returns, the contents of this region are replaced by the bytes read from the current source.</span></span></param>
        <summary><span data-ttu-id="79bf5-477">Liest beim Überschreiben in einer abgeleiteten Klasse eine Folge von Bytes aus dem aktuellen Stream und erhöht die Position im Stream um die Anzahl der gelesenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="79bf5-477">When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="79bf5-478">Die Gesamtanzahl der in den Puffer gelesenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="79bf5-478">The total number of bytes read into the buffer.</span></span> <span data-ttu-id="79bf5-479">Dies kann weniger als die Anzahl der im Puffer zugeordneten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder 0 (null), wenn das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="79bf5-479">This can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-480">Verwenden Sie <xref:System.IO.Stream.CanRead%2A> die-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt</span><span class="sxs-lookup"><span data-stu-id="79bf5-480">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span> <span data-ttu-id="79bf5-481">Verwenden Sie <xref:System.IO.Stream.ReadAsync%2A> die-Methode, um asynchron aus dem aktuellen Stream zu lesen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-481">Use the <xref:System.IO.Stream.ReadAsync%2A> method to read asynchronously from the current stream.</span></span>  
  
 <span data-ttu-id="79bf5-482">Implementierungen dieser Methode lesen eine maximale Anzahl von `buffer.Length` Bytes aus dem aktuellen Stream und speichern Sie in `buffer`.</span><span class="sxs-lookup"><span data-stu-id="79bf5-482">Implementations of this method read a maximum of `buffer.Length` bytes from the current stream and store them in `buffer`.</span></span> <span data-ttu-id="79bf5-483">Die aktuelle Position innerhalb des Streams wird um die Anzahl der gelesenen Bytes erweitert. Wenn jedoch eine Ausnahme auftritt, bleibt die aktuelle Position im Stream unverändert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-483">The current position within the stream is advanced by the number of bytes read; however, if an exception occurs, the current position within the stream remains unchanged.</span></span> <span data-ttu-id="79bf5-484">Implementierungen geben die Anzahl der gelesenen Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="79bf5-484">Implementations return the number of bytes read.</span></span> <span data-ttu-id="79bf5-485">Die-Implementierung wird blockiert, bis mindestens ein Byte der Daten gelesen werden kann, wenn keine Daten verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="79bf5-485">The implementation will block until at least one byte of data can be read, in the event that no data is available.</span></span> <span data-ttu-id="79bf5-486"><xref:System.IO.Stream.Read%2A>gibt 0 (null) nur dann zurück, wenn keine weiteren Daten im Stream vorhanden sind und nicht mehr erwartet wird (z. b. ein geschlossener Socket oder ein Dateiende).</span><span class="sxs-lookup"><span data-stu-id="79bf5-486"><xref:System.IO.Stream.Read%2A> returns 0 only when there is no more data in the stream and no more is expected (such as a closed socket or end of file).</span></span> <span data-ttu-id="79bf5-487">Eine-Implementierung kann weniger Bytes zurückgeben als angefordert werden, auch wenn das Ende des Streams nicht erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="79bf5-487">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="79bf5-488">Verwenden <xref:System.IO.BinaryReader> Sie zum Lesen primitiver Datentypen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-488">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>    
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="abstract member Read : byte[] * int * int -&gt; int" Usage="stream.Read (buffer, offset, count)" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="79bf5-489">Ein Bytearray.</span><span class="sxs-lookup"><span data-stu-id="79bf5-489">An array of bytes.</span></span> <span data-ttu-id="79bf5-490">Nach dem Beenden dieser Methode enthält der Puffer das angegebene Bytearray mit den Werten zwischen <paramref name="offset" /> und (<paramref name="offset" /> + <paramref name="count" /> - 1), die durch aus der aktuellen Quelle gelesene Bytes ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-490">When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1) replaced by the bytes read from the current source.</span></span></param>
        <param name="offset"><span data-ttu-id="79bf5-491">Der nullbasierte Byteoffset im <paramref name="buffer" />, ab dem die aus dem aktuellen Stream gelesenen Daten gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-491">The zero-based byte offset in <paramref name="buffer" /> at which to begin storing the data read from the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="79bf5-492">Die maximale Anzahl an Bytes, die aus dem aktuellen Stream gelesen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-492">The maximum number of bytes to be read from the current stream.</span></span></param>
        <summary><span data-ttu-id="79bf5-493">Liest beim Überschreiben in einer abgeleiteten Klasse eine Folge von Bytes aus dem aktuellen Stream und erhöht die Position im Stream um die Anzahl der gelesenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="79bf5-493">When overridden in a derived class, reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="79bf5-494">Die Gesamtanzahl der in den Puffer gelesenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="79bf5-494">The total number of bytes read into the buffer.</span></span> <span data-ttu-id="79bf5-495">Dies kann weniger als die Anzahl der angeforderten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder 0, wenn das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="79bf5-495">This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-496">Verwenden Sie <xref:System.IO.Stream.CanRead%2A> die-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt</span><span class="sxs-lookup"><span data-stu-id="79bf5-496">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span> <span data-ttu-id="79bf5-497">Verwenden Sie <xref:System.IO.Stream.ReadAsync%2A> die-Methode, um asynchron aus dem aktuellen Stream zu lesen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-497">Use the <xref:System.IO.Stream.ReadAsync%2A> method to read asynchronously from the current stream.</span></span>  
  
 <span data-ttu-id="79bf5-498">Implementierungen dieser Methode lesen eine maximale Anzahl von `count` Bytes aus dem aktuellen Stream und speichern `buffer` Sie `offset`ab ab.</span><span class="sxs-lookup"><span data-stu-id="79bf5-498">Implementations of this method read a maximum of `count` bytes from the current stream and store them in `buffer` beginning at `offset`.</span></span> <span data-ttu-id="79bf5-499">Die aktuelle Position innerhalb des Streams wird um die Anzahl der gelesenen Bytes erweitert. Wenn jedoch eine Ausnahme auftritt, bleibt die aktuelle Position im Stream unverändert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-499">The current position within the stream is advanced by the number of bytes read; however, if an exception occurs, the current position within the stream remains unchanged.</span></span> <span data-ttu-id="79bf5-500">Implementierungen geben die Anzahl der gelesenen Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="79bf5-500">Implementations return the number of bytes read.</span></span> <span data-ttu-id="79bf5-501">Die-Implementierung wird blockiert, bis mindestens ein Byte der Daten gelesen werden kann, wenn keine Daten verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="79bf5-501">The implementation will block until at least one byte of data can be read, in the event that no data is available.</span></span> <span data-ttu-id="79bf5-502"><xref:System.IO.Stream.Read%2A>gibt 0 (null) nur dann zurück, wenn keine weiteren Daten im Stream vorhanden sind und nicht mehr erwartet wird (z. b. ein geschlossener Socket oder ein Dateiende).</span><span class="sxs-lookup"><span data-stu-id="79bf5-502"><xref:System.IO.Stream.Read%2A> returns 0 only when there is no more data in the stream and no more is expected (such as a closed socket or end of file).</span></span> <span data-ttu-id="79bf5-503">Eine-Implementierung kann weniger Bytes zurückgeben als angefordert werden, auch wenn das Ende des Streams nicht erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="79bf5-503">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="79bf5-504">Verwenden <xref:System.IO.BinaryReader> Sie zum Lesen primitiver Datentypen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-504">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79bf5-505">Im folgenden Beispiel wird gezeigt, <xref:System.IO.Stream.Read%2A> wie mit ein Datenblock gelesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="79bf5-505">The following example shows how to use <xref:System.IO.Stream.Read%2A> to read a block of data.</span></span>  
  
 [!code-cpp[Classic Stream.Read Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stream.Read Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stream.Read Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stream.Read Example/CS/source.cs#1)]
 [!code-vb[Classic Stream.Read Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stream.Read Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79bf5-506">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Pufferlänge.</span><span class="sxs-lookup"><span data-stu-id="79bf5-506">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79bf5-507"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79bf5-507"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="79bf5-508"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-508"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79bf5-509">Ein E/A-Fehler tritt auf.</span><span class="sxs-lookup"><span data-stu-id="79bf5-509">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79bf5-510">Lesevorgänge werden vom Stream nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-510">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-511">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="79bf5-511">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="79bf5-512">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-512">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="79bf5-513">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="79bf5-513">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="79bf5-514">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="79bf5-514">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="79bf5-515">Liest eine Bytesequenz asynchron aus dem aktuellen Stream und setzt die Position in diesem Stream um die Anzahl der gelesenen Bytes nach vorn.</span><span class="sxs-lookup"><span data-stu-id="79bf5-515">Asynchronously reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;&#xA;override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="stream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="79bf5-516">Der Bereich im Arbeitsspeicher, in den die Daten geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-516">The region of memory to write the data into.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="79bf5-517">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-517">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="79bf5-518">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />sein.</span><span class="sxs-lookup"><span data-stu-id="79bf5-518">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="79bf5-519">Liest eine Folge von Bytes asynchron aus aktuellen Stream, erhöht die Position im Stream um die Anzahl der gelesenen Bytes und überwacht Abbruchanfragen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-519">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="79bf5-520">Eine Aufgabe, die den asynchronen Lesevorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-520">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="79bf5-521">Der Wert seiner <see cref="P:System.Threading.Tasks.ValueTask`1.Result" />-Eigenschaft enthält die Gesamtzahl der Bytes, die in den Puffer gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-521">The value of its <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> property contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="79bf5-522">Der Ergebniswert kann weniger als die Anzahl der im Puffer zugeordneten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder er kann 0 (null) sein, wenn das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="79bf5-522">The result value can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-523">Mit <xref:System.IO.Stream.ReadAsync%2A> der-Methode können Sie ressourcenintensive e/a-Vorgänge durchführen, ohne den Haupt Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-523">The <xref:System.IO.Stream.ReadAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="79bf5-524">Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-524">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="79bf5-525">Die Async-Methoden werden in Verbindung mit den `async` Schlüssel `await` Wörtern und in Visual Basic C#und verwendet.</span><span class="sxs-lookup"><span data-stu-id="79bf5-525">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="79bf5-526">Verwenden Sie <xref:System.IO.Stream.CanRead%2A> die-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt</span><span class="sxs-lookup"><span data-stu-id="79bf5-526">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="79bf5-527">Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> zurückgegebene Aufgabe <xref:System.Threading.Tasks.Task.Status> den Wert für die-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="79bf5-527">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status> property.</span></span>  
  
 <span data-ttu-id="79bf5-528">Ein Beispiel finden Sie unter <xref:System.IO.Stream.ReadAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Überladung.</span><span class="sxs-lookup"><span data-stu-id="79bf5-528">For an example, see the <xref:System.IO.Stream.ReadAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAsync (buffer As Byte(), offset As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.ReadAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stream.ReadAsync (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="79bf5-529">Der Puffer, in den die Daten geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-529">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="79bf5-530">Der Byteoffset im <paramref name="buffer" />, ab dem Daten aus dem Stream geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-530">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="79bf5-531">Die maximale Anzahl der zu lesenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="79bf5-531">The maximum number of bytes to read.</span></span></param>
        <summary><span data-ttu-id="79bf5-532">Liest eine Bytesequenz asynchron aus dem aktuellen Stream und setzt die Position in diesem Stream um die Anzahl der gelesenen Bytes nach vorn.</span><span class="sxs-lookup"><span data-stu-id="79bf5-532">Asynchronously reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="79bf5-533">Eine Aufgabe, die den asynchronen Lesevorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-533">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="79bf5-534">Der Wert des <paramref name="TResult" />-Parameters enthält die Gesamtzahl der Bytes, die in den Puffer gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-534">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="79bf5-535">Der Ergebniswert kann niedriger als die Anzahl der angeforderten Bytes sein, wenn die Anzahl an derzeit verfügbaren Bytes kleiner ist als die angeforderte Anzahl, oder sie kann 0 (null) sein, wenn das Datenstromende erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="79bf5-535">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-536">Mit <xref:System.IO.Stream.ReadAsync%2A> der-Methode können Sie ressourcenintensive e/a-Vorgänge durchführen, ohne den Haupt Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-536">The <xref:System.IO.Stream.ReadAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="79bf5-537">Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-537">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="79bf5-538">Die Async-Methoden werden in Verbindung mit den `async` Schlüssel `await` Wörtern und in Visual Basic C#und verwendet.</span><span class="sxs-lookup"><span data-stu-id="79bf5-538">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="79bf5-539">Verwenden Sie <xref:System.IO.Stream.CanRead%2A> die-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt</span><span class="sxs-lookup"><span data-stu-id="79bf5-539">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79bf5-540">Im folgenden Beispiel wird gezeigt, wie Sie asynchron aus einer Datei lesen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-540">The following example shows how to read from a file asynchronously.</span></span> <span data-ttu-id="79bf5-541">Im Beispiel wird die <xref:System.IO.FileStream> -Klasse verwendet, die von <xref:System.IO.Stream> der-Klasse abgeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-541">The example uses the <xref:System.IO.FileStream> class, which derives from the <xref:System.IO.Stream> class.</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79bf5-542"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79bf5-542"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="79bf5-543"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-543"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79bf5-544">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Pufferlänge.</span><span class="sxs-lookup"><span data-stu-id="79bf5-544">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79bf5-545">Lesevorgänge werden vom Stream nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-545">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-546">Der Stream wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-546">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79bf5-547">Der Stream wird zurzeit von einem vorherigen Lesevorgang verwendet.</span><span class="sxs-lookup"><span data-stu-id="79bf5-547">The stream is currently in use by a previous read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="stream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="79bf5-548">Der Puffer, in den die Daten geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-548">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="79bf5-549">Der Byteoffset im <paramref name="buffer" />, ab dem Daten aus dem Stream geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-549">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="79bf5-550">Die maximale Anzahl der zu lesenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="79bf5-550">The maximum number of bytes to read.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="79bf5-551">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-551">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="79bf5-552">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />sein.</span><span class="sxs-lookup"><span data-stu-id="79bf5-552">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="79bf5-553">Liest eine Folge von Bytes asynchron aus aktuellen Stream, erhöht die Position im Stream um die Anzahl der gelesenen Bytes und überwacht Abbruchanfragen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-553">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="79bf5-554">Eine Aufgabe, die den asynchronen Lesevorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-554">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="79bf5-555">Der Wert des <paramref name="TResult" />-Parameters enthält die Gesamtzahl der Bytes, die in den Puffer gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-555">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="79bf5-556">Der Ergebniswert kann niedriger als die Anzahl der angeforderten Bytes sein, wenn die Anzahl an derzeit verfügbaren Bytes kleiner ist als die angeforderte Anzahl, oder sie kann 0 (null) sein, wenn das Datenstromende erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="79bf5-556">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-557">Mit <xref:System.IO.Stream.ReadAsync%2A> der-Methode können Sie ressourcenintensive e/a-Vorgänge durchführen, ohne den Haupt Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-557">The <xref:System.IO.Stream.ReadAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="79bf5-558">Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-558">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="79bf5-559">Die Async-Methoden werden in Verbindung mit den `async` Schlüssel `await` Wörtern und in Visual Basic C#und verwendet.</span><span class="sxs-lookup"><span data-stu-id="79bf5-559">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="79bf5-560">Verwenden Sie <xref:System.IO.Stream.CanRead%2A> die-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt</span><span class="sxs-lookup"><span data-stu-id="79bf5-560">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="79bf5-561">Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die <xref:System.Threading.Tasks.TaskStatus.Canceled> zurückgegebene Aufgabe <xref:System.Threading.Tasks.Task.Status%2A> den Wert für die-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="79bf5-561">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="79bf5-562">Ein Beispiel finden Sie unter <xref:System.IO.Stream.ReadAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Überladung.</span><span class="sxs-lookup"><span data-stu-id="79bf5-562">For an example, see the <xref:System.IO.Stream.ReadAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79bf5-563"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79bf5-563"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="79bf5-564"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-564"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79bf5-565">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Pufferlänge.</span><span class="sxs-lookup"><span data-stu-id="79bf5-565">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79bf5-566">Lesevorgänge werden vom Stream nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-566">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-567">Der Stream wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-567">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79bf5-568">Der Stream wird zurzeit von einem vorherigen Lesevorgang verwendet.</span><span class="sxs-lookup"><span data-stu-id="79bf5-568">The stream is currently in use by a previous read operation.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md"><span data-ttu-id="79bf5-569">Abbruch</span><span class="sxs-lookup"><span data-stu-id="79bf5-569">Cancellation</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public virtual int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadByte();" />
      <MemberSignature Language="F#" Value="abstract member ReadByte : unit -&gt; int&#xA;override this.ReadByte : unit -&gt; int" Usage="stream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79bf5-570">Liest ein Byte aus dem Stream und erhöht die Position im Stream um ein Byte, oder gibt -1 zurück, wenn das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="79bf5-570">Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.</span></span></summary>
        <returns><span data-ttu-id="79bf5-571">Das Byte ohne Vorzeichen, umgewandelt in <see langword="Int32" />, oder -1, wenn das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="79bf5-571">The unsigned byte cast to an <see langword="Int32" />, or -1 if at the end of the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-572">Verwenden Sie <xref:System.IO.Stream.CanRead%2A> die-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt</span><span class="sxs-lookup"><span data-stu-id="79bf5-572">Use the <xref:System.IO.Stream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="79bf5-573">Versucht, den Datenstrom zu manipulieren, nachdem der Stream geschlossen wurde, <xref:System.ObjectDisposedException>könnte eine auslösen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-573">Attempts to manipulate the stream after the stream has been closed could throw an <xref:System.ObjectDisposedException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79bf5-574">Lesevorgänge werden vom Stream nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-574">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-575">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="79bf5-575">Methods were called after the stream was closed.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="79bf5-576">Die Standard Implementierung von <see langword="Stream" /> erstellt ein neues Einzel Byte Array und ruft <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />dann auf.</span><span class="sxs-lookup"><span data-stu-id="79bf5-576">The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />.</span></span> <span data-ttu-id="79bf5-577">Obwohl dies formal korrekt ist, ist es ineffizient.</span><span class="sxs-lookup"><span data-stu-id="79bf5-577">While this is formally correct, it is inefficient.</span></span> <span data-ttu-id="79bf5-578">Jeder Datenstrom mit einem internen Puffer sollte diese Methode überschreiben und eine wesentlich effizientere Version bereitstellen, die den Puffer direkt liest, wobei die zusätzliche Array Zuordnung bei jedem-Befehl vermieden wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-578">Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</span></span></para></block>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="79bf5-579">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-579">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="79bf5-580">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="79bf5-580">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="79bf5-581">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="79bf5-581">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public virtual int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.IO.Stream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79bf5-582">Ruft einen Wert in Millisekunden ab, der bestimmt, wie lange der Stream versucht, Lesevorgänge durchzuführen, bevor ein Timeout auftritt, oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="79bf5-582">Gets or sets a value, in milliseconds, that determines how long the stream will attempt to read before timing out.</span></span></summary>
        <value><span data-ttu-id="79bf5-583">Ein Wert in Millisekunden, der bestimmt, wie lange der Stream versucht, Lesevorgänge durchzuführen, bevor ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-583">A value, in milliseconds, that determines how long the stream will attempt to read before timing out.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79bf5-584">Die <see cref="P:System.IO.Stream.ReadTimeout" />-Methode löst immer eine <see cref="T:System.InvalidOperationException" /> aus.</span><span class="sxs-lookup"><span data-stu-id="79bf5-584">The <see cref="P:System.IO.Stream.ReadTimeout" /> method always throws an <see cref="T:System.InvalidOperationException" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="79bf5-585">Die <see cref="P:System.IO.Stream.ReadTimeout" /> -Eigenschaft sollte überschrieben werden, um das entsprechende Verhalten für den Stream bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-585">The <see cref="P:System.IO.Stream.ReadTimeout" /> property should be overridden to provide the appropriate behavior for the stream.</span></span> <span data-ttu-id="79bf5-586">Wenn der Stream keine zeitliche Überschreitung unterstützt, sollte diese Eigenschaft eine <see cref="T:System.InvalidOperationException" />-Klasse aus.</span><span class="sxs-lookup"><span data-stu-id="79bf5-586">If the stream does not support timing out, this property should raise an <see cref="T:System.InvalidOperationException" />.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public abstract long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="abstract member Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="stream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="79bf5-587">Ein Byteoffset relativ zum <paramref name="origin" />-Parameter.</span><span class="sxs-lookup"><span data-stu-id="79bf5-587">A byte offset relative to the <paramref name="origin" /> parameter.</span></span></param>
        <param name="origin"><span data-ttu-id="79bf5-588">Ein Wert vom Typ <see cref="T:System.IO.SeekOrigin" />, der den Bezugspunkt angibt, von dem aus die neue Position ermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-588">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the reference point used to obtain the new position.</span></span></param>
        <summary><span data-ttu-id="79bf5-589">Legt beim Überschreiben in einer abgeleiteten Klasse die Position im aktuellen Stream fest.</span><span class="sxs-lookup"><span data-stu-id="79bf5-589">When overridden in a derived class, sets the position within the current stream.</span></span></summary>
        <returns><span data-ttu-id="79bf5-590">Die neue Position innerhalb des aktuellen Streams.</span><span class="sxs-lookup"><span data-stu-id="79bf5-590">The new position within the current stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-591">Verwenden Sie <xref:System.IO.Stream.CanSeek%2A> die-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Suchvorgänge unterstützt</span><span class="sxs-lookup"><span data-stu-id="79bf5-591">Use the <xref:System.IO.Stream.CanSeek%2A> property to determine whether the current instance supports seeking.</span></span>  
  
 <span data-ttu-id="79bf5-592">Wenn `offset` negativ ist, muss die neue Position der durch angegebenen `offset`Anzahl von Bytes vorangestellt `origin` werden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-592">If `offset` is negative, the new position is required to precede the position specified by `origin` by the number of bytes specified by `offset`.</span></span> <span data-ttu-id="79bf5-593">Wenn `offset` 0 (null) ist, muss die neue Position die durch `origin`angegebene Position sein.</span><span class="sxs-lookup"><span data-stu-id="79bf5-593">If `offset` is zero (0), the new position is required to be the position specified by `origin`.</span></span> <span data-ttu-id="79bf5-594">Wenn `offset` positiv ist, ist die neue Position erforderlich, um die durch angegebene `offset`Anzahl `origin` von Bytes an der von angegebenen Position zu befolgen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-594">If `offset` is positive, the new position is required to follow the position specified by `origin` by the number of bytes specified by `offset`.</span></span>  
  
 <span data-ttu-id="79bf5-595">Von `Stream` abgeleitete Klassen, die Suchvorgänge unterstützen, müssen diese Methode überschreiben, um die oben beschriebene Funktionalität bereitzustellen</span><span class="sxs-lookup"><span data-stu-id="79bf5-595">Classes derived from `Stream` that support seeking must override this method to provide the functionality described above.</span></span>  
  
 <span data-ttu-id="79bf5-596">Das Suchen nach einem beliebigen Speicherort über die Länge des Streams wird unterstützt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-596">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79bf5-597">Ein E/A-Fehler tritt auf.</span><span class="sxs-lookup"><span data-stu-id="79bf5-597">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79bf5-598">Der Stream unterstützt keine Suchvorgänge. Dies ist beispielsweise der Fall, wenn der Stream aus einer Pipe- oder Konsolenausgabe erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-598">The stream does not support seeking, such as if the stream is constructed from a pipe or console output.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-599">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="79bf5-599">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="79bf5-600">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-600">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="79bf5-601">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="79bf5-601">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="79bf5-602">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="79bf5-602">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public abstract void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void SetLength(long value);" />
      <MemberSignature Language="F#" Value="abstract member SetLength : int64 -&gt; unit" Usage="stream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="79bf5-603">Die gewünschte Länge des aktuellen Streams in Bytes.</span><span class="sxs-lookup"><span data-stu-id="79bf5-603">The desired length of the current stream in bytes.</span></span></param>
        <summary><span data-ttu-id="79bf5-604">Legt beim Überschreiben in einer abgeleiteten Klasse die Länge des aktuellen Streams fest.</span><span class="sxs-lookup"><span data-stu-id="79bf5-604">When overridden in a derived class, sets the length of the current stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-605">Wenn der angegebene Wert kleiner als die aktuelle Länge des Streams ist, wird der Stream abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="79bf5-605">If the specified value is less than the current length of the stream, the stream is truncated.</span></span> <span data-ttu-id="79bf5-606">Wenn der angegebene Wert größer als die aktuelle Länge des Streams ist, wird der Stream erweitert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-606">If the specified value is larger than the current length of the stream, the stream is expanded.</span></span> <span data-ttu-id="79bf5-607">Wenn der Stream erweitert ist, werden die Inhalte des Streams zwischen der alten und der neuen Länge nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-607">If the stream is expanded, the contents of the stream between the old and the new length are not defined.</span></span>  
  
 <span data-ttu-id="79bf5-608">Ein Datenstrom muss sowohl das Schreiben als auch `SetLength` das Suchen nach unterstützen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-608">A stream must support both writing and seeking for `SetLength` to work.</span></span>  
  
 <span data-ttu-id="79bf5-609">Verwenden Sie <xref:System.IO.Stream.CanWrite%2A> die-Eigenschaft, um zu bestimmen, ob die aktuelle- <xref:System.IO.Stream.CanSeek%2A> Instanz Schreibvorgänge unterstützt, und die-Eigenschaft, um zu bestimmen, ob</span><span class="sxs-lookup"><span data-stu-id="79bf5-609">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing, and the <xref:System.IO.Stream.CanSeek%2A> property to determine whether seeking is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79bf5-610">Ein E/A-Fehler tritt auf.</span><span class="sxs-lookup"><span data-stu-id="79bf5-610">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79bf5-611">Der Stream unterstützt nicht sowohl Lese- als auch Schreibvorgänge. Dies ist beispielsweise der Fall, wenn der Stream aus einer Pipe- oder Konsolenausgabe erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-611">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-612">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="79bf5-612">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="79bf5-613">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-613">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="79bf5-614">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="79bf5-614">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="79bf5-615">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="79bf5-615">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.IO.Stream Synchronized (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream Synchronized(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Synchronized(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ Synchronized(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.IO.Stream -&gt; System.IO.Stream" Usage="System.IO.Stream.Synchronized stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="79bf5-616">Das <see cref="T:System.IO.Stream" />-Objekt, das synchronisiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="79bf5-616">The <see cref="T:System.IO.Stream" /> object to synchronize.</span></span></param>
        <summary><span data-ttu-id="79bf5-617">Erstellt um das angegebene <see cref="T:System.IO.Stream" />-Objekt einen threadsicheren (synchronisierten) Wrapper.</span><span class="sxs-lookup"><span data-stu-id="79bf5-617">Creates a thread-safe (synchronized) wrapper around the specified <see cref="T:System.IO.Stream" /> object.</span></span></summary>
        <returns><span data-ttu-id="79bf5-618">Ein threadsicheres <see cref="T:System.IO.Stream" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-618">A thread-safe <see cref="T:System.IO.Stream" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-619">Diese Methode gibt eine Klasse zurück, die das <xref:System.IO.Stream> angegebene Objekt umschließt und den Zugriff von mehreren Threads einschränkt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-619">This method returns a class that wraps the specified <xref:System.IO.Stream> object and restricts access to it from multiple threads.</span></span> <span data-ttu-id="79bf5-620">Der gesamte Zugriff auf <xref:System.IO.Stream> das Objekt ist Thread sicher.</span><span class="sxs-lookup"><span data-stu-id="79bf5-620">All access to the <xref:System.IO.Stream> object will be thread safe.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79bf5-621"><paramref name="stream" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79bf5-621"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="79bf5-622">Gibt alle vom <see cref="T:System.IO.Stream" /> verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="79bf5-622">Releases all resources used by the <see cref="T:System.IO.Stream" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="79bf5-623">Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung.</span><span class="sxs-lookup"><span data-stu-id="79bf5-623">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="79bf5-624">Er kann nur verwendet werden, wenn die <xref:System.IO.Stream>-Instanz in eine <xref:System.IDisposable>-Schnittstelle umgewandelt wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-624">It can be used only when the <xref:System.IO.Stream> instance is cast to an <xref:System.IDisposable> interface.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public virtual void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member Write : ReadOnlySpan&lt;byte&gt; -&gt; unit&#xA;override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="stream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="79bf5-625">Ein Bereich im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="79bf5-625">A region of memory.</span></span> <span data-ttu-id="79bf5-626">Diese Methode kopiert den Inhalt dieses Bereichs in den aktuellen Datenstrom.</span><span class="sxs-lookup"><span data-stu-id="79bf5-626">This method copies the contents of this region to the current stream.</span></span></param>
        <summary><span data-ttu-id="79bf5-627">Schreibt beim Überschreiben in einer abgeleiteten Klasse eine Folge von Bytes in den aktuellen Stream und erhöht die aktuelle Position im Stream um die Anzahl der geschriebenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="79bf5-627">When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-628">Verwenden Sie <xref:System.IO.Stream.CanWrite%2A> die-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt</span><span class="sxs-lookup"><span data-stu-id="79bf5-628">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="79bf5-629">Verwenden Sie <xref:System.IO.Stream.WriteAsync%2A> die-Methode, um asynchron in den aktuellen Stream zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="79bf5-629">Use the <xref:System.IO.Stream.WriteAsync%2A> method to write asynchronously to the current stream.</span></span>  
  
 <span data-ttu-id="79bf5-630">Wenn der Schreibvorgang erfolgreich ist, wird die Position im Stream um die Anzahl der geschriebenen Bytes fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-630">If the write operation is successful, the position within the stream advances by the number of bytes written.</span></span> <span data-ttu-id="79bf5-631">Wenn eine Ausnahme auftritt, bleibt die Position im Stream unverändert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-631">If an exception occurs, the position within the stream remains unchanged.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public abstract void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="abstract member Write : byte[] * int * int -&gt; unit" Usage="stream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="79bf5-632">Ein Bytearray.</span><span class="sxs-lookup"><span data-stu-id="79bf5-632">An array of bytes.</span></span> <span data-ttu-id="79bf5-633">Diese Methode kopiert <paramref name="count" /> Bytes aus dem <paramref name="buffer" /> in den aktuellen Stream.</span><span class="sxs-lookup"><span data-stu-id="79bf5-633">This method copies <paramref name="count" /> bytes from <paramref name="buffer" /> to the current stream.</span></span></param>
        <param name="offset"><span data-ttu-id="79bf5-634">Der nullbasierte Byteoffset im <paramref name="buffer" />, ab dem Bytes in den aktuellen Stream kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-634">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="79bf5-635">Die Anzahl an Bytes, die in den aktuellen Stream geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-635">The number of bytes to be written to the current stream.</span></span></param>
        <summary><span data-ttu-id="79bf5-636">Schreibt beim Überschreiben in einer abgeleiteten Klasse eine Folge von Bytes in den aktuellen Stream und erhöht die aktuelle Position im Stream um die Anzahl der geschriebenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="79bf5-636">When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-637">Verwenden Sie <xref:System.IO.Stream.CanWrite%2A> die-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt</span><span class="sxs-lookup"><span data-stu-id="79bf5-637">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="79bf5-638">Verwenden Sie <xref:System.IO.Stream.WriteAsync%2A> die-Methode, um asynchron in den aktuellen Stream zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="79bf5-638">Use the <xref:System.IO.Stream.WriteAsync%2A> method to write asynchronously to the current stream.</span></span>  
  
 <span data-ttu-id="79bf5-639">Wenn der Schreibvorgang erfolgreich ist, wird die Position im Stream um die Anzahl der geschriebenen Bytes fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-639">If the write operation is successful, the position within the stream advances by the number of bytes written.</span></span> <span data-ttu-id="79bf5-640">Wenn eine Ausnahme auftritt, bleibt die Position im Stream unverändert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-640">If an exception occurs, the position within the stream remains unchanged.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79bf5-641">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Pufferlänge.</span><span class="sxs-lookup"><span data-stu-id="79bf5-641">The sum of <paramref name="offset" /> and <paramref name="count" /> is greater than the buffer length.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79bf5-642"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79bf5-642"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="79bf5-643"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-643"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79bf5-644">Ein E/A-Fehler ist aufgetreten, z.B. „Die angegebene Datei kann nicht gefunden werden“.</span><span class="sxs-lookup"><span data-stu-id="79bf5-644">An I/O error occurred, such as the specified file cannot be found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79bf5-645">Der Stream unterstützt das Schreiben nicht.</span><span class="sxs-lookup"><span data-stu-id="79bf5-645">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-646"><see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> wurde aufgerufen, nachdem der Stream geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="79bf5-646"><see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> was called after the stream was closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="79bf5-647">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-647">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="79bf5-648">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="79bf5-648">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="79bf5-649">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="79bf5-649">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="79bf5-650">Schreibt eine Bytesequenz asynchron in den aktuellen Stream und setzt die aktuelle Position in diesem Stream um die Anzahl der geschriebenen Bytes nach vorn.</span><span class="sxs-lookup"><span data-stu-id="79bf5-650">Asynchronously writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="abstract member WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&#xA;override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="stream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="79bf5-651">Die Region im Arbeitsspeicher, aus der die Daten für das Schreiben gelesen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-651">The region of memory to write data from.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="79bf5-652">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-652">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="79bf5-653">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />sein.</span><span class="sxs-lookup"><span data-stu-id="79bf5-653">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="79bf5-654">Schreibt beim Überschreiben in einer abgeleiteten Klasse eine Folge von Bytes asynchron in den aktuellen Stream und erhöht die aktuelle Position im Stream um die Anzahl der geschriebenen Bytes und überwacht Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-654">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="79bf5-655">Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-655">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-656">Mit <xref:System.IO.Stream.WriteAsync%2A> der-Methode können Sie ressourcenintensive e/a-Vorgänge durchführen, ohne den Haupt Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-656">The <xref:System.IO.Stream.WriteAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="79bf5-657">Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-657">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="79bf5-658">Die Async-Methoden werden in Verbindung mit den `async` Schlüssel `await` Wörtern und in Visual Basic C#und verwendet.</span><span class="sxs-lookup"><span data-stu-id="79bf5-658">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="79bf5-659">Verwenden Sie <xref:System.IO.Stream.CanWrite%2A> die-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt</span><span class="sxs-lookup"><span data-stu-id="79bf5-659">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
 <span data-ttu-id="79bf5-660">Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die <xref:System.Threading.Tasks.TaskStatus.Canceled> zurückgegebene Aufgabe <xref:System.Threading.Tasks.Task.Status%2A> den Wert für die-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="79bf5-660">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="79bf5-661">Ein Beispiel finden Sie unter <xref:System.IO.Stream.WriteAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Überladung.</span><span class="sxs-lookup"><span data-stu-id="79bf5-661">For an example, see the <xref:System.IO.Stream.WriteAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteAsync (buffer As Byte(), offset As Integer, count As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.WriteAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task" Usage="stream.WriteAsync (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="79bf5-662">Der Puffer, aus dem Daten geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-662">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="79bf5-663">Der nullbasierte Byteoffset im <paramref name="buffer" />, ab dem Bytes in den Stream kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-663">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="79bf5-664">Die maximale Anzahl der zu schreibenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="79bf5-664">The maximum number of bytes to write.</span></span></param>
        <summary><span data-ttu-id="79bf5-665">Schreibt eine Bytesequenz asynchron in den aktuellen Stream und setzt die aktuelle Position in diesem Stream um die Anzahl der geschriebenen Bytes nach vorn.</span><span class="sxs-lookup"><span data-stu-id="79bf5-665">Asynchronously writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</span></span></summary>
        <returns><span data-ttu-id="79bf5-666">Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-666">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-667">Mit <xref:System.IO.Stream.WriteAsync%2A> der-Methode können Sie ressourcenintensive e/a-Vorgänge durchführen, ohne den Haupt Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-667">The <xref:System.IO.Stream.WriteAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="79bf5-668">Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-668">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="79bf5-669">Die Async-Methoden werden in Verbindung mit den `async` Schlüssel `await` Wörtern und in Visual Basic C#und verwendet.</span><span class="sxs-lookup"><span data-stu-id="79bf5-669">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="79bf5-670">Verwenden Sie <xref:System.IO.Stream.CanWrite%2A> die-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt</span><span class="sxs-lookup"><span data-stu-id="79bf5-670">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79bf5-671">Im folgenden Beispiel wird gezeigt, wie asynchron in eine Datei geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-671">The following example shows how to write asynchronously to a file.</span></span> <span data-ttu-id="79bf5-672">Im Beispiel wird die <xref:System.IO.FileStream> -Klasse verwendet, die von <xref:System.IO.Stream> der-Klasse abgeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-672">The example uses the <xref:System.IO.FileStream> class, which derives from the <xref:System.IO.Stream> class.</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79bf5-673"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79bf5-673"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="79bf5-674"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-674"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79bf5-675">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Pufferlänge.</span><span class="sxs-lookup"><span data-stu-id="79bf5-675">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79bf5-676">Der Stream unterstützt das Schreiben nicht.</span><span class="sxs-lookup"><span data-stu-id="79bf5-676">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-677">Der Stream wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-677">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79bf5-678">Der Stream wird zurzeit von einem vorherigen Schreibvorgang verwendet.</span><span class="sxs-lookup"><span data-stu-id="79bf5-678">The stream is currently in use by a previous write operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&#xA;override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="stream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="79bf5-679">Der Puffer, aus dem Daten geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-679">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="79bf5-680">Der nullbasierte Byteoffset im <paramref name="buffer" />, ab dem Bytes in den Stream kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="79bf5-680">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="79bf5-681">Die maximale Anzahl der zu schreibenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="79bf5-681">The maximum number of bytes to write.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="79bf5-682">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-682">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="79bf5-683">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />sein.</span><span class="sxs-lookup"><span data-stu-id="79bf5-683">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="79bf5-684">Schreibt beim Überschreiben in einer abgeleiteten Klasse eine Folge von Bytes asynchron in den aktuellen Stream und erhöht die aktuelle Position im Stream um die Anzahl der geschriebenen Bytes und überwacht Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-684">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="79bf5-685">Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-685">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-686">Mit <xref:System.IO.Stream.WriteAsync%2A> der-Methode können Sie ressourcenintensive e/a-Vorgänge durchführen, ohne den Haupt Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="79bf5-686">The <xref:System.IO.Stream.WriteAsync%2A> method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="79bf5-687">Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-687">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="79bf5-688">Die Async-Methoden werden in Verbindung mit den `async` Schlüssel `await` Wörtern und in Visual Basic C#und verwendet.</span><span class="sxs-lookup"><span data-stu-id="79bf5-688">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="79bf5-689">Verwenden Sie <xref:System.IO.Stream.CanWrite%2A> die-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt</span><span class="sxs-lookup"><span data-stu-id="79bf5-689">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
 <span data-ttu-id="79bf5-690">Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die <xref:System.Threading.Tasks.TaskStatus.Canceled> zurückgegebene Aufgabe <xref:System.Threading.Tasks.Task.Status%2A> den Wert für die-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="79bf5-690">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="79bf5-691">Ein Beispiel finden Sie unter <xref:System.IO.Stream.WriteAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Überladung.</span><span class="sxs-lookup"><span data-stu-id="79bf5-691">For an example, see the <xref:System.IO.Stream.WriteAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="79bf5-692"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="79bf5-692"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="79bf5-693"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="79bf5-693"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="79bf5-694">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Pufferlänge.</span><span class="sxs-lookup"><span data-stu-id="79bf5-694">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79bf5-695">Der Stream unterstützt das Schreiben nicht.</span><span class="sxs-lookup"><span data-stu-id="79bf5-695">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-696">Der Stream wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-696">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79bf5-697">Der Stream wird zurzeit von einem vorherigen Schreibvorgang verwendet.</span><span class="sxs-lookup"><span data-stu-id="79bf5-697">The stream is currently in use by a previous write operation.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md"><span data-ttu-id="79bf5-698">Abbruch</span><span class="sxs-lookup"><span data-stu-id="79bf5-698">Cancellation</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public virtual void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="abstract member WriteByte : byte -&gt; unit&#xA;override this.WriteByte : byte -&gt; unit" Usage="stream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="79bf5-699">Das Byte, das in den Stream geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="79bf5-699">The byte to write to the stream.</span></span></param>
        <summary><span data-ttu-id="79bf5-700">Schreibt ein Byte an die aktuellen Position im Stream und erhöht die aktuelle Position im Stream um ein Byte.</span><span class="sxs-lookup"><span data-stu-id="79bf5-700">Writes a byte to the current position in the stream and advances the position within the stream by one byte.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79bf5-701">Verwenden Sie <xref:System.IO.Stream.CanWrite%2A> die-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt</span><span class="sxs-lookup"><span data-stu-id="79bf5-701">Use the <xref:System.IO.Stream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="79bf5-702">Ein E/A-Fehler tritt auf.</span><span class="sxs-lookup"><span data-stu-id="79bf5-702">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="79bf5-703">Der Stream unterstützt keine Schreibvorgänge, oder er wurde bereits geschlossen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-703">The stream does not support writing, or the stream is already closed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="79bf5-704">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="79bf5-704">Methods were called after the stream was closed.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="79bf5-705">Die Standard Implementierung von <see langword="Stream" /> erstellt ein neues Einzel Byte Array und ruft <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />dann auf.</span><span class="sxs-lookup"><span data-stu-id="79bf5-705">The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />.</span></span> <span data-ttu-id="79bf5-706">Obwohl dies formal korrekt ist, ist es ineffizient.</span><span class="sxs-lookup"><span data-stu-id="79bf5-706">While this is formally correct, it is inefficient.</span></span> <span data-ttu-id="79bf5-707">Jeder Datenstrom mit einem internen Puffer sollte diese Methode überschreiben und eine wesentlich effizientere Version bereitstellen, die direkt in den Puffer schreibt, sodass die zusätzliche Array Zuordnung bei jedem-Befehl vermieden wird.</span><span class="sxs-lookup"><span data-stu-id="79bf5-707">Any stream with an internal buffer should override this method and provide a much more efficient version that writes to the buffer directly, avoiding the extra array allocation on every call.</span></span></para></block>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="79bf5-708">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="79bf5-708">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="79bf5-709">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="79bf5-709">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="79bf5-710">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="79bf5-710">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public virtual int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.IO.Stream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="79bf5-711">Ruft einen Wert in Millisekunden ab, der bestimmt, wie lange der Stream versucht, Schreibvorgänge durchzuführen, bevor ein Timeout auftritt, oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="79bf5-711">Gets or sets a value, in milliseconds, that determines how long the stream will attempt to write before timing out.</span></span></summary>
        <value><span data-ttu-id="79bf5-712">Ein Wert in Millisekunden, der bestimmt, wie lange der Stream versucht, Schreibvorgänge durchzuführen, bevor ein Timeout auftritt.</span><span class="sxs-lookup"><span data-stu-id="79bf5-712">A value, in milliseconds, that determines how long the stream will attempt to write before timing out.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="79bf5-713">Die <see cref="P:System.IO.Stream.WriteTimeout" />-Methode löst immer eine <see cref="T:System.InvalidOperationException" /> aus.</span><span class="sxs-lookup"><span data-stu-id="79bf5-713">The <see cref="P:System.IO.Stream.WriteTimeout" /> method always throws an <see cref="T:System.InvalidOperationException" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="79bf5-714">Die <see cref="P:System.IO.Stream.WriteTimeout" /> -Eigenschaft sollte überschrieben werden, um das entsprechende Verhalten für den Stream bereitzustellen.</span><span class="sxs-lookup"><span data-stu-id="79bf5-714">The <see cref="P:System.IO.Stream.WriteTimeout" /> property should be overridden to provide the appropriate behavior for the stream.</span></span> <span data-ttu-id="79bf5-715">Wenn der Stream keine zeitliche Überschreitung unterstützt, sollte diese Eigenschaft eine <see cref="T:System.InvalidOperationException" />-Klasse aus.</span><span class="sxs-lookup"><span data-stu-id="79bf5-715">If the stream does not support timing out, this property should raise an <see cref="T:System.InvalidOperationException" />.</span></span></para></block>
      </Docs>
    </Member>
  </Members>
</Type>
