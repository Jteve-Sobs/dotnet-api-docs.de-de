<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1eaca2d8dfd9fc38261f9fb7664ea9a4126f45f4" /><Meta Name="ms.sourcegitcommit" Value="220917117f9d774aaa482439aa7324e39dc1f5b6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/25/2019" /><Meta Name="ms.locfileid" Value="56763521" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="6ac5b-101">Führt Vorgänge für <see cref="T:System.String" />-Instanzen aus, die Datei- oder Verzeichnispfadinformationen enthalten.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-101">Performs operations on <see cref="T:System.String" /> instances that contain file or directory path information.</span></span> <span data-ttu-id="6ac5b-102">Diese Vorgänge werden plattformübergreifend durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-102">These operations are performed in a cross-platform manner.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="6ac5b-103">Ein Pfad ist eine Zeichenfolge, die den Speicherort einer Datei oder Verzeichnis bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-103">A path is a string that provides the location of a file or directory.</span></span> <span data-ttu-id="6ac5b-104">Ein Pfad verweist nicht unbedingt auf einen Speicherort auf dem Datenträger; Beispielsweise kann ein Pfad an einem Speicherort im Arbeitsspeicher oder auf einem Gerät zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-104">A path does not necessarily point to a location on disk; for example, a path might map to a location in memory or on a device.</span></span> <span data-ttu-id="6ac5b-105">Das genaue Format eines Pfads richtet sich nach der aktuellen Plattform.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-105">The exact format of a path is determined by the current platform.</span></span> <span data-ttu-id="6ac5b-106">Beispielsweise kann bei einigen Systemen ein Pfad mit einem Buchstaben Laufwerk oder Volume beginnen, während dieses Element nicht in anderen Systemen vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-106">For example, on some systems, a path can start with a drive or volume letter, while this element is not present in other systems.</span></span> <span data-ttu-id="6ac5b-107">Bei einigen Systemen können Dateipfade Erweiterungen enthalten den Typ der in der Datei gespeicherten Informationen angeben.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-107">On some systems, file paths can contain extensions, which indicate the type of information stored in the file.</span></span> <span data-ttu-id="6ac5b-108">Das Format der Erweiterung ist plattformabhängig; Klicken Sie z. B. einige Systeme beschränken Erweiterungen auf drei Zeichen, und andere nicht.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-108">The format of a file name extension is platform-dependent; for example, some systems limit extensions to three characters, and others do not.</span></span> <span data-ttu-id="6ac5b-109">Die aktuelle Plattform bestimmt auch den Satz von Zeichen verwendet, um die Elemente eines Pfads zu trennen und die Gruppe von Zeichen, die beim Angeben von Pfaden verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-109">The current platform also determines the set of characters used to separate the elements of a path, and the set of characters that cannot be used when specifying paths.</span></span> <span data-ttu-id="6ac5b-110">Aufgrund dieser Unterschiede, die Felder der `Path` sowie das genaue Verhalten einiger Member der Klasse die `Path` Klasse hängen von der Plattform ab.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-110">Because of these differences, the fields of the `Path` class as well as the exact behavior of some members of the `Path` class are platform-dependent.</span></span>  
  
 <span data-ttu-id="6ac5b-111">Ein Pfad kann absolut oder relativ Standortinformationen enthalten.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-111">A path can contain absolute or relative location information.</span></span> <span data-ttu-id="6ac5b-112">Absolute Pfade vollständig Geben Sie einen Speicherort: Datei oder des Verzeichnisses eindeutig unabhängig von der aktuellen Position identifiziert werden kann.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-112">Absolute paths fully specify a location: the file or directory can be uniquely identified regardless of the current location.</span></span> <span data-ttu-id="6ac5b-113">Relative Pfade geben Sie einen teilweise Ort: der aktuelle Speicherort dient als Ausgangspunkt beim Suchen einer Datei mit einem relativen Pfad angegeben.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-113">Relative paths specify a partial location: the current location is used as the starting point when locating a file specified with a relative path.</span></span> <span data-ttu-id="6ac5b-114">Um das aktuelle Verzeichnis zu ermitteln, rufen <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-114">To determine the current directory, call <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span></span>  

 <span data-ttu-id="6ac5b-115">.NET Core 1.1 und höher und .NET Framework 4.6.2 und höher unterstützen auch den Zugriff auf Dateisystemobjekte, die Namen der Geräte, wie z. B. "\\? \C:\".</span><span class="sxs-lookup"><span data-stu-id="6ac5b-115">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support access to file system objects that are device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="6ac5b-116">Weitere Informationen zu Path-Dateiformaten in Windows finden Sie unter [Pfad Dateiformate auf Windows-Systemen](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-116">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span>

 <span data-ttu-id="6ac5b-117">Die meisten Personen in der `Path` Klasse nicht mit dem Dateisystem und das Vorhandensein von einer Pfadzeichenfolge für den angegebene Datei nicht überprüfen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-117">Most members of the `Path` class do not interact with the file system and do not verify the existence of the file specified by a path string.</span></span> <span data-ttu-id="6ac5b-118">`Path` Klassenmember, die eine Pfadzeichenfolge, z. B. ändern <xref:System.IO.Path.ChangeExtension%2A>, wirken sich nicht auf den Namen der Dateien im Dateisystem.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-118">`Path` class members that modify a path string, such as <xref:System.IO.Path.ChangeExtension%2A>, have no effect on names of files in the file system.</span></span> <span data-ttu-id="6ac5b-119">`Path` Elemente, jedoch überprüft den Inhalt einer angegebenen Pfadzeichenfolge und löst eine <xref:System.ArgumentException> -Ausnahme aus, wenn die Zeichenfolge Zeichen, die nicht in Pfadzeichenfolgen gültig sind, die enthält von zurückgegebenen Zeichen gemäß der <xref:System.IO.Path.GetInvalidPathChars%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-119">`Path` members do, however, validate the contents of a specified path string, and throw an <xref:System.ArgumentException> exception if the string contains characters that are not valid in path strings, as defined in the characters returned from the <xref:System.IO.Path.GetInvalidPathChars%2A> method.</span></span> <span data-ttu-id="6ac5b-120">Beispielsweise auf Windows-basierten desktop-Plattformen, ungültige Pfadzeichen sind Anführungszeichen ("), kleiner als (\<), größer als (>), Pipe (&#124;), Rücktaste (\b), Null (\0) und Unicode-Zeichen 16 bis 18 und 20 bis 25.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-120">For example, on Windows-based desktop platforms, invalid path characters might include quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0), and Unicode characters 16 through 18 and 20 through 25.</span></span>  
  
 <span data-ttu-id="6ac5b-121">Die Mitglieder der `Path` Klasse ermöglichen es Ihnen, schnell und einfach Ausführen allgemeiner Vorgänge wie z. B. ermitteln, ob eine Dateinamenerweiterung Teil eines Pfads ist, und Kombinieren von zwei Zeichenfolgen in einem Pfadnamen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-121">The members of the `Path` class enable you to quickly and easily perform common operations such as determining whether a file name extension is part of a path, and combining two strings into one path name.</span></span>  
  
 <span data-ttu-id="6ac5b-122">Alle Mitglieder der `Path` -Klasse sind statisch und können daher ohne eine Instanz eines Pfads aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-122">All members of the `Path` class are static and can therefore be called without having an instance of a path.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6ac5b-123">Klicken Sie im Member, die einen Pfad als eine Eingabezeichenfolge akzeptieren, dass der Pfad muss wohlgeformt sein, oder eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-123">In members that accept a path as an input string, that path must be well-formed or an exception is raised.</span></span> <span data-ttu-id="6ac5b-124">Wenn ein Pfad vollständig qualifiziert ist, aber mit einem Leerzeichen beginnt, wird der Pfad beispielsweise nicht in Methoden der Klasse gekürzt.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-124">For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class.</span></span> <span data-ttu-id="6ac5b-125">Aus diesem Grund wird der Pfad ist falsch formatiert, und wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-125">Therefore, the path is malformed and an exception is raised.</span></span> <span data-ttu-id="6ac5b-126">Auf ähnliche Weise kann keinen Pfad oder eine Kombination von Pfaden zweimal vollqualifiziert sein.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-126">Similarly, a path or a combination of paths cannot be fully qualified twice.</span></span> <span data-ttu-id="6ac5b-127">Eine Ausnahme in den meisten Fällen wird in "c:\temp c:\windows" z. B. auch auslöst.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-127">For example, "c:\temp c:\windows" also raises an exception in most cases.</span></span> <span data-ttu-id="6ac5b-128">Stellen Sie sicher, dass die Pfade wohlgeformt sind, bei Verwendung von Methoden, die eine Pfadzeichenfolge akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-128">Ensure that your paths are well-formed when using methods that accept a path string.</span></span>  
  
 <span data-ttu-id="6ac5b-129">Bei Membern, die einen Pfad zu akzeptieren, kann der Pfad zu einer Datei oder nur ein Verzeichnis verweisen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-129">In members that accept a path, the path can refer to a file or just a directory.</span></span> <span data-ttu-id="6ac5b-130">Der angegebene Pfad kann auch auf einen relativen Pfad oder ein Universal Naming Convention (UNC)-Pfad für den Namen eines Servers und der freigabeeinstellungen verweisen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-130">The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name.</span></span> <span data-ttu-id="6ac5b-131">Beispielsweise sind alle folgenden Pfade zulässig:</span><span class="sxs-lookup"><span data-stu-id="6ac5b-131">For example, all the following are acceptable paths:</span></span>  
  
-   <span data-ttu-id="6ac5b-132">"c:\\\MyDir\\\MyFile.txt" in C#- oder "c:\MyDir\MyFile.txt" in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-132">"c:\\\MyDir\\\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="6ac5b-133">"c:\\\MyDir" in C#- oder "c:\MyDir" in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-133">"c:\\\MyDir" in C#, or "c:\MyDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="6ac5b-134">"" MyDir "\\\MySubdir" in C#- oder "MyDir\MySubDir" in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-134">"MyDir\\\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="6ac5b-135">"\\\\\\\MyServer\\\MyShare" in c# oder "\\\MyServer\MyShare" in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-135">"\\\\\\\MyServer\\\MyShare" in C#, or "\\\MyServer\MyShare" in Visual Basic.</span></span>  
  
 <span data-ttu-id="6ac5b-136">Da alle diese Vorgänge für Zeichenfolgen ausgeführt werden, ist es unmöglich, stellen Sie sicher, dass die Ergebnisse in allen Szenarien gültig sind.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-136">Because all these operations are performed on strings, it is impossible to verify that the results are valid in all scenarios.</span></span> <span data-ttu-id="6ac5b-137">Z. B. die <xref:System.IO.Path.GetExtension%2A> -Methode analysiert eine Zeichenfolge, die an sie übergeben werden, und gibt die Erweiterung aus dieser Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-137">For example, the <xref:System.IO.Path.GetExtension%2A> method parses a string that you pass to it and returns the extension from that string.</span></span> <span data-ttu-id="6ac5b-138">Dies bedeutet jedoch nicht, dass eine Datei mit dieser Erweiterung auf dem Datenträger vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-138">However, this does not mean that a file with that extension exists on the disk.</span></span>  
  
 <span data-ttu-id="6ac5b-139">Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-139">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>   
  
## Examples  
 <span data-ttu-id="6ac5b-140">Das folgende Beispiel zeigt einige der wichtigsten Elemente der `Path` Klasse.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-140">The following example demonstrates some of the main members of the `Path` class.</span></span>  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6ac5b-141">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="6ac5b-141">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6ac5b-142">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-142">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6ac5b-143">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-143">How to: Write Text to a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md"><span data-ttu-id="6ac5b-144">Gewusst wie: Lesen und Schreiben einer neu erstellten Datendatei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-144">How to: Read and Write to a Newly Created Data File</span></span></related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-145">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-145">File path formats on Windows systems</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6ac5b-146">Stellt ein plattformspezifisches, alternatives Zeichen bereit, das zur Trennung von Verzeichnisebenen in einer Pfadzeichenfolge verwendet wird und eine hierarchische Dateisystemorganisation wiedergibt.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-146">Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="6ac5b-147">In diesem Feld haben den gleichen Wert wie <xref:System.IO.Path.DirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-147">This field can have the same value as <xref:System.IO.Path.DirectorySeparatorChar>.</span></span> <span data-ttu-id="6ac5b-148">`AltDirectorySeparatorChar` und <xref:System.IO.Path.DirectorySeparatorChar> gelten sowohl für die Trennung von Verzeichnisebenen in einer Pfadzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-148">`AltDirectorySeparatorChar` and <xref:System.IO.Path.DirectorySeparatorChar> are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="6ac5b-149">Der Wert dieses Felds ist ein Schrägstrich ("/") auf Windows und Unix-Betriebssystemen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-149">The value of this field is a slash ('/') on both Windows and Unix-based operating systems.</span></span>  
  
## Examples  

<span data-ttu-id="6ac5b-150">Das folgende Beispiel zeigt <xref:System.IO.Path> Feldwerte auf Windows und Unix-basierte Systeme.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-150">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="6ac5b-151">Beachten Sie, dass Windows entweder den Schrägstrich unterstützt (die von zurückgegeben wird die <xref:System.IO.Path.AltDirectorySeparatorChar> Feld) oder den umgekehrten Schrägstrich (die von zurückgegeben wird die <xref:System.IO.Path.DirectorySeparatorChar> Feld) als Trennzeichen Pfadzeichen, während der Unix-basierten Systemen nur einen Schrägstrich unterstützen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-151">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6ac5b-152">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="6ac5b-152">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6ac5b-153">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-153">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6ac5b-154">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-154">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6ac5b-155">Die zu ändernden Pfadinformationen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-155">The path information to modify.</span></span> <span data-ttu-id="6ac5b-156">Der Pfad darf keines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten Zeichen enthalten.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-156">The path cannot contain any of the characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></param>
        <param name="extension"><span data-ttu-id="6ac5b-157">Die neue Erweiterung (mit oder ohne führenden Punkt).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-157">The new extension (with or without a leading period).</span></span> <span data-ttu-id="6ac5b-158">Geben Sie <see langword="null" /> an, um eine vorhandene Erweiterung aus <paramref name="path" /> zu entfernen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-158">Specify <see langword="null" /> to remove an existing extension from <paramref name="path" />.</span></span></param>
        <summary><span data-ttu-id="6ac5b-159">Ändert die Erweiterung einer Pfadzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-159">Changes the extension of a path string.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-160">Die geänderten Pfadinformationen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-160">The modified path information.</span></span>  
  
<span data-ttu-id="6ac5b-161">Auf Desktopplattformen auf Grundlage von Windows werden die Pfadinformationen unverändert zurückgegeben, wenn <paramref name="path" /> <see langword="null" /> oder eine leere Zeichenfolge ("") ist.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-161">On Windows-based desktop platforms, if <paramref name="path" /> is <see langword="null" /> or an empty string (""), the path information is returned unmodified.</span></span> <span data-ttu-id="6ac5b-162">Wenn <paramref name="extension" /><see langword="null" /> ist, enthält die zurückgegebene Zeichenfolge den angegebenen Pfad ohne die Erweiterung.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-162">If <paramref name="extension" /> is <see langword="null" />, the returned string contains the specified path with its extension removed.</span></span> <span data-ttu-id="6ac5b-163">Wenn <paramref name="path" /> keine Erweiterung besitzt und <paramref name="extension" /> nicht <see langword="null" /> ist, enthält die zurückgegebene Pfadzeichenfolge <paramref name="extension" />, angefügt an das Ende von <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-163">If <paramref name="path" /> has no extension, and <paramref name="extension" /> is not <see langword="null" />, the returned path string contains <paramref name="extension" /> appended to the end of <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6ac5b-164">Wenn weder `path` noch `extension` enthält einen Punkt (.), `ChangeExtension` fügt den Punkt hinzu.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-164">If neither `path` nor `extension` contains a period (.), `ChangeExtension` adds the period.</span></span>  
  
 <span data-ttu-id="6ac5b-165">Die `extension` Parameter kann mehrere Punkte und keine gültigen Pfad-Zeichen enthalten und kann eine beliebige Länge aufweisen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-165">The `extension` parameter can contain multiple periods and any valid path characters, and can be any length.</span></span> <span data-ttu-id="6ac5b-166">Wenn `extension` ist `null`, die zurückgegebene Zeichenfolge enthält den Inhalt der `path` mit den letzten Punkt und alle folgenden Zeichen entfernt.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-166">If `extension` is `null`, the returned string contains the contents of `path` with the last period and all characters following it removed.</span></span>  
  
 <span data-ttu-id="6ac5b-167">Wenn `extension` ist eine leere Zeichenfolge, die zurückgegebene Pfadzeichenfolge enthält den Inhalt der `path` mit jedem Zeichen, die nach dem letzten Punkt entfernt.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-167">If `extension` is an empty string, the returned path string contains the contents of `path` with any characters following the last period removed.</span></span>  
  
 <span data-ttu-id="6ac5b-168">Wenn `path` verfügt nicht über eine Erweiterung und `extension` nicht `null`, enthält die zurückgegebene Zeichenfolge `path` gefolgt von `extension`.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-168">If `path` does not have an extension and `extension` is not `null`, the returned string contains `path` followed by `extension`.</span></span>  
  
 <span data-ttu-id="6ac5b-169">Wenn `extension` nicht `null` und enthält keine führenden Punkt, der Zeitraum hinzugefügt wird.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-169">If `extension` is not `null` and does not contain a leading period, the period is added.</span></span>  
  
 <span data-ttu-id="6ac5b-170">Wenn `path` eine mehrfache Erweiterung durch mehrere Punkte getrennt, enthält die zurückgegebene Zeichenfolge enthält den Inhalt der `path` mit den letzten Punkt und alle folgenden Zeichen durch ersetzt `extension`.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-170">If `path` contains a multiple extension separated by multiple periods, the returned string contains the contents of `path` with the last period and all characters following it replaced by `extension`.</span></span> <span data-ttu-id="6ac5b-171">Z. B. wenn `path` "\Dir1\examples\pathtests.csx.txt" und `extension` "Cs", ist des geänderten Pfads "\Dir1\examples\pathtests.csx.cs".</span><span class="sxs-lookup"><span data-stu-id="6ac5b-171">For example, if `path` is "\Dir1\examples\pathtests.csx.txt" and `extension` is "cs", the modified path is "\Dir1\examples\pathtests.csx.cs".</span></span>  
  
 <span data-ttu-id="6ac5b-172">Es ist nicht möglich, um sicherzustellen, dass die zurückgegebenen Ergebnisse in allen Szenarien gültig sind.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-172">It is not possible to verify that the returned results are valid in all scenarios.</span></span> <span data-ttu-id="6ac5b-173">Z. B. wenn `path` ist leer, `extension` angefügt wird.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-173">For example, if `path` is empty, `extension` is appended.</span></span>  
  
 <span data-ttu-id="6ac5b-174">Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-174">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6ac5b-175">Das folgende Beispiel veranschaulicht die Verwendung des der `ChangeExtension` Methode.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-175">The following example demonstrates a use of the `ChangeExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6ac5b-176"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-176"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-177">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-177">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6ac5b-178">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="6ac5b-178">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6ac5b-179">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-179">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6ac5b-180">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-180">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6ac5b-181">Kombiniert Zeichenfolgen zu einem Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-181">Combines strings into a path.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="6ac5b-182">Diese Methode ist vorgesehen, um die einzelne Zeichenfolgen in einer einzelnen Zeichenfolge zu verketten, die einen Dateipfad darstellt.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-182">This method is intended to concatenate individual strings into a single string that represents a file path.</span></span> <span data-ttu-id="6ac5b-183">Wenn nicht das erste Argument um einen Stammpfad enthält, allerdings werden alle vorherigen Pfadkomponenten ignoriert, und die zurückgegebene Zeichenfolge beginnt mit dieser Komponente Stammpfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-183">However, if an argument other than the first contains a rooted path, any previous path components are ignored, and the returned string begins with that rooted path component.</span></span> <span data-ttu-id="6ac5b-184">Als Alternative zu den `Combine` -Methode, erwägen Sie die Verwendung der <xref:System.IO.Path.Join%2A> oder <xref:System.IO.Path.TryJoin%2A> Methoden.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-184">As an alternative to the `Combine` method, consider using the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> methods.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="6ac5b-185">Diese Methode wird davon ausgegangen, dass das erste Argument ein absoluter Pfad ist und die folgenden Argumente oder Argumente relative Pfade sind.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-185">This method assumes that the first argument is an absolute path and that the following argument or arguments are relative paths.</span></span> <span data-ttu-id="6ac5b-186">Wenn dies nicht der Fall ist, und insbesondere, wenn nachfolgende Argumente, Zeichenfolgen, die vom Benutzer eingegebene sind, rufen Sie die <xref:System.IO.Path.Join%2A> oder <xref:System.IO.Path.TryJoin%2A> Methode stattdessen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-186">If this is not the case, and particularly if any subsequent arguments are strings input by the user, call the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> method instead.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths"><span data-ttu-id="6ac5b-187">Ein Array der Teile des Pfads.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-187">An array of parts of the path.</span></span></param>
        <summary><span data-ttu-id="6ac5b-188">Kombiniert ein Array von Zeichenfolgen zu einem Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-188">Combines an array of strings into a path.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-189">Die kombinierten Pfade.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-189">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="6ac5b-190">`paths` sollte ein Array der Teile der zu kombinierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-190">`paths` should be an array of the parts of the path to combine.</span></span> <span data-ttu-id="6ac5b-191">Wenn eine der nachfolgenden Pfade ein absoluter Pfad ist, setzt der Gruppierungsvorgang durchgeführt, beginnend mit diesem absoluten Pfad, verwerfen alle vorherigen kombinierten Pfade.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-191">If the one of the subsequent paths is an absolute path, then the combine operation resets starting with that absolute path, discarding all previous combined paths.</span></span>  

<span data-ttu-id="6ac5b-192">Wenn jedes Element in `paths` jedoch die letzte Lektion ist kein Laufwerk, und endet nicht mit der <xref:System.IO.Path.DirectorySeparatorChar> oder die <xref:System.IO.Path.AltDirectorySeparatorChar> Zeichen, die `Combine` Methode fügt eine <xref:System.IO.Path.DirectorySeparatorChar> zwischen diesem Element und den darauffolgenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-192">If any element in `paths` but the last one is not a drive and does not end with either the <xref:System.IO.Path.DirectorySeparatorChar> or the <xref:System.IO.Path.AltDirectorySeparatorChar> character, the `Combine` method adds a <xref:System.IO.Path.DirectorySeparatorChar> character between that element and the next one.</span></span> <span data-ttu-id="6ac5b-193">Beachten Sie, dass, wenn das Element in einem Pfadtrennzeichen beendet wird, die nicht geeignet für die Zielplattform ist die `Combine` Methode behält die ursprünglichen Pfadtrennzeichen und fügt Sie unterstützte Formate.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-193">Note that, if the element ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="6ac5b-194">Im folgenden Beispiel wird das Ergebnis auf Windows und Unix-basierte Systeme, bei der umgekehrten Schrägstrich als eine Pfadtrennzeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-194">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 <span data-ttu-id="6ac5b-195">Leere Zeichenfolgen werden aus den kombinierten Pfad weggelassen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-195">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="6ac5b-196">Wenn sie Leerzeichen haben die Parameter nicht analysiert.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-196">The parameters are not parsed if they have white space.</span></span>  
  
 <span data-ttu-id="6ac5b-197">Nicht alle für Verzeichnis-und Dateinamen ungültige Zeichen interpretiert werden als inakzeptabel ist, indem die `Combine` -Methode, da Sie diese Zeichen nach den Platzhalterzeichen suchen können.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-197">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="6ac5b-198">Während beispielsweise `Path.Combine("c:\\", "*.txt")` ist möglicherweise ungültig würden Sie eine Datei erstellen, es gilt als eine Suchzeichenfolge ein.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-198">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="6ac5b-199">Es ist daher erfolgreich von interpretiert die `Combine` Methode.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-199">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
## Examples  
 <span data-ttu-id="6ac5b-200">Das folgende Beispiel kombiniert ein Array von Zeichenfolgen zu einem Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-200">The following example combines an array of strings into a path.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6ac5b-201">Eine der Zeichenfolgen im Array enthält eines oder mehrere der ungültigen Zeichen, die in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definiert sind.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-201">One of the strings in the array contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6ac5b-202">Eine der Zeichenfolgen im Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-202">One of the strings in the array is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-203">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-203">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" />
        <Parameter Name="path2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="6ac5b-204">Der erste zu kombinierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-204">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="6ac5b-205">Der zweite zu kombinierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-205">The second path to combine.</span></span></param>
        <summary><span data-ttu-id="6ac5b-206">Kombiniert zwei Zeichenfolgen zu einem Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-206">Combines two strings into a path.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-207">Die kombinierten Pfade.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-207">The combined paths.</span></span> <span data-ttu-id="6ac5b-208">Wenn einer der beiden angegebenen Pfade eine Zeichenfolge der Länge 0 ist, gibt diese Methode den anderen Pfad zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-208">If one of the specified paths is a zero-length string, this method returns the other path.</span></span> <span data-ttu-id="6ac5b-209">Wenn <paramref name="path2" /> einen absoluten Pfad enthält, gibt diese Methode <paramref name="path2" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-209">If <paramref name="path2" /> contains an absolute path, this method returns <paramref name="path2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6ac5b-210">Wenn `path1` ist kein Laufwerkverweis (d. h. "C:" oder "D:") und endet nicht mit einem gültigen Trennzeichen, gemäß <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, oder <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> wird angefügt `path1` vor der Verkettung.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-210">If `path1` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` before concatenation.</span></span> <span data-ttu-id="6ac5b-211">Beachten Sie, dass bei `path1` endet in einem Pfadtrennzeichen, die nicht geeignet für die Zielplattform ist die `Combine` Methode behält die ursprünglichen Pfadtrennzeichen und fügt Sie unterstützte Formate.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-211">Note that if `path1` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="6ac5b-212">Im folgenden Beispiel wird das Ergebnis auf Windows und Unix-basierte Systeme, bei der umgekehrten Schrägstrich als eine Pfadtrennzeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-212">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 <span data-ttu-id="6ac5b-213">Wenn `path2` enthält keinen Stamm (z. B. wenn `path2` beginnt nicht mit einem Trennzeichen oder eine Laufwerkangabe), das Ergebnis ist eine Verkettung der beiden Pfade mit einem Trennzeichen dazwischen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-213">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="6ac5b-214">Wenn `path2` ein Stammverzeichnis enthält, `path2` zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-214">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="6ac5b-215">Wenn sie Leerzeichen haben die Parameter nicht analysiert.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-215">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="6ac5b-216">Aus diesem Grund Wenn `path2` enthält Leerzeichen (z. B. "\file.txt"), die <xref:System.IO.Path.Combine%2A> Methode fügt `path2` zu `path1` anstatt nur `path2`.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-216">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1` instead of returning only `path2`.</span></span>  
  
 <span data-ttu-id="6ac5b-217">Nicht alle für Verzeichnis-und Dateinamen ungültige Zeichen interpretiert werden als inakzeptabel ist, indem die `Combine` -Methode, da Sie diese Zeichen nach den Platzhalterzeichen suchen können.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-217">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="6ac5b-218">Während beispielsweise `Path.Combine("c:\\", "*.txt")` ist möglicherweise ungültig würden Sie eine Datei erstellen, es gilt als eine Suchzeichenfolge ein.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-218">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="6ac5b-219">Es ist daher erfolgreich von interpretiert die `Combine` Methode.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-219">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
 <span data-ttu-id="6ac5b-220">Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-220">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6ac5b-221">Das folgende Beispiel veranschaulicht die Verwendung der `Combine` Methode für eine Windows-basierte desktop-Plattform.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-221">The following example demonstrates using the `Combine` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6ac5b-222"><paramref name="path1" /> oder <paramref name="path2" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-222"><paramref name="path1" /> or <paramref name="path2" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6ac5b-223"><paramref name="path1" /> oder <paramref name="path2" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-223"><paramref name="path1" /> or <paramref name="path2" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-224">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-224">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6ac5b-225">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="6ac5b-225">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6ac5b-226">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-226">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6ac5b-227">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-227">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" />
        <Parameter Name="path2" Type="System.String" />
        <Parameter Name="path3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="6ac5b-228">Der erste zu kombinierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-228">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="6ac5b-229">Der zweite zu kombinierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-229">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="6ac5b-230">Der dritte zu kombinierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-230">The third path to combine.</span></span></param>
        <summary><span data-ttu-id="6ac5b-231">Kombiniert drei Zeichenfolgen zu einem Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-231">Combines three strings into a path.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-232">Die kombinierten Pfade.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-232">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6ac5b-233">`path1` sollte ein absoluter Pfad sein (z. B. "d:\archives" oder "\\\archives\public").</span><span class="sxs-lookup"><span data-stu-id="6ac5b-233">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").</span></span> <span data-ttu-id="6ac5b-234">Wenn `path2` oder `path3` ist auch ein absoluter Pfad sein, kombinieren Vorgang verwirft alle zuvor kombiniert Pfade und Zurücksetzen von Kennwörtern zu diesem absoluten Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-234">If `path2` or `path3` is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="6ac5b-235">Leere Zeichenfolgen werden aus den kombinierten Pfad weggelassen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-235">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="6ac5b-236">Wenn `path1` oder `path2` ist kein Laufwerkverweis (d. h. "C:" oder "D:") und endet nicht mit einem gültigen Trennzeichen, gemäß <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, oder <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> wird angefügt `path1` oder `path2` vor der Verkettung.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-236">If `path1` or `path2` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` or `path2` before concatenation.</span></span> <span data-ttu-id="6ac5b-237">Beachten Sie, dass bei `path1` oder `path2` endet in einem Pfadtrennzeichen, die nicht geeignet für die Zielplattform ist die `Combine` Methode behält die ursprünglichen Pfadtrennzeichen und fügt Sie unterstützte Formate.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-237">Note that if `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="6ac5b-238">Im folgenden Beispiel wird das Ergebnis auf Windows und Unix-basierte Systeme, bei der umgekehrten Schrägstrich als eine Pfadtrennzeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-238">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 <span data-ttu-id="6ac5b-239">Wenn `path2` enthält keinen Stamm (z. B. wenn `path2` beginnt nicht mit einem Trennzeichen oder eine Laufwerkangabe), das Ergebnis ist eine Verkettung der beiden Pfade mit einem Trennzeichen dazwischen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-239">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="6ac5b-240">Wenn `path2` ein Stammverzeichnis enthält, `path2` zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-240">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="6ac5b-241">Wenn sie Leerzeichen haben die Parameter nicht analysiert.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-241">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="6ac5b-242">Aus diesem Grund Wenn `path2` enthält Leerzeichen (z. B. "\file.txt"), die <xref:System.IO.Path.Combine%2A> Methode fügt `path2` zu `path1`.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-242">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="6ac5b-243">Nicht alle für Verzeichnis-und Dateinamen ungültige Zeichen interpretiert werden als inakzeptabel ist, indem die `Combine` -Methode, da Sie diese Zeichen nach den Platzhalterzeichen suchen können.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-243">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="6ac5b-244">Während beispielsweise `Path.Combine("c:\\", "*.txt")` ist möglicherweise ungültig würden Sie eine Datei erstellen, es gilt als eine Suchzeichenfolge ein.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-244">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="6ac5b-245">Es ist daher erfolgreich von interpretiert die `Combine` Methode.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-245">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6ac5b-246">Das folgende Beispiel kombiniert die Pfade an.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-246">The following example combines three paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6ac5b-247"><paramref name="path1" />, <paramref name="path2" /> oder <paramref name="path3" /> enthält mindestens ein ungültiges Zeichen gemäß der Definition in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-247"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6ac5b-248"><paramref name="path1" />, <paramref name="path2" /> oder <paramref name="path3" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-248"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-249">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-249">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" />
        <Parameter Name="path2" Type="System.String" />
        <Parameter Name="path3" Type="System.String" />
        <Parameter Name="path4" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="6ac5b-250">Der erste zu kombinierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-250">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="6ac5b-251">Der zweite zu kombinierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-251">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="6ac5b-252">Der dritte zu kombinierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-252">The third path to combine.</span></span></param>
        <param name="path4"><span data-ttu-id="6ac5b-253">Der vierte zu kombinierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-253">The fourth path to combine.</span></span></param>
        <summary><span data-ttu-id="6ac5b-254">Kombiniert vier Zeichenfolgen zu einem Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-254">Combines four strings into a path.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-255">Die kombinierten Pfade.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-255">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6ac5b-256">`path1` sollte ein absoluter Pfad sein (z. B. "d:\archives" oder "\\\archives\public"). Wenn einer der folgenden Pfade auch einen absoluten Pfad ist, wird der Gruppierungsvorgang durchgeführt verwirft alle zuvor kombinierten Pfade, und klicken Sie auf diesem absoluten Pfad zurückgesetzt.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-256">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").If one of the subsequent paths is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="6ac5b-257">Leere Zeichenfolgen werden aus den kombinierten Pfad weggelassen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-257">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="6ac5b-258">Wenn `path1`, `path2`, oder `path3` ist kein Laufwerkverweis (d. h. "C:" oder "D:") und endet nicht mit einem gültigen Trennzeichen, gemäß <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, oder <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> angefügt ist vor der Verkettung.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-258">If `path1`, `path2`, or `path3` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to it before concatenation.</span></span> <span data-ttu-id="6ac5b-259">Beachten Sie, dass bei `path1`, `path2`, oder `path3` endet in einem Pfadtrennzeichen, die nicht geeignet für die Zielplattform ist die `Combine` Methode behält die ursprünglichen Pfadtrennzeichen und fügt Sie unterstützte Formate.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-259">Note that if `path1`, `path2`, or `path3` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="6ac5b-260">Im folgenden Beispiel wird das Ergebnis auf Windows und Unix-basierte Systeme, bei der umgekehrten Schrägstrich als eine Pfadtrennzeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-260">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 <span data-ttu-id="6ac5b-261">Wenn `path2` enthält keinen Stamm (z. B. wenn `path2` beginnt nicht mit einem Trennzeichen oder eine Laufwerkangabe), das Ergebnis ist eine Verkettung der beiden Pfade mit einem Trennzeichen dazwischen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-261">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="6ac5b-262">Wenn `path2` ein Stammverzeichnis enthält, `path2` zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-262">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="6ac5b-263">Wenn sie Leerzeichen haben die Parameter nicht analysiert.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-263">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="6ac5b-264">Aus diesem Grund Wenn `path2` enthält Leerzeichen (z. B. "\file.txt"), die <xref:System.IO.Path.Combine%2A> Methode fügt `path2` zu `path1`.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-264">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="6ac5b-265">Nicht alle für Verzeichnis-und Dateinamen ungültige Zeichen interpretiert werden als inakzeptabel ist, indem die `Combine` -Methode, da Sie diese Zeichen nach den Platzhalterzeichen suchen können.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-265">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="6ac5b-266">Während beispielsweise `Path.Combine("c:\\", "*.txt")` ist möglicherweise ungültig würden Sie eine Datei erstellen, es gilt als eine Suchzeichenfolge ein.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-266">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="6ac5b-267">Es ist daher erfolgreich von interpretiert die `Combine` Methode.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-267">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6ac5b-268">Im folgende Beispiel werden vier Pfade kombiniert.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-268">The following example combines four paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6ac5b-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> oder <paramref name="path4" /> enthält mindestens ein ungültiges Zeichen gemäß der Definition in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6ac5b-270"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> oder <paramref name="path4" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-270"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-271">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-271">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6ac5b-272">Stellt ein plattformspezifisches Zeichen bereit, das zur Trennung von Verzeichnisebenen in einer Pfadzeichenfolge verwendet wird und eine hierarchische Dateisystemorganisation wiedergibt.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-272">Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="6ac5b-273"><xref:System.IO.Path.AltDirectorySeparatorChar> und `DirectorySeparatorChar` gelten sowohl für die Trennung von Verzeichnisebenen in einer Pfadzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-273"><xref:System.IO.Path.AltDirectorySeparatorChar> and `DirectorySeparatorChar` are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="6ac5b-274">Wenn Sie .NET Core verwenden zum Entwickeln von Anwendungen, die auf mehreren Plattformen ausgeführt werden:</span><span class="sxs-lookup"><span data-stu-id="6ac5b-274">When you are using .NET Core to develop applications that run on multiple platforms:</span></span>

- <span data-ttu-id="6ac5b-275">Wenn Sie, das Verzeichnistrennzeichen zu programmieren lieber, verwenden Sie einen Schrägstrich (`/`) Zeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-275">If you prefer to hard-code the directory separator character, you should use the forward slash (`/`) character.</span></span> <span data-ttu-id="6ac5b-276">Dabei handelt es sich dem nur bekannte Verzeichnistrennzeichen auf Unix-Systemen, wie die Ausgabe des Beispiels zeigt, ist die <xref:System.IO.Path.AltDirectorySeparatorChar> auf Windows.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-276">It is the only recognized directory separator character on Unix systems, as the output from the example shows, and is the <xref:System.IO.Path.AltDirectorySeparatorChar> on Windows.</span></span>

- <span data-ttu-id="6ac5b-277">Verwenden Sie Verketten von Zeichenfolgen, um dynamisch das Pfadtrennzeichen zur Laufzeit abrufen und in Dateisystempfaden einbinden.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-277">Use string concatenation to dynamically retrieve the path separator character at runtime and incorporate it into file system paths.</span></span> <span data-ttu-id="6ac5b-278">Ein auf ein Objekt angewendeter</span><span class="sxs-lookup"><span data-stu-id="6ac5b-278">For example,</span></span> 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```
   ```vb
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ``` 
   <span data-ttu-id="6ac5b-279">Sie können auch abrufen, den Wert aus der <xref:System.IO.Path.AltDirectorySeparatorChar> -Eigenschaft, da es auf Windows und Unx-basierte Systeme identisch ist.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-279">You can also retrieve the value from the <xref:System.IO.Path.AltDirectorySeparatorChar> property, since it is the same on both Windows and Unx-based systems.</span></span>

- <span data-ttu-id="6ac5b-280">Abrufen der <xref:System.IO.Path.AltDirectorySeparatorChar> Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="6ac5b-280">Retrieve the <xref:System.IO.Path.AltDirectorySeparatorChar> property</span></span>

<span data-ttu-id="6ac5b-281">Wenn Ihre Anwendung nicht plattformübergreifend ist, können Sie das Trennzeichen, die für Ihr Betriebssystem.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-281">If your application is not cross-platform, you can use the separator appropriate for your system.</span></span>

## Examples  

<span data-ttu-id="6ac5b-282">Das folgende Beispiel zeigt <xref:System.IO.Path> Feldwerte auf Windows und Unix-basierte Systeme.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-282">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="6ac5b-283">Beachten Sie, dass Windows entweder den Schrägstrich unterstützt (die von zurückgegeben wird die <xref:System.IO.Path.AltDirectorySeparatorChar> Feld) oder den umgekehrten Schrägstrich (die von zurückgegeben wird die <xref:System.IO.Path.DirectorySeparatorChar> Feld) als Trennzeichen Pfadzeichen, während der Unix-basierten Systemen nur einen Schrägstrich unterstützen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-283">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6ac5b-284">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="6ac5b-284">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-285">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-285">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6ac5b-286">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-286">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6ac5b-287">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-287">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary><span data-ttu-id="6ac5b-288">Gibt die Verzeichnisinformationen für den angegebenen Pfad in Form einer Zeichenspanne zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-288">Returns the directory information for the specified path represented by a character span.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-289">Verzeichnisinformationen für <paramref name="path" /> oder eine leere Spanne, wenn <paramref name="path" /> <see langword="null" /> ist, eine leere Spanne oder ein Stamm (wie \, C: oder \\server\share).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-289">Directory information for <paramref name="path" />, or an empty span if <paramref name="path" /> is <see langword="null" />, an empty span, or a root (such as \, C:, or \\server\share).</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-290">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-290">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6ac5b-291">Der Pfad einer Datei oder eines Verzeichnisses.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-291">The path of a file or directory.</span></span></param>
        <summary><span data-ttu-id="6ac5b-292">Gibt die Verzeichnisinformationen für die angegebene Pfadzeichenfolge zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-292">Returns the directory information for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-293">Verzeichnisinformationen für <paramref name="path" /> oder <see langword="null" />, wenn <paramref name="path" /> ein Stammverzeichnis bezeichnet oder NULL ist.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-293">Directory information for <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> denotes a root directory or is null.</span></span> <span data-ttu-id="6ac5b-294">Gibt <see cref="F:System.String.Empty" /> zurück, wenn <paramref name="path" /> keine Verzeichnisinformationen enthält.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-294">Returns <see cref="F:System.String.Empty" /> if <paramref name="path" /> does not contain directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6ac5b-295">In den meisten Fällen, die von dieser Methode zurückgegebene Zeichenfolge enthält alle Zeichen im Pfad bis, jedoch nicht einschließlich dem letzten <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-295">In most cases, the string returned by this method consists of all characters in the path up to but not including the last <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span> <span data-ttu-id="6ac5b-296">Wenn der Pfad des ein Stammverzeichnis, z. B. besteht aus "c:\\", wird Null zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-296">If the path consists of a root directory, such as "c:\\", null is returned.</span></span> <span data-ttu-id="6ac5b-297">Beachten Sie, dass es sich bei dieser Methode mithilfe von Pfaden nicht unterstützt "Datei:".</span><span class="sxs-lookup"><span data-stu-id="6ac5b-297">Note that this method does not support paths using "file:".</span></span> <span data-ttu-id="6ac5b-298">Da keine der zurückgegebene Pfad enthält die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, übergeben die zurückgegebenen Pfad zurück in die <xref:System.IO.Path.GetDirectoryName%2A> Methode führt dazu, in das Abschneiden von eine Ordnerebene pro nachfolgenden Aufruf der Ergebniszeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-298">Because the returned path does not include the <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, passing the returned path back into the <xref:System.IO.Path.GetDirectoryName%2A> method will result in the truncation of one folder level per subsequent call on the result string.</span></span> <span data-ttu-id="6ac5b-299">Beispielsweise der Pfad "C:\Directory\SubDirectory\test.txt" übergeben, in der <xref:System.IO.Path.GetDirectoryName%2A> "C:\Directory\SubDirectory"-Methode zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-299">For example, passing the path "C:\Directory\SubDirectory\test.txt" into the <xref:System.IO.Path.GetDirectoryName%2A> method will return "C:\Directory\SubDirectory".</span></span> <span data-ttu-id="6ac5b-300">Übergeben an dieser Begriff "C:\Directory\SubDirectory" <xref:System.IO.Path.GetDirectoryName%2A> führt zu "C:\Directory".</span><span class="sxs-lookup"><span data-stu-id="6ac5b-300">Passing that string, "C:\Directory\SubDirectory", into <xref:System.IO.Path.GetDirectoryName%2A> will result in "C:\Directory".</span></span>  
  
 <span data-ttu-id="6ac5b-301">Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-301">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6ac5b-302">Das folgende Beispiel veranschaulicht die Verwendung der `GetDirectoryName` Methode für eine Windows-basierte desktop-Plattform.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-302">The following example demonstrates using the `GetDirectoryName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6ac5b-303">Der <paramref name="path" />-Parameter enthält nur ungültige Zeichen, ist leer oder enthält nur Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-303">The <paramref name="path" /> parameter contains invalid characters, is empty, or contains only white spaces.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="6ac5b-304">Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.IO.IOException" /> ab.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-304">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="6ac5b-305">Der <paramref name="path" />-Parameter überschreitet die vom System definierte Maximallänge.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-305">The <paramref name="path" /> parameter is longer than the system-defined maximum length.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-306">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-306">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6ac5b-307">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="6ac5b-307">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6ac5b-308">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-308">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6ac5b-309">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-309">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6ac5b-310">Der Dateipfad, aus dem die Erweiterung abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-310">The file path from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="6ac5b-311">Gibt die Erweiterung eines Dateipfads zurück, der durch eine schreibgeschützte Zeichenspanne dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-311">Returns the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-312">Die Erweiterung des angegebenen Pfads (einschließlich des Punkts „.“) oder <see cref="P:System.ReadOnlySpan`1.Empty" />, falls <paramref name="path" /> keine Erweiterungsinformationen umfasst.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-312">The extension of the specified path (including the period, "."), or <see cref="P:System.ReadOnlySpan`1.Empty" /> if <paramref name="path" /> does not have extension information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="6ac5b-313">Diese Methode ruft die Erweiterung der `path` Überwachungspakete `path` für einen bestimmten Zeitraum ("."), beginnend mit dem letzten Zeichen in der Spanne schreibgeschützt und auf das erste Zeichen fortfahren.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-313">This method obtains the extension of `path` by searching `path` for a period ("."), starting from the last character in the read-only span and continuing toward its first character.</span></span> <span data-ttu-id="6ac5b-314">Wenn ein Punkt gefunden wird, bevor Sie eine <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar> Zeichen, die zurückgegebene schreibgeschützten Spanne enthält den Zeitraum und die Zeichen nach ist, andernfalls <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-314">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned read-only span contains the period and the characters after it; otherwise, <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> is returned.</span></span>  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-315">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-315">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6ac5b-316">Die Pfadzeichenfolge, aus der die Erweiterung abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-316">The path string from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="6ac5b-317">Gibt die Erweiterung der angegebenen Pfadzeichenfolge zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-317">Returns the extension of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-318">Die Erweiterung des angegebenen Pfads (einschließlich des Punkts ".") oder <see langword="null" /> oder <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-318">The extension of the specified path (including the period "."), or <see langword="null" />, or <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="6ac5b-319">Wenn <paramref name="path" /> gleich <see langword="null" /> ist, gibt <see cref="M:System.IO.Path.GetExtension(System.String)" /> <see langword="null" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-319">If <paramref name="path" /> is <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see langword="null" />.</span></span> <span data-ttu-id="6ac5b-320">Wenn <paramref name="path" /> keine Informationen über die Erweiterung enthält, gibt <see cref="M:System.IO.Path.GetExtension(System.String)" /><see cref="F:System.String.Empty" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-320">If <paramref name="path" /> does not have extension information, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="6ac5b-321">Diese Methode ruft die Erweiterung der `path` Überwachungspakete `path` für einen Punkt (.), beginnend mit dem letzten Zeichen in `path` und auf das erste Zeichen fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-321">This method obtains the extension of `path` by searching `path` for a period (.), starting with the last character in `path` and continuing toward the first character.</span></span> <span data-ttu-id="6ac5b-322">Wenn ein Punkt gefunden wird, bevor Sie eine <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar> Zeichen ist, enthält die zurückgegebene Zeichenfolge den Zeitraum und die Zeichen nach dem ist, andernfalls <xref:System.String.Empty?displayProperty=nameWithType> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-322">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned string contains the period and the characters after it; otherwise, <xref:System.String.Empty?displayProperty=nameWithType> is returned.</span></span>  
  
 <span data-ttu-id="6ac5b-323">Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-323">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
 
## Examples  
 <span data-ttu-id="6ac5b-324">Das folgende Beispiel veranschaulicht die Verwendung der `GetExtension` Methode für eine Windows-basierte desktop-Plattform.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-324">The following example demonstrates using the `GetExtension` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6ac5b-325"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-325"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-326">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-326">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6ac5b-327">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="6ac5b-327">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6ac5b-328">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-328">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6ac5b-329">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-329">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6ac5b-330">Eine schreibgeschützte Spanne, die den Pfad enthält, aus dem der Dateiname und die Erweiterung abgerufen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-330">A read-only span that contains the path from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="6ac5b-331">Gibt den Dateinamen und die Erweiterung eines Dateipfads zurück, der durch eine schreibgeschützte Zeichenspanne dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-331">Returns the file name and extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-332">Die Zeichen nach dem letzten Verzeichnistrennzeichen in <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-332">The characters after the last directory separator character in <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="6ac5b-333">Die zurückgegebene schreibgeschützten Spanne enthält die Zeichen des Pfads, der das letzte Trennzeichen in folgen `path`.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-333">The returned read-only span contains the characters of the path that follow the last separator in `path`.</span></span> <span data-ttu-id="6ac5b-334">Wenn das letzte Zeichen in `path` ein Volume oder das Verzeichnis Volumetrennzeichen ist, gibt die Methode zurück <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithtype>.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-334">If the last character in `path` is a volume or directory separator character, the method returns <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithtype>.</span></span> <span data-ttu-id="6ac5b-335">Wenn `path` enthält keine Zeichen als Trennzeichen, gibt die Methode zurück `path`.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-335">If `path` contains no separator character, the method returns `path`.</span></span>

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-336">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-336">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6ac5b-337">Die Pfadzeichenfolge, aus der der Dateiname und die Erweiterung abgerufen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-337">The path string from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="6ac5b-338">Gibt den Dateinamen und die Erweiterung der angegebenen Pfadzeichenfolge zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-338">Returns the file name and extension of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-339">Die Zeichen nach dem letzten Verzeichnistrennzeichen in <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-339">The characters after the last directory separator character in <paramref name="path" />.</span></span> <span data-ttu-id="6ac5b-340">Wenn das letzte Zeichen von <paramref name="path" /> ein Verzeichnis- bzw. Volumetrennzeichen ist, gibt diese Methode <see cref="F:System.String.Empty" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-340">If the last character of <paramref name="path" /> is a directory or volume separator character, this method returns <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="6ac5b-341">Wenn <paramref name="path" /> gleich <see langword="null" /> ist, gibt die Methode <see langword="null" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-341">If <paramref name="path" /> is <see langword="null" />, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="6ac5b-342">Der zurückgegebene Wert ist `null` ist der Dateipfad `null`.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-342">The returned value is `null` if the file path is `null`.</span></span>  
  
<span data-ttu-id="6ac5b-343">Die Trennzeichen verwendet, um den Anfang des Dateinamens bestimmen sind <xref:System.IO.Path.DirectorySeparatorChar> und <xref:System.IO.Path.AltDirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-343">The separator characters used to determine the start of the file name are <xref:System.IO.Path.DirectorySeparatorChar> and <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span>  

<span data-ttu-id="6ac5b-344">Da *\\* ist ein zulässiger Dateiname unter Unix `GetFileName` unter UNIX-Plattformen ausgeführt kann keine ordnungsgemäß den Dateinamen aus einem Windows zurückgeben = basierend Pfad wie *"c:"\\"MyDir"\\myfile.ext*, aber `GetFileName` Ausführung unter Windows-basierten Plattformen kann ordnungsgemäß den Dateinamen aus einem Unix-basierte Pfad wie zurückgeben */tmp/myfile.ext*, sodass das Verhalten der `GetFileName` Methode ist nicht unbedingt mit auf Unix-basierte und Windows-basierten Plattformen identisch.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-344">Because *\\* is a legal file name on Unix, `GetFileName` running under Unix-based platforms cannot correctly return the file name from a Windows=based path like *C:\\mydir\\myfile.ext*, but `GetFileName` running under Windows-based platforms can correctly return the file name from a Unix-based path like */tmp/myfile.ext*, so the behavior of the `GetFileName` method is not strictly the same on Unix-based and Windows-based platforms.</span></span>

<span data-ttu-id="6ac5b-345">Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-345">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6ac5b-346">Das folgende Beispiel veranschaulicht das Verhalten der `GetFileName` Methode für eine Windows-basierte desktop-Plattform.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-346">The following example demonstrates the behavior of the `GetFileName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6ac5b-347"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-347"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-348">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-348">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6ac5b-349">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="6ac5b-349">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6ac5b-350">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-350">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6ac5b-351">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-351">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6ac5b-352">Eine schreibgeschützte Spanne, die den Pfad enthält, aus dem der Dateiname ohne die Erweiterung abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-352">A read-only span that contains the path from which to obtain the file name without the extension.</span></span></param>
        <summary><span data-ttu-id="6ac5b-353">Gibt den Dateinamen ohne die Erweiterung eines Dateipfads zurück, der durch eine schreibgeschützte Zeichenspanne dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-353">Returns the file name without the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-354">Die von <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" /> zurückgegebenen Zeichen in der schreibgeschützten Spanne ohne den letzten Punkt (.) und alle folgenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-354">The characters in the read-only span returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-355">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-355">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6ac5b-356">Der Pfad der Datei.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-356">The path of the file.</span></span></param>
        <summary><span data-ttu-id="6ac5b-357">Gibt den Dateinamen der angegebenen Pfadzeichenfolge ohne Erweiterung zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-357">Returns the file name of the specified path string without the extension.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-358">Die von <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" /> zurückgegebene Zeichenfolge ohne den letzten Punkt (.) und alle folgenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-358">The string returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6ac5b-359">Diese Methode überprüft nicht, dass der Pfad oder Dateiname vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-359">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="6ac5b-360">Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-360">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6ac5b-361">Das folgende Beispiel veranschaulicht die Verwendung des der `GetFileNameWithoutExtension` Methode.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-361">The following example demonstrates a use of the `GetFileNameWithoutExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6ac5b-362"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-362"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-363">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-363">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6ac5b-364">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="6ac5b-364">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6ac5b-365">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-365">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6ac5b-366">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-366">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6ac5b-367">Die Datei oder das Verzeichnis, für das die absoluten Pfadinformationen abgerufen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-367">The file or directory for which to obtain absolute path information.</span></span></param>
        <summary><span data-ttu-id="6ac5b-368">Gibt den absoluten Pfad für die angegebene Pfadzeichenfolge zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-368">Returns the absolute path for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-369">Der vollqualifizierte Speicherort von <paramref name="path" />, z. B. "C:\MyFile.txt".</span><span class="sxs-lookup"><span data-stu-id="6ac5b-369">The fully qualified location of <paramref name="path" />, such as "C:\MyFile.txt".</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="6ac5b-370">Der absolute Pfad enthält alle Informationen, um eine Datei oder ein Verzeichnis auf einem System zu suchen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-370">The absolute path includes all information required to locate a file or directory on a system.</span></span>  
  
 <span data-ttu-id="6ac5b-371">Die Datei oder das Verzeichnis, die anhand des `path` muss nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-371">The file or directory specified by `path` is not required to exist.</span></span> <span data-ttu-id="6ac5b-372">Z. B. wenn *c:\temp\newdir* ist das Verzeichnis des aktuelle Aufrufen `GetFullPath` auf einen Dateinamen ein, z. B. *"Test.txt"* gibt *c:\temp\newdir\test.txt*.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-372">For example, if *c:\temp\newdir* is the current directory, calling `GetFullPath` on a file name such as *test.txt* returns *c:\temp\newdir\test.txt*.</span></span> <span data-ttu-id="6ac5b-373">Die Datei muss nicht vorhanden sein.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-373">The file need not exist.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="6ac5b-374">Wenn `path` ist ein relativer Pfad, diese Überladung gibt einen vollqualifizierten Pfad, der auf das aktuelle Laufwerk und das aktuelle Verzeichnis basieren kann.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-374">If `path` is a relative path, this overload returns a fully qualified path that can be based on the current drive and current directory.</span></span> <span data-ttu-id="6ac5b-375">Das aktuelle Laufwerk und das aktuelle Verzeichnis können sich jederzeit ändern, wie eine Anwendung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-375">The current drive and current directory can change at any time as an application executes.</span></span> <span data-ttu-id="6ac5b-376">Daher kann der von dieser Überladung zurückgegebene Pfad im Voraus bestimmt werden.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-376">As a result, the path returned by this overload cannot be determined in advance.</span></span> <span data-ttu-id="6ac5b-377">Rufen Sie zum Zurückgeben eines deterministischen Pfads der <xref:System.IO.Path.GetFullPath(System.String,System.String)> überladen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-377">To return a deterministic path, call the <xref:System.IO.Path.GetFullPath(System.String,System.String)> overload.</span></span> <span data-ttu-id="6ac5b-378">Sie können auch Aufrufen der <xref:System.IO.Path.IsPathFullyQualified%2A> Methode, um zu bestimmen, ob ein Pfad voll qualifiziert ist oder einen Pfad relativ und somit auch, ob ein Aufruf zum `GetFullPath` ist erforderlich.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-378">You can also call the <xref:System.IO.Path.IsPathFullyQualified%2A> method to determine whether a path is fully qualified or relative and therefore whether a call to `GetFullPath` is necessary.</span></span>

 <span data-ttu-id="6ac5b-379">Aber wenn `path` vorhanden ist, der Aufrufer muss über die Berechtigung zum Abrufen von Informationen über Pfade für `path`.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-379">However, if `path` does exist, the caller must have permission to obtain path information for `path`.</span></span> <span data-ttu-id="6ac5b-380">Beachten Sie, dass im Gegensatz zu den meisten Elementen von der <xref:System.IO.Path> Klasse diese Methode greift auf das Dateisystem.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-380">Note that unlike most members of the <xref:System.IO.Path> class, this method accesses the file system.</span></span>  
  
 <span data-ttu-id="6ac5b-381">Diese Methode verwendet das aktuelle Verzeichnis und das aktuelle Volumeinformationen zur vollständigen Qualifizierung `path`.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-381">This method uses the current directory and current volume information to fully qualify `path`.</span></span> <span data-ttu-id="6ac5b-382">Bei Angabe eine Datei nur im Namen `path`, `GetFullPath` gibt den vollqualifizierten Pfad des aktuellen Verzeichnisses.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-382">If you specify a file name only in `path`, `GetFullPath` returns the fully qualified path of the current directory.</span></span>  
  
 <span data-ttu-id="6ac5b-383">Wenn Sie in einem kurzen Dateinamen übergeben, wird er zu einer langen Dateinamen erweitert.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-383">If you pass in a short file name, it is expanded to a long file name.</span></span>  
  
 <span data-ttu-id="6ac5b-384">Wenn ein Pfad keine signifikanten Zeichen enthält, ist ungültig, wenn sie eine oder mehrere enthält "." Zeichen, gefolgt von einer beliebigen Anzahl von Leerzeichen und es entweder als analysiert werden "."oder"..".</span><span class="sxs-lookup"><span data-stu-id="6ac5b-384">If a path contains no significant characters, it is invalid unless it contains one or more "." characters followed by any number of spaces; then it will be parsed as either "." or "..".</span></span>  

<span data-ttu-id="6ac5b-385">.NET Core 1.1 und höher und .NET Framework 4.6.2 und höher unterstützen auch die Pfade, die Gerätenamen, z. B. enthalten "\\? \C:\".</span><span class="sxs-lookup"><span data-stu-id="6ac5b-385">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support paths that include device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="6ac5b-386">Weitere Informationen zu Path-Dateiformaten in Windows finden Sie unter [Pfad Dateiformate auf Windows-Systemen](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-386">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="6ac5b-387">Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-387">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
  
## Examples  
 <span data-ttu-id="6ac5b-388">Das folgende Beispiel zeigt die `GetFullPath` Methode für eine Windows-basierte desktop-Plattform.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-388">The following example demonstrates the `GetFullPath` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6ac5b-389"><paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), besteht nur aus Leerraum oder enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültige Zeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-389"><paramref name="path" /> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="6ac5b-390">- oder -</span><span class="sxs-lookup"><span data-stu-id="6ac5b-390">-or-</span></span> 
<span data-ttu-id="6ac5b-391">Das System konnte den absoluten Pfad nicht abrufen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-391">The system could not retrieve the absolute path.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="6ac5b-392">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-392">The caller does not have the required permissions.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6ac5b-393"><paramref name="path" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-393"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6ac5b-394"><paramref name="path" /> enthält einen Doppelpunkt („:“), der kein Teil eines Volumenbezeichners (z.B. „c:\\“) ist.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-394"><paramref name="path" /> contains a colon (":") that is not part of a volume identifier (for example, "c:\\").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="6ac5b-395">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-395">The specified path, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6ac5b-396">für den Zugriff auf den Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-396">for access to the path.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-397">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-397">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6ac5b-398">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="6ac5b-398">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6ac5b-399">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-399">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6ac5b-400">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-400">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="basePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6ac5b-401">Ein relativer Pfad zum Verketten mit <see paramref="basePath" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-401">A relative path to concatenate to <see paramref="basePath" />.</span></span></param>
        <param name="basePath"><span data-ttu-id="6ac5b-402">Der Anfang eines vollqualifizierten Pfads.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-402">The beginning of a fully qualified path.</span></span></param>
        <summary><span data-ttu-id="6ac5b-403">Gibt einen absoluten Pfad aus einem vollqualifizierten Basispfad und einem relativen Pfad zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-403">Returns an absolute path from a fully qualified base path and a relative path.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-404">Der absolute Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-404">The absolute path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="6ac5b-405">Wenn `path` ist ein leerer Pfad, der Methodenrückgabe `basePath`.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-405">If `path` is an empty path, the method returns `basePath`.</span></span> <span data-ttu-id="6ac5b-406">Wenn `path` ist ein vollqualifizierter Pfad, der Methode übergibt `path` auf die <xref:System.IO.Path.GetFullPath(System.String)> Methode und gibt das Ergebnis zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-406">If `path` is a fully qualified path, the method passes `path` to the <xref:System.IO.Path.GetFullPath(System.String)> method and returns the result.</span></span>

<span data-ttu-id="6ac5b-407">Verwenden Sie diese Methode zurückgegeben wird, einen deterministischen Pfad basierend auf ein angegebenes Volume und wurden die nutzungsbeschränkungen entfernt Verzeichnis auf, wenn Sie relative Pfade verwenden.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-407">Use this method to return a deterministic path based on a specified volume and rooted directory when you're using relative paths.</span></span> <span data-ttu-id="6ac5b-408">Verwenden eine vordefinierte `basePath` anstelle basierend auf den aktuellen Laufwerk Directory dient als Schutz vor unerwünschter Dateipfade, die durch unerwartete Änderungen in das aktuelle Laufwerk und Verzeichnis verursacht werden.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-408">Using a predefined `basePath` rather than one based on the current drive directory guards against unwanted file paths caused by unexpected changes in the current drive and directory.</span></span> 

## <a name="example"></a><span data-ttu-id="6ac5b-409">Beispiel</span><span class="sxs-lookup"><span data-stu-id="6ac5b-409">Example</span></span>

<span data-ttu-id="6ac5b-410">Im folgende Beispiel wird eine Variable, `basePath`, um das aktuelle Verzeichnis einer Anwendung repräsentiert.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-410">The following example defines a variable, `basePath`, to represent an application's current directory.</span></span> <span data-ttu-id="6ac5b-411">Anschließend übergibt es an der `GetFullPath` Methode, um einen vollqualifizierten Pfad zum Datenverzeichnis der Anwendung abzurufen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-411">It then passes it to the `GetFullPath` method to get a fully qualified path to the application's data directory.</span></span>

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6ac5b-412"><paramref name="path" /> oder <paramref name="basePath" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-412"><paramref name="path" /> or <paramref name="basePath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6ac5b-413"><paramref name="basePath" /> ist kein vollqualifizierter Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-413"><paramref name="basePath" /> is not a fully qualified path.</span></span>
<span data-ttu-id="6ac5b-414">– Oder – <paramref name="path" /> oder <paramref name="basePath" /> enthält ungültige Pfadzeichen, z.B. U+0000.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-414">-or- <paramref name="path" /> or <paramref name="basePath" /> contains invalid path characters, such as U+0000.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6ac5b-415">Ruft ein Array ab, das die Zeichen enthält, die in Dateinamen nicht zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-415">Gets an array containing the characters that are not allowed in file names.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-416">Ein Array, das die Zeichen enthält, die in Dateinamen nicht zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-416">An array containing the characters that are not allowed in file names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6ac5b-417">Von dieser Methode zurückgegebenen Arrays wird nicht unbedingt den vollständigen Satz von Zeichen enthalten, die in Datei- und Verzeichnisnamen ungültig sind.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-417">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="6ac5b-418">Der vollständige Satz von ungültigen Zeichen kann je nach Dateisystem variieren.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-418">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="6ac5b-419">Z. B. auf Windows-basierte desktop-Plattformen ungültige Pfadzeichen möglicherweise ASCII-/Unicode-Zeichen 1 bis 31 sowie Anführungszeichen ("), kleiner als (\<), größer als (>), Pipe (&#124;), Rücktaste (\b), Null (\0) und Tabulator (\t).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-419">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6ac5b-420">Das folgende Beispiel zeigt die <xref:System.IO.Path.GetInvalidFileNameChars%2A> Methode und die <xref:System.IO.Path.GetInvalidPathChars%2A> Methode, um ungültige Zeichen abzurufen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-420">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6ac5b-421">Ruft ein Array ab, das die Zeichen enthält, die in Pfadnamen nicht zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-421">Gets an array containing the characters that are not allowed in path names.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-422">Ein Array, das die Zeichen enthält, die in Pfadnamen nicht zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-422">An array containing the characters that are not allowed in path names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6ac5b-423">Von dieser Methode zurückgegebenen Arrays wird nicht unbedingt den vollständigen Satz von Zeichen enthalten, die in Datei- und Verzeichnisnamen ungültig sind.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-423">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="6ac5b-424">Der vollständige Satz von ungültigen Zeichen kann je nach Dateisystem variieren.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-424">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="6ac5b-425">Z. B. auf Windows-basierte desktop-Plattformen ungültige Pfadzeichen möglicherweise ASCII-/Unicode-Zeichen 1 bis 31 sowie Anführungszeichen ("), kleiner als (\<), größer als (>), Pipe (&#124;), Rücktaste (\b), Null (\0) und Tabulator (\t).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-425">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6ac5b-426">Das folgende Beispiel zeigt die <xref:System.IO.Path.GetInvalidFileNameChars%2A> Methode und die <xref:System.IO.Path.GetInvalidPathChars%2A> Methode, um ungültige Zeichen abzurufen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-426">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6ac5b-427">Der Pfad, von dem Informationen über das Stammverzeichnis abgerufen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-427">The path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="6ac5b-428">Ruft Informationen über das Stammverzeichnis aus dem Pfad ab, der in der angegebenen Zeichenspanne enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-428">Gets the root directory information from the path contained in the specified character span.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-429">Eine Zeichenspanne mit dem Stammverzeichnis von `path`.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-429">A character span containing the root directory of `path`.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-430">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-430">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6ac5b-431">Der Pfad, von dem Informationen über das Stammverzeichnis abgerufen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-431">The path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="6ac5b-432">Ruft die Informationen über das Stammverzeichnis des angegebenen Pfads ab.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-432">Gets the root directory information of the specified path.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-433">Das Stammverzeichnis von <paramref name="path" /> oder <see langword="null" />, wenn <paramref name="path" /> <see langword="null" /> ist, oder eine leere Zeichenfolge, wenn <paramref name="path" /> keine Informationen über das Stammverzeichnis enthält.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-433">The root directory of <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> is <see langword="null" />, or an empty string if <paramref name="path" /> does not contain root directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6ac5b-434">Diese Methode überprüft nicht, dass der Pfad oder Dateiname vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-434">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="6ac5b-435">Mögliche Muster für die Zeichenfolge, die von dieser Methode zurückgegebene lauten wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="6ac5b-435">Possible patterns for the string returned by this method are as follows:</span></span>  
  
- <span data-ttu-id="6ac5b-436">Eine leere Zeichenfolge (`path` gibt einen relativen Pfad auf dem aktuellen Laufwerk oder Volume).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-436">An empty string (`path` specified a relative path on the current drive or volume).</span></span>  
  
- <span data-ttu-id="6ac5b-437">"\" (`path` einen absoluten Pfad für das aktuelle Laufwerk angegeben).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-437">"\" (`path` specified an absolute path on the current drive).</span></span>  
  
- <span data-ttu-id="6ac5b-438">"X" (`path` gibt einen relativen Pfad auf einem Laufwerk, wobei X ein Laufwerk oder Volume darstellt).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-438">"X:" (`path` specified a relative path on a drive, where X represents a drive or volume letter).</span></span>  
  
- <span data-ttu-id="6ac5b-439">"X:\" (`path` gibt einen absoluten Pfad auf einem bestimmten Laufwerk).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-439">"X:\" (`path` specified an absolute path on a given drive).</span></span>  
  
- <span data-ttu-id="6ac5b-440">"\\\ComputerName\SharedFolder" (ein UNC-Pfad).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-440">"\\\ComputerName\SharedFolder" (a UNC path).</span></span>  
  
- <span data-ttu-id="6ac5b-441">"\\? \C:" (eine DOS-Gerätepfad, in .NET Core 1.1 und höher und in .NET Framework 4.6.2 und höher unterstützt)</span><span class="sxs-lookup"><span data-stu-id="6ac5b-441">"\\?\C:" (a DOS device path, supported in .NET Core 1.1 and later versions and in .NET Framework 4.6.2 and later versions)</span></span>
   
 <span data-ttu-id="6ac5b-442">Weitere Informationen zu Dateipfade unter Windows, finden Sie unter [Pfad Dateiformate auf Windows-Systemen](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-442">For more information on file paths on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="6ac5b-443">Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-443">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
## Examples  
 <span data-ttu-id="6ac5b-444">Das folgende Beispiel veranschaulicht die Verwendung des der `GetPathRoot` Methode.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-444">The following example demonstrates a use of the `GetPathRoot` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
 [!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
 [!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6ac5b-445"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-445"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="6ac5b-446">- oder -</span><span class="sxs-lookup"><span data-stu-id="6ac5b-446">-or-</span></span> 
 <span data-ttu-id="6ac5b-447"><see cref="F:System.String.Empty" /> wurde an <paramref name="path" /> übergeben.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-447"><see cref="F:System.String.Empty" /> was passed to <paramref name="path" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-448">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-448">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6ac5b-449">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="6ac5b-449">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6ac5b-450">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-450">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6ac5b-451">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-451">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6ac5b-452">Gibt einen zufälligen Ordnernamen oder Dateinamen zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-452">Returns a random folder name or file name.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-453">Ein zufälliger Ordnername oder Dateiname.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-453">A random folder name or file name.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6ac5b-454">Die <xref:System.IO.Path.GetRandomFileName%2A> Methode gibt eine kryptografisch starke, zufällige Zeichenfolge, die als einen Ordnernamen oder ein Dateiname verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-454">The <xref:System.IO.Path.GetRandomFileName%2A> method returns a cryptographically strong, random string that can be used as either a folder name or a file name.</span></span> <span data-ttu-id="6ac5b-455">Im Gegensatz zu <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> erstellt eine Datei nicht.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-455">Unlike <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> does not create a file.</span></span> <span data-ttu-id="6ac5b-456">Wenn die Sicherheit Ihres Dateisystems entscheidend ist, sollte diese Methode verwendet werden, anstelle von <xref:System.IO.Path.GetTempFileName%2A>.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-456">When the security of your file system is paramount, this method should be used instead of <xref:System.IO.Path.GetTempFileName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6ac5b-457">Das folgende Beispiel zeigt die Ausgabe der <xref:System.IO.Path.GetRandomFileName%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-457">The following example show output from the <xref:System.IO.Path.GetRandomFileName%2A> method.</span></span>  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeTo"><span data-ttu-id="6ac5b-458">Der Quellpfad, zu dem das Ergebnis relativ sein muss.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-458">The source path the result should be relative to.</span></span> <span data-ttu-id="6ac5b-459">Dieser Pfad wird nicht immer als Verzeichnis betrachtet.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-459">This path is always considered to be a directory.</span></span></param>
        <param name="path"><span data-ttu-id="6ac5b-460">Der Zielpfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-460">The destination path.</span></span></param>
        <summary><span data-ttu-id="6ac5b-461">Gibt einen relativen Pfad von einem Pfad zu einem anderen zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-461">Returns a relative path from one path to another.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-462">Der relative Pfad oder <paramref name="path" />, wenn die Pfade nicht denselben Stamm aufweisen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-462">The relative path, or <paramref name="path" /> if the paths don't share the same root.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="6ac5b-463">Pfade aufgelöst werden, durch den Aufruf der <xref:System.IO.Path.GetFullPath%2A> Methode vor dem Berechnen der Differenz.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-463">Paths are resolved by calling the <xref:System.IO.Path.GetFullPath%2A> method before calculating the difference.</span></span> <span data-ttu-id="6ac5b-464">Die Methode verwendet den Pfad den Standardvergleich-Datei für die aktuelle Plattform (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> für Windows und MacOs <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> für Linux.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-464">The method uses the default file path comparison for the current platform (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for Windows and MacOs, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> for Linux.</span></span> 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6ac5b-465"><paramref name="relativeTo" /> oder <paramref name="path" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-465"><paramref name="relativeTo" /> or <paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-466">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-466">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6ac5b-467">Erstellt eine eindeutig benannte temporäre Datei auf dem Datenträger mit einer Größe von 0 Byte und gibt den vollständigen Pfad dieser Datei zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-467">Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-468">Der vollständige Pfad der temporären Datei.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-468">The full path of the temporary file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6ac5b-469">Diese Methode erstellt eine temporäre Datei mit ein. TMP-Dateierweiterung.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-469">This method creates a temporary file with a .TMP file extension.</span></span> <span data-ttu-id="6ac5b-470">Die temporäre Datei wird erstellt, in den temporären Ordner des Benutzers, der der Pfad ist zurückgegebenes der <xref:System.IO.Path.GetTempPath%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-470">The temporary file is created within the user's temporary folder, which is the path returned by the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
 <span data-ttu-id="6ac5b-471">Die <xref:System.IO.Path.GetTempFileName%2A> Methode löst eine <xref:System.IO.IOException> Wenn es verwendet wird, um mehr als 65535 Dateien zu erstellen, ohne vorherige temporäre Dateien zu löschen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-471">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if it is used to create more than 65535 files without deleting previous temporary files.</span></span>  
  
 <span data-ttu-id="6ac5b-472">Die <xref:System.IO.Path.GetTempFileName%2A> Methode löst eine <xref:System.IO.IOException> ist kein eindeutiger temporärer Dateiname verfügbar.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-472">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if no unique temporary file name is available.</span></span> <span data-ttu-id="6ac5b-473">Um diesen Fehler zu beheben, löschen Sie alle nicht benötigte temporäre Dateien.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-473">To resolve this error, delete all unneeded temporary files.</span></span>  
  
 <span data-ttu-id="6ac5b-474">Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-474">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="6ac5b-475">Ein E/A-Fehler tritt auf, z. B. ist kein eindeutiger temporärer Dateiname verfügbar.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-475">An I/O error occurs, such as no unique temporary file name is available.</span></span>  
  
<span data-ttu-id="6ac5b-476">- oder -</span><span class="sxs-lookup"><span data-stu-id="6ac5b-476">-or-</span></span> 
<span data-ttu-id="6ac5b-477">Diese Methode konnte keine temporäre Datei erstellen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-477">This method was unable to create a temporary file.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6ac5b-478">zum Schreiben in das temporäre Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-478">for writing to the temporary directory.</span></span> <span data-ttu-id="6ac5b-479">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span><span class="sxs-lookup"><span data-stu-id="6ac5b-479">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6ac5b-480">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="6ac5b-480">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6ac5b-481">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-481">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6ac5b-482">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-482">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6ac5b-483">Gibt den Pfad des temporären Ordners des aktuellen Benutzers zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-483">Returns the path of the current user's temporary folder.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-484">Der Pfad zum temporären Ordner, endend mit einem umgekehrten Schrägstrich.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-484">The path to the temporary folder, ending with a backslash.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6ac5b-485">Diese Methode wird das Vorhandensein von Umgebungsvariablen in der folgenden Reihenfolge überprüft und verwendet den ersten Pfad gefunden:</span><span class="sxs-lookup"><span data-stu-id="6ac5b-485">This method checks for the existence of environment variables in the following order and uses the first path found:</span></span>  
  
1.  <span data-ttu-id="6ac5b-486">Der Pfad, der durch die TMP-Umgebungsvariable angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-486">The path specified by the TMP environment variable.</span></span>  
  
2.  <span data-ttu-id="6ac5b-487">Der Pfad, der durch die Umgebungsvariable TEMP angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-487">The path specified by the TEMP environment variable.</span></span>  
  
3.  <span data-ttu-id="6ac5b-488">Der Pfad, der durch die Umgebungsvariable USERPROFILE angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-488">The path specified by the USERPROFILE environment variable.</span></span>  
  
4.  <span data-ttu-id="6ac5b-489">Das Windows-Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-489">The Windows directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6ac5b-490">Im folgenden Code wird das Aufrufen der <xref:System.IO.Path.GetTempPath%2A>-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-490">The following code shows how to call the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
```vb  
result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 <span data-ttu-id="6ac5b-491">In diesem Beispiel wird die Ausgabe ähnlich der folgenden.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-491">This example produces output similar to the following.</span></span>  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="6ac5b-492">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-492">The caller does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission"><span data-ttu-id="6ac5b-493">für einen uneingeschränkten Zugriff auf Umgebungsvariablen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-493">for unrestricted access to environment variables.</span></span> <span data-ttu-id="6ac5b-494">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="6ac5b-494">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6ac5b-495">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="6ac5b-495">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6ac5b-496">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-496">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6ac5b-497">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-497">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6ac5b-498">Der Pfad, in dem nach einer Erweiterung gesucht werden soll.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-498">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="6ac5b-499">Legt fest, ob der Pfad, der durch die angegebene Zeichenspanne dargestellt wird, eine Erweiterung enthält.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-499">Determines whether the path represented by the specified character span includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-500"><see langword="true" />, wenn die Zeichen, die auf das letzte Verzeichnistrennzeichen oder Volumentrennzeichen im Pfad folgen, einen Punkt (.) gefolgt von einem oder mehreren Zeichen enthalten; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-500"><see langword="true" /> if the characters that follow the last directory separator character or volume separator in the path include a period (".") followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="6ac5b-501">In einen abschließenden Punkt `path` ist eine Erweiterung nicht berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-501">A trailing period in `path` is not considered an extension.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-502">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-502">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6ac5b-503">Der Pfad, in dem nach einer Erweiterung gesucht werden soll.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-503">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="6ac5b-504">Bestimmt, ob ein Pfad eine Dateierweiterung enthält.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-504">Determines whether a path includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-505"><see langword="true" />, wenn die Zeichen, die auf das letzte Verzeichnistrennzeichen (\\\ oder /) oder Volumentrennzeichen (:) im Pfad folgen, einen Punkt (.) gefolgt von einem oder mehreren Zeichen enthalten; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-505"><see langword="true" /> if the characters that follow the last directory separator (\\\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6ac5b-506">Ab dem Ende des `path`, diese Methode sucht nach einem Punkt (.) gefolgt von mindestens einem Zeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-506">Starting from the end of `path`, this method searches for a period (.) followed by at least one character.</span></span> <span data-ttu-id="6ac5b-507">Wenn dieses Muster, bevor gefunden wird eine <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, oder <xref:System.IO.Path.VolumeSeparatorChar> Zeichen festgestellt wird, gibt diese Methode zurück `true`.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-507">If this pattern is found before a <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar> character is encountered, this method returns `true`.</span></span>  
  
 <span data-ttu-id="6ac5b-508">Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-508">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6ac5b-509">Im folgenden Beispiel wird die Verwendung der `HasExtension`-Methode gezeigt.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-509">The following example demonstrates the use of the `HasExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6ac5b-510"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-510"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-511">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-511">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6ac5b-512">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="6ac5b-512">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6ac5b-513">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-513">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6ac5b-514">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-514">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6ac5b-515">Stellt ein plattformspezifisches Array von Zeichen bereit, die nicht in Pfadzeichenfolgenargumenten angegeben werden können, die an Member der <see cref="T:System.IO.Path" />-Klasse übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-515">Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <see cref="T:System.IO.Path" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6ac5b-516">Von dieser Methode zurückgegebenen Arrays wird nicht unbedingt den vollständigen Satz von Zeichen enthalten, die in Datei- und Verzeichnisnamen ungültig sind.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-516">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="6ac5b-517">Der vollständige Satz von ungültigen Zeichen kann je nach Dateisystem variieren.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-517">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="6ac5b-518">Z. B. auf Windows-basierte desktop-Plattformen ungültige Pfadzeichen möglicherweise ASCII-/Unicode-Zeichen 1 bis 31 sowie Anführungszeichen ("), kleiner als (\<), größer als (>), Pipe (&#124;), Rücktaste (\b), Null (\0) und Tabulator (\t).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-518">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="6ac5b-519">Verwenden Sie keine <xref:System.IO.Path.InvalidPathChars> sollten Sie Ihren Code in der gleichen Anwendungsdomäne als nicht vertrauenswürdigen Code ausführen kann.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-519">Do not use <xref:System.IO.Path.InvalidPathChars> if you think your code might execute in the same application domain as untrusted code.</span></span> <span data-ttu-id="6ac5b-520"><xref:System.IO.Path.InvalidPathChars> ist ein Array, an, damit seine Elemente überschrieben werden können.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-520"><xref:System.IO.Path.InvalidPathChars> is an array, so its elements can be overwritten.</span></span> <span data-ttu-id="6ac5b-521">Wenn nicht vertrauenswürdiger Code Elemente überschreibt <xref:System.IO.Path.InvalidPathChars>, kann dies in Ihrem Code zu Fehlfunktionen, die ausgenutzt werden könnten.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-521">If untrusted code overwrites elements of <xref:System.IO.Path.InvalidPathChars>, it might cause your code to malfunction in ways that could be exploited.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6ac5b-522">Das folgende Beispiel zeigt die Verwendung der `InvalidPathChars` Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-522">The following example demonstrates the use of the `InvalidPathChars` property.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6ac5b-523">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="6ac5b-523">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6ac5b-524">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-524">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6ac5b-525">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-525">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary><span data-ttu-id="6ac5b-526">Gibt einen Wert zurück, der angibt, ob ein Dateipfad vollqualifiziert ist.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-526">Returns a value that indicates whether a file path is fully qualified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="6ac5b-527">Die Überladungen von der `IsPathFullyQualified` Methode Handle Pfade, die sowohl die <xref:System.IO.Path.DirectorySeparatorChar> und die <xref:System.IO.Path.AltDirectorySeparatorChar> Zeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-527">The overloads of the `IsPathFullyQualified` method handle paths that use both the <xref:System.IO.Path.DirectorySeparatorChar> and the <xref:System.IO.Path.AltDirectorySeparatorChar> characters.</span></span> <span data-ttu-id="6ac5b-528">Es führt keine Validierung für den Pfad, der als Argument übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-528">It does not perform any validation on the path that is passed to it as an argument.</span></span> <span data-ttu-id="6ac5b-529">Daher URIs werden als relative Pfade interpretiert und zurückgeben `false`.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-529">As a result, URIs are interpreted as relative paths and return `false`.</span></span> 

<span data-ttu-id="6ac5b-530">Besteht ein Unterschied zwischen einem vollqualifizierten Pfad (wie durch die `IsPathFullyQualified` Methode) und einen vollständigen Pfad (wie durch die <xref:System.IO.Path.IsPathRooted%2A> Methode).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-530">There is a difference between a fully qualified path (as indicated by the `IsPathFullyQualified` method) and a rooted path (as indicated by the <xref:System.IO.Path.IsPathRooted%2A> method).</span></span> <span data-ttu-id="6ac5b-531">Ein *vollständig qualifizierten Pfad* oder *absoluten Pfad* immer definiert einen genauen Pfad von einem bestimmten Gerät oder auf eine Zieldatei oder das Verzeichnis, und ist nicht auf dem aktuellen Laufwerk oder das aktuelle Verzeichnis abhängig.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-531">A *fully qualified path* or *absolute path* always defines an exact path from a particular drive or device to a target file or directory, and does not depend on the current drive or current directory.</span></span> <span data-ttu-id="6ac5b-532">Auf Windows-Systemen, z. B. *C:/users/user1/documents/reports/2019/january/highlights.pdf* definiert einen absoluten Pfad vom Stamm von Laufwerk C: auf die Zieldatei *highlights.pdf*.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-532">For example, on Windows systems, *C:/users/user1/documents/reports/2019/january/highlights.pdf* defines an absolute path from the root of the C: drive to the target file, *highlights.pdf*.</span></span> <span data-ttu-id="6ac5b-533">Ein *Stammpfad* gibt entweder einen ab Laufwerk oder ein Stammverzeichnis hängt jedoch von entweder im aktuellen Verzeichnis (falls es von einem angegebenen Laufwerk als Stamm verknüpft ist) oder das aktuelle Laufwerk (wenn es durch das Root-Verzeichnis als Stamm verknüpft ist).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-533">A *rooted path* specifies either a starting drive or root directory, but depends on either the current directory (if it is rooted by a specified drive) or the current drive (if it is rooted by the root directory).</span></span> <span data-ttu-id="6ac5b-534">Das folgende Beispiel veranschaulicht den Unterschied zwischen vollqualifizierte Pfade und Pfade mit entfernten nutzungsbeschränkungen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-534">The following example illustrates the difference between fully qualified paths and rooted paths.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6ac5b-535">Ein Dateipfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-535">A file path.</span></span></param>
        <summary><span data-ttu-id="6ac5b-536">Gibt einen Wert zurück, der angibt, ob der durch die angegebene Zeichenspanne dargestellte Dateipfad auf ein bestimmtes Laufwerk oder einen UNC-Pfad festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-536">Returns a value that indicates whether the file path represented by the specified character span is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-537"><see langword="true" />, wenn der Pfad auf ein bestimmtes Laufwerk oder einen UNC-Pfad festgelegt ist; <see langword="false" />, wenn der Pfad relativ zum aktuellen Laufwerk oder Arbeitsverzeichnis angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-537"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-538">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-538">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6ac5b-539">Ein Dateipfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-539">A file path.</span></span></param>
        <summary><span data-ttu-id="6ac5b-540">Gibt einen Wert zurück, der angibt, ob der angegebene Dateipfad auf ein bestimmtes Laufwerk oder einen UNC-Pfad festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-540">Returns a value that indicates whether the specified file path is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-541"><see langword="true" />, wenn der Pfad auf ein bestimmtes Laufwerk oder einen UNC-Pfad festgelegt ist; <see langword="false" />, wenn der Pfad relativ zum aktuellen Laufwerk oder Arbeitsverzeichnis angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-541"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6ac5b-542"><paramref name="path" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-542"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-543">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-543">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary><span data-ttu-id="6ac5b-544">Gibt einen Wert zurück, der angibt, ob ein Dateipfad einen Stamm enthält.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-544">Returns a value that indicates whether a file path contains a root.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="6ac5b-545">Ein **Stammpfad** Dateipfad ist, ist für ein bestimmtes Laufwerk oder einen UNIC Pfad festgelegt, im Gegensatz dazu mit einem Pfad, der relativ zum aktuellen Laufwerk oder Arbeitsverzeichnis ist.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-545">A **rooted path** is file path that is fixed to a specific drive or UNIC path; it contrasts with a path that is relative to the current drive or working directory.</span></span> <span data-ttu-id="6ac5b-546">Beispielsweise startet ein Stammpfad auf Windows-Systemen mit einem umgekehrten Schrägstrich (z. B. "\Documents") oder einem Laufwerkbuchstaben und Doppelpunkt (z. B. "C:Documents").</span><span class="sxs-lookup"><span data-stu-id="6ac5b-546">For example, on Windows systems, a rooted path begins with a backslash (for example, "\Documents") or a drive letter and colon (for example, "C:Documents").</span></span> 

<span data-ttu-id="6ac5b-547">Beachten Sie, dass mit entfernten nutzungsbeschränkungen Pfade entweder Absolute (die voll qualifiziert ist,) oder einen Pfad relativ.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-547">Note that rooted paths can be either absolute (that is, fully qualified) or relative.</span></span> <span data-ttu-id="6ac5b-548">Ein absoluter Pfad Stammpfad ist es sich um einen vollqualifizierten Pfad vom Stamm des Laufwerks auf ein bestimmtes Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-548">An absolute rooted path is a fully qualified path from the root of a drive to a specific directory.</span></span> <span data-ttu-id="6ac5b-549">Ein relativer Pfad für die mit entfernten nutzungsbeschränkungen gibt an, ein Laufwerk, aber der vollständig qualifizierte Pfad wird für das aktuelle Verzeichnis aufgelöst.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-549">A relative rooted path specifies a drive, but its fully qualified path is resolved against the current directory.</span></span> <span data-ttu-id="6ac5b-550">Der Unterschied wird im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-550">The following example illustrates the difference.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6ac5b-551">Der zu testende Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-551">The path to test.</span></span></param>
        <summary><span data-ttu-id="6ac5b-552">Gibt einen Wert zurück, der angibt, ob die angegebene Zeichenspanne zur Darstellung eines Dateipfads einen Stamm enthält.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-552">Returns a value that indicates whether the specified character span that represents a file path contains a root.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-553"><see langword="true" />, wenn <paramref name="path" /> einen Stamm enthält, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-553"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-554">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-554">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6ac5b-555">Der zu testende Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-555">The path to test.</span></span></param>
        <summary><span data-ttu-id="6ac5b-556">Gibt einen Wert zurück, der angibt, ob die angegebene Pfadzeichenfolge einen Stamm enthält.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-556">Returns a value indicating whether the specified path string contains a root.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-557"><see langword="true" />, wenn <paramref name="path" /> einen Stamm enthält, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-557"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6ac5b-558">Die <xref:System.IO.Path.IsPathRooted%2A> Methodenrückgabe `true` ist das erste Zeichen einem Verzeichnistrennzeichen wie z. B. "\\", oder wenn der Pfad mit einem Laufwerkbuchstaben und Doppelpunkt (:) beginnt.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-558">The <xref:System.IO.Path.IsPathRooted%2A> method returns `true` if the first character is a directory separator character such as "\\", or if the path starts with a drive letter and colon (:).</span></span> <span data-ttu-id="6ac5b-559">Es gibt z. B. `true` für `path` Zeichenfolgen wie "\\\MyDir\\\MyFile.txt", "C:\\\MyDir", oder "C:MyDir".</span><span class="sxs-lookup"><span data-stu-id="6ac5b-559">For example, it returns `true` for `path` strings such as "\\\MyDir\\\MyFile.txt", "C:\\\MyDir", or "C:MyDir".</span></span> <span data-ttu-id="6ac5b-560">Es gibt `false` für `path` Zeichenfolgen wie "MyDir".</span><span class="sxs-lookup"><span data-stu-id="6ac5b-560">It returns `false` for `path` strings such as "MyDir".</span></span>  
  
 <span data-ttu-id="6ac5b-561">Diese Methode überprüft nicht, dass der Pfad oder Dateiname vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-561">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="6ac5b-562">Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="6ac5b-562">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  

## Examples  
 <span data-ttu-id="6ac5b-563">Im folgende Beispiel wird veranschaulicht, wie die `IsPathRooted` Methode kann verwendet werden, um die drei Zeichenfolgen zu testen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-563">The following example demonstrates how the `IsPathRooted` method can be used to test three strings.</span></span>  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6ac5b-564"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-564"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-565">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-565">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6ac5b-566">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="6ac5b-566">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6ac5b-567">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-567">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6ac5b-568">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-568">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="6ac5b-569">Eine Zeichenspanne, die den ersten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-569">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="6ac5b-570">Eine Zeichenspanne, die den zweiten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-570">A character span that contains the second path to join.</span></span></param>
        <summary><span data-ttu-id="6ac5b-571">Verkettet zwei Pfadkomponenten zu einem einzigen Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-571">Concatenates two path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-572">Die kombinierten Pfade.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-572">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="6ac5b-573">Diese Methode einfach verkettet `path` und `path2` und fügt Sie einem Verzeichnistrennzeichen zwischen den zwei Pfadkomponenten aus, wenn nicht bereits vorhanden ist, am Ende ist `path1` oder der Anfang des `path2`.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-573">This method simply concatenates `path` and `path2` and adds a directory separator character between the two path components if one is not already present at the end of `path1` or the beginning of `path2`.</span></span> <span data-ttu-id="6ac5b-574">Wenn die <xref:System.ReadOnlySpan%601.Length> entweder `path1` oder `path2` 0 (null), wird die Methode gibt den anderen Pfad zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-574">If the <xref:System.ReadOnlySpan%601.Length> of either `path1` or `path2` is zero, the method returns the other path.</span></span> <span data-ttu-id="6ac5b-575">Wenn die <xref:System.ReadOnlySpan%601.Length> beider `path1` und `path2` NULL ist, gibt die Methode zurück <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-575">If the <xref:System.ReadOnlySpan%601.Length> of both `path1` and `path2` is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> 

<span data-ttu-id="6ac5b-576">Wenn `path1` endet in einem Pfadtrennzeichen, die nicht geeignet für die Zielplattform ist die `Join` Methode behält die ursprünglichen Pfadtrennzeichen und fügt Sie unterstützt.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-576">If `path1` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="6ac5b-577">Dieses Problem tritt in hartcodierte Pfade, mit denen den Windows-umgekehrte Schrägstrich ("\")-Zeichen, die als Pfadtrennzeichen auf Unix-basierten Systemen nicht erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-577">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="6ac5b-578">Um dieses Problem zu umgehen, können Sie folgende Aktionen ausführen:</span><span class="sxs-lookup"><span data-stu-id="6ac5b-578">To work around this issue, you can:</span></span>

- <span data-ttu-id="6ac5b-579">Abrufen des Werts der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> Eigenschaft statt einem Verzeichnistrennzeichen fest zu programmieren.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-579">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="6ac5b-580">Verwenden Sie einen Schrägstrich ("/"), als dem Verzeichnistrennzeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-580">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="6ac5b-581">Dieses Zeichen wird zurückgegeben, durch die <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> Eigenschaft auf Unix-basierte Systeme und von der <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> Eigenschaft, die auf Windows-Systemen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-581">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span> 

<span data-ttu-id="6ac5b-582">Im Gegensatz zu den <xref:System.IO.Path.Combine%2A> -Methode, die <xref:System.IO.Path.Join%2A> Methhod wird nicht versucht, den zurückgegebenen Pfad als Stamm.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-582">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> methhod does not attempt to root the returned path.</span></span> <span data-ttu-id="6ac5b-583">(D. h., wenn `path2` ist ein absoluter Pfad, der `Join` -Methode verwirft keine `path1` und zurückgeben `path2` als die <xref:System.IO.Path.Combine%2A> Methode.) Das folgende Beispiel veranschaulicht den Unterschied in den Pfaden, die mithilfe der beiden Methoden zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-583">(That is, if `path2` is an absolute path, the `Join` method does not discard `path1` and return `path2` as the <xref:System.IO.Path.Combine%2A> method does.) The following example illustrates the difference in the paths returned by the two methods.</span></span> <span data-ttu-id="6ac5b-584">Wenn die Quelle der `path2` Benutzereingabe, wird die <xref:System.IO.Path.Combine%2A> Methode ermöglicht es einem Benutzer auf einer Dateisystemressource (z. B. *C:/Benutzer / "user1" /Dokumente/Finanz-/* im Beispiel), die die Anwendung nicht zugänglich machen möchten.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-584">If the source of `path2` is user input, the <xref:System.IO.Path.Combine%2A> method makes it possible for a user to access a file system resource (such as *C:/Users/User1/Documents/Financial/* in the case of hte example) that the application did not intend to make accessible.</span></span>  

<span data-ttu-id="6ac5b-585">Nicht alle für Verzeichnis-und Dateinamen ungültige Zeichen interpretiert werden als inakzeptabel ist, indem die `Join` -Methode, da Sie diese Zeichen nach den Platzhalterzeichen suchen können.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-585">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="6ac5b-586">Während beispielsweise `Path.Join("c:\\", "*.txt")` möglicherweise werden ungültige bei Erstellen einer Datei, es gilt als eine Suchzeichenfolge ein.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-586">For example, while `Path.Join("c:\\", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="6ac5b-587">Die `Join` Methode erfolgreich interpretiert es.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-587">The `Join` method therefore successfully interprets it.</span></span> 

## <a name="example"></a><span data-ttu-id="6ac5b-588">Beispiel</span><span class="sxs-lookup"><span data-stu-id="6ac5b-588">Example</span></span>

<span data-ttu-id="6ac5b-589">Das folgende Beispiel veranschaulicht den Unterschied in den Pfaden, die zurückgegeben werden, indem die <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> und <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> Methoden.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-589">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="6ac5b-590">Wenn die erste Zeichenfolge ist ein vollständig qualifizierten Pfad an, der ein Laufwerk und den Root-Verzeichnis enthält, und das zweite der erste Pfad ein relativer Pfad ist, werden die beiden Methoden identische Ergebnisse erzielt.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-590">When the first string is an fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="6ac5b-591">In den zweiten und dritten Aufrufen der `ShowPathInformation` -Methode, die mithilfe der beiden Methoden zurückgegebenen Zeichenfolgen voneinander abweichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-591">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="6ac5b-592">In der zweiten Methodenaufruf wird die erste Zeichenfolge Argument ist ein Laufwerk, während das zweite ein Verzeichnis mit entfernten nutzungsbeschränkungen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-592">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="6ac5b-593">Die `Join` Methode verkettet die beiden Zeichenfolgen und behält doppelt vorhandene Pfadtrennzeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-593">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="6ac5b-594">Die `Combine` Methode bricht ab dem Laufwerk, und gibt ein Verzeichnis mit entfernten nutzungsbeschränkungen auf das aktuelle Laufwerk zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-594">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="6ac5b-595">Wenn der Anwendung aktuelle Laufwerk C:\ ist. und diese Zeichenfolge wird verwendet, den Zugriff auf eine Datei oder Dateien im Verzeichnis, würden sie "c:" anstelle von "d:" zugreifen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-595">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="6ac5b-596">Abschließend da beide Argumente im dritten Aufruf `ShowPathInformation` als Stamm sind, die `Join` Methode fügt diese einfach um einen unsinnig Dateipfad zu erstellen, während er sich die `Combine` -Methode verwirft die erste Zeichenfolge Anmd gibt die Sekunde zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-596">Finally, becasue both arguments in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends them to create a nonsensical file path, while the `Combine` method discards the first string anmd returns the second.</span></span> <span data-ttu-id="6ac5b-597">Verwenden diese Zeichenfolge für den Zugriff auf Dateien gewähren, die Anwendung beispielsweise unerwünschten Zugriff auf vertrauliche Dateien.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-597">Using this string for file access could give the application unintended access to sensitive files.</span></span>  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-csharp[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-598">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-598">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="6ac5b-599">Eine Zeichenspanne, die den ersten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-599">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="6ac5b-600">Eine Zeichenspanne, die den zweiten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-600">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="6ac5b-601">Eine Zeichenspanne, die den dritten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-601">A character span that contains the third path to join.</span></span></param>
        <summary><span data-ttu-id="6ac5b-602">Verkettet drei Pfadkomponenten zu einem einzigen Pfad.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-602">Concatenates three path components into a single path.</span></span></summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="6ac5b-603">Diese Methode einfach verkettet `path`, `path2`, und `path3` und fügt Sie einem Verzeichnistrennzeichen zwischen von Pfadkomponenten, sofern nicht bereits vorhanden.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-603">This method simply concatenates `path`, `path2`, and `path3` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="6ac5b-604">Wenn die <xref:System.ReadOnlySpan%601.Length> aller `path1`, `path2`, oder `path3` Argument NULL ist, die Methode Contatenates die übrigen Argumente.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-604">If the <xref:System.ReadOnlySpan%601.Length> of any of `path1`, `path2`, or `path3` argument is zero, the method contatenates the remaining arguments.</span></span> <span data-ttu-id="6ac5b-605">Wenn die <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> aller Komponenten ist 0 (null), die der Methodenrückgabe <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-605">If the <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> of all components is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>    

<span data-ttu-id="6ac5b-606">Wenn `path1` oder `path2` endet in einem Pfadtrennzeichen, die nicht geeignet für die Zielplattform ist die `Join` Methode behält die ursprünglichen Pfadtrennzeichen und fügt Sie unterstützt.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-606">If `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="6ac5b-607">Dieses Problem tritt in hartcodierte Pfade, mit denen den Windows-umgekehrte Schrägstrich ("\")-Zeichen, die als Pfadtrennzeichen auf Unix-basierten Systemen nicht erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-607">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="6ac5b-608">Um dieses Problem zu umgehen, können Sie folgende Aktionen ausführen:</span><span class="sxs-lookup"><span data-stu-id="6ac5b-608">To work around this issue, you can:</span></span>

- <span data-ttu-id="6ac5b-609">Abrufen des Werts der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> Eigenschaft statt einem Verzeichnistrennzeichen fest zu programmieren.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-609">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="6ac5b-610">Verwenden Sie einen Schrägstrich ("/"), als dem Verzeichnistrennzeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-610">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="6ac5b-611">Dieses Zeichen wird zurückgegeben, durch die <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> Eigenschaft auf Unix-basierte Systeme und von der <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> Eigenschaft, die auf Windows-Systemen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-611">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span> 

<span data-ttu-id="6ac5b-612">Im Gegensatz zu den <xref:System.IO.Path.Combine%2A> -Methode, die <xref:System.IO.Path.Join%2A> Methhod wird nicht versucht, den zurückgegebenen Pfad als Stamm.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-612">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> methhod does not attempt to root the returned path.</span></span> <span data-ttu-id="6ac5b-613">(D. h., wenn `path2` oder `path2` ist ein absoluter Pfad, der `Join` -Methode verwirft keine der vorherigen Pfade wie die <xref:System.IO.Path.Combine%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-613">(That is, if `path2` or `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>  
  
<span data-ttu-id="6ac5b-614">Nicht alle für Verzeichnis-und Dateinamen ungültige Zeichen interpretiert werden als inakzeptabel ist, indem die `Join` -Methode, da Sie diese Zeichen nach den Platzhalterzeichen suchen können.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-614">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="6ac5b-615">Während beispielsweise `Path.Join("c:\\", "temp", "*.txt")` möglicherweise werden ungültige bei Erstellen einer Datei, es gilt als eine Suchzeichenfolge ein.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-615">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="6ac5b-616">Die `Join` Methode erfolgreich interpretiert es.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-616">The `Join` method therefore successfully interprets it.</span></span> 

## <a name="example"></a><span data-ttu-id="6ac5b-617">Beispiel</span><span class="sxs-lookup"><span data-stu-id="6ac5b-617">Example</span></span>

<span data-ttu-id="6ac5b-618">Das folgende Beispiel veranschaulicht den Unterschied in den Pfaden, die zurückgegeben werden, indem die <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> und <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> Methoden.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-618">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="6ac5b-619">Wenn die erste Zeichenfolge ist ein vollständig qualifizierten Pfad an, der ein Laufwerk und den Root-Verzeichnis enthält, und das zweite der erste Pfad ein relativer Pfad ist, werden die beiden Methoden identische Ergebnisse erzielt.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-619">When the first string is an fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="6ac5b-620">In den zweiten und dritten Aufrufen der `ShowPathInformation` -Methode, die mithilfe der beiden Methoden zurückgegebenen Zeichenfolgen voneinander abweichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-620">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="6ac5b-621">In der zweiten Methodenaufruf wird die erste Zeichenfolge Argument ist ein Laufwerk, während das zweite ein Verzeichnis mit entfernten nutzungsbeschränkungen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-621">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="6ac5b-622">Die `Join` Methode verkettet die beiden Zeichenfolgen und behält doppelt vorhandene Pfadtrennzeichen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-622">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="6ac5b-623">Ein Aufruf der <xref:System.IO.Path.GetFullPath%2A> Methode wäre keine doppelte codierungskosten vermeiden.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-623">A call to the <xref:System.IO.Path.GetFullPath%2A> method would eliminate the duplication.</span></span> <span data-ttu-id="6ac5b-624">Die `Combine` Methode bricht ab dem Laufwerk, und gibt ein Verzeichnis mit entfernten nutzungsbeschränkungen auf das aktuelle Laufwerk zurück.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-624">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="6ac5b-625">Wenn der Anwendung aktuelle Laufwerk C:\ ist. und diese Zeichenfolge wird verwendet, den Zugriff auf eine Datei oder Dateien im Verzeichnis, würden sie "c:" anstelle von "d:" zugreifen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-625">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="6ac5b-626">Schließlich da das letzte Argument im dritten Aufruf `ShowPathInformation` als Stamm sind, die `Join` Methode fügt diese einfach an die ersten beiden Argumente einen unsinnig Dateipfad erstellen während der `Combine` -Methode verwirft die ersten zwei Zeichenfolgen Anmd zurückgibt die dritte.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-626">Finally, becasue the final argument in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends it to the first two arguments to create a nonsensical file path, while the `Combine` method discards the first two strings anmd returns the third.</span></span> <span data-ttu-id="6ac5b-627">Verwenden diese Zeichenfolge für den Zugriff auf Dateien gewähren, die Anwendung beispielsweise unerwünschten Zugriff auf vertrauliche Dateien.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-627">Using this string for file access could give the application unintended access to sensitive files.</span></span>  

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)] 
[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)] 

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-628">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-628">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="path3">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6ac5b-629">Ein plattformspezifisches Trennzeichen, das zur Trennung von Pfadzeichenfolgen in Umgebungsvariablen verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-629">A platform-specific separator character used to separate path strings in environment variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6ac5b-630">Auf Windows-basierte desktop-Plattformen ist der Wert dieses Felds das Semikolon (;) wird standardmäßig, sondern auf anderen Plattformen zu variieren.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-630">On Windows-based desktop platforms, the value of this field is the semicolon (;) by default, but might vary on other platforms.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6ac5b-631">Das folgende Beispiel zeigt die Verwendung der `PathSeparator` Feld.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-631">The following example demonstrates the use of the `PathSeparator` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6ac5b-632">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="6ac5b-632">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6ac5b-633">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-633">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6ac5b-634">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-634">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary><span data-ttu-id="6ac5b-635">Versucht, einzelne Pfadkomponenten zu einer vorbelegten Zeichenspanne zu verketten, und gibt einen Wert zurück, der den Erfolg des Vorgangs angibt.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-635">Attempts to concatenate individual path components to a preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="6ac5b-636">Die Spanne der Ziel-Zeichen muss groß genug für den Concatentated-Pfad sein.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-636">The destination character span must be large enough to hold the concatentated path.</span></span> <span data-ttu-id="6ac5b-637">Sie können dann den verketteten Pfad abrufen, durch den Aufruf der <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> -Methode, wie im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-637">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the following example illustrates.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="6ac5b-638">Eine Zeichenspanne, die den ersten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-638">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="6ac5b-639">Eine Zeichenspanne, die den zweiten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-639">A character span that contains the second path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="6ac5b-640">Eine Zeichenspanne, die den verketteten Pfad enthalten soll.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-640">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="6ac5b-641">Ein Wert bei Rückgabe der Methode, der die Anzahl der Zeichen angibt, die in <paramref name="destination" /> geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-641">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="6ac5b-642">Versucht, zwei Pfadkomponenten zu einer einzigen vorbelegten Zeichenspanne zu verketten, und gibt einen Wert zurück, der den Erfolg des Vorgangs angibt.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-642">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-643"><see langword="true" />, wenn der Verkettungsvorgang erfolgreich ist; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-643"><see langword="true" /> if the concatentation operaton is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="6ac5b-644">`destination` muss groß genug für den Concatentated-Pfad sein.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-644">`destination` must be large enough to hold the concatentated path.</span></span> <span data-ttu-id="6ac5b-645">Sie können dann den verketteten Pfad abrufen, durch den Aufruf der <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> -Methode, wie im Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-645">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-646">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-646">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="6ac5b-647">Eine Zeichenspanne, die den ersten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-647">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="6ac5b-648">Eine Zeichenspanne, die den zweiten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-648">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="6ac5b-649">Eine Zeichenspanne, die den dritten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-649">A character span that contains the third path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="6ac5b-650">Eine Zeichenspanne, die den verketteten Pfad enthalten soll.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-650">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="6ac5b-651">Ein Wert bei Rückgabe der Methode, der die Anzahl der Zeichen angibt, die in <paramref name="destination" /> geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-651">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="6ac5b-652">Versucht, zwei Pfadkomponenten zu einer einzigen vorbelegten Zeichenspanne zu verketten, und gibt einen Wert zurück, der den Erfolg des Vorgangs angibt.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-652">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="6ac5b-653"><see langword="true" />, wenn der Verkettungsvorgang erfolgreich ist; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-653"><see langword="true" /> if the concatentation operaton is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="6ac5b-654">`destination` muss groß genug für den Concatentated-Pfad sein.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-654">`destination` must be large enough to hold the concatentated path.</span></span> <span data-ttu-id="6ac5b-655">Sie können dann den verketteten Pfad abrufen, durch den Aufruf der <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> -Methode, wie im Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-655">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="6ac5b-656">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="6ac5b-656">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6ac5b-657">Stellt ein plattformspezifisches Volumetrennzeichen bereit.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-657">Provides a platform-specific volume separator character.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6ac5b-658">Der Wert dieses Felds ist ein Doppelpunkt (:)) auf Windows und Macintosh sowie ein Schrägstrich (/) für UNIX-Betriebssystemen.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-658">The value of this field is a colon (:) on Windows and Macintosh, and a slash (/) on UNIX operating systems.</span></span> <span data-ttu-id="6ac5b-659">Dies ist besonders hilfreich für die Analyse von Pfaden, z. B. "c:\windows" oder "MacVolume: Ordner".</span><span class="sxs-lookup"><span data-stu-id="6ac5b-659">This is most useful for parsing paths such as "c:\windows" or "MacVolume:System Folder".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6ac5b-660">Das folgende Beispiel zeigt die Verwendung der `VolumeSeparatorChar` Feld.</span><span class="sxs-lookup"><span data-stu-id="6ac5b-660">The following example demonstrates the use of the `VolumeSeparatorChar` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6ac5b-661">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="6ac5b-661">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6ac5b-662">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-662">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6ac5b-663">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="6ac5b-663">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>