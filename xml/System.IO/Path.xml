<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bbceb05c56c65218177af6b97840c0c9b2ab8ae0" /><Meta Name="ms.sourcegitcommit" Value="2b0967e04b047f6709322418d97215dfcef6a938" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/20/2019" /><Meta Name="ms.locfileid" Value="74235878" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Führt Vorgänge für <see cref="T:System.String" />-Instanzen aus, die Datei- oder Verzeichnispfadinformationen enthalten. Diese Vorgänge werden plattformübergreifend durchgeführt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Ein Pfad ist eine Zeichenfolge, die den Speicherort einer Datei oder eines Verzeichnisses bereitstellt. Ein Pfad verweist nicht unbedingt auf einen Speicherort auf dem Datenträger. Beispielsweise kann ein Pfad einem Speicherort im Arbeitsspeicher oder auf einem Gerät zugeordnet werden. Das genaue Format eines Pfads wird von der aktuellen Plattform bestimmt. Beispielsweise kann ein Pfad auf einigen Systemen mit einem Laufwerk-oder Volumebuchstaben beginnen, während dieses Element nicht in anderen Systemen vorhanden ist. Auf einigen Systemen können Dateipfade Erweiterungen enthalten, die den Typ der in der Datei gespeicherten Informationen angeben. Das Format einer Dateinamenerweiterung ist plattformabhängig. beispielsweise beschränken einige Systeme Erweiterungen auf drei Zeichen, andere hingegen nicht. Die aktuelle Plattform bestimmt auch die Zeichen, die zum Trennen der Elemente eines Pfads verwendet werden, und den Satz von Zeichen, die beim Angeben von Pfaden nicht verwendet werden können. Aufgrund dieser Unterschiede sind die Felder der `Path`-Klasse sowie das genaue Verhalten einiger Member der `Path`-Klasse plattformabhängig.  
  
 Ein Pfad kann absolute oder relative Speicherort Informationen enthalten. Absolute Pfade geben einen Speicherort vollständig an: die Datei oder das Verzeichnis kann unabhängig vom aktuellen Speicherort eindeutig identifiziert werden. Relative Pfade geben einen partiellen Speicherort an: der aktuelle Speicherort wird beim Suchen einer Datei, die mit einem relativen Pfad angegeben ist, als Ausgangspunkt verwendet. Um das aktuelle Verzeichnis zu ermitteln, wenden Sie <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>an.  

 .Net Core 1,1 und höhere Versionen sowie .NET Framework 4.6.2 und höhere Versionen unterstützen auch den Zugriff auf Dateisystem Objekte, bei denen es sich um Gerätenamen handelt, z. b. "\\? \c:\".

Weitere Informationen zu Datei Pfad Formaten unter Windows finden Sie unter [Dateipfad Formate auf Windows-Systemen](~/docs/standard/io/file-path-formats.md).

 Die meisten Member der `Path`-Klasse interagieren nicht mit dem Dateisystem und überprüfen nicht, ob die Datei vorhanden ist, die durch eine Pfad Zeichenfolge angegeben wird. `Path` Klassenmember, die eine Pfad Zeichenfolge ändern, z. b. <xref:System.IO.Path.ChangeExtension%2A>, haben keine Auswirkung auf die Namen von Dateien im Dateisystem. `Path` Mitglieder jedoch den Inhalt einer angegebenen Pfad Zeichenfolge überprüfen und eine <xref:System.ArgumentException> Ausnahme auslösen, wenn die Zeichenfolge Zeichen enthält, die in Pfad Zeichenfolgen nicht gültig sind, wie in den von der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode zurückgegebenen Zeichen definiert. Beispielsweise können auf Windows-basierten Desktop Plattformen ungültige Pfad Zeichen Anführungszeichen ("), kleiner als (\<), größer als (>), Pipe (&#124;), Rücktaste (\b), NULL (\ 0) und Unicode-Zeichen 16 bis 18 und 20 bis 25 enthalten.  
  
 Die Member der `Path`-Klasse ermöglichen es Ihnen, häufig gängige Vorgänge auszuführen, z. b. zu ermitteln, ob eine Dateinamenerweiterung Teil eines Pfads ist, und zwei Zeichen folgen zu einem Pfadnamen zu kombinieren.  
  
 Alle Member der `Path`-Klasse sind statisch und können daher aufgerufen werden, ohne dass eine Instanz eines Pfades vorhanden ist.  
  
> [!NOTE]
>  In Membern, die einen Pfad als Eingabe Zeichenfolge akzeptieren, muss dieser Pfad wohl geformt sein, oder es wird eine Ausnahme ausgelöst. Wenn ein Pfad z. b. voll qualifiziert ist, aber mit einem Leerzeichen beginnt, wird der Pfad nicht in den Methoden der Klasse gekürzt. Daher ist der Pfad falsch formatiert, und es wird eine Ausnahme ausgelöst. Ebenso kann ein Pfad oder eine Kombination von Pfaden nicht zweimal voll qualifiziert werden. Beispielsweise löst "c:\temp c:\Windows" in den meisten Fällen auch eine Ausnahme aus. Stellen Sie sicher, dass die Pfade wohl geformt sind, wenn Sie Methoden verwenden, die eine Pfad Zeichenfolge akzeptieren.  
  
 In Membern, die einen Pfad akzeptieren, kann der Pfad auf eine Datei oder nur auf ein Verzeichnis verweisen. Der angegebene Pfad kann auch auf einen relativen Pfad oder einen Universal Naming Convention Pfad (UNC-Pfad) für einen Server und einen Freigabe Namen verweisen. Die folgenden Pfade sind beispielsweise zulässig:  
  
-   "c:\\\meindir\\\meineDatei.txt C#" in, oder "c:\mydir\meinedatei.txt" in Visual Basic.  
  
-   "c:\\\meinedir" C#in, oder "c:\meinedir" in Visual Basic.  
  
-   "Mydir\\\meinsubdir" in C#, oder "mydir\meinsubdir" in Visual Basic.  
  
-   "\\\\\\\meinserver\meineserver\\C#\meinefreigabe" in, oder "\\\meinserver\meinefreigabe" in Visual Basic.  
  
 Da all diese Vorgänge für Zeichen folgen ausgeführt werden, ist es nicht möglich, zu überprüfen, ob die Ergebnisse in allen Szenarien gültig sind. Die <xref:System.IO.Path.GetExtension%2A>-Methode analysiert z. b. eine Zeichenfolge, die Sie übergibt, und gibt die Erweiterung aus dieser Zeichenfolge zurück. Dies bedeutet jedoch nicht, dass eine Datei mit dieser Erweiterung auf dem Datenträger vorhanden ist.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.   
  
## Examples  
 Im folgenden Beispiel werden einige der Hauptmember der `Path`-Klasse veranschaulicht.  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Gewusst wie: Lesen und Schreiben einer neu erstellten Datendatei</related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt ein plattformspezifisches, alternatives Zeichen bereit, das zur Trennung von Verzeichnisebenen in einer Pfadzeichenfolge verwendet wird und eine hierarchische Dateisystemorganisation wiedergibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Dieses Feld kann denselben Wert wie <xref:System.IO.Path.DirectorySeparatorChar>haben. `AltDirectorySeparatorChar` und <xref:System.IO.Path.DirectorySeparatorChar> sind sowohl für die Trennung von Verzeichnis Ebenen in einer Pfad Zeichenfolge gültig.  
  
Der Wert dieses Felds ist ein Schrägstrich ("/") auf Windows-und UNIX-basierten Betriebssystemen.  
  
## Examples  

Im folgenden Beispiel werden <xref:System.IO.Path> Feldwerte in Windows und auf UNIX-basierten Systemen angezeigt. Beachten Sie, dass Windows entweder den Schrägstrich (der vom Feld "<xref:System.IO.Path.AltDirectorySeparatorChar>" zurückgegeben wird) oder den umgekehrten Schrägstrich (der vom Feld "<xref:System.IO.Path.DirectorySeparatorChar>" zurückgegeben wird) als Pfad Trennzeichen unterstützt, während UNIX-basierte Systeme nur den Schrägstrich unterstützen.

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die zu ändernden Pfadinformationen. Der Pfad darf keines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten Zeichen enthalten.</param>
        <param name="extension">Die neue Erweiterung (mit oder ohne führenden Punkt). Geben Sie <see langword="null" /> an, um eine vorhandene Erweiterung aus <paramref name="path" /> zu entfernen.</param>
        <summary>Ändert die Erweiterung einer Pfadzeichenfolge.</summary>
        <returns>Die geänderten Pfadinformationen.  
  
Auf Desktopplattformen auf Grundlage von Windows werden die Pfadinformationen unverändert zurückgegeben, wenn <paramref name="path" /> <see langword="null" /> oder eine leere Zeichenfolge ("") ist. Wenn <paramref name="extension" /><see langword="null" /> ist, enthält die zurückgegebene Zeichenfolge den angegebenen Pfad ohne die Erweiterung. Wenn <paramref name="path" /> keine Erweiterung besitzt und <paramref name="extension" /> nicht <see langword="null" /> ist, enthält die zurückgegebene Pfadzeichenfolge <paramref name="extension" />, angefügt an das Ende von <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn weder `path` noch `extension` einen Zeitraum (.) enthält, fügt `ChangeExtension` den Zeitraum hinzu.  
  
 Der `extension`-Parameter kann mehrere Zeiträume und alle gültigen Pfad Zeichen enthalten und kann eine beliebige Länge aufweisen. Wenn `extension` `null`ist, enthält die zurückgegebene Zeichenfolge den Inhalt von `path`, wobei der letzte Zeitraum und alle nachfolgenden Zeichen entfernt wurden.  
  
 Wenn `extension` eine leere Zeichenfolge ist, enthält die zurückgegebene Pfad Zeichenfolge den Inhalt `path` mit allen Zeichen, die nach dem letzten entfernten Zeitraum liegen.  
  
 Wenn `path` über keine Erweiterung verfügt und `extension` nicht `null`ist, enthält die zurückgegebene Zeichenfolge `path` gefolgt von `extension`.  
  
 Wenn `extension` nicht `null` ist und keinen führenden Zeitraum enthält, wird der Zeitraum hinzugefügt.  
  
 Wenn `path` eine mehrere durch mehrere Zeiträume getrennte Erweiterung enthält, enthält die zurückgegebene Zeichenfolge den Inhalt von `path`, wobei der letzte Zeitraum und alle nachfolgenden Zeichen durch `extension`ersetzt wurden. Wenn `path` z. b. "\Dir1\examples\pathtests.CSX.txt" lautet und `extension` "CS" ist, lautet der geänderte Pfad "\Dir1\examples\pathtests.CSX.cs".  
  
 Es ist nicht möglich, zu überprüfen, ob die zurückgegebenen Ergebnisse in allen Szenarien gültig sind. Wenn `path` z. b. leer ist, wird `extension` angefügt.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `ChangeExtension`-Methode veranschaulicht.  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kombiniert Zeichenfolgen zu einem Pfad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

Diese Methode ist für die Verkettung einzelner Zeichen folgen zu einer einzelnen Zeichenfolge vorgesehen, die einen Dateipfad darstellt. Wenn jedoch ein anderes Argument als das erste einen Rootpfad enthält, werden alle vorherigen Pfad Komponenten ignoriert, und die zurückgegebene Zeichenfolge beginnt mit der Stamm Pfadkomponente. Als Alternative zur `Combine`-Methode sollten Sie die Verwendung der Methoden <xref:System.IO.Path.Join%2A> oder <xref:System.IO.Path.TryJoin%2A> in Erwägung gezogen.

> [!IMPORTANT]
> Bei dieser Methode wird davon ausgegangen, dass das erste Argument ein absoluter Pfad ist und dass es sich bei den folgenden Argumenten um relative Pfade handelt. Wenn dies nicht der Fall ist, und vor allem, wenn nachfolgende Argumente Zeichen folgen Eingaben vom Benutzer sind, müssen Sie stattdessen die <xref:System.IO.Path.Join%2A>-oder <xref:System.IO.Path.TryJoin%2A>-Methode abrufen.

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths">Ein Array der Teile des Pfads.</param>
        <summary>Kombiniert ein Array von Zeichenfolgen zu einem Pfad.</summary>
        <returns>Die kombinierten Pfade.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

`paths` muss ein Array der zu kombinierenden Teile des Pfads sein. Wenn es sich bei einem der nachfolgenden Pfade um einen absoluten Pfad handelt, wird die Kombination aus dem absoluten Pfad zurückgesetzt, wobei alle vorherigen kombinierten Pfade verworfen werden.  

Wenn ein Element in `paths`, aber das letzte kein Laufwerk ist und nicht mit dem <xref:System.IO.Path.DirectorySeparatorChar> oder dem <xref:System.IO.Path.AltDirectorySeparatorChar> Zeichen endet, fügt die `Combine`-Methode ein <xref:System.IO.Path.DirectorySeparatorChar> Zeichen zwischen diesem und dem nächsten-Element hinzu. Beachten Sie Folgendes: Wenn das Element mit einem Pfad Trennzeichen endet, das für die Zielplattform nicht geeignet ist, behält die `Combine` Methode das ursprüngliche Pfad Trennzeichen bei und fügt eine unterstützte ein. Im folgenden Beispiel wird das Ergebnis auf Windows-und UNIX-basierten Systemen verglichen, wenn der umgekehrte Schrägstrich als Pfad Trennzeichen verwendet wird.

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 Zeichen folgen der Länge 0 (null) werden im kombinierten Pfad weggelassen.  
  
 Die Parameter werden nicht analysiert, wenn Sie Leerzeichen enthalten.  
  
 Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Combine`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können. Beispielsweise ist `Path.Combine("c:\\", "*.txt")` möglicherweise ungültig, wenn Sie eine Datei aus der Datei erstellen möchten, Sie als Such Zeichenfolge gültig ist. Sie wird daher von der `Combine`-Methode erfolgreich interpretiert.  
  
## Examples  
 Im folgenden Beispiel wird ein Array von Zeichen folgen zu einem Pfad kombiniert.  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Eine der Zeichenfolgen im Array enthält eines oder mehrere der ungültigen Zeichen, die in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definiert sind.</exception>
        <exception cref="T:System.ArgumentNullException">Eine der Zeichenfolgen im Array ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Der erste zu kombinierende Pfad.</param>
        <param name="path2">Der zweite zu kombinierende Pfad.</param>
        <summary>Kombiniert zwei Zeichenfolgen zu einem Pfad.</summary>
        <returns>Die kombinierten Pfade. Wenn einer der beiden angegebenen Pfade eine Zeichenfolge der Länge 0 ist, gibt diese Methode den anderen Pfad zurück. Wenn <paramref name="path2" /> einen absoluten Pfad enthält, gibt diese Methode <paramref name="path2" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `path1` kein Laufwerk Verweis ist (d. h. "C:" oder "D:") und nicht mit einem gültigen Trennzeichen endet, wie in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>oder <xref:System.IO.Path.VolumeSeparatorChar>definiert, wird <xref:System.IO.Path.DirectorySeparatorChar> vor der Verkettung an `path1` angehängt. Beachten Sie Folgendes: Wenn `path1` in einem Pfad Trennzeichen endet, das für die Zielplattform nicht geeignet ist, behält die `Combine` Methode das ursprüngliche Pfad Trennzeichen bei und fügt eine unterstützte ein. Im folgenden Beispiel wird das Ergebnis auf Windows-und UNIX-basierten Systemen verglichen, wenn der umgekehrte Schrägstrich als Pfad Trennzeichen verwendet wird.  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 Wenn `path2` keinen Stamm enthält (z. b., wenn `path2` nicht mit einem Trennzeichen oder einer Laufwerk Spezifikation beginnt), ist das Ergebnis eine Verkettung der beiden Pfade mit einem dazwischen liegenden Trennzeichen. Wenn `path2` einen Stamm enthält, wird `path2` zurückgegeben.  
  
 Die Parameter werden nicht analysiert, wenn Sie Leerzeichen enthalten. Wenn `path2` Leerraum (z. b. "\file.txt") enthält, fügt die <xref:System.IO.Path.Combine%2A>-Methode `path2` an `path1` an, anstatt nur `path2`zurückzugeben.  
  
 Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Combine`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können. Beispielsweise ist `Path.Combine("c:\\", "*.txt")` möglicherweise ungültig, wenn Sie eine Datei aus der Datei erstellen möchten, Sie als Such Zeichenfolge gültig ist. Sie wird daher von der `Combine`-Methode erfolgreich interpretiert.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `Combine`-Methode auf einer Windows-basierten Desktop Plattform veranschaulicht.  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" /> oder <paramref name="path2" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" /> oder <paramref name="path2" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Der erste zu kombinierende Pfad.</param>
        <param name="path2">Der zweite zu kombinierende Pfad.</param>
        <param name="path3">Der dritte zu kombinierende Pfad.</param>
        <summary>Kombiniert drei Zeichenfolgen zu einem Pfad.</summary>
        <returns>Die kombinierten Pfade.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1` sollte ein absoluter Pfad sein (z. b. "d:\archive" oder "\\\archives\public"). Wenn `path2` oder `path3` auch ein absoluter Pfad ist, verwirft der Combine-Vorgang alle zuvor kombinierten Pfade und setzt auf diesen absoluten Pfad zurück.  
  
 Zeichen folgen der Länge 0 (null) werden im kombinierten Pfad weggelassen.  
  
 Wenn `path1` oder `path2` kein Laufwerks Verweis ist (d. h. "C:" oder "D:") und nicht mit einem gültigen Trennzeichen endet, wie in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>oder <xref:System.IO.Path.VolumeSeparatorChar>definiert, wird <xref:System.IO.Path.DirectorySeparatorChar> vor der Verkettung an `path1` oder `path2` angehängt. Beachten Sie, dass die `Combine` Methode das ursprüngliche Pfad Trennzeichen beibehält und einen unterstützten Pfad anfügt, wenn `path1` oder `path2` in einem Pfad Trennzeichen endet, das für die Zielplattform nicht geeignet ist. Im folgenden Beispiel wird das Ergebnis auf Windows-und UNIX-basierten Systemen verglichen, wenn der umgekehrte Schrägstrich als Pfad Trennzeichen verwendet wird. 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 Wenn `path2` keinen Stamm enthält (z. b., wenn `path2` nicht mit einem Trennzeichen oder einer Laufwerk Spezifikation beginnt), ist das Ergebnis eine Verkettung der beiden Pfade mit einem dazwischen liegenden Trennzeichen. Wenn `path2` einen Stamm enthält, wird `path2` zurückgegeben.  
  
 Die Parameter werden nicht analysiert, wenn Sie Leerzeichen enthalten. Wenn `path2` Leerraum (z. b. "\file.txt") enthält, fügt die <xref:System.IO.Path.Combine%2A>-Methode `path2` an `path1`an.  
  
 Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Combine`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können. Beispielsweise ist `Path.Combine("c:\\", "*.txt")` möglicherweise ungültig, wenn Sie eine Datei aus der Datei erstellen möchten, Sie als Such Zeichenfolge gültig ist. Sie wird daher von der `Combine`-Methode erfolgreich interpretiert.  
  
   
  
## Examples  
 Im folgenden Beispiel werden drei Pfade kombiniert.  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" />, <paramref name="path2" /> oder <paramref name="path3" /> enthält mindestens ein ungültiges Zeichen gemäß der Definition in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" />, <paramref name="path2" /> oder <paramref name="path3" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Der erste zu kombinierende Pfad.</param>
        <param name="path2">Der zweite zu kombinierende Pfad.</param>
        <param name="path3">Der dritte zu kombinierende Pfad.</param>
        <param name="path4">Der vierte zu kombinierende Pfad.</param>
        <summary>Kombiniert vier Zeichenfolgen zu einem Pfad.</summary>
        <returns>Die kombinierten Pfade.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1` sollte ein absoluter Pfad sein (z. b. "d:\archive" oder "\\\archives\public"). Wenn einer der nachfolgenden Pfade ebenfalls ein absoluter Pfad ist, verwirft der Combine-Vorgang alle zuvor kombinierten Pfade und setzt auf diesen absoluten Pfad zurück.  
  
 Zeichen folgen der Länge 0 (null) werden im kombinierten Pfad weggelassen.  
  
 Wenn `path1`, `path2`oder `path3` kein Laufwerks Verweis ist (d. h. "C:" oder "D:") und nicht mit einem gültigen Trennzeichen endet, wie in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>oder <xref:System.IO.Path.VolumeSeparatorChar>definiert, wird <xref:System.IO.Path.DirectorySeparatorChar> vor der Verkettung angehängt. Beachten Sie Folgendes: Wenn `path1`, `path2`oder `path3` in einem Pfad Trennzeichen enden, das für die Zielplattform nicht geeignet ist, behält die `Combine`-Methode das ursprüngliche Pfad Trennzeichen bei und fügt eine unterstützte ein. Im folgenden Beispiel wird das Ergebnis auf Windows-und UNIX-basierten Systemen verglichen, wenn der umgekehrte Schrägstrich als Pfad Trennzeichen verwendet wird. 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 Wenn `path2` keinen Stamm enthält (z. b., wenn `path2` nicht mit einem Trennzeichen oder einer Laufwerk Spezifikation beginnt), ist das Ergebnis eine Verkettung der beiden Pfade mit einem dazwischen liegenden Trennzeichen. Wenn `path2` einen Stamm enthält, wird `path2` zurückgegeben.  
  
 Die Parameter werden nicht analysiert, wenn Sie Leerzeichen enthalten. Wenn `path2` Leerraum (z. b. "\file.txt") enthält, fügt die <xref:System.IO.Path.Combine%2A>-Methode `path2` an `path1`an.  
  
 Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Combine`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können. Beispielsweise ist `Path.Combine("c:\\", "*.txt")` möglicherweise ungültig, wenn Sie eine Datei aus der Datei erstellen möchten, Sie als Such Zeichenfolge gültig ist. Sie wird daher von der `Combine`-Methode erfolgreich interpretiert.  
  
   
  
## Examples  
 Im folgenden Beispiel werden vier Pfade kombiniert.  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> oder <paramref name="path4" /> enthält mindestens ein ungültiges Zeichen gemäß der Definition in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> oder <paramref name="path4" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt ein plattformspezifisches Zeichen bereit, das zur Trennung von Verzeichnisebenen in einer Pfadzeichenfolge verwendet wird und eine hierarchische Dateisystemorganisation wiedergibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.IO.Path.AltDirectorySeparatorChar> und `DirectorySeparatorChar` sind sowohl für die Trennung von Verzeichnis Ebenen in einer Pfad Zeichenfolge gültig.  
  
Wenn Sie .net Core verwenden, um Anwendungen zu entwickeln, die auf mehreren Plattformen ausgeführt werden:

- Wenn Sie das Verzeichnis Trennzeichen lieber hart codieren möchten, sollten Sie den Schrägstrich (`/`) verwenden. Es ist das einzige erkannte Verzeichnis Trennzeichen auf UNIX-Systemen, wie die Ausgabe des Beispiels zeigt, und ist der <xref:System.IO.Path.AltDirectorySeparatorChar> unter Windows.

- Verwenden Sie die Zeichen folgen Verkettung, um das Pfad Trennzeichen dynamisch zur Laufzeit abzurufen und in Dateisystem Pfade einzubinden. Ein auf ein Objekt angewendeter 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```

   ```vb
   separator = Path.DirectorySeparatorChar
   path = $"{separator}users{separator}user1{separator}"
   ``` 

   Sie können auch den Wert aus der <xref:System.IO.Path.AltDirectorySeparatorChar>-Eigenschaft abrufen, da dieser auf Windows-und Unx-basierten Systemen identisch ist.

- Abrufen der <xref:System.IO.Path.AltDirectorySeparatorChar>-Eigenschaft

Wenn Ihre Anwendung nicht plattformübergreifend ist, können Sie das für das System geeignete Trennzeichen verwenden.

## Examples  

Im folgenden Beispiel werden <xref:System.IO.Path> Feldwerte in Windows und auf UNIX-basierten Systemen angezeigt. Beachten Sie, dass Windows entweder den Schrägstrich (der vom Feld "<xref:System.IO.Path.AltDirectorySeparatorChar>" zurückgegeben wird) oder den umgekehrten Schrägstrich (der vom Feld "<xref:System.IO.Path.DirectorySeparatorChar>" zurückgegeben wird) als Pfad Trennzeichen unterstützt, während UNIX-basierte Systeme nur den Schrägstrich unterstützen.  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Der zu analysierende Pfad.</param>
        <summary>Gibt einen Wert zurück, mit dem angegeben wird, ob der als schreibgeschützter Bereich angegebene Pfad auf ein Verzeichnistrennzeichen endet.</summary>
        <returns><see langword="true" />, wenn der Pfad auf ein Verzeichnistrennzeichen endet; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : string -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Der zu analysierende Pfad.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der angegebene Pfad auf ein Verzeichnistrennzeichen endet.</summary>
        <returns><see langword="true" />, wenn der Pfad auf ein Verzeichnistrennzeichen endet; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad, aus dem die Verzeichnisinformationen abgerufen werden sollen.</param>
        <summary>Gibt die Verzeichnisinformationen für den angegebenen Pfad in Form einer Zeichenspanne zurück.</summary>
        <returns>Verzeichnisinformationen für <paramref name="path" /> oder eine leere Spanne, wenn <paramref name="path" /> <see langword="null" /> ist, eine leere Spanne oder ein Stamm (wie \, C: oder \\server\share).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Anders als bei der Zeichen folgen Überladung normalisiert diese Methode keine Verzeichnis Trennzeichen.

          ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad einer Datei oder eines Verzeichnisses.</param>
        <summary>Gibt die Verzeichnisinformationen für die angegebene Pfadzeichenfolge zurück.</summary>
        <returns>Verzeichnisinformationen für <paramref name="path" /> oder <see langword="null" />, wenn <paramref name="path" /> ein Stammverzeichnis bezeichnet oder NULL ist. Gibt <see cref="F:System.String.Empty" /> zurück, wenn <paramref name="path" /> keine Verzeichnisinformationen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In den meisten Fällen besteht die Zeichenfolge, die von dieser Methode zurückgegeben wird, aus allen Zeichen im Pfad bis einschließlich der letzten <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>. Wenn der Pfad aus einem Stammverzeichnis (z. b. "c:\\") besteht, wird NULL zurückgegeben. Beachten Sie, dass diese Methode keine Pfade unterstützt, die "file:" verwenden. Da der zurückgegebene Pfad die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>nicht enthält, führt das Übergeben des zurückgegebenen Pfades zurück in die <xref:System.IO.Path.GetDirectoryName%2A>-Methode dazu, dass eine Ordnerebene pro nachfolgenden Aufrufe der Ergebnis Zeichenfolge abgeschnitten wird. Wenn Sie z. b. den Pfad "c:\Directory\SubDirectory\test.txt" an die <xref:System.IO.Path.GetDirectoryName%2A>-Methode übergeben, wird "c:\Directory\SubDirectory" zurückgegeben. Wenn Sie die Zeichenfolge "c:\direct\subdirectory" in <xref:System.IO.Path.GetDirectoryName%2A> übergeben, wird "c:\directory" angezeigt.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `GetDirectoryName`-Methode auf einer Windows-basierten Desktop Plattform veranschaulicht.  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter enthält nur ungültige Zeichen, ist leer oder enthält nur Leerzeichen.</exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.IO.IOException" /> ab.  
  
</para>
          </block>  
  
 Der <paramref name="path" />-Parameter überschreitet die vom System definierte Maximallänge.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Der Dateipfad, aus dem die Erweiterung abgerufen werden soll.</param>
        <summary>Gibt die Erweiterung eines Dateipfads zurück, der durch eine schreibgeschützte Zeichenspanne dargestellt wird.</summary>
        <returns>Die Erweiterung des angegebenen Pfads (einschließlich des Punkts „.“) oder <see cref="P:System.ReadOnlySpan`1.Empty" />, falls <paramref name="path" /> keine Erweiterungsinformationen umfasst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Diese Methode ruft die Erweiterung der `path` ab, indem Sie `path` nach einem bestimmten Zeitraum (".") sucht, beginnend mit dem letzten Zeichen in der schreibgeschützten Spanne und Fortsetzung des ersten Zeichens. Wenn ein Zeitraum vor einem <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar> Zeichen gefunden wird, enthält die zurückgegebene schreibgeschützte Spanne den Zeitraum und die Zeichen danach. Andernfalls wird <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> zurückgegeben.  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Pfadzeichenfolge, aus der die Erweiterung abgerufen werden soll.</param>
        <summary>Gibt die Erweiterung (einschließlich des Punkts „.“) der angegebenen Pfadzeichenfolge zurück.</summary>
        <returns>Die Erweiterung des angegebenen Pfads (einschließlich des Punkts ".") oder <see langword="null" /> oder <see cref="F:System.String.Empty" />. Wenn <paramref name="path" /> gleich <see langword="null" /> ist, gibt <see cref="M:System.IO.Path.GetExtension(System.String)" /> <see langword="null" /> zurück. Wenn <paramref name="path" /> keine Informationen über die Erweiterung enthält, gibt <see cref="M:System.IO.Path.GetExtension(System.String)" /><see cref="F:System.String.Empty" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Diese Methode ruft die Erweiterung von `path` ab, indem Sie `path` nach einem bestimmten Zeitraum (.) sucht, beginnend mit dem letzten Zeichen in `path` und Fortfahren mit dem ersten Zeichen. Wenn ein Zeitraum vor einem <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar> Zeichen gefunden wird, enthält die zurückgegebene Zeichenfolge den Zeitraum und die Zeichen danach. Andernfalls wird <xref:System.String.Empty?displayProperty=nameWithType> zurückgegeben.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.
 
## Examples  
 Im folgenden Beispiel wird die Verwendung der `GetExtension`-Methode auf einer Windows-basierten Desktop Plattform veranschaulicht.  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Eine schreibgeschützte Spanne, die den Pfad enthält, aus dem der Dateiname und die Erweiterung abgerufen werden sollen.</param>
        <summary>Gibt den Dateinamen und die Erweiterung eines Dateipfads zurück, der durch eine schreibgeschützte Zeichenspanne dargestellt wird.</summary>
        <returns>Die Zeichen nach dem letzten Verzeichnistrennzeichen in <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Die zurückgegebene schreibgeschützte Spanne enthält die Zeichen des Pfads, der auf das letzte Trennzeichen in `path`folgt. Wenn das letzte Zeichen in `path` ein Volume oder ein Verzeichnis Trennzeichen ist, gibt die Methode <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>zurück. Wenn `path` kein Trennzeichen enthält, gibt die Methode `path`zurück.

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Pfadzeichenfolge, aus der der Dateiname und die Erweiterung abgerufen werden sollen.</param>
        <summary>Gibt den Dateinamen und die Erweiterung der angegebenen Pfadzeichenfolge zurück.</summary>
        <returns>Die Zeichen nach dem letzten Verzeichnistrennzeichen in <paramref name="path" />. Wenn das letzte Zeichen von <paramref name="path" /> ein Verzeichnis- bzw. Volumetrennzeichen ist, gibt diese Methode <see cref="F:System.String.Empty" /> zurück. Wenn <paramref name="path" /> gleich <see langword="null" /> ist, gibt die Methode <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Der zurückgegebene Wert ist `null`, wenn der Dateipfad `null`ist.  
  
Die Trennzeichen, mit denen der Start des Datei namens bestimmt wird, sind <xref:System.IO.Path.DirectorySeparatorChar> und <xref:System.IO.Path.AltDirectorySeparatorChar>.  

Da *\\* ein gültiger Dateiname auf UNIX ist, können `GetFileName`, der unter UNIX-basierten Plattformen ausgeführt wird, den Dateinamen nicht ordnungsgemäß aus einem Windows-basierten Pfad wie " *C:\\" MyDir "\\MyFile. ext*" zurückgeben, `GetFileName` aber unter Windows-basierte Plattformen können den Dateinamen ordnungsgemäß aus einem UNIX-basierten Pfad wie */tmp/MyFile.ext*zurückgeben, sodass das Verhalten der `GetFileName` Methode auf UNIX-und Windows-basierten Plattformen nicht genau identisch ist.

Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Verhalten der `GetFileName` Methode auf einer Windows-basierten Desktop Plattform veranschaulicht.  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Eine schreibgeschützte Spanne, die den Pfad enthält, aus dem der Dateiname ohne die Erweiterung abgerufen werden soll.</param>
        <summary>Gibt den Dateinamen ohne die Erweiterung eines Dateipfads zurück, der durch eine schreibgeschützte Zeichenspanne dargestellt wird.</summary>
        <returns>Die von <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" /> zurückgegebenen Zeichen in der schreibgeschützten Spanne ohne den letzten Punkt (.) und alle folgenden Zeichen.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad der Datei.</param>
        <summary>Gibt den Dateinamen der angegebenen Pfadzeichenfolge ohne Erweiterung zurück.</summary>
        <returns>Die von <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" /> zurückgegebene Zeichenfolge ohne den letzten Punkt (.) und alle folgenden Zeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überprüft nicht, ob der Pfad oder Dateiname vorhanden ist.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `GetFileNameWithoutExtension`-Methode veranschaulicht.  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für das die absoluten Pfadinformationen abgerufen werden sollen.</param>
        <summary>Gibt den absoluten Pfad für die angegebene Pfadzeichenfolge zurück.</summary>
        <returns>Der vollqualifizierte Speicherort von <paramref name="path" />, z. B. "C:\MyFile.txt".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Der absolute Pfad enthält alle Informationen, die erforderlich sind, um eine Datei oder ein Verzeichnis auf einem System zu finden.  
  
 Die Datei oder das Verzeichnis, das von `path` angegeben wird, muss nicht vorhanden sein. Wenn z. b. *c:\temp\newdir* das aktuelle Verzeichnis ist, wird beim Aufrufen von `GetFullPath` für einen Dateinamen wie " *Test. txt* " *c:\temp\newdir\test.txt*zurückgegeben. Die Datei muss nicht vorhanden sein.  

> [!IMPORTANT]
> Wenn `path` ein relativer Pfad ist, gibt diese Überladung einen voll qualifizierten Pfad zurück, der auf dem aktuellen Laufwerk und dem aktuellen Verzeichnis basieren kann. Das aktuelle Laufwerk und das aktuelle Verzeichnis können sich jederzeit ändern, wenn eine Anwendung ausgeführt wird. Folglich kann der von dieser Überladung zurückgegebene Pfad nicht im Voraus bestimmt werden. Um einen deterministischen Pfad zurückzugeben, müssen Sie die <xref:System.IO.Path.GetFullPath(System.String,System.String)> Überladung aufrufen. Sie können auch die <xref:System.IO.Path.IsPathFullyQualified%2A>-Methode aufzurufen, um zu bestimmen, ob ein Pfad vollständig qualifiziert oder relativ ist, und daher, ob ein `GetFullPath` erforderlich ist.

 Wenn `path` jedoch vorhanden ist, muss der Aufrufer über die Berechtigung zum Abrufen von Pfadinformationen für `path`verfügen. Beachten Sie, dass diese Methode im Gegensatz zu den meisten Membern der <xref:System.IO.Path>-Klasse auf das Dateisystem zugreift.  
  
 Diese Methode verwendet das aktuelle Verzeichnis und die aktuellen Volumeinformationen, um `path`vollständig zu qualifizieren. Wenn Sie in `path`nur einen Dateinamen angeben, gibt `GetFullPath` den voll qualifizierten Pfad des aktuellen Verzeichnisses zurück.  
  
 Wenn Sie einen kurzen Dateinamen übergeben, wird er auf einen langen Dateinamen erweitert.  
  
 Wenn ein Pfad keine signifikanten Zeichen enthält, ist er ungültig, es sei denn, er enthält mindestens ein "."-Zeichen, auf das eine beliebige Anzahl von Leerzeichen folgt. Anschließend wird Sie entweder als "." oder ".." analysiert.  

.Net Core 1,1 und höhere Versionen sowie .NET Framework 4.6.2 und höhere Versionen unterstützen auch Pfade, die Gerätenamen enthalten, z. b. "\\? \c:\".

Weitere Informationen zu Datei Pfad Formaten unter Windows finden Sie unter [Dateipfad Formate auf Windows-Systemen](~/docs/standard/io/file-path-formats.md). Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.
  
## Examples  
 Im folgenden Beispiel wird die `GetFullPath`-Methode auf einer Windows-basierten Desktop Plattform veranschaulicht.  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), besteht nur aus Leerraum oder enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültige Zeichen.  
  
- oder - 
Das System konnte den absoluten Pfad nicht abrufen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> enthält einen Doppelpunkt („:“), der kein Teil eines Volumenbezeichners (z.B. „c:\\“) ist.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf den Pfad.</permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="basePath" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer Pfad zum Verketten mit <paramref name="basePath" />.</param>
        <param name="basePath">Der Anfang eines vollqualifizierten Pfads.</param>
        <summary>Gibt einen absoluten Pfad aus einem vollqualifizierten Basispfad und einem relativen Pfad zurück.</summary>
        <returns>Der absolute Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Wenn `path` ein leerer Pfad ist, gibt die Methode `basePath`zurück. Wenn `path` ein voll qualifizierter Pfad ist, übergibt die Methode `path` an die <xref:System.IO.Path.GetFullPath(System.String)>-Methode und gibt das Ergebnis zurück.

Verwenden Sie diese Methode, um einen deterministischen Pfad basierend auf einem angegebenen Volume und Stammverzeichnis zurückzugeben, wenn Sie relative Pfade verwenden. Die Verwendung eines vordefinierten `basePath` nicht auf Grundlage des aktuellen Laufwerks Verzeichnisses schützt vor unerwünschten Dateipfaden, die durch unerwartete Änderungen im aktuellen Laufwerk und Verzeichnis verursacht werden. 

## <a name="example"></a>Beispiel

Im folgenden Beispiel wird eine Variable, `basePath`, definiert, um das aktuelle Verzeichnis einer Anwendung darzustellen. Er übergibt ihn dann an die `GetFullPath`-Methode, um einen voll qualifizierten Pfad zum Datenverzeichnis der Anwendung zu erhalten.

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-vb[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> oder <paramref name="basePath" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="basePath" /> ist kein vollqualifizierter Pfad.

- oder -

<paramref name="path" /> oder <paramref name="basePath" /> enthält ungültige Pfadzeichen, z. B. U+0000.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein Array ab, das die Zeichen enthält, die in Dateinamen nicht zulässig sind.</summary>
        <returns>Ein Array, das die Zeichen enthält, die in Dateinamen nicht zulässig sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das von dieser Methode zurückgegebene Array enthält nicht unbedingt den kompletten Satz von Zeichen, die in Datei-und Verzeichnisnamen ungültig sind. Der vollständige Satz von ungültigen Zeichen kann je nach Dateisystem variieren. Beispielsweise können auf Windows-basierten Desktop Plattformen ungültige Pfad Zeichen ASCII/Unicode-Zeichen 1 bis 31 sowie Anführungszeichen ("), kleiner als (\<), größer als (>), Pipe (&#124;), Rücktaste (\b), NULL (\ 0) und Tabulator (\t) enthalten.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.IO.Path.GetInvalidFileNameChars%2A>-Methode und die <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode zum Abrufen ungültiger Zeichen veranschaulicht.  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein Array ab, das die Zeichen enthält, die in Pfadnamen nicht zulässig sind.</summary>
        <returns>Ein Array, das die Zeichen enthält, die in Pfadnamen nicht zulässig sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das von dieser Methode zurückgegebene Array enthält nicht unbedingt den kompletten Satz von Zeichen, die in Datei-und Verzeichnisnamen ungültig sind. Der vollständige Satz von ungültigen Zeichen kann je nach Dateisystem variieren. Beispielsweise können auf Windows-basierten Desktop Plattformen ungültige Pfad Zeichen ASCII/Unicode-Zeichen 1 bis 31 sowie Anführungszeichen ("), kleiner als (\<), größer als (>), Pipe (&#124;), Rücktaste (\b), NULL (\ 0) und Tabulator (\t) enthalten.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.IO.Path.GetInvalidFileNameChars%2A>-Methode und die <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode zum Abrufen ungültiger Zeichen veranschaulicht.  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Eine schreibgeschützte Spanne von Zeichen, die den Pfad enthält, für den Stammverzeichnisinformationen abgerufen werden sollen.</param>
        <summary>Ruft Informationen über das Stammverzeichnis aus dem Pfad ab, der in der angegebenen Zeichenspanne enthalten ist.</summary>
        <returns>Eine schreibgeschützte Zeichenspanne mit dem Stammverzeichnis von <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Diese Methode überprüft nicht, ob der Pfad oder die Datei vorhanden ist.

Anders als bei der Zeichen folgen Überladung normalisiert diese Methode keine Verzeichnis Trennzeichen.

Ein `ReadOnlySpan<System.Char>` ist "effektiv leer", wenn Folgendes gilt:

- In Windows gibt das Aufrufen von <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> für diese Zeichen Spanne `true`zurück, oder alle Zeichen sind Leerzeichen ("").
- In UNIX gibt das Aufrufen von <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> für diese Zeichen Spanne `true`zurück.

Mögliche Muster für die schreibgeschützte Zeichen Spanne, die von dieser Methode zurückgegeben wird, lauten wie folgt:

- <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> (`path` wurde <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.

- <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> (`path` einen relativen Pfad auf dem aktuellen Laufwerk oder Volume angegeben).

- "\" (Unix: `path` einen absoluten Pfad auf dem aktuellen Laufwerk angegeben).

- "X:" (Windows: `path` einen relativen Pfad auf einem Laufwerk angeben, wobei *X* ein Laufwerk oder einen Volumebuchstaben darstellt).

- "X:\" (Windows: `path` einen absoluten Pfad auf einem angegebenen Laufwerk angeben).

- "\\\computername\sharedfolder" (Windows: ein UNC-Pfad).

- "\\\\\?\c:" (Windows: ein DOS-Gerätepfad, der in .net Core 1,1 und höheren Versionen und in .NET Framework 4.6.2 und höheren Versionen unterstützt wird).
 
Weitere Informationen zu Dateipfaden unter Windows finden Sie unter [Dateipfad Formate auf Windows-Systemen](~/docs/standard/io/file-path-formats.md). Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.


          ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Eine Zeichenfolge mit dem Pfad, für den Informationen über das Stammverzeichnis abgerufen werden sollen.</param>
        <summary>Ruft Informationen über das Stammverzeichnis aus dem Pfad ab, der in der angegebenen Zeichenfolge enthalten ist.</summary>
        <returns>Das Stammverzeichnis von <paramref name="path" />, wenn es einen Stamm hat.

- oder - 
<see cref="P:System.String.Empty" />, wenn <paramref name="path" /> keine Stammverzeichnisinformationen enthält.

- oder - 
<see langword="null" />, wenn <paramref name="path" /> <see langword="null" /> oder effektiv leer ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Diese Methode überprüft nicht, ob der Pfad oder die Datei vorhanden ist.

Mit dieser Methode werden Verzeichnis Trennzeichen normalisiert.

Eine Zeichenfolge ist "effektiv leer", wenn Folgendes gilt:

- In Windows gibt das Aufrufen von `IsEmpty` für diese Zeichenfolge `true`zurück, oder alle zugehörigen Zeichen sind Leerzeichen ("").
- In UNIX gibt das Aufrufen von <xref:System.String.IsNullOrEmpty%2A> für diese Zeichenfolge `true`zurück.

Mögliche Muster für die von dieser Methode zurückgegebene Zeichenfolge sind folgende:

- `null` (`path` war NULL oder eine leere Zeichenfolge).

- Eine leere Zeichenfolge (`path` einen relativen Pfad auf dem aktuellen Laufwerk oder Volume angegeben).

- "\" (Unix: `path` einen absoluten Pfad auf dem aktuellen Laufwerk angegeben).

- "X:" (Windows: `path` einen relativen Pfad auf einem Laufwerk angeben, wobei *X* ein Laufwerk oder einen Volumebuchstaben darstellt).

- "X:\" (Windows: `path` einen absoluten Pfad auf einem angegebenen Laufwerk angeben).

- "\\\computername\sharedfolder" (Windows: ein UNC-Pfad).

- "\\\\\?\c:" (Windows: ein DOS-Gerätepfad, der in .net Core 1,1 und höheren Versionen und in .NET Framework 4.6.2 und höheren Versionen unterstützt wird).
 
Weitere Informationen zu Dateipfaden unter Windows finden Sie unter [Dateipfad Formate auf Windows-Systemen](~/docs/standard/io/file-path-formats.md). Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.

## Examples
Im folgenden Beispiel wird die Verwendung der `GetPathRoot`-Methode veranschaulicht.

[!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
[!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
[!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nur .NET Framework: <paramref name="path" /> mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.

- oder -

Nur .NET Framework: <see cref="F:System.String.Empty" /> wurde an <paramref name="path" /> übergeben.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen zufälligen Ordnernamen oder Dateinamen zurück.</summary>
        <returns>Ein zufälliger Ordnername oder Dateiname.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Path.GetRandomFileName%2A>-Methode gibt eine kryptografisch starke, zufällige Zeichenfolge zurück, die entweder als Ordnername oder Dateiname verwendet werden kann. Im Gegensatz zu <xref:System.IO.Path.GetTempFileName%2A>erstellt <xref:System.IO.Path.GetRandomFileName%2A> keine Datei. Wenn die Sicherheit Ihres Dateisystems Vorrang hat, sollte diese Methode anstelle von <xref:System.IO.Path.GetTempFileName%2A>verwendet werden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Ausgabe der <xref:System.IO.Path.GetRandomFileName%2A>-Methode.  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="relativeTo">Der Quellpfad, zu dem das Ergebnis relativ sein muss. Dieser Pfad wird nicht immer als Verzeichnis betrachtet.</param>
        <param name="path">Der Zielpfad.</param>
        <summary>Gibt einen relativen Pfad von einem Pfad zu einem anderen zurück.</summary>
        <returns>Der relative Pfad oder <paramref name="path" />, wenn die Pfade nicht denselben Stamm aufweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Pfade werden durch Aufrufen der <xref:System.IO.Path.GetFullPath%2A>-Methode aufgelöst, bevor die Differenz berechnet wird. Die-Methode verwendet den standardmäßigen Dateipfad Vergleich für die aktuelle Plattform (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> für Windows und MacOS <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> für Linux. 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relativeTo" /> oder <paramref name="path" /> ist <see langword="null" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine eindeutig benannte temporäre Datei auf dem Datenträger mit einer Größe von 0 Byte und gibt den vollständigen Pfad dieser Datei zurück.</summary>
        <returns>Der vollständige Pfad der temporären Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine temporäre Datei mit einem. Tmp-Dateierweiterung. Die temporäre Datei wird im temporären Ordner des Benutzers erstellt. Dies ist der Pfad, der von der <xref:System.IO.Path.GetTempPath%2A>-Methode zurückgegeben wird.  
  
 Die <xref:System.IO.Path.GetTempFileName%2A>-Methode gibt eine <xref:System.IO.IOException> aus, wenn mehr als 65535 Dateien erstellt werden, ohne vorherige temporäre Dateien zu löschen.  
  
 Die <xref:System.IO.Path.GetTempFileName%2A>-Methode gibt eine <xref:System.IO.IOException> aus, wenn kein eindeutiger temporärer Dateiname verfügbar ist. Löschen Sie alle nicht benötigten temporären Dateien, um diesen Fehler zu beheben.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler tritt auf, z. B. ist kein eindeutiger temporärer Dateiname verfügbar.  
  
- oder -
  
 Diese Methode konnte keine temporäre Datei erstellen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in das temporäre Verzeichnis. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Pfad des temporären Ordners des aktuellen Benutzers zurück.</summary>
        <returns>Der Pfad zum temporären Ordner, endend mit einem umgekehrten Schrägstrich.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überprüft, ob Umgebungsvariablen in der folgenden Reihenfolge vorhanden sind, und verwendet den ersten gefundenen Pfad:  
  
1.  Der von der TMP-Umgebungsvariablen angegebene Pfad.  
  
2.  Der von der TEMP-Umgebungsvariablen angegebene Pfad.  
  
3.  Der von der User Profile-Umgebungsvariablen angegebene Pfad.  
  
4.  Das Windows-Verzeichnis.  
  
   
  
## Examples  
 Im folgenden Code wird das Aufrufen der <xref:System.IO.Path.GetTempPath%2A>-Methode veranschaulicht.  
  
```vb  
Dim result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 Dieses Beispiel erzeugt eine Ausgabe ähnlich der folgenden.  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für den uneingeschränkten Zugriff auf Umgebungsvariablen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad, in dem nach einer Erweiterung gesucht werden soll.</param>
        <summary>Legt fest, ob der Pfad, der durch die angegebene Zeichenspanne dargestellt wird, eine Erweiterung enthält.</summary>
        <returns><see langword="true" />, wenn die Zeichen, die auf das letzte Verzeichnistrennzeichen oder Volumentrennzeichen im Pfad folgen, einen Punkt (.) gefolgt von einem oder mehreren Zeichen enthalten; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Ein nach stehender Zeitraum in `path` wird nicht als Erweiterung angesehen.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad, in dem nach einer Erweiterung gesucht werden soll.</param>
        <summary>Bestimmt, ob ein Pfad eine Dateierweiterung enthält.</summary>
        <returns><see langword="true" />, wenn die Zeichen, die auf das letzte Verzeichnistrennzeichen (\\\ oder /) oder Volumentrennzeichen (:) im Pfad folgen, einen Punkt (.) gefolgt von einem oder mehreren Zeichen enthalten; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beginnend ab dem Ende `path`sucht diese Methode nach einem Zeitraum (.), gefolgt von mindestens einem Zeichen. Wenn dieses Muster gefunden wird, bevor eine <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>oder <xref:System.IO.Path.VolumeSeparatorChar> Zeichen gefunden wird, gibt diese Methode `true`zurück.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `HasExtension`-Methode gezeigt.  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt ein plattformspezifisches Array von Zeichen bereit, die nicht in Pfadzeichenfolgenargumenten angegeben werden können, die an Member der <see cref="T:System.IO.Path" />-Klasse übergeben werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das von dieser Methode zurückgegebene Array enthält nicht unbedingt den kompletten Satz von Zeichen, die in Datei-und Verzeichnisnamen ungültig sind. Der vollständige Satz von ungültigen Zeichen kann je nach Dateisystem variieren. Beispielsweise können auf Windows-basierten Desktop Plattformen ungültige Pfad Zeichen ASCII/Unicode-Zeichen 1 bis 31 sowie Anführungszeichen ("), kleiner als (\<), größer als (>), Pipe (&#124;), Rücktaste (\b), NULL (\ 0) und Tabulator (\t) enthalten.  
  
> [!CAUTION]
>  Verwenden Sie <xref:System.IO.Path.InvalidPathChars> nicht, wenn Sie der Ansicht sind, dass Ihr Code in derselben Anwendungsdomäne wie nicht vertrauenswürdiger Code ausgeführt werden kann. <xref:System.IO.Path.InvalidPathChars> ist ein Array, sodass seine Elemente überschrieben werden können. Wenn nicht vertrauenswürdiger Code Elemente <xref:System.IO.Path.InvalidPathChars>überschreibt, kann dies dazu führen, dass der Code nicht mehr funktioniert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `InvalidPathChars`-Eigenschaft veranschaulicht.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob ein Dateipfad vollqualifiziert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

Die über Ladungen der `IsPathFullyQualified`-Methode behandeln Pfade, die sowohl die <xref:System.IO.Path.DirectorySeparatorChar> als auch die <xref:System.IO.Path.AltDirectorySeparatorChar> Zeichen verwenden. Es wird keine Überprüfung des Pfads durchgeführt, der als Argument an ihn weitergeleitet wird. Demzufolge werden URIs als relative Pfade interpretiert und `false`zurückgegeben. 

Es gibt einen Unterschied zwischen einem voll qualifizierten Pfad (wie durch die `IsPathFullyQualified`-Methode angegeben) und einem Rootpfad (wie durch die <xref:System.IO.Path.IsPathRooted%2A>-Methode angegeben). Durch einen *voll qualifizierten Pfad* oder einen *absoluten Pfad* wird immer ein genauer Pfad von einem bestimmten Laufwerk oder Gerät zu einer Zieldatei oder einem Zielverzeichnis definiert, und es hängt nicht vom aktuellen Laufwerk oder aktuellen Verzeichnis ab. Auf Windows-Systemen definiert z. *b. C:/users/user1/Documents/Reports/2019/January/Highlights. PDF* einen absoluten Pfad vom Stamm des Laufwerks c: zur Zieldatei, *Highlights. PDF*. Ein *Stammpfad* gibt entweder ein Start Laufwerk oder ein Stammverzeichnis an, hängt jedoch vom aktuellen Verzeichnis (wenn es sich um ein bestimmtes Laufwerk befindet) oder dem aktuellen Laufwerk (wenn es sich um ein Stammverzeichnis des Stamm Verzeichnisses befindet) ab. Im folgenden Beispiel wird der Unterschied zwischen voll qualifizierten Pfaden und rootpfaden veranschaulicht.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Ein Dateipfad.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der durch die angegebene Zeichenspanne dargestellte Dateipfad auf ein bestimmtes Laufwerk oder einen UNC-Pfad festgelegt ist.</summary>
        <returns><see langword="true" />, wenn der Pfad auf ein bestimmtes Laufwerk oder einen UNC-Pfad festgelegt ist; <see langword="false" />, wenn der Pfad relativ zum aktuellen Laufwerk oder Arbeitsverzeichnis angegeben ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Ein Dateipfad.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der angegebene Dateipfad auf ein bestimmtes Laufwerk oder einen UNC-Pfad festgelegt ist.</summary>
        <returns><see langword="true" />, wenn der Pfad auf ein bestimmtes Laufwerk oder einen UNC-Pfad festgelegt ist; <see langword="false" />, wenn der Pfad relativ zum aktuellen Laufwerk oder Arbeitsverzeichnis angegeben ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Diese Methode verarbeitet Pfade, die das alternative Verzeichnis Trennzeichen verwenden. Es ist ein häufiger Fehler, zu vermuten, dass Stamm Pfade (<xref:System.IO.Path.IsPathRooted(System.String)>) nicht relativ sind. Beispielsweise ist "c:a" das Laufwerk relativ, d. h., es wird anhand des aktuellen Verzeichnisses für C: (rooting, aber relativ) aufgelöst. "C:\a" ist von einem Stamm und nicht relativ, d. h., das aktuelle Verzeichnis wird nicht zum Ändern des Pfads verwendet.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob ein Dateipfad einen Stamm enthält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

Ein **Stammpfad** ist ein Dateipfad, der auf einem bestimmten Laufwerk oder einem bestimmten Unic-Pfad korrigiert wird. Es steht im Gegensatz zu einem Pfad, der relativ zum aktuellen Laufwerk oder Arbeitsverzeichnis ist. Auf Windows-Systemen beginnt ein Stammpfad z. b. mit einem umgekehrten Schrägstrich (z. b. "\Documents") oder einem Laufwerk Buchstaben und Doppelpunkt (z. b. "c:Documents"). 

Beachten Sie, dass Stamm Pfade entweder absolut (d. h. voll qualifiziert) oder relativ sind. Ein absoluter Stammpfad ist ein voll qualifizierter Pfad vom Stammverzeichnis eines Laufwerks zu einem bestimmten Verzeichnis. Ein relativer Stammpfad gibt ein Laufwerk an, aber der voll qualifizierte Pfad wird anhand des aktuellen Verzeichnisses aufgelöst. Der Unterschied wird im folgenden Beispiel veranschaulicht.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Der zu testende Pfad.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Zeichenspanne zur Darstellung eines Dateipfads einen Stamm enthält.</summary>
        <returns><see langword="true" />, wenn <paramref name="path" /> einen Stamm enthält, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der zu testende Pfad.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Pfadzeichenfolge einen Stamm enthält.</summary>
        <returns><see langword="true" />, wenn <paramref name="path" /> einen Stamm enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Path.IsPathRooted%2A>-Methode gibt `true` zurück, wenn das erste Zeichen ein Verzeichnis Trennzeichen wie z. b. "\\" ist, oder wenn der Pfad mit einem Laufwerk Buchstaben und einem Doppelpunkt (":)") beginnt. Er gibt z. b. `true` für `path` Zeichenfolgen zurück, z. b. "\\\meinredir\\\meineDatei.txt", "C:\\\meinredir" oder "c:MyDir". Sie gibt `false` für `path` Zeichenfolgen zurück, z. b. "MyDir".  
  
 Diese Methode überprüft nicht, ob der Pfad oder Dateiname vorhanden ist.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  

## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die `IsPathRooted`-Methode zum Testen von drei Zeichen folgen verwendet werden kann.  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Join : string[] -&gt; string" Usage="System.IO.Path.Join paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="netcore-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths">Ein Array von Pfaden.</param>
        <summary>Verkettet ein Array von Pfaden zu einem einzelnen Pfad.</summary>
        <returns>Der verkettete Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Diese Methode verkettet einfach alle Zeichen folgen in `paths` und fügt ein Verzeichnis Trennzeichen zwischen allen Pfad Komponenten hinzu, wenn noch keines vorhanden ist. Wenn die <xref:System.String.Length> eines der Pfade in `paths` 0 (null) ist, verkettet die Methode die restlichen Argumente. Wenn die resultierende verketteten Zeichen folgen Länge 0 (null) ist, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithType>zurück.

Wenn einer der Pfade in `paths`, mit Ausnahme des letzten, mit einem Pfad Trennzeichen endet, das für die Zielplattform nicht geeignet ist, behält die `Join` Methode das ursprüngliche Pfad Trennzeichen bei und fügt die unterstützte Methode an. Dieses Problem tritt in hart codierten Pfaden auf, die den umgekehrten Schrägstrich ("\"") von Windows verwenden, der nicht als Pfad Trennzeichen auf UNIX-basierten Systemen erkannt wird. Um dieses Problem zu umgehen, können Sie folgende Aktionen ausführen:

- Rufen Sie den Wert der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft ab, anstatt ein Verzeichnis Trennzeichen hart zu codieren.

- Verwenden Sie einen Schrägstrich ("/") als Trennzeichen für das Verzeichnis. Dieses Zeichen wird von der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf UNIX-basierten Systemen und von der <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf Windows-Systemen zurückgegeben.

Anders als bei der <xref:System.IO.Path.Combine%2A>-Methode versucht die <xref:System.IO.Path.Join%2A>-Methode nicht, den zurückgegebenen Pfad zu verankern. (Das heißt, wenn einer der Pfade in `paths`, mit Ausnahme des letzten, ein absoluter Pfad ist, werden die vorherigen Pfade von der `Join`-Methode nicht verworfen, wenn die <xref:System.IO.Path.Combine%2A>-Methode dies tut.

Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Join`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können. Wenn `Path.Join("c:\\", "temp", "*.txt")` beispielsweise beim Erstellen einer Datei ungültig sein kann, ist Sie als Such Zeichenfolge gültig. Diese Methode wird von der `Join`-Methode daher erfolgreich interpretiert.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Eine Zeichenspanne, die den ersten Pfad für die Verknüpfung enthält.</param>
        <param name="path2">Eine Zeichenspanne, die den zweiten Pfad für die Verknüpfung enthält.</param>
        <summary>Verkettet zwei Pfadkomponenten zu einem einzigen Pfad.</summary>
        <returns>Die kombinierten Pfade.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Mit dieser Methode werden einfach `path` und `path2` verkettet, und es wird ein Verzeichnis Trennzeichen zwischen den beiden Pfad Komponenten hinzugefügt, wenn am Ende der `path1` oder am Anfang `path2`nicht bereits vorhanden ist. Wenn die <xref:System.ReadOnlySpan%601.Length> von `path1` oder `path2` NULL ist, gibt die Methode den anderen Pfad zurück. Wenn die <xref:System.ReadOnlySpan%601.Length> von `path1` und `path2` NULL ist, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithType>zurück. 

Wenn `path1` in einem Pfad Trennzeichen endet, das für die Zielplattform nicht geeignet ist, behält die `Join` Methode das ursprüngliche Pfad Trennzeichen bei und fügt das unterstützte ein. Dieses Problem tritt in hart codierten Pfaden auf, die den umgekehrten Schrägstrich ("\"") von Windows verwenden, der nicht als Pfad Trennzeichen auf UNIX-basierten Systemen erkannt wird. Um dieses Problem zu umgehen, können Sie folgende Aktionen ausführen:

- Rufen Sie den Wert der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft ab, anstatt ein Verzeichnis Trennzeichen hart zu codieren.

- Verwenden Sie einen Schrägstrich ("/") als Trennzeichen für das Verzeichnis. Dieses Zeichen wird von der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf UNIX-basierten Systemen und von der <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf Windows-Systemen zurückgegeben. 

Anders als bei der <xref:System.IO.Path.Combine%2A>-Methode versucht die <xref:System.IO.Path.Join%2A>-Methode nicht, den zurückgegebenen Pfad zu verankern. (Das heißt, wenn `path2` ein absoluter Pfad ist, wird die `Join`-Methode nicht `path1` verworfen und `path2` zurückgegeben, wie die <xref:System.IO.Path.Combine%2A>-Methode dies tut.) Das folgende Beispiel veranschaulicht den Unterschied in den Pfaden, die von den beiden Methoden zurückgegeben werden. Wenn die Quelle von `path2` Benutzereingaben ist, ermöglicht die <xref:System.IO.Path.Combine%2A>-Methode einem Benutzer den Zugriff auf eine Dateisystem Ressource (z. *b. C:/users/user1/Documents/Financial/* im Fall des Beispiels), auf die die Anwendung nicht zugreifen konnte.  

Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Join`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können. Wenn `Path.Join("c:\\", "*.txt")` beispielsweise beim Erstellen einer Datei ungültig sein kann, ist Sie als Such Zeichenfolge gültig. Diese Methode wird von der `Join`-Methode daher erfolgreich interpretiert. 

## <a name="example"></a>Beispiel

Das folgende Beispiel veranschaulicht den Unterschied in den Pfaden, die von den Methoden <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> und <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> zurückgegeben werden. Wenn die erste Zeichenfolge ein voll qualifizierter Pfad ist, der ein Laufwerk und ein Stammverzeichnis enthält und der zweite ein relativer Pfad vom ersten Pfad ist, führen die beiden Methoden zu identischen Ergebnissen. In den zweiten und dritten Aufrufen der `ShowPathInformation`-Methode weichen die von den beiden Methoden zurückgegebenen Zeichen folgen ab. Beim zweiten Methoden aufrufist das erste Zeichen folgen Argument ein Laufwerk, während das zweite ein Stammverzeichnis ist. Die `Join`-Methode verkettet die beiden Zeichen folgen und bewahrt doppelte Pfad Trennzeichen auf. Mit der `Combine`-Methode wird das Laufwerk abgebrochen, und es wird ein Stammverzeichnis auf dem aktuellen Laufwerk zurückgegeben. Wenn das aktuelle Laufwerk der Anwendung C:\ ist und die Zeichenfolge wird für den Zugriff auf eine Datei oder auf Dateien im Verzeichnis verwendet. der Zugriff auf C: anstelle von d:. Da beide Argumente im dritten `ShowPathInformation`-aufrufsstamm sind, fügt die `Join`-Methode Sie einfach an, um einen unsinnigen Dateipfad zu erstellen, während die `Combine`-Methode die erste Zeichenfolge verwirft und die zweite zurückgibt. Wenn diese Zeichenfolge für den Dateizugriff verwendet wird, kann die Anwendung unbeabsichtigten Zugriff auf sensible Dateien erhalten.  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-vb[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Der erste Pfad für die Verknüpfung.</param>
        <param name="path2">Der zweite Pfad für die Verknüpfung.</param>
        <summary>Verkettet zwei Pfade zu einem einzelnen Pfad.</summary>
        <returns>Der verkettete Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Mit dieser Methode werden einfach `path` und `path2` verkettet und ein Verzeichnis Trennzeichen zwischen den Pfad Komponenten hinzugefügt, sofern nicht bereits vorhanden. Wenn die Länge von `path1` oder `path2` 0 (null) ist, verkettet die Methode das verbleibende Argument. Wenn die Länge der resultierenden verketteten Zeichenfolge 0 (null) ist, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithType>zurück.

Wenn `path1` in einem Pfad Trennzeichen endet, das für die Zielplattform nicht geeignet ist, behält die `Join` Methode das ursprüngliche Pfad Trennzeichen bei und fügt das unterstützte ein. Dieses Problem tritt in hart codierten Pfaden auf, die den umgekehrten Schrägstrich ("\"") von Windows verwenden, der nicht als Pfad Trennzeichen auf UNIX-basierten Systemen erkannt wird. Um dieses Problem zu umgehen, können Sie folgende Aktionen ausführen:

- Rufen Sie den Wert der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft ab, anstatt ein Verzeichnis Trennzeichen hart zu codieren.

- Verwenden Sie einen Schrägstrich ("/") als Trennzeichen für das Verzeichnis. Dieses Zeichen wird von der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf UNIX-basierten Systemen und von der <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf Windows-Systemen zurückgegeben.

Anders als bei der <xref:System.IO.Path.Combine%2A>-Methode versucht die <xref:System.IO.Path.Join%2A>-Methode nicht, den zurückgegebenen Pfad zu verankern. (Das heißt, wenn `path2` ein absoluter Pfad ist, werden die vorherigen Pfade von der `Join`-Methode nicht verworfen, wenn die <xref:System.IO.Path.Combine%2A>-Methode dies tut.

Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Join`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können. Wenn `Path.Join("c:\\", "temp", "*.txt")` beispielsweise beim Erstellen einer Datei ungültig sein kann, ist Sie als Such Zeichenfolge gültig. Diese Methode wird von der `Join`-Methode daher erfolgreich interpretiert.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Eine Zeichenspanne, die den ersten Pfad für die Verknüpfung enthält.</param>
        <param name="path2">Eine Zeichenspanne, die den zweiten Pfad für die Verknüpfung enthält.</param>
        <param name="path3">Eine Zeichenspanne, die den dritten Pfad für die Verknüpfung enthält.</param>
        <summary>Verkettet drei Pfadkomponenten zu einem einzigen Pfad.</summary>
        <returns>Der verkettete Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Mit dieser Methode werden einfach `path`, `path2`und `path3` verkettet, und es wird ein Verzeichnis Trennzeichen zwischen den Pfad Komponenten hinzugefügt, wenn noch keines vorhanden ist. Wenn die <xref:System.ReadOnlySpan%601.Length> eines `path1`-, `path2`-oder `path3`-Arguments 0 (null) ist, verkettet die Methode die restlichen Argumente. Wenn die <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> aller Komponenten 0 (null) ist, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithType>zurück.

Wenn `path1` oder `path2` in einem Pfad Trennzeichen endet, das für die Zielplattform nicht geeignet ist, behält die `Join` Methode das ursprüngliche Pfad Trennzeichen bei und fügt das unterstützte ein. Dieses Problem tritt in hart codierten Pfaden auf, die den umgekehrten Schrägstrich ("\"") von Windows verwenden, der nicht als Pfad Trennzeichen auf UNIX-basierten Systemen erkannt wird. Um dieses Problem zu umgehen, können Sie folgende Aktionen ausführen:

- Rufen Sie den Wert der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft ab, anstatt ein Verzeichnis Trennzeichen hart zu codieren.

- Verwenden Sie einen Schrägstrich ("/") als Trennzeichen für das Verzeichnis. Dieses Zeichen wird von der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf UNIX-basierten Systemen und von der <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf Windows-Systemen zurückgegeben.

Anders als bei der <xref:System.IO.Path.Combine%2A>-Methode versucht die <xref:System.IO.Path.Join%2A>-Methode nicht, den zurückgegebenen Pfad zu verankern. (Das heißt, wenn `path2` oder `path2` ein absoluter Pfad ist, werden die vorherigen Pfade von der `Join`-Methode nicht verworfen, wenn die <xref:System.IO.Path.Combine%2A>-Methode dies tut.
  
Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Join`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können. Wenn `Path.Join("c:\\", "temp", "*.txt")` beispielsweise beim Erstellen einer Datei ungültig sein kann, ist Sie als Such Zeichenfolge gültig. Diese Methode wird von der `Join`-Methode daher erfolgreich interpretiert.

## <a name="example"></a>Beispiel

Das folgende Beispiel veranschaulicht den Unterschied in den Pfaden, die von den Methoden <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> und <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> zurückgegeben werden. Wenn die erste Zeichenfolge ein voll qualifizierter Pfad ist, der ein Laufwerk und ein Stammverzeichnis enthält und der zweite ein relativer Pfad vom ersten Pfad ist, führen die beiden Methoden zu identischen Ergebnissen. In den zweiten und dritten Aufrufen der `ShowPathInformation`-Methode weichen die von den beiden Methoden zurückgegebenen Zeichen folgen ab. Beim zweiten Methoden aufrufist das erste Zeichen folgen Argument ein Laufwerk, während das zweite ein Stammverzeichnis ist. Die `Join`-Methode verkettet die beiden Zeichen folgen und bewahrt doppelte Pfad Trennzeichen auf. Durch einen aufzurufenden <xref:System.IO.Path.GetFullPath%2A>-Methode wird die Duplizierung vermieden. Mit der `Combine`-Methode wird das Laufwerk abgebrochen, und es wird ein Stammverzeichnis auf dem aktuellen Laufwerk zurückgegeben. Wenn das aktuelle Laufwerk der Anwendung C:\ ist und die Zeichenfolge wird für den Zugriff auf eine Datei oder auf Dateien im Verzeichnis verwendet. der Zugriff auf C: anstelle von d:. Da schließlich das letzte Argument im dritten `ShowPathInformation` Stamm ist, fügt die `Join`-Methode Sie einfach an die ersten beiden Argumente an, um einen unsinnigen Dateipfad zu erstellen, während die `Combine`-Methode die ersten beiden Zeichen folgen verwirft und die dritte zurückgibt. Wenn diese Zeichenfolge für den Dateizugriff verwendet wird, kann die Anwendung unbeabsichtigten Zugriff auf sensible Dateien erhalten.

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)]
[!code-vb[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)]

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Der erste Pfad für die Verknüpfung.</param>
        <param name="path2">Der zweite Pfad für die Verknüpfung.</param>
        <param name="path3">Der dritte Pfad für die Verknüpfung.</param>
        <summary>Verkettet drei Pfade zu einem einzelnen Pfad.</summary>
        <returns>Der verkettete Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Mit dieser Methode werden einfach `path`, `path2`und `path3` verkettet, und es wird ein Verzeichnis Trennzeichen zwischen den Pfad Komponenten hinzugefügt, wenn noch keines vorhanden ist. Wenn die Länge eines `path1`, `path2` oder `path3` Arguments 0 (null) ist, verkettet die Methode die restlichen Argumente. Wenn die Länge der resultierenden verketteten Zeichenfolge 0 (null) ist, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithType>zurück.

Wenn `path1` oder `path2` in einem Pfad Trennzeichen endet, das für die Zielplattform nicht geeignet ist, behält die `Join` Methode das ursprüngliche Pfad Trennzeichen bei und fügt das unterstützte ein. Dieses Problem tritt in hart codierten Pfaden auf, die den umgekehrten Schrägstrich ("\"") von Windows verwenden, der nicht als Pfad Trennzeichen auf UNIX-basierten Systemen erkannt wird. Um dieses Problem zu umgehen, können Sie folgende Aktionen ausführen:

- Rufen Sie den Wert der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft ab, anstatt ein Verzeichnis Trennzeichen hart zu codieren.

- Verwenden Sie einen Schrägstrich ("/") als Trennzeichen für das Verzeichnis. Dieses Zeichen wird von der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf UNIX-basierten Systemen und von der <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf Windows-Systemen zurückgegeben.

Anders als bei der <xref:System.IO.Path.Combine%2A>-Methode versucht die <xref:System.IO.Path.Join%2A>-Methode nicht, den zurückgegebenen Pfad zu verankern. (Das heißt, wenn `path2` oder `path2` ein absoluter Pfad ist, werden die vorherigen Pfade von der `Join`-Methode nicht verworfen, wenn die <xref:System.IO.Path.Combine%2A>-Methode dies tut.

Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Join`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können. Wenn `Path.Join("c:\\", "temp", "*.txt")` beispielsweise beim Erstellen einer Datei ungültig sein kann, ist Sie als Such Zeichenfolge gültig. Diese Methode wird von der `Join`-Methode daher erfolgreich interpretiert.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.ReadOnlySpan`1&lt;char&gt; path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), path4 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path4" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Eine Zeichenspanne, die den ersten Pfad für die Verknüpfung enthält.</param>
        <param name="path2">Eine Zeichenspanne, die den zweiten Pfad für die Verknüpfung enthält.</param>
        <param name="path3">Eine Zeichenspanne, die den dritten Pfad für die Verknüpfung enthält.</param>
        <param name="path4">Eine Zeichenspanne, die den vierten zu verknüpfenden Pfad enthält.</param>
        <summary>Verkettet vier Pfadkomponenten zu einem einzelnen Pfad.</summary>
        <returns>Der verkettete Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Mit dieser Methode werden einfach `path`, `path2``path3` und `path4` verkettet, und es wird ein Verzeichnis Trennzeichen zwischen den Pfad Komponenten hinzugefügt, sofern nicht bereits vorhanden. Wenn die <xref:System.ReadOnlySpan%601.Length> eines `path1`, `path2`, `path3` oder `path4` Arguments 0 (null) ist, verkettet die Methode die restlichen Argumente. Wenn die <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> aller Komponenten 0 (null) ist, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithType>zurück.

Wenn `path1` oder `path2` oder `path3` in einem Pfad Trennzeichen endet, das für die Zielplattform nicht geeignet ist, behält die `Join` Methode das ursprüngliche Pfad Trennzeichen bei und fügt die unterstützte Methode an. Dieses Problem tritt in hart codierten Pfaden auf, die den umgekehrten Schrägstrich ("\"") von Windows verwenden, der nicht als Pfad Trennzeichen auf UNIX-basierten Systemen erkannt wird. Um dieses Problem zu umgehen, können Sie folgende Aktionen ausführen:

- Rufen Sie den Wert der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft ab, anstatt ein Verzeichnis Trennzeichen hart zu codieren.

- Verwenden Sie einen Schrägstrich ("/") als Trennzeichen für das Verzeichnis. Dieses Zeichen wird von der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf UNIX-basierten Systemen und von der <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf Windows-Systemen zurückgegeben.

Anders als bei der <xref:System.IO.Path.Combine%2A>-Methode versucht die <xref:System.IO.Path.Join%2A>-Methode nicht, den zurückgegebenen Pfad zu verankern. (Das heißt, wenn `path2` oder `path2` oder `path3` ein absoluter Pfad ist, werden die vorherigen Pfade von der `Join`-Methode nicht verworfen, wenn die <xref:System.IO.Path.Combine%2A>-Methode dies tut.

Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Join`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können. Wenn `Path.Join("c:\\", "temp", "*.txt")` beispielsweise beim Erstellen einer Datei ungültig sein kann, ist Sie als Such Zeichenfolge gültig. Diese Methode wird von der `Join`-Methode daher erfolgreich interpretiert.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Der erste Pfad für die Verknüpfung.</param>
        <param name="path2">Der zweite Pfad für die Verknüpfung.</param>
        <param name="path3">Der dritte Pfad für die Verknüpfung.</param>
        <param name="path4">Der vierte Pfad für die Verknüpfung.</param>
        <summary>Verkettet vier Pfade zu einem einzelnen Pfad.</summary>
        <returns>Der verkettete Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Mit dieser Methode werden einfach `path`, `path2``path3` und `path4` verkettet, und es wird ein Verzeichnis Trennzeichen zwischen den Pfad Komponenten hinzugefügt, sofern nicht bereits vorhanden. Wenn die Länge eines `path1`-, `path2`-, `path3`-oder `path4`-Arguments 0 (null) ist, verkettet die Methode die restlichen Argumente. Wenn die Länge der resultierenden verketteten Zeichenfolge 0 (null) ist, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithType>zurück.

Wenn `path1` oder `path2` oder `path3` in einem Pfad Trennzeichen endet, das für die Zielplattform nicht geeignet ist, behält die `Join` Methode das ursprüngliche Pfad Trennzeichen bei und fügt die unterstützte Methode an. Dieses Problem tritt in hart codierten Pfaden auf, die den umgekehrten Schrägstrich ("\"") von Windows verwenden, der nicht als Pfad Trennzeichen auf UNIX-basierten Systemen erkannt wird. Um dieses Problem zu umgehen, können Sie folgende Aktionen ausführen:

- Rufen Sie den Wert der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft ab, anstatt ein Verzeichnis Trennzeichen hart zu codieren.

- Verwenden Sie einen Schrägstrich ("/") als Trennzeichen für das Verzeichnis. Dieses Zeichen wird von der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf UNIX-basierten Systemen und von der <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf Windows-Systemen zurückgegeben.

Anders als bei der <xref:System.IO.Path.Combine%2A>-Methode versucht die <xref:System.IO.Path.Join%2A>-Methode nicht, den zurückgegebenen Pfad zu verankern. (Das heißt, wenn `path2` oder `path2` oder `path3` ein absoluter Pfad ist, werden die vorherigen Pfade von der `Join`-Methode nicht verworfen, wenn die <xref:System.IO.Path.Combine%2A>-Methode dies tut.

Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Join`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können. Wenn `Path.Join("c:\\", "temp", "*.txt")` beispielsweise beim Erstellen einer Datei ungültig sein kann, ist Sie als Such Zeichenfolge gültig. Diese Methode wird von der `Join`-Methode daher erfolgreich interpretiert.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ein plattformspezifisches Trennzeichen, das zur Trennung von Pfadzeichenfolgen in Umgebungsvariablen verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Auf Windows-basierten Desktop Plattformen ist der Wert dieses Felds das Semikolon (;) Standardmäßig können Sie sich jedoch auf anderen Plattformen unterscheiden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung des Felds `PathSeparator` veranschaulicht.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEndingDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad, der zugeschnitten werden soll.</param>
        <summary>Schneidet ein nachstehendes Verzeichnistrennzeichen nach dem Stamm des angegebenen Pfads ab.</summary>
        <returns><paramref name="path" /> ohne nachstehende Verzeichnistrennzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static string TrimEndingDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string TrimEndingDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ TrimEndingDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : string -&gt; string" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad, der zugeschnitten werden soll.</param>
        <summary>Schneidet ein nachstehendes Verzeichnistrennzeichen nach dem Stamm des angegebenen Pfads ab.</summary>
        <returns><paramref name="path" /> ohne nachstehende Verzeichnistrennzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary>Versucht, einzelne Pfadkomponenten zu einer vorbelegten Zeichenspanne zu verketten, und gibt einen Wert zurück, der den Erfolg des Vorgangs angibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

Die Ziel zeichenspanne muss groß genug sein, um den verketteten Pfad zu speichern. Anschließend können Sie den verketteten Pfad abrufen, indem Sie die <xref:System.Span%601.Slice%2A?displayProperty=nameWithType>-Methode aufrufen, wie im folgenden Beispiel veranschaulicht.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * int -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Eine Zeichenspanne, die den ersten Pfad für die Verknüpfung enthält.</param>
        <param name="path2">Eine Zeichenspanne, die den zweiten Pfad für die Verknüpfung enthält.</param>
        <param name="destination">Eine Zeichenspanne, die den verketteten Pfad enthalten soll.</param>
        <param name="charsWritten">Ein Wert bei Rückgabe der Methode, der die Anzahl der Zeichen angibt, die in <paramref name="destination" /> geschrieben werden.</param>
        <summary>Versucht, zwei Pfadkomponenten zu einer einzigen vorbelegten Zeichenspanne zu verketten, und gibt einen Wert zurück, der den Erfolg des Vorgangs angibt.</summary>
        <returns><see langword="true" />, wenn die Verkettung erfolgreich ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

`destination` müssen groß genug sein, um den verketteten Pfad zu speichern. Anschließend können Sie den verketteten Pfad abrufen, indem Sie die <xref:System.Span%601.Slice%2A?displayProperty=nameWithType>-Methode aufrufen, wie im Beispiel veranschaulicht.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * int -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Eine Zeichenspanne, die den ersten Pfad für die Verknüpfung enthält.</param>
        <param name="path2">Eine Zeichenspanne, die den zweiten Pfad für die Verknüpfung enthält.</param>
        <param name="path3">Eine Zeichenspanne, die den dritten Pfad für die Verknüpfung enthält.</param>
        <param name="destination">Eine Zeichenspanne, die den verketteten Pfad enthalten soll.</param>
        <param name="charsWritten">Ein Wert bei Rückgabe der Methode, der die Anzahl der Zeichen angibt, die in <paramref name="destination" /> geschrieben werden.</param>
        <summary>Versucht, zwei Pfadkomponenten zu einer einzigen vorbelegten Zeichenspanne zu verketten, und gibt einen Wert zurück, der den Erfolg des Vorgangs angibt.</summary>
        <returns><see langword="true" />, wenn die Verkettung erfolgreich ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

`destination` müssen groß genug sein, um den verketteten Pfad zu speichern. Anschließend können Sie den verketteten Pfad abrufen, indem Sie die <xref:System.Span%601.Slice%2A?displayProperty=nameWithType>-Methode aufrufen, wie im Beispiel veranschaulicht.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt ein plattformspezifisches Volumetrennzeichen bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieses Felds ist ein Doppelpunkt (:) unter Windows und Macintosh und ein Schrägstrich (/) auf UNIX-Betriebssystemen. Dies ist besonders nützlich für das Durchsuchen von Pfaden, wie z. b. "c:\Windows" oder "MacVolume: System Ordner".  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung des Felds `VolumeSeparatorChar` veranschaulicht.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
  </Members>
</Type>
