<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="94ea148128c0cccd165ba819efa387ce53b1d985" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75132061" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="8f3af-101">Führt Vorgänge für <see cref="T:System.String" />-Instanzen aus, die Datei- oder Verzeichnispfadinformationen enthalten.</span><span class="sxs-lookup"><span data-stu-id="8f3af-101">Performs operations on <see cref="T:System.String" /> instances that contain file or directory path information.</span></span> <span data-ttu-id="8f3af-102">Diese Vorgänge werden plattformübergreifend durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-102">These operations are performed in a cross-platform manner.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="8f3af-103">Ein Pfad ist eine Zeichenfolge, die den Speicherort einer Datei oder eines Verzeichnisses bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-103">A path is a string that provides the location of a file or directory.</span></span> <span data-ttu-id="8f3af-104">Ein Pfad verweist nicht unbedingt auf einen Speicherort auf dem Datenträger. Beispielsweise kann ein Pfad einem Speicherort im Arbeitsspeicher oder auf einem Gerät zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-104">A path does not necessarily point to a location on disk; for example, a path might map to a location in memory or on a device.</span></span> <span data-ttu-id="8f3af-105">Das genaue Format eines Pfads wird von der aktuellen Plattform bestimmt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-105">The exact format of a path is determined by the current platform.</span></span> <span data-ttu-id="8f3af-106">Beispielsweise kann ein Pfad auf einigen Systemen mit einem Laufwerk-oder Volumebuchstaben beginnen, während dieses Element nicht in anderen Systemen vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-106">For example, on some systems, a path can start with a drive or volume letter, while this element is not present in other systems.</span></span> <span data-ttu-id="8f3af-107">Auf einigen Systemen können Dateipfade Erweiterungen enthalten, die den Typ der in der Datei gespeicherten Informationen angeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-107">On some systems, file paths can contain extensions, which indicate the type of information stored in the file.</span></span> <span data-ttu-id="8f3af-108">Das Format einer Dateinamenerweiterung ist plattformabhängig. beispielsweise beschränken einige Systeme Erweiterungen auf drei Zeichen, andere hingegen nicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-108">The format of a file name extension is platform-dependent; for example, some systems limit extensions to three characters, and others do not.</span></span> <span data-ttu-id="8f3af-109">Die aktuelle Plattform bestimmt auch die Zeichen, die zum Trennen der Elemente eines Pfads verwendet werden, und den Satz von Zeichen, die beim Angeben von Pfaden nicht verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="8f3af-109">The current platform also determines the set of characters used to separate the elements of a path, and the set of characters that cannot be used when specifying paths.</span></span> <span data-ttu-id="8f3af-110">Aufgrund dieser Unterschiede sind die Felder der `Path`-Klasse sowie das genaue Verhalten einiger Member der `Path`-Klasse plattformabhängig.</span><span class="sxs-lookup"><span data-stu-id="8f3af-110">Because of these differences, the fields of the `Path` class as well as the exact behavior of some members of the `Path` class are platform-dependent.</span></span>  
  
 <span data-ttu-id="8f3af-111">Ein Pfad kann absolute oder relative Speicherort Informationen enthalten.</span><span class="sxs-lookup"><span data-stu-id="8f3af-111">A path can contain absolute or relative location information.</span></span> <span data-ttu-id="8f3af-112">Absolute Pfade geben einen Speicherort vollständig an: die Datei oder das Verzeichnis kann unabhängig vom aktuellen Speicherort eindeutig identifiziert werden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-112">Absolute paths fully specify a location: the file or directory can be uniquely identified regardless of the current location.</span></span> <span data-ttu-id="8f3af-113">Relative Pfade geben einen partiellen Speicherort an: der aktuelle Speicherort wird beim Suchen einer Datei, die mit einem relativen Pfad angegeben ist, als Ausgangspunkt verwendet.</span><span class="sxs-lookup"><span data-stu-id="8f3af-113">Relative paths specify a partial location: the current location is used as the starting point when locating a file specified with a relative path.</span></span> <span data-ttu-id="8f3af-114">Um das aktuelle Verzeichnis zu ermitteln, wenden Sie <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>an.</span><span class="sxs-lookup"><span data-stu-id="8f3af-114">To determine the current directory, call <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span></span>  

 <span data-ttu-id="8f3af-115">.Net Core 1,1 und höhere Versionen sowie .NET Framework 4.6.2 und höhere Versionen unterstützen auch den Zugriff auf Dateisystem Objekte, bei denen es sich um Gerätenamen handelt, z. b. "\\? \c:\".</span><span class="sxs-lookup"><span data-stu-id="8f3af-115">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support access to file system objects that are device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="8f3af-116">Weitere Informationen zu Datei Pfad Formaten unter Windows finden Sie unter [Dateipfad Formate auf Windows-Systemen](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="8f3af-116">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span>

 <span data-ttu-id="8f3af-117">Die meisten Member der `Path`-Klasse interagieren nicht mit dem Dateisystem und überprüfen nicht, ob die Datei vorhanden ist, die durch eine Pfad Zeichenfolge angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-117">Most members of the `Path` class do not interact with the file system and do not verify the existence of the file specified by a path string.</span></span> <span data-ttu-id="8f3af-118">`Path` Klassenmember, die eine Pfad Zeichenfolge ändern, z. b. <xref:System.IO.Path.ChangeExtension%2A>, haben keine Auswirkung auf die Namen von Dateien im Dateisystem.</span><span class="sxs-lookup"><span data-stu-id="8f3af-118">`Path` class members that modify a path string, such as <xref:System.IO.Path.ChangeExtension%2A>, have no effect on names of files in the file system.</span></span> <span data-ttu-id="8f3af-119">`Path` Mitglieder jedoch den Inhalt einer angegebenen Pfad Zeichenfolge überprüfen und eine <xref:System.ArgumentException> Ausnahme auslösen, wenn die Zeichenfolge Zeichen enthält, die in Pfad Zeichenfolgen nicht gültig sind, wie in den von der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode zurückgegebenen Zeichen definiert.</span><span class="sxs-lookup"><span data-stu-id="8f3af-119">`Path` members do, however, validate the contents of a specified path string, and throw an <xref:System.ArgumentException> exception if the string contains characters that are not valid in path strings, as defined in the characters returned from the <xref:System.IO.Path.GetInvalidPathChars%2A> method.</span></span> <span data-ttu-id="8f3af-120">Beispielsweise können auf Windows-basierten Desktop Plattformen ungültige Pfad Zeichen Anführungszeichen ("), kleiner als (\<), größer als (>), Pipe (&#124;), Rücktaste (\b), NULL (\ 0) und Unicode-Zeichen 16 bis 18 und 20 bis 25 enthalten.</span><span class="sxs-lookup"><span data-stu-id="8f3af-120">For example, on Windows-based desktop platforms, invalid path characters might include quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0), and Unicode characters 16 through 18 and 20 through 25.</span></span>  
  
 <span data-ttu-id="8f3af-121">Die Member der `Path`-Klasse ermöglichen es Ihnen, häufig gängige Vorgänge auszuführen, z. b. zu ermitteln, ob eine Dateinamenerweiterung Teil eines Pfads ist, und zwei Zeichen folgen zu einem Pfadnamen zu kombinieren.</span><span class="sxs-lookup"><span data-stu-id="8f3af-121">The members of the `Path` class enable you to quickly and easily perform common operations such as determining whether a file name extension is part of a path, and combining two strings into one path name.</span></span>  
  
 <span data-ttu-id="8f3af-122">Alle Member der `Path`-Klasse sind statisch und können daher aufgerufen werden, ohne dass eine Instanz eines Pfades vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-122">All members of the `Path` class are static and can therefore be called without having an instance of a path.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f3af-123">In Membern, die einen Pfad als Eingabe Zeichenfolge akzeptieren, muss dieser Pfad wohl geformt sein, oder es wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="8f3af-123">In members that accept a path as an input string, that path must be well-formed or an exception is raised.</span></span> <span data-ttu-id="8f3af-124">Wenn ein Pfad z. b. voll qualifiziert ist, aber mit einem Leerzeichen beginnt, wird der Pfad nicht in den Methoden der Klasse gekürzt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-124">For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class.</span></span> <span data-ttu-id="8f3af-125">Daher ist der Pfad falsch formatiert, und es wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="8f3af-125">Therefore, the path is malformed and an exception is raised.</span></span> <span data-ttu-id="8f3af-126">Ebenso kann ein Pfad oder eine Kombination von Pfaden nicht zweimal voll qualifiziert werden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-126">Similarly, a path or a combination of paths cannot be fully qualified twice.</span></span> <span data-ttu-id="8f3af-127">Beispielsweise löst "c:\temp c:\Windows" in den meisten Fällen auch eine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="8f3af-127">For example, "c:\temp c:\windows" also raises an exception in most cases.</span></span> <span data-ttu-id="8f3af-128">Stellen Sie sicher, dass die Pfade wohl geformt sind, wenn Sie Methoden verwenden, die eine Pfad Zeichenfolge akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="8f3af-128">Ensure that your paths are well-formed when using methods that accept a path string.</span></span>  
  
 <span data-ttu-id="8f3af-129">In Membern, die einen Pfad akzeptieren, kann der Pfad auf eine Datei oder nur auf ein Verzeichnis verweisen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-129">In members that accept a path, the path can refer to a file or just a directory.</span></span> <span data-ttu-id="8f3af-130">Der angegebene Pfad kann auch auf einen relativen Pfad oder einen Universal Naming Convention Pfad (UNC-Pfad) für einen Server und einen Freigabe Namen verweisen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-130">The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name.</span></span> <span data-ttu-id="8f3af-131">Die folgenden Pfade sind beispielsweise zulässig:</span><span class="sxs-lookup"><span data-stu-id="8f3af-131">For example, all the following are acceptable paths:</span></span>  
  
-   <span data-ttu-id="8f3af-132">"c:\\\meindir\\\meineDatei.txt C#" in, oder "c:\mydir\meinedatei.txt" in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="8f3af-132">"c:\\\MyDir\\\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="8f3af-133">"c:\\\meinedir" C#in, oder "c:\meinedir" in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="8f3af-133">"c:\\\MyDir" in C#, or "c:\MyDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="8f3af-134">"Mydir\\\meinsubdir" in C#, oder "mydir\meinsubdir" in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="8f3af-134">"MyDir\\\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="8f3af-135">"\\\\\\\meinserver\meineserver\\C#\meinefreigabe" in, oder "\\\meinserver\meinefreigabe" in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="8f3af-135">"\\\\\\\MyServer\\\MyShare" in C#, or "\\\MyServer\MyShare" in Visual Basic.</span></span>  
  
 <span data-ttu-id="8f3af-136">Da all diese Vorgänge für Zeichen folgen ausgeführt werden, ist es nicht möglich, zu überprüfen, ob die Ergebnisse in allen Szenarien gültig sind.</span><span class="sxs-lookup"><span data-stu-id="8f3af-136">Because all these operations are performed on strings, it is impossible to verify that the results are valid in all scenarios.</span></span> <span data-ttu-id="8f3af-137">Die <xref:System.IO.Path.GetExtension%2A>-Methode analysiert z. b. eine Zeichenfolge, die Sie übergibt, und gibt die Erweiterung aus dieser Zeichenfolge zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-137">For example, the <xref:System.IO.Path.GetExtension%2A> method parses a string that you pass to it and returns the extension from that string.</span></span> <span data-ttu-id="8f3af-138">Dies bedeutet jedoch nicht, dass eine Datei mit dieser Erweiterung auf dem Datenträger vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-138">However, this does not mean that a file with that extension exists on the disk.</span></span>  
  
 <span data-ttu-id="8f3af-139">Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-139">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>   
  
## Examples  
 <span data-ttu-id="8f3af-140">Im folgenden Beispiel werden einige der Hauptmember der `Path`-Klasse veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-140">The following example demonstrates some of the main members of the `Path` class.</span></span>  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8f3af-141">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="8f3af-141">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8f3af-142">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="8f3af-142">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8f3af-143">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="8f3af-143">How to: Write Text to a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md"><span data-ttu-id="8f3af-144">Gewusst wie: Lesen und Schreiben einer neu erstellten Datendatei</span><span class="sxs-lookup"><span data-stu-id="8f3af-144">How to: Read and Write to a Newly Created Data File</span></span></related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-145">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-145">File path formats on Windows systems</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f3af-146">Stellt ein plattformspezifisches, alternatives Zeichen bereit, das zur Trennung von Verzeichnisebenen in einer Pfadzeichenfolge verwendet wird und eine hierarchische Dateisystemorganisation wiedergibt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-146">Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="8f3af-147">Dieses Feld kann denselben Wert wie <xref:System.IO.Path.DirectorySeparatorChar>haben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-147">This field can have the same value as <xref:System.IO.Path.DirectorySeparatorChar>.</span></span> <span data-ttu-id="8f3af-148">`AltDirectorySeparatorChar` und <xref:System.IO.Path.DirectorySeparatorChar> sind sowohl für die Trennung von Verzeichnis Ebenen in einer Pfad Zeichenfolge gültig.</span><span class="sxs-lookup"><span data-stu-id="8f3af-148">`AltDirectorySeparatorChar` and <xref:System.IO.Path.DirectorySeparatorChar> are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="8f3af-149">Der Wert dieses Felds ist ein Schrägstrich ("/") auf Windows-und UNIX-basierten Betriebssystemen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-149">The value of this field is a slash ('/') on both Windows and Unix-based operating systems.</span></span>  
  
## Examples  

<span data-ttu-id="8f3af-150">Im folgenden Beispiel werden <xref:System.IO.Path> Feldwerte in Windows und auf UNIX-basierten Systemen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-150">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="8f3af-151">Beachten Sie, dass Windows entweder den Schrägstrich (der vom Feld "<xref:System.IO.Path.AltDirectorySeparatorChar>" zurückgegeben wird) oder den umgekehrten Schrägstrich (der vom Feld "<xref:System.IO.Path.DirectorySeparatorChar>" zurückgegeben wird) als Pfad Trennzeichen unterstützt, während UNIX-basierte Systeme nur den Schrägstrich unterstützen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-151">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8f3af-152">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="8f3af-152">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8f3af-153">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="8f3af-153">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8f3af-154">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="8f3af-154">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-155">Die zu ändernden Pfadinformationen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-155">The path information to modify.</span></span> <span data-ttu-id="8f3af-156">Der Pfad darf keines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten Zeichen enthalten.</span><span class="sxs-lookup"><span data-stu-id="8f3af-156">The path cannot contain any of the characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></param>
        <param name="extension"><span data-ttu-id="8f3af-157">Die neue Erweiterung (mit oder ohne führenden Punkt).</span><span class="sxs-lookup"><span data-stu-id="8f3af-157">The new extension (with or without a leading period).</span></span> <span data-ttu-id="8f3af-158">Geben Sie <see langword="null" /> an, um eine vorhandene Erweiterung aus <paramref name="path" /> zu entfernen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-158">Specify <see langword="null" /> to remove an existing extension from <paramref name="path" />.</span></span></param>
        <summary><span data-ttu-id="8f3af-159">Ändert die Erweiterung einer Pfadzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="8f3af-159">Changes the extension of a path string.</span></span></summary>
        <returns><span data-ttu-id="8f3af-160">Die geänderten Pfadinformationen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-160">The modified path information.</span></span>  
  
<span data-ttu-id="8f3af-161">Auf Desktopplattformen auf Grundlage von Windows werden die Pfadinformationen unverändert zurückgegeben, wenn <paramref name="path" /><see langword="null" /> oder eine leere Zeichenfolge ("") ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-161">On Windows-based desktop platforms, if <paramref name="path" /> is <see langword="null" /> or an empty string (""), the path information is returned unmodified.</span></span> <span data-ttu-id="8f3af-162">Wenn <paramref name="extension" /><see langword="null" /> ist, enthält die zurückgegebene Zeichenfolge den angegebenen Pfad ohne die Erweiterung.</span><span class="sxs-lookup"><span data-stu-id="8f3af-162">If <paramref name="extension" /> is <see langword="null" />, the returned string contains the specified path with its extension removed.</span></span> <span data-ttu-id="8f3af-163">Wenn <paramref name="path" /> keine Erweiterung besitzt und <paramref name="extension" /> nicht <see langword="null" /> ist, enthält die zurückgegebene Pfadzeichenfolge <paramref name="extension" />, angefügt an das Ende von <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-163">If <paramref name="path" /> has no extension, and <paramref name="extension" /> is not <see langword="null" />, the returned path string contains <paramref name="extension" /> appended to the end of <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f3af-164">Wenn weder `path` noch `extension` einen Zeitraum (.) enthält, fügt `ChangeExtension` den Zeitraum hinzu.</span><span class="sxs-lookup"><span data-stu-id="8f3af-164">If neither `path` nor `extension` contains a period (.), `ChangeExtension` adds the period.</span></span>  
  
 <span data-ttu-id="8f3af-165">Der `extension`-Parameter kann mehrere Zeiträume und alle gültigen Pfad Zeichen enthalten und kann eine beliebige Länge aufweisen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-165">The `extension` parameter can contain multiple periods and any valid path characters, and can be any length.</span></span> <span data-ttu-id="8f3af-166">Wenn `extension` `null`ist, enthält die zurückgegebene Zeichenfolge den Inhalt von `path`, wobei der letzte Zeitraum und alle nachfolgenden Zeichen entfernt wurden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-166">If `extension` is `null`, the returned string contains the contents of `path` with the last period and all characters following it removed.</span></span>  
  
 <span data-ttu-id="8f3af-167">Wenn `extension` eine leere Zeichenfolge ist, enthält die zurückgegebene Pfad Zeichenfolge den Inhalt `path` mit allen Zeichen, die nach dem letzten entfernten Zeitraum liegen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-167">If `extension` is an empty string, the returned path string contains the contents of `path` with any characters following the last period removed.</span></span>  
  
 <span data-ttu-id="8f3af-168">Wenn `path` über keine Erweiterung verfügt und `extension` nicht `null`ist, enthält die zurückgegebene Zeichenfolge `path` gefolgt von `extension`.</span><span class="sxs-lookup"><span data-stu-id="8f3af-168">If `path` does not have an extension and `extension` is not `null`, the returned string contains `path` followed by `extension`.</span></span>  
  
 <span data-ttu-id="8f3af-169">Wenn `extension` nicht `null` ist und keinen führenden Zeitraum enthält, wird der Zeitraum hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-169">If `extension` is not `null` and does not contain a leading period, the period is added.</span></span>  
  
 <span data-ttu-id="8f3af-170">Wenn `path` eine mehrere durch mehrere Zeiträume getrennte Erweiterung enthält, enthält die zurückgegebene Zeichenfolge den Inhalt von `path`, wobei der letzte Zeitraum und alle nachfolgenden Zeichen durch `extension`ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-170">If `path` contains a multiple extension separated by multiple periods, the returned string contains the contents of `path` with the last period and all characters following it replaced by `extension`.</span></span> <span data-ttu-id="8f3af-171">Wenn `path` z. b. "\Dir1\examples\pathtests.CSX.txt" lautet und `extension` "CS" ist, lautet der geänderte Pfad "\Dir1\examples\pathtests.CSX.cs".</span><span class="sxs-lookup"><span data-stu-id="8f3af-171">For example, if `path` is "\Dir1\examples\pathtests.csx.txt" and `extension` is "cs", the modified path is "\Dir1\examples\pathtests.csx.cs".</span></span>  
  
 <span data-ttu-id="8f3af-172">Es ist nicht möglich, zu überprüfen, ob die zurückgegebenen Ergebnisse in allen Szenarien gültig sind.</span><span class="sxs-lookup"><span data-stu-id="8f3af-172">It is not possible to verify that the returned results are valid in all scenarios.</span></span> <span data-ttu-id="8f3af-173">Wenn `path` z. b. leer ist, wird `extension` angefügt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-173">For example, if `path` is empty, `extension` is appended.</span></span>  
  
 <span data-ttu-id="8f3af-174">Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-174">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f3af-175">Im folgenden Beispiel wird die Verwendung der `ChangeExtension`-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-175">The following example demonstrates a use of the `ChangeExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f3af-176"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-176"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-177">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-177">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8f3af-178">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="8f3af-178">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8f3af-179">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="8f3af-179">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8f3af-180">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="8f3af-180">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8f3af-181">Kombiniert Zeichenfolgen zu einem Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-181">Combines strings into a path.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="8f3af-182">Diese Methode ist für die Verkettung einzelner Zeichen folgen zu einer einzelnen Zeichenfolge vorgesehen, die einen Dateipfad darstellt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-182">This method is intended to concatenate individual strings into a single string that represents a file path.</span></span> <span data-ttu-id="8f3af-183">Wenn jedoch ein anderes Argument als das erste einen Rootpfad enthält, werden alle vorherigen Pfad Komponenten ignoriert, und die zurückgegebene Zeichenfolge beginnt mit der Stamm Pfadkomponente.</span><span class="sxs-lookup"><span data-stu-id="8f3af-183">However, if an argument other than the first contains a rooted path, any previous path components are ignored, and the returned string begins with that rooted path component.</span></span> <span data-ttu-id="8f3af-184">Als Alternative zur `Combine`-Methode sollten Sie die Verwendung der Methoden <xref:System.IO.Path.Join%2A> oder <xref:System.IO.Path.TryJoin%2A> in Erwägung gezogen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-184">As an alternative to the `Combine` method, consider using the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> methods.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="8f3af-185">Bei dieser Methode wird davon ausgegangen, dass das erste Argument ein absoluter Pfad ist und dass es sich bei den folgenden Argumenten um relative Pfade handelt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-185">This method assumes that the first argument is an absolute path and that the following argument or arguments are relative paths.</span></span> <span data-ttu-id="8f3af-186">Wenn dies nicht der Fall ist, und vor allem, wenn nachfolgende Argumente Zeichen folgen Eingaben vom Benutzer sind, müssen Sie stattdessen die <xref:System.IO.Path.Join%2A>-oder <xref:System.IO.Path.TryJoin%2A>-Methode abrufen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-186">If this is not the case, and particularly if any subsequent arguments are strings input by the user, call the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> method instead.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths"><span data-ttu-id="8f3af-187">Ein Array der Teile des Pfads.</span><span class="sxs-lookup"><span data-stu-id="8f3af-187">An array of parts of the path.</span></span></param>
        <summary><span data-ttu-id="8f3af-188">Kombiniert ein Array von Zeichenfolgen zu einem Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-188">Combines an array of strings into a path.</span></span></summary>
        <returns><span data-ttu-id="8f3af-189">Die kombinierten Pfade.</span><span class="sxs-lookup"><span data-stu-id="8f3af-189">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="8f3af-190">`paths` muss ein Array der zu kombinierenden Teile des Pfads sein.</span><span class="sxs-lookup"><span data-stu-id="8f3af-190">`paths` should be an array of the parts of the path to combine.</span></span> <span data-ttu-id="8f3af-191">Wenn es sich bei einem der nachfolgenden Pfade um einen absoluten Pfad handelt, wird die Kombination aus dem absoluten Pfad zurückgesetzt, wobei alle vorherigen kombinierten Pfade verworfen werden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-191">If the one of the subsequent paths is an absolute path, then the combine operation resets starting with that absolute path, discarding all previous combined paths.</span></span>  

<span data-ttu-id="8f3af-192">Wenn ein Element in `paths`, aber das letzte kein Laufwerk ist und nicht mit dem <xref:System.IO.Path.DirectorySeparatorChar> oder dem <xref:System.IO.Path.AltDirectorySeparatorChar> Zeichen endet, fügt die `Combine`-Methode ein <xref:System.IO.Path.DirectorySeparatorChar> Zeichen zwischen diesem und dem nächsten-Element hinzu.</span><span class="sxs-lookup"><span data-stu-id="8f3af-192">If any element in `paths` but the last one is not a drive and does not end with either the <xref:System.IO.Path.DirectorySeparatorChar> or the <xref:System.IO.Path.AltDirectorySeparatorChar> character, the `Combine` method adds a <xref:System.IO.Path.DirectorySeparatorChar> character between that element and the next one.</span></span> <span data-ttu-id="8f3af-193">Beachten Sie Folgendes: Wenn das Element mit einem Pfad Trennzeichen endet, das für die Zielplattform nicht geeignet ist, behält die `Combine` Methode das ursprüngliche Pfad Trennzeichen bei und fügt eine unterstützte ein.</span><span class="sxs-lookup"><span data-stu-id="8f3af-193">Note that, if the element ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="8f3af-194">Im folgenden Beispiel wird das Ergebnis auf Windows-und UNIX-basierten Systemen verglichen, wenn der umgekehrte Schrägstrich als Pfad Trennzeichen verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-194">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 <span data-ttu-id="8f3af-195">Zeichen folgen der Länge 0 (null) werden im kombinierten Pfad weggelassen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-195">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="8f3af-196">Die Parameter werden nicht analysiert, wenn Sie Leerzeichen enthalten.</span><span class="sxs-lookup"><span data-stu-id="8f3af-196">The parameters are not parsed if they have white space.</span></span>  
  
 <span data-ttu-id="8f3af-197">Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Combine`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="8f3af-197">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8f3af-198">Beispielsweise ist `Path.Combine("c:\\", "*.txt")` möglicherweise ungültig, wenn Sie eine Datei aus der Datei erstellen möchten, Sie als Such Zeichenfolge gültig ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-198">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="8f3af-199">Sie wird daher von der `Combine`-Methode erfolgreich interpretiert.</span><span class="sxs-lookup"><span data-stu-id="8f3af-199">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
## Examples  
 <span data-ttu-id="8f3af-200">Im folgenden Beispiel wird ein Array von Zeichen folgen zu einem Pfad kombiniert.</span><span class="sxs-lookup"><span data-stu-id="8f3af-200">The following example combines an array of strings into a path.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f3af-201">Eine der Zeichenfolgen im Array enthält eines oder mehrere der ungültigen Zeichen, die in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definiert sind.</span><span class="sxs-lookup"><span data-stu-id="8f3af-201">One of the strings in the array contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f3af-202">Eine der Zeichenfolgen im Array ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-202">One of the strings in the array is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-203">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-203">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8f3af-204">Der erste zu kombinierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-204">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="8f3af-205">Der zweite zu kombinierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-205">The second path to combine.</span></span></param>
        <summary><span data-ttu-id="8f3af-206">Kombiniert zwei Zeichenfolgen zu einem Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-206">Combines two strings into a path.</span></span></summary>
        <returns><span data-ttu-id="8f3af-207">Die kombinierten Pfade.</span><span class="sxs-lookup"><span data-stu-id="8f3af-207">The combined paths.</span></span> <span data-ttu-id="8f3af-208">Wenn einer der beiden angegebenen Pfade eine Zeichenfolge der Länge 0 ist, gibt diese Methode den anderen Pfad zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-208">If one of the specified paths is a zero-length string, this method returns the other path.</span></span> <span data-ttu-id="8f3af-209">Wenn <paramref name="path2" /> einen absoluten Pfad enthält, gibt diese Methode <paramref name="path2" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-209">If <paramref name="path2" /> contains an absolute path, this method returns <paramref name="path2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f3af-210">Wenn `path1` kein Laufwerk Verweis ist (d. h. "C:" oder "D:") und nicht mit einem gültigen Trennzeichen endet, wie in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>oder <xref:System.IO.Path.VolumeSeparatorChar>definiert, wird <xref:System.IO.Path.DirectorySeparatorChar> vor der Verkettung an `path1` angehängt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-210">If `path1` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` before concatenation.</span></span> <span data-ttu-id="8f3af-211">Beachten Sie Folgendes: Wenn `path1` in einem Pfad Trennzeichen endet, das für die Zielplattform nicht geeignet ist, behält die `Combine` Methode das ursprüngliche Pfad Trennzeichen bei und fügt eine unterstützte ein.</span><span class="sxs-lookup"><span data-stu-id="8f3af-211">Note that if `path1` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="8f3af-212">Im folgenden Beispiel wird das Ergebnis auf Windows-und UNIX-basierten Systemen verglichen, wenn der umgekehrte Schrägstrich als Pfad Trennzeichen verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-212">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 <span data-ttu-id="8f3af-213">Wenn `path2` keinen Stamm enthält (z. b., wenn `path2` nicht mit einem Trennzeichen oder einer Laufwerk Spezifikation beginnt), ist das Ergebnis eine Verkettung der beiden Pfade mit einem dazwischen liegenden Trennzeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-213">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="8f3af-214">Wenn `path2` einen Stamm enthält, wird `path2` zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-214">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="8f3af-215">Die Parameter werden nicht analysiert, wenn Sie Leerzeichen enthalten.</span><span class="sxs-lookup"><span data-stu-id="8f3af-215">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="8f3af-216">Wenn `path2` Leerraum (z. b. "\file.txt") enthält, fügt die <xref:System.IO.Path.Combine%2A>-Methode `path2` an `path1` an, anstatt nur `path2`zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-216">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1` instead of returning only `path2`.</span></span>  
  
 <span data-ttu-id="8f3af-217">Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Combine`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="8f3af-217">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8f3af-218">Beispielsweise ist `Path.Combine("c:\\", "*.txt")` möglicherweise ungültig, wenn Sie eine Datei aus der Datei erstellen möchten, Sie als Such Zeichenfolge gültig ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-218">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="8f3af-219">Sie wird daher von der `Combine`-Methode erfolgreich interpretiert.</span><span class="sxs-lookup"><span data-stu-id="8f3af-219">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
 <span data-ttu-id="8f3af-220">Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-220">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f3af-221">Im folgenden Beispiel wird die Verwendung der `Combine`-Methode auf einer Windows-basierten Desktop Plattform veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-221">The following example demonstrates using the `Combine` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f3af-222"><paramref name="path1" /> oder <paramref name="path2" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-222"><paramref name="path1" /> or <paramref name="path2" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f3af-223"><paramref name="path1" /> oder <paramref name="path2" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-223"><paramref name="path1" /> or <paramref name="path2" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-224">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-224">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8f3af-225">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="8f3af-225">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8f3af-226">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="8f3af-226">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8f3af-227">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="8f3af-227">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8f3af-228">Der erste zu kombinierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-228">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="8f3af-229">Der zweite zu kombinierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-229">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="8f3af-230">Der dritte zu kombinierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-230">The third path to combine.</span></span></param>
        <summary><span data-ttu-id="8f3af-231">Kombiniert drei Zeichenfolgen zu einem Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-231">Combines three strings into a path.</span></span></summary>
        <returns><span data-ttu-id="8f3af-232">Die kombinierten Pfade.</span><span class="sxs-lookup"><span data-stu-id="8f3af-232">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f3af-233">`path1` sollte ein absoluter Pfad sein (z. b. "d:\archive" oder "\\\archives\public").</span><span class="sxs-lookup"><span data-stu-id="8f3af-233">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").</span></span> <span data-ttu-id="8f3af-234">Wenn `path2` oder `path3` auch ein absoluter Pfad ist, verwirft der Combine-Vorgang alle zuvor kombinierten Pfade und setzt auf diesen absoluten Pfad zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-234">If `path2` or `path3` is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="8f3af-235">Zeichen folgen der Länge 0 (null) werden im kombinierten Pfad weggelassen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-235">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="8f3af-236">Wenn `path1` oder `path2` kein Laufwerks Verweis ist (d. h. "C:" oder "D:") und nicht mit einem gültigen Trennzeichen endet, wie in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>oder <xref:System.IO.Path.VolumeSeparatorChar>definiert, wird <xref:System.IO.Path.DirectorySeparatorChar> vor der Verkettung an `path1` oder `path2` angehängt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-236">If `path1` or `path2` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` or `path2` before concatenation.</span></span> <span data-ttu-id="8f3af-237">Beachten Sie, dass die `Combine` Methode das ursprüngliche Pfad Trennzeichen beibehält und einen unterstützten Pfad anfügt, wenn `path1` oder `path2` in einem Pfad Trennzeichen endet, das für die Zielplattform nicht geeignet ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-237">Note that if `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="8f3af-238">Im folgenden Beispiel wird das Ergebnis auf Windows-und UNIX-basierten Systemen verglichen, wenn der umgekehrte Schrägstrich als Pfad Trennzeichen verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-238">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 <span data-ttu-id="8f3af-239">Wenn `path2` keinen Stamm enthält (z. b., wenn `path2` nicht mit einem Trennzeichen oder einer Laufwerk Spezifikation beginnt), ist das Ergebnis eine Verkettung der beiden Pfade mit einem dazwischen liegenden Trennzeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-239">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="8f3af-240">Wenn `path2` einen Stamm enthält, wird `path2` zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-240">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="8f3af-241">Die Parameter werden nicht analysiert, wenn Sie Leerzeichen enthalten.</span><span class="sxs-lookup"><span data-stu-id="8f3af-241">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="8f3af-242">Wenn `path2` Leerraum (z. b. "\file.txt") enthält, fügt die <xref:System.IO.Path.Combine%2A>-Methode `path2` an `path1`an.</span><span class="sxs-lookup"><span data-stu-id="8f3af-242">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="8f3af-243">Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Combine`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="8f3af-243">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8f3af-244">Beispielsweise ist `Path.Combine("c:\\", "*.txt")` möglicherweise ungültig, wenn Sie eine Datei aus der Datei erstellen möchten, Sie als Such Zeichenfolge gültig ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-244">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="8f3af-245">Sie wird daher von der `Combine`-Methode erfolgreich interpretiert.</span><span class="sxs-lookup"><span data-stu-id="8f3af-245">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f3af-246">Im folgenden Beispiel werden drei Pfade kombiniert.</span><span class="sxs-lookup"><span data-stu-id="8f3af-246">The following example combines three paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f3af-247"><paramref name="path1" />, <paramref name="path2" /> oder <paramref name="path3" /> enthält mindestens ein ungültiges Zeichen gemäß der Definition in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-247"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f3af-248"><paramref name="path1" />, <paramref name="path2" /> oder <paramref name="path3" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-248"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-249">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-249">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8f3af-250">Der erste zu kombinierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-250">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="8f3af-251">Der zweite zu kombinierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-251">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="8f3af-252">Der dritte zu kombinierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-252">The third path to combine.</span></span></param>
        <param name="path4"><span data-ttu-id="8f3af-253">Der vierte zu kombinierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-253">The fourth path to combine.</span></span></param>
        <summary><span data-ttu-id="8f3af-254">Kombiniert vier Zeichenfolgen zu einem Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-254">Combines four strings into a path.</span></span></summary>
        <returns><span data-ttu-id="8f3af-255">Die kombinierten Pfade.</span><span class="sxs-lookup"><span data-stu-id="8f3af-255">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f3af-256">`path1` sollte ein absoluter Pfad sein (z. b. "d:\archive" oder "\\\archives\public"). Wenn einer der nachfolgenden Pfade ebenfalls ein absoluter Pfad ist, verwirft der Combine-Vorgang alle zuvor kombinierten Pfade und setzt auf diesen absoluten Pfad zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-256">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").If one of the subsequent paths is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="8f3af-257">Zeichen folgen der Länge 0 (null) werden im kombinierten Pfad weggelassen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-257">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="8f3af-258">Wenn `path1`, `path2`oder `path3` kein Laufwerks Verweis ist (d. h. "C:" oder "D:") und nicht mit einem gültigen Trennzeichen endet, wie in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>oder <xref:System.IO.Path.VolumeSeparatorChar>definiert, wird <xref:System.IO.Path.DirectorySeparatorChar> vor der Verkettung angehängt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-258">If `path1`, `path2`, or `path3` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to it before concatenation.</span></span> <span data-ttu-id="8f3af-259">Beachten Sie Folgendes: Wenn `path1`, `path2`oder `path3` in einem Pfad Trennzeichen enden, das für die Zielplattform nicht geeignet ist, behält die `Combine`-Methode das ursprüngliche Pfad Trennzeichen bei und fügt eine unterstützte ein.</span><span class="sxs-lookup"><span data-stu-id="8f3af-259">Note that if `path1`, `path2`, or `path3` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="8f3af-260">Im folgenden Beispiel wird das Ergebnis auf Windows-und UNIX-basierten Systemen verglichen, wenn der umgekehrte Schrägstrich als Pfad Trennzeichen verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-260">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 <span data-ttu-id="8f3af-261">Wenn `path2` keinen Stamm enthält (z. b., wenn `path2` nicht mit einem Trennzeichen oder einer Laufwerk Spezifikation beginnt), ist das Ergebnis eine Verkettung der beiden Pfade mit einem dazwischen liegenden Trennzeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-261">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="8f3af-262">Wenn `path2` einen Stamm enthält, wird `path2` zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-262">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="8f3af-263">Die Parameter werden nicht analysiert, wenn Sie Leerzeichen enthalten.</span><span class="sxs-lookup"><span data-stu-id="8f3af-263">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="8f3af-264">Wenn `path2` Leerraum (z. b. "\file.txt") enthält, fügt die <xref:System.IO.Path.Combine%2A>-Methode `path2` an `path1`an.</span><span class="sxs-lookup"><span data-stu-id="8f3af-264">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="8f3af-265">Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Combine`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="8f3af-265">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8f3af-266">Beispielsweise ist `Path.Combine("c:\\", "*.txt")` möglicherweise ungültig, wenn Sie eine Datei aus der Datei erstellen möchten, Sie als Such Zeichenfolge gültig ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-266">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="8f3af-267">Sie wird daher von der `Combine`-Methode erfolgreich interpretiert.</span><span class="sxs-lookup"><span data-stu-id="8f3af-267">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f3af-268">Im folgenden Beispiel werden vier Pfade kombiniert.</span><span class="sxs-lookup"><span data-stu-id="8f3af-268">The following example combines four paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f3af-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> oder <paramref name="path4" /> enthält mindestens ein ungültiges Zeichen gemäß der Definition in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f3af-270"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> oder <paramref name="path4" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-270"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-271">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-271">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f3af-272">Stellt ein plattformspezifisches Zeichen bereit, das zur Trennung von Verzeichnisebenen in einer Pfadzeichenfolge verwendet wird und eine hierarchische Dateisystemorganisation wiedergibt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-272">Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="8f3af-273"><xref:System.IO.Path.AltDirectorySeparatorChar> und `DirectorySeparatorChar` sind sowohl für die Trennung von Verzeichnis Ebenen in einer Pfad Zeichenfolge gültig.</span><span class="sxs-lookup"><span data-stu-id="8f3af-273"><xref:System.IO.Path.AltDirectorySeparatorChar> and `DirectorySeparatorChar` are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="8f3af-274">Wenn Sie .net Core verwenden, um Anwendungen zu entwickeln, die auf mehreren Plattformen ausgeführt werden:</span><span class="sxs-lookup"><span data-stu-id="8f3af-274">When you are using .NET Core to develop applications that run on multiple platforms:</span></span>

- <span data-ttu-id="8f3af-275">Wenn Sie das Verzeichnis Trennzeichen lieber hart codieren möchten, sollten Sie den Schrägstrich (`/`) verwenden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-275">If you prefer to hard-code the directory separator character, you should use the forward slash (`/`) character.</span></span> <span data-ttu-id="8f3af-276">Es ist das einzige erkannte Verzeichnis Trennzeichen auf UNIX-Systemen, wie die Ausgabe des Beispiels zeigt, und ist der <xref:System.IO.Path.AltDirectorySeparatorChar> unter Windows.</span><span class="sxs-lookup"><span data-stu-id="8f3af-276">It is the only recognized directory separator character on Unix systems, as the output from the example shows, and is the <xref:System.IO.Path.AltDirectorySeparatorChar> on Windows.</span></span>

- <span data-ttu-id="8f3af-277">Verwenden Sie die Zeichen folgen Verkettung, um das Pfad Trennzeichen dynamisch zur Laufzeit abzurufen und in Dateisystem Pfade einzubinden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-277">Use string concatenation to dynamically retrieve the path separator character at runtime and incorporate it into file system paths.</span></span> <span data-ttu-id="8f3af-278">Ein auf ein Objekt angewendeter</span><span class="sxs-lookup"><span data-stu-id="8f3af-278">For example,</span></span> 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```

   ```vb
   separator = Path.DirectorySeparatorChar
   path = $"{separator}users{separator}user1{separator}"
   ``` 

   <span data-ttu-id="8f3af-279">Sie können auch den Wert aus der <xref:System.IO.Path.AltDirectorySeparatorChar>-Eigenschaft abrufen, da dieser auf Windows-und Unx-basierten Systemen identisch ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-279">You can also retrieve the value from the <xref:System.IO.Path.AltDirectorySeparatorChar> property, since it is the same on both Windows and Unx-based systems.</span></span>

- <span data-ttu-id="8f3af-280">Abrufen der <xref:System.IO.Path.AltDirectorySeparatorChar>-Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="8f3af-280">Retrieve the <xref:System.IO.Path.AltDirectorySeparatorChar> property</span></span>

<span data-ttu-id="8f3af-281">Wenn Ihre Anwendung nicht plattformübergreifend ist, können Sie das für das System geeignete Trennzeichen verwenden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-281">If your application is not cross-platform, you can use the separator appropriate for your system.</span></span>

## Examples  

<span data-ttu-id="8f3af-282">Im folgenden Beispiel werden <xref:System.IO.Path> Feldwerte in Windows und auf UNIX-basierten Systemen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-282">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="8f3af-283">Beachten Sie, dass Windows entweder den Schrägstrich (der vom Feld "<xref:System.IO.Path.AltDirectorySeparatorChar>" zurückgegeben wird) oder den umgekehrten Schrägstrich (der vom Feld "<xref:System.IO.Path.DirectorySeparatorChar>" zurückgegeben wird) als Pfad Trennzeichen unterstützt, während UNIX-basierte Systeme nur den Schrägstrich unterstützen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-283">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8f3af-284">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="8f3af-284">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-285">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-285">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8f3af-286">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="8f3af-286">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8f3af-287">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="8f3af-287">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-288">Der zu analysierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-288">The path to analyze.</span></span></param>
        <summary><span data-ttu-id="8f3af-289">Gibt einen Wert zurück, mit dem angegeben wird, ob der als schreibgeschützter Bereich angegebene Pfad auf ein Verzeichnistrennzeichen endet.</span><span class="sxs-lookup"><span data-stu-id="8f3af-289">Returns a value that indicates whether the path, specified as a read-only span, ends in a directory separator.</span></span></summary>
        <returns><span data-ttu-id="8f3af-290"><see langword="true" />, wenn der Pfad auf ein Verzeichnistrennzeichen endet; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-290"><see langword="true" /> if the path ends in a directory separator; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : string -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-291">Der zu analysierende Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-291">The path to analyze.</span></span></param>
        <summary><span data-ttu-id="8f3af-292">Gibt einen Wert zurück, der angibt, ob der angegebene Pfad auf ein Verzeichnistrennzeichen endet.</span><span class="sxs-lookup"><span data-stu-id="8f3af-292">Returns a value that indicates whether the specified path ends in a directory separator.</span></span></summary>
        <returns><span data-ttu-id="8f3af-293"><see langword="true" />, wenn der Pfad auf ein Verzeichnistrennzeichen endet; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-293"><see langword="true" /> if the path ends in a directory separator; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-294">Der Pfad, aus dem die Verzeichnisinformationen abgerufen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-294">The path to retrieve the directory information from.</span></span></param>
        <summary><span data-ttu-id="8f3af-295">Gibt die Verzeichnisinformationen für den angegebenen Pfad in Form einer Zeichenspanne zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-295">Returns the directory information for the specified path represented by a character span.</span></span></summary>
        <returns><span data-ttu-id="8f3af-296">Verzeichnisinformationen für <paramref name="path" /> oder eine leere Spanne, wenn <paramref name="path" /><see langword="null" /> ist, eine leere Spanne oder ein Stamm (wie \, C: oder \\server\share).</span><span class="sxs-lookup"><span data-stu-id="8f3af-296">Directory information for <paramref name="path" />, or an empty span if <paramref name="path" /> is <see langword="null" />, an empty span, or a root (such as \, C:, or \\server\share).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8f3af-297">Anders als bei der Zeichen folgen Überladung normalisiert diese Methode keine Verzeichnis Trennzeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-297">Unlike the string overload, this method doesn't normalize directory separators.</span></span>

          ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-298">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-298">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-299">Der Pfad einer Datei oder eines Verzeichnisses.</span><span class="sxs-lookup"><span data-stu-id="8f3af-299">The path of a file or directory.</span></span></param>
        <summary><span data-ttu-id="8f3af-300">Gibt die Verzeichnisinformationen für die angegebene Pfadzeichenfolge zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-300">Returns the directory information for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="8f3af-301">Verzeichnisinformationen für <paramref name="path" /> oder <see langword="null" />, wenn <paramref name="path" /> ein Stammverzeichnis bezeichnet oder NULL ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-301">Directory information for <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> denotes a root directory or is null.</span></span> <span data-ttu-id="8f3af-302">Gibt <see cref="F:System.String.Empty" /> zurück, wenn <paramref name="path" /> keine Verzeichnisinformationen enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-302">Returns <see cref="F:System.String.Empty" /> if <paramref name="path" /> does not contain directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f3af-303">In den meisten Fällen besteht die Zeichenfolge, die von dieser Methode zurückgegeben wird, aus allen Zeichen im Pfad bis einschließlich der letzten <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="8f3af-303">In most cases, the string returned by this method consists of all characters in the path up to but not including the last <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span> <span data-ttu-id="8f3af-304">Wenn der Pfad aus einem Stammverzeichnis (z. b. "c:\\") besteht, wird NULL zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-304">If the path consists of a root directory, such as "c:\\", null is returned.</span></span> <span data-ttu-id="8f3af-305">Beachten Sie, dass diese Methode keine Pfade unterstützt, die "file:" verwenden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-305">Note that this method does not support paths using "file:".</span></span> <span data-ttu-id="8f3af-306">Da der zurückgegebene Pfad die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>nicht enthält, führt das Übergeben des zurückgegebenen Pfades zurück in die <xref:System.IO.Path.GetDirectoryName%2A>-Methode dazu, dass eine Ordnerebene pro nachfolgenden Aufrufe der Ergebnis Zeichenfolge abgeschnitten wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-306">Because the returned path does not include the <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, passing the returned path back into the <xref:System.IO.Path.GetDirectoryName%2A> method will result in the truncation of one folder level per subsequent call on the result string.</span></span> <span data-ttu-id="8f3af-307">Wenn Sie z. b. den Pfad "c:\Directory\SubDirectory\test.txt" an die <xref:System.IO.Path.GetDirectoryName%2A>-Methode übergeben, wird "c:\Directory\SubDirectory" zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-307">For example, passing the path "C:\Directory\SubDirectory\test.txt" into the <xref:System.IO.Path.GetDirectoryName%2A> method will return "C:\Directory\SubDirectory".</span></span> <span data-ttu-id="8f3af-308">Wenn Sie die Zeichenfolge "c:\direct\subdirectory" in <xref:System.IO.Path.GetDirectoryName%2A> übergeben, wird "c:\directory" angezeigt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-308">Passing that string, "C:\Directory\SubDirectory", into <xref:System.IO.Path.GetDirectoryName%2A> will result in "C:\Directory".</span></span>  
  
 <span data-ttu-id="8f3af-309">Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-309">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f3af-310">Im folgenden Beispiel wird die Verwendung der `GetDirectoryName`-Methode auf einer Windows-basierten Desktop Plattform veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-310">The following example demonstrates using the `GetDirectoryName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f3af-311">Der <paramref name="path" />-Parameter enthält nur ungültige Zeichen, ist leer oder enthält nur Leerzeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-311">The <paramref name="path" /> parameter contains invalid characters, is empty, or contains only white spaces.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="8f3af-312">Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.IO.IOException" /> ab.</span><span class="sxs-lookup"><span data-stu-id="8f3af-312">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="8f3af-313">Der <paramref name="path" />-Parameter überschreitet die vom System definierte Maximallänge.</span><span class="sxs-lookup"><span data-stu-id="8f3af-313">The <paramref name="path" /> parameter is longer than the system-defined maximum length.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-314">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-314">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8f3af-315">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="8f3af-315">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8f3af-316">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="8f3af-316">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8f3af-317">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="8f3af-317">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-318">Der Dateipfad, aus dem die Erweiterung abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="8f3af-318">The file path from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="8f3af-319">Gibt die Erweiterung eines Dateipfads zurück, der durch eine schreibgeschützte Zeichenspanne dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-319">Returns the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="8f3af-320">Die Erweiterung des angegebenen Pfads (einschließlich des Punkts „.“) oder <see cref="P:System.ReadOnlySpan`1.Empty" />, falls <paramref name="path" /> keine Erweiterungsinformationen umfasst.</span><span class="sxs-lookup"><span data-stu-id="8f3af-320">The extension of the specified path (including the period, "."), or <see cref="P:System.ReadOnlySpan`1.Empty" /> if <paramref name="path" /> does not have extension information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="8f3af-321">Diese Methode ruft die Erweiterung der `path` ab, indem Sie `path` nach einem bestimmten Zeitraum (".") sucht, beginnend mit dem letzten Zeichen in der schreibgeschützten Spanne und Fortsetzung des ersten Zeichens.</span><span class="sxs-lookup"><span data-stu-id="8f3af-321">This method obtains the extension of `path` by searching `path` for a period ("."), starting from the last character in the read-only span and continuing toward its first character.</span></span> <span data-ttu-id="8f3af-322">Wenn ein Zeitraum vor einem <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar> Zeichen gefunden wird, enthält die zurückgegebene schreibgeschützte Spanne den Zeitraum und die Zeichen danach. Andernfalls wird <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-322">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned read-only span contains the period and the characters after it; otherwise, <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> is returned.</span></span>  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-323">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-323">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-324">Die Pfadzeichenfolge, aus der die Erweiterung abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="8f3af-324">The path string from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="8f3af-325">Gibt die Erweiterung (einschließlich des Punkts „.“) der angegebenen Pfadzeichenfolge zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-325">Returns the extension (including the period ".") of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="8f3af-326">Die Erweiterung des angegebenen Pfads (einschließlich des Punkts ".") oder <see langword="null" /> oder <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-326">The extension of the specified path (including the period "."), or <see langword="null" />, or <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="8f3af-327">Wenn <paramref name="path" /> gleich <see langword="null" /> ist, gibt <see cref="M:System.IO.Path.GetExtension(System.String)" /><see langword="null" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-327">If <paramref name="path" /> is <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see langword="null" />.</span></span> <span data-ttu-id="8f3af-328">Wenn <paramref name="path" /> keine Informationen über die Erweiterung enthält, gibt <see cref="M:System.IO.Path.GetExtension(System.String)" /><see cref="F:System.String.Empty" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-328">If <paramref name="path" /> does not have extension information, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="8f3af-329">Diese Methode ruft die Erweiterung von `path` ab, indem Sie `path` nach einem bestimmten Zeitraum (.) sucht, beginnend mit dem letzten Zeichen in `path` und Fortfahren mit dem ersten Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-329">This method obtains the extension of `path` by searching `path` for a period (.), starting with the last character in `path` and continuing toward the first character.</span></span> <span data-ttu-id="8f3af-330">Wenn ein Zeitraum vor einem <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar> Zeichen gefunden wird, enthält die zurückgegebene Zeichenfolge den Zeitraum und die Zeichen danach. Andernfalls wird <xref:System.String.Empty?displayProperty=nameWithType> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-330">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned string contains the period and the characters after it; otherwise, <xref:System.String.Empty?displayProperty=nameWithType> is returned.</span></span>  
  
 <span data-ttu-id="8f3af-331">Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-331">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
 
## Examples  
 <span data-ttu-id="8f3af-332">Im folgenden Beispiel wird die Verwendung der `GetExtension`-Methode auf einer Windows-basierten Desktop Plattform veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-332">The following example demonstrates using the `GetExtension` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f3af-333"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-333"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-334">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-334">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8f3af-335">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="8f3af-335">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8f3af-336">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="8f3af-336">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8f3af-337">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="8f3af-337">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-338">Eine schreibgeschützte Spanne, die den Pfad enthält, aus dem der Dateiname und die Erweiterung abgerufen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-338">A read-only span that contains the path from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="8f3af-339">Gibt den Dateinamen und die Erweiterung eines Dateipfads zurück, der durch eine schreibgeschützte Zeichenspanne dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-339">Returns the file name and extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="8f3af-340">Die Zeichen nach dem letzten Verzeichnistrennzeichen in <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-340">The characters after the last directory separator character in <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="8f3af-341">Die zurückgegebene schreibgeschützte Spanne enthält die Zeichen des Pfads, der auf das letzte Trennzeichen in `path`folgt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-341">The returned read-only span contains the characters of the path that follow the last separator in `path`.</span></span> <span data-ttu-id="8f3af-342">Wenn das letzte Zeichen in `path` ein Volume oder ein Verzeichnis Trennzeichen ist, gibt die Methode <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-342">If the last character in `path` is a volume or directory separator character, the method returns <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8f3af-343">Wenn `path` kein Trennzeichen enthält, gibt die Methode `path`zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-343">If `path` contains no separator character, the method returns `path`.</span></span>

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-344">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-344">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-345">Die Pfadzeichenfolge, aus der der Dateiname und die Erweiterung abgerufen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-345">The path string from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="8f3af-346">Gibt den Dateinamen und die Erweiterung der angegebenen Pfadzeichenfolge zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-346">Returns the file name and extension of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="8f3af-347">Die Zeichen nach dem letzten Verzeichnistrennzeichen in <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-347">The characters after the last directory separator character in <paramref name="path" />.</span></span> <span data-ttu-id="8f3af-348">Wenn das letzte Zeichen von <paramref name="path" /> ein Verzeichnis- bzw. Volumetrennzeichen ist, gibt diese Methode <see cref="F:System.String.Empty" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-348">If the last character of <paramref name="path" /> is a directory or volume separator character, this method returns <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="8f3af-349">Wenn <paramref name="path" /> gleich <see langword="null" /> ist, gibt die Methode <see langword="null" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-349">If <paramref name="path" /> is <see langword="null" />, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="8f3af-350">Der zurückgegebene Wert ist `null`, wenn der Dateipfad `null`ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-350">The returned value is `null` if the file path is `null`.</span></span>  
  
<span data-ttu-id="8f3af-351">Die Trennzeichen, mit denen der Start des Datei namens bestimmt wird, sind <xref:System.IO.Path.DirectorySeparatorChar> und <xref:System.IO.Path.AltDirectorySeparatorChar>.</span><span class="sxs-lookup"><span data-stu-id="8f3af-351">The separator characters used to determine the start of the file name are <xref:System.IO.Path.DirectorySeparatorChar> and <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span>  

<span data-ttu-id="8f3af-352">Da *\\* ein gültiger Dateiname unter Unix ist, `GetFileName`, die unter UNIX-basierten Plattformen ausgeführt werden, können den Dateinamen nicht ordnungsgemäß aus einem Windows-basierten Pfad wie " *C:\\" MyDir "\\MyFile. ext*" zurückgeben, aber *`GetFileName`, die*unter Windows-basierten Plattformen ausgeführt werden, können den Dateinamen ordnungsgemäß auf UNIX-und Windows-basierten Platt `GetFileName` Formen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-352">Because *\\* is a legal file name on Unix, `GetFileName` running under Unix-based platforms cannot correctly return the file name from a Windows-based path like *C:\\mydir\\myfile.ext*, but `GetFileName` running under Windows-based platforms can correctly return the file name from a Unix-based path like */tmp/myfile.ext*, so the behavior of the `GetFileName` method is not strictly the same on Unix-based and Windows-based platforms.</span></span>

<span data-ttu-id="8f3af-353">Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-353">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f3af-354">Im folgenden Beispiel wird das Verhalten der `GetFileName` Methode auf einer Windows-basierten Desktop Plattform veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-354">The following example demonstrates the behavior of the `GetFileName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f3af-355"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-355"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-356">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-356">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8f3af-357">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="8f3af-357">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8f3af-358">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="8f3af-358">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8f3af-359">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="8f3af-359">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-360">Eine schreibgeschützte Spanne, die den Pfad enthält, aus dem der Dateiname ohne die Erweiterung abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="8f3af-360">A read-only span that contains the path from which to obtain the file name without the extension.</span></span></param>
        <summary><span data-ttu-id="8f3af-361">Gibt den Dateinamen ohne die Erweiterung eines Dateipfads zurück, der durch eine schreibgeschützte Zeichenspanne dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-361">Returns the file name without the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="8f3af-362">Die von <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" /> zurückgegebenen Zeichen in der schreibgeschützten Spanne ohne den letzten Punkt (.) und alle folgenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-362">The characters in the read-only span returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-363">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-363">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-364">Der Pfad der Datei.</span><span class="sxs-lookup"><span data-stu-id="8f3af-364">The path of the file.</span></span></param>
        <summary><span data-ttu-id="8f3af-365">Gibt den Dateinamen der angegebenen Pfadzeichenfolge ohne Erweiterung zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-365">Returns the file name of the specified path string without the extension.</span></span></summary>
        <returns><span data-ttu-id="8f3af-366">Die von <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" /> zurückgegebene Zeichenfolge ohne den letzten Punkt (.) und alle folgenden Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-366">The string returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f3af-367">Diese Methode überprüft nicht, ob der Pfad oder Dateiname vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-367">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="8f3af-368">Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-368">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f3af-369">Im folgenden Beispiel wird die Verwendung der `GetFileNameWithoutExtension`-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-369">The following example demonstrates a use of the `GetFileNameWithoutExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f3af-370"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-370"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-371">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-371">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8f3af-372">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="8f3af-372">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8f3af-373">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="8f3af-373">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8f3af-374">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="8f3af-374">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-375">Die Datei oder das Verzeichnis, für das die absoluten Pfadinformationen abgerufen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-375">The file or directory for which to obtain absolute path information.</span></span></param>
        <summary><span data-ttu-id="8f3af-376">Gibt den absoluten Pfad für die angegebene Pfadzeichenfolge zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-376">Returns the absolute path for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="8f3af-377">Der vollqualifizierte Speicherort von <paramref name="path" />, z. B. "C:\MyFile.txt".</span><span class="sxs-lookup"><span data-stu-id="8f3af-377">The fully qualified location of <paramref name="path" />, such as "C:\MyFile.txt".</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="8f3af-378">Der absolute Pfad enthält alle Informationen, die erforderlich sind, um eine Datei oder ein Verzeichnis auf einem System zu finden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-378">The absolute path includes all information required to locate a file or directory on a system.</span></span>  
  
 <span data-ttu-id="8f3af-379">Die Datei oder das Verzeichnis, das von `path` angegeben wird, muss nicht vorhanden sein.</span><span class="sxs-lookup"><span data-stu-id="8f3af-379">The file or directory specified by `path` is not required to exist.</span></span> <span data-ttu-id="8f3af-380">Wenn z. b. *c:\temp\newdir* das aktuelle Verzeichnis ist, wird beim Aufrufen von `GetFullPath` für einen Dateinamen wie " *Test. txt* " *c:\temp\newdir\test.txt*zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-380">For example, if *c:\temp\newdir* is the current directory, calling `GetFullPath` on a file name such as *test.txt* returns *c:\temp\newdir\test.txt*.</span></span> <span data-ttu-id="8f3af-381">Die Datei muss nicht vorhanden sein.</span><span class="sxs-lookup"><span data-stu-id="8f3af-381">The file need not exist.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="8f3af-382">Wenn `path` ein relativer Pfad ist, gibt diese Überladung einen voll qualifizierten Pfad zurück, der auf dem aktuellen Laufwerk und dem aktuellen Verzeichnis basieren kann.</span><span class="sxs-lookup"><span data-stu-id="8f3af-382">If `path` is a relative path, this overload returns a fully qualified path that can be based on the current drive and current directory.</span></span> <span data-ttu-id="8f3af-383">Das aktuelle Laufwerk und das aktuelle Verzeichnis können sich jederzeit ändern, wenn eine Anwendung ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-383">The current drive and current directory can change at any time as an application executes.</span></span> <span data-ttu-id="8f3af-384">Folglich kann der von dieser Überladung zurückgegebene Pfad nicht im Voraus bestimmt werden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-384">As a result, the path returned by this overload cannot be determined in advance.</span></span> <span data-ttu-id="8f3af-385">Um einen deterministischen Pfad zurückzugeben, müssen Sie die <xref:System.IO.Path.GetFullPath(System.String,System.String)> Überladung aufrufen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-385">To return a deterministic path, call the <xref:System.IO.Path.GetFullPath(System.String,System.String)> overload.</span></span> <span data-ttu-id="8f3af-386">Sie können auch die <xref:System.IO.Path.IsPathFullyQualified%2A>-Methode aufzurufen, um zu bestimmen, ob ein Pfad vollständig qualifiziert oder relativ ist, und daher, ob ein `GetFullPath` erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-386">You can also call the <xref:System.IO.Path.IsPathFullyQualified%2A> method to determine whether a path is fully qualified or relative and therefore whether a call to `GetFullPath` is necessary.</span></span>

 <span data-ttu-id="8f3af-387">Wenn `path` jedoch vorhanden ist, muss der Aufrufer über die Berechtigung zum Abrufen von Pfadinformationen für `path`verfügen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-387">However, if `path` does exist, the caller must have permission to obtain path information for `path`.</span></span> <span data-ttu-id="8f3af-388">Beachten Sie, dass diese Methode im Gegensatz zu den meisten Membern der <xref:System.IO.Path>-Klasse auf das Dateisystem zugreift.</span><span class="sxs-lookup"><span data-stu-id="8f3af-388">Note that unlike most members of the <xref:System.IO.Path> class, this method accesses the file system.</span></span>  
  
 <span data-ttu-id="8f3af-389">Diese Methode verwendet das aktuelle Verzeichnis und die aktuellen Volumeinformationen, um `path`vollständig zu qualifizieren.</span><span class="sxs-lookup"><span data-stu-id="8f3af-389">This method uses the current directory and current volume information to fully qualify `path`.</span></span> <span data-ttu-id="8f3af-390">Wenn Sie in `path`nur einen Dateinamen angeben, gibt `GetFullPath` den voll qualifizierten Pfad des aktuellen Verzeichnisses zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-390">If you specify a file name only in `path`, `GetFullPath` returns the fully qualified path of the current directory.</span></span>  
  
 <span data-ttu-id="8f3af-391">Wenn Sie einen kurzen Dateinamen übergeben, wird er auf einen langen Dateinamen erweitert.</span><span class="sxs-lookup"><span data-stu-id="8f3af-391">If you pass in a short file name, it is expanded to a long file name.</span></span>  
  
 <span data-ttu-id="8f3af-392">Wenn ein Pfad keine signifikanten Zeichen enthält, ist er ungültig, es sei denn, er enthält mindestens ein "."-Zeichen, auf das eine beliebige Anzahl von Leerzeichen folgt. Anschließend wird Sie entweder als "." oder ".." analysiert.</span><span class="sxs-lookup"><span data-stu-id="8f3af-392">If a path contains no significant characters, it is invalid unless it contains one or more "." characters followed by any number of spaces; then it will be parsed as either "." or "..".</span></span>  

<span data-ttu-id="8f3af-393">.Net Core 1,1 und höhere Versionen sowie .NET Framework 4.6.2 und höhere Versionen unterstützen auch Pfade, die Gerätenamen enthalten, z. b. "\\? \c:\".</span><span class="sxs-lookup"><span data-stu-id="8f3af-393">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support paths that include device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="8f3af-394">Weitere Informationen zu Datei Pfad Formaten unter Windows finden Sie unter [Dateipfad Formate auf Windows-Systemen](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="8f3af-394">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="8f3af-395">Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-395">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
  
## Examples  
 <span data-ttu-id="8f3af-396">Im folgenden Beispiel wird die `GetFullPath`-Methode auf einer Windows-basierten Desktop Plattform veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-396">The following example demonstrates the `GetFullPath` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f3af-397"><paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), besteht nur aus Leerraum oder enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültige Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-397"><paramref name="path" /> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="8f3af-398">- oder -</span><span class="sxs-lookup"><span data-stu-id="8f3af-398">-or-</span></span> 
<span data-ttu-id="8f3af-399">Das System konnte den absoluten Pfad nicht abrufen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-399">The system could not retrieve the absolute path.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="8f3af-400">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-400">The caller does not have the required permissions.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f3af-401"><paramref name="path" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-401"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8f3af-402"><paramref name="path" /> enthält einen Doppelpunkt („:“), der kein Teil eines Volumenbezeichners (z.B. „c:\\“) ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-402"><paramref name="path" /> contains a colon (":") that is not part of a volume identifier (for example, "c:\\").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="8f3af-403">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</span><span class="sxs-lookup"><span data-stu-id="8f3af-403">The specified path, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="8f3af-404">für den Zugriff auf den Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-404">for access to the path.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-405">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-405">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8f3af-406">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="8f3af-406">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8f3af-407">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="8f3af-407">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8f3af-408">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="8f3af-408">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="basePath" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-409">Ein relativer Pfad zum Verketten mit <paramref name="basePath" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-409">A relative path to concatenate to <paramref name="basePath" />.</span></span></param>
        <param name="basePath"><span data-ttu-id="8f3af-410">Der Anfang eines vollqualifizierten Pfads.</span><span class="sxs-lookup"><span data-stu-id="8f3af-410">The beginning of a fully qualified path.</span></span></param>
        <summary><span data-ttu-id="8f3af-411">Gibt einen absoluten Pfad aus einem vollqualifizierten Basispfad und einem relativen Pfad zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-411">Returns an absolute path from a fully qualified base path and a relative path.</span></span></summary>
        <returns><span data-ttu-id="8f3af-412">Der absolute Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-412">The absolute path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="8f3af-413">Wenn `path` ein leerer Pfad ist, gibt die Methode `basePath`zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-413">If `path` is an empty path, the method returns `basePath`.</span></span> <span data-ttu-id="8f3af-414">Wenn `path` ein voll qualifizierter Pfad ist, übergibt die Methode `path` an die <xref:System.IO.Path.GetFullPath(System.String)>-Methode und gibt das Ergebnis zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-414">If `path` is a fully qualified path, the method passes `path` to the <xref:System.IO.Path.GetFullPath(System.String)> method and returns the result.</span></span>

<span data-ttu-id="8f3af-415">Verwenden Sie diese Methode, um einen deterministischen Pfad basierend auf einem angegebenen Volume und Stammverzeichnis zurückzugeben, wenn Sie relative Pfade verwenden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-415">Use this method to return a deterministic path based on a specified volume and rooted directory when you're using relative paths.</span></span> <span data-ttu-id="8f3af-416">Die Verwendung eines vordefinierten `basePath` nicht auf Grundlage des aktuellen Laufwerks Verzeichnisses schützt vor unerwünschten Dateipfaden, die durch unerwartete Änderungen im aktuellen Laufwerk und Verzeichnis verursacht werden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-416">Using a predefined `basePath` rather than one based on the current drive directory guards against unwanted file paths caused by unexpected changes in the current drive and directory.</span></span> 

## <a name="example"></a><span data-ttu-id="8f3af-417">Beispiel</span><span class="sxs-lookup"><span data-stu-id="8f3af-417">Example</span></span>

<span data-ttu-id="8f3af-418">Im folgenden Beispiel wird eine Variable, `basePath`, definiert, um das aktuelle Verzeichnis einer Anwendung darzustellen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-418">The following example defines a variable, `basePath`, to represent an application's current directory.</span></span> <span data-ttu-id="8f3af-419">Er übergibt ihn dann an die `GetFullPath`-Methode, um einen voll qualifizierten Pfad zum Datenverzeichnis der Anwendung zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="8f3af-419">It then passes it to the `GetFullPath` method to get a fully qualified path to the application's data directory.</span></span>

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-vb[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f3af-420"><paramref name="path" /> oder <paramref name="basePath" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-420"><paramref name="path" /> or <paramref name="basePath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f3af-421"><paramref name="basePath" /> ist kein vollqualifizierter Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-421"><paramref name="basePath" /> is not a fully qualified path.</span></span>

<span data-ttu-id="8f3af-422">- oder -</span><span class="sxs-lookup"><span data-stu-id="8f3af-422">-or-</span></span>

<span data-ttu-id="8f3af-423"><paramref name="path" /> oder <paramref name="basePath" /> enthält ungültige Pfadzeichen, z. B. U+0000.</span><span class="sxs-lookup"><span data-stu-id="8f3af-423"><paramref name="path" /> or <paramref name="basePath" /> contains invalid path characters, such as U+0000.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8f3af-424">Ruft ein Array ab, das die Zeichen enthält, die in Dateinamen nicht zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="8f3af-424">Gets an array containing the characters that are not allowed in file names.</span></span></summary>
        <returns><span data-ttu-id="8f3af-425">Ein Array, das die Zeichen enthält, die in Dateinamen nicht zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="8f3af-425">An array containing the characters that are not allowed in file names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f3af-426">Das von dieser Methode zurückgegebene Array enthält nicht unbedingt den kompletten Satz von Zeichen, die in Datei-und Verzeichnisnamen ungültig sind.</span><span class="sxs-lookup"><span data-stu-id="8f3af-426">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="8f3af-427">Der vollständige Satz von ungültigen Zeichen kann je nach Dateisystem variieren.</span><span class="sxs-lookup"><span data-stu-id="8f3af-427">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="8f3af-428">Beispielsweise können auf Windows-basierten Desktop Plattformen ungültige Pfad Zeichen ASCII/Unicode-Zeichen 1 bis 31 sowie Anführungszeichen ("), kleiner als (\<), größer als (>), Pipe (&#124;), Rücktaste (\b), NULL (\ 0) und Tabulator (\t) enthalten.</span><span class="sxs-lookup"><span data-stu-id="8f3af-428">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f3af-429">Im folgenden Beispiel werden die <xref:System.IO.Path.GetInvalidFileNameChars%2A>-Methode und die <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode zum Abrufen ungültiger Zeichen veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-429">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8f3af-430">Ruft ein Array ab, das die Zeichen enthält, die in Pfadnamen nicht zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="8f3af-430">Gets an array containing the characters that are not allowed in path names.</span></span></summary>
        <returns><span data-ttu-id="8f3af-431">Ein Array, das die Zeichen enthält, die in Pfadnamen nicht zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="8f3af-431">An array containing the characters that are not allowed in path names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f3af-432">Das von dieser Methode zurückgegebene Array enthält nicht unbedingt den kompletten Satz von Zeichen, die in Datei-und Verzeichnisnamen ungültig sind.</span><span class="sxs-lookup"><span data-stu-id="8f3af-432">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="8f3af-433">Der vollständige Satz von ungültigen Zeichen kann je nach Dateisystem variieren.</span><span class="sxs-lookup"><span data-stu-id="8f3af-433">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="8f3af-434">Beispielsweise können auf Windows-basierten Desktop Plattformen ungültige Pfad Zeichen ASCII/Unicode-Zeichen 1 bis 31 sowie Anführungszeichen ("), kleiner als (\<), größer als (>), Pipe (&#124;), Rücktaste (\b), NULL (\ 0) und Tabulator (\t) enthalten.</span><span class="sxs-lookup"><span data-stu-id="8f3af-434">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f3af-435">Im folgenden Beispiel werden die <xref:System.IO.Path.GetInvalidFileNameChars%2A>-Methode und die <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode zum Abrufen ungültiger Zeichen veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-435">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-436">Eine schreibgeschützte Spanne von Zeichen, die den Pfad enthält, für den Stammverzeichnisinformationen abgerufen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-436">A read-only span of characters containing the path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="8f3af-437">Ruft Informationen über das Stammverzeichnis aus dem Pfad ab, der in der angegebenen Zeichenspanne enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-437">Gets the root directory information from the path contained in the specified character span.</span></span></summary>
        <returns><span data-ttu-id="8f3af-438">Eine schreibgeschützte Zeichenspanne mit dem Stammverzeichnis von <paramref name="path" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-438">A read-only span of characters containing the root directory of <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8f3af-439">Diese Methode überprüft nicht, ob der Pfad oder die Datei vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-439">This method does not verify that the path or file exists.</span></span>

<span data-ttu-id="8f3af-440">Anders als bei der Zeichen folgen Überladung normalisiert diese Methode keine Verzeichnis Trennzeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-440">Unlike the string overload, this method doesn't normalize directory separators.</span></span>

<span data-ttu-id="8f3af-441">Ein `ReadOnlySpan<System.Char>` ist "effektiv leer", wenn Folgendes gilt:</span><span class="sxs-lookup"><span data-stu-id="8f3af-441">A `ReadOnlySpan<System.Char>` is "effectively empty" if:</span></span>

- <span data-ttu-id="8f3af-442">In Windows gibt das Aufrufen von <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> für diese Zeichen Spanne `true`zurück, oder alle Zeichen sind Leerzeichen ("").</span><span class="sxs-lookup"><span data-stu-id="8f3af-442">In Windows, calling <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> on this span of characters returns `true`, or all its characters are spaces (' ').</span></span>
- <span data-ttu-id="8f3af-443">In UNIX gibt das Aufrufen von <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> für diese Zeichen Spanne `true`zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-443">In Unix, calling <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> on this span of characters returns `true`.</span></span>

<span data-ttu-id="8f3af-444">Mögliche Muster für die schreibgeschützte Zeichen Spanne, die von dieser Methode zurückgegeben wird, lauten wie folgt:</span><span class="sxs-lookup"><span data-stu-id="8f3af-444">Possible patterns for the read-only character span returned by this method are as follows:</span></span>

- <span data-ttu-id="8f3af-445"><xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> (`path` wurde <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8f3af-445"><xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> (`path` was <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.</span></span>

- <span data-ttu-id="8f3af-446"><xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> (`path` einen relativen Pfad auf dem aktuellen Laufwerk oder Volume angegeben).</span><span class="sxs-lookup"><span data-stu-id="8f3af-446"><xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> (`path` specified a relative path on the current drive or volume).</span></span>

- <span data-ttu-id="8f3af-447">"\" (Unix: `path` einen absoluten Pfad auf dem aktuellen Laufwerk angegeben).</span><span class="sxs-lookup"><span data-stu-id="8f3af-447">"\" (Unix: `path` specified an absolute path on the current drive).</span></span>

- <span data-ttu-id="8f3af-448">"X:" (Windows: `path` einen relativen Pfad auf einem Laufwerk angeben, wobei *X* ein Laufwerk oder einen Volumebuchstaben darstellt).</span><span class="sxs-lookup"><span data-stu-id="8f3af-448">"X:" (Windows: `path` specified a relative path on a drive, where *X* represents a drive or volume letter).</span></span>

- <span data-ttu-id="8f3af-449">"X:\" (Windows: `path` einen absoluten Pfad auf einem angegebenen Laufwerk angeben).</span><span class="sxs-lookup"><span data-stu-id="8f3af-449">"X:\" (Windows: `path` specified an absolute path on a given drive).</span></span>

- <span data-ttu-id="8f3af-450">"\\\computername\sharedfolder" (Windows: ein UNC-Pfad).</span><span class="sxs-lookup"><span data-stu-id="8f3af-450">"\\\ComputerName\SharedFolder" (Windows: a UNC path).</span></span>

- <span data-ttu-id="8f3af-451">"\\\\\?\c:" (Windows: ein DOS-Gerätepfad, der in .net Core 1,1 und höheren Versionen und in .NET Framework 4.6.2 und höheren Versionen unterstützt wird).</span><span class="sxs-lookup"><span data-stu-id="8f3af-451">"\\\\\?\C:" (Windows: a DOS device path, supported in .NET Core 1.1 and later versions, and in .NET Framework 4.6.2 and later versions).</span></span>
 
<span data-ttu-id="8f3af-452">Weitere Informationen zu Dateipfaden unter Windows finden Sie unter [Dateipfad Formate auf Windows-Systemen](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="8f3af-452">For more information on file paths on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="8f3af-453">Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-453">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>


          ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-454">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-454">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-455">Eine Zeichenfolge mit dem Pfad, für den Informationen über das Stammverzeichnis abgerufen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-455">A string containing the path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="8f3af-456">Ruft Informationen über das Stammverzeichnis aus dem Pfad ab, der in der angegebenen Zeichenfolge enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-456">Gets the root directory information from the path contained in the specified string.</span></span></summary>
        <returns><span data-ttu-id="8f3af-457">Das Stammverzeichnis von <paramref name="path" />, wenn es einen Stamm hat.</span><span class="sxs-lookup"><span data-stu-id="8f3af-457">The root directory of <paramref name="path" /> if it is rooted.</span></span>

<span data-ttu-id="8f3af-458">- oder -</span><span class="sxs-lookup"><span data-stu-id="8f3af-458">-or-</span></span> 
<span data-ttu-id="8f3af-459"><see cref="P:System.String.Empty" />, wenn <paramref name="path" /> keine Stammverzeichnisinformationen enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-459"><see cref="P:System.String.Empty" /> if <paramref name="path" /> does not contain root directory information.</span></span>

<span data-ttu-id="8f3af-460">- oder -</span><span class="sxs-lookup"><span data-stu-id="8f3af-460">-or-</span></span> 
<span data-ttu-id="8f3af-461"><see langword="null" />, wenn <paramref name="path" /><see langword="null" /> oder effektiv leer ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-461"><see langword="null" /> if <paramref name="path" /> is <see langword="null" /> or is effectively empty.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8f3af-462">Diese Methode überprüft nicht, ob der Pfad oder die Datei vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-462">This method does not verify that the path or file exists.</span></span>

<span data-ttu-id="8f3af-463">Mit dieser Methode werden Verzeichnis Trennzeichen normalisiert.</span><span class="sxs-lookup"><span data-stu-id="8f3af-463">This method will normalize directory separators.</span></span>

<span data-ttu-id="8f3af-464">Eine Zeichenfolge ist "effektiv leer", wenn Folgendes gilt:</span><span class="sxs-lookup"><span data-stu-id="8f3af-464">A string is "effectively empty" if:</span></span>

- <span data-ttu-id="8f3af-465">In Windows gibt das Aufrufen von `IsEmpty` für diese Zeichenfolge `true`zurück, oder alle zugehörigen Zeichen sind Leerzeichen ("").</span><span class="sxs-lookup"><span data-stu-id="8f3af-465">In Windows, calling `IsEmpty` on this string returns `true`, or all its characters are spaces (' ').</span></span>
- <span data-ttu-id="8f3af-466">In UNIX gibt das Aufrufen von <xref:System.String.IsNullOrEmpty%2A> für diese Zeichenfolge `true`zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-466">In Unix, calling <xref:System.String.IsNullOrEmpty%2A> on this string returns `true`.</span></span>

<span data-ttu-id="8f3af-467">Mögliche Muster für die von dieser Methode zurückgegebene Zeichenfolge sind folgende:</span><span class="sxs-lookup"><span data-stu-id="8f3af-467">Possible patterns for the string returned by this method are as follows:</span></span>

- <span data-ttu-id="8f3af-468">`null` (`path` war NULL oder eine leere Zeichenfolge).</span><span class="sxs-lookup"><span data-stu-id="8f3af-468">`null` (`path` was null or an empty string).</span></span>

- <span data-ttu-id="8f3af-469">Eine leere Zeichenfolge (`path` einen relativen Pfad auf dem aktuellen Laufwerk oder Volume angegeben).</span><span class="sxs-lookup"><span data-stu-id="8f3af-469">An empty string (`path` specified a relative path on the current drive or volume).</span></span>

- <span data-ttu-id="8f3af-470">"\" (Unix: `path` einen absoluten Pfad auf dem aktuellen Laufwerk angegeben).</span><span class="sxs-lookup"><span data-stu-id="8f3af-470">"\" (Unix: `path` specified an absolute path on the current drive).</span></span>

- <span data-ttu-id="8f3af-471">"X:" (Windows: `path` einen relativen Pfad auf einem Laufwerk angeben, wobei *X* ein Laufwerk oder einen Volumebuchstaben darstellt).</span><span class="sxs-lookup"><span data-stu-id="8f3af-471">"X:" (Windows: `path` specified a relative path on a drive, where *X* represents a drive or volume letter).</span></span>

- <span data-ttu-id="8f3af-472">"X:\" (Windows: `path` einen absoluten Pfad auf einem angegebenen Laufwerk angeben).</span><span class="sxs-lookup"><span data-stu-id="8f3af-472">"X:\" (Windows: `path` specified an absolute path on a given drive).</span></span>

- <span data-ttu-id="8f3af-473">"\\\computername\sharedfolder" (Windows: ein UNC-Pfad).</span><span class="sxs-lookup"><span data-stu-id="8f3af-473">"\\\ComputerName\SharedFolder" (Windows: a UNC path).</span></span>

- <span data-ttu-id="8f3af-474">"\\\\\?\c:" (Windows: ein DOS-Gerätepfad, der in .net Core 1,1 und höheren Versionen und in .NET Framework 4.6.2 und höheren Versionen unterstützt wird).</span><span class="sxs-lookup"><span data-stu-id="8f3af-474">"\\\\\?\C:" (Windows: a DOS device path, supported in .NET Core 1.1 and later versions, and in .NET Framework 4.6.2 and later versions).</span></span>
 
<span data-ttu-id="8f3af-475">Weitere Informationen zu Dateipfaden unter Windows finden Sie unter [Dateipfad Formate auf Windows-Systemen](~/docs/standard/io/file-path-formats.md).</span><span class="sxs-lookup"><span data-stu-id="8f3af-475">For more information on file paths on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="8f3af-476">Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-476">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>

## Examples
<span data-ttu-id="8f3af-477">Im folgenden Beispiel wird die Verwendung der `GetPathRoot`-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-477">The following example demonstrates a use of the `GetPathRoot` method.</span></span>

[!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
[!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
[!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f3af-478">Nur .NET Framework: <paramref name="path" /> mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-478">.NET Framework only: <paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>

<span data-ttu-id="8f3af-479">- oder -</span><span class="sxs-lookup"><span data-stu-id="8f3af-479">-or-</span></span>

<span data-ttu-id="8f3af-480">Nur .NET Framework: <see cref="F:System.String.Empty" /> wurde an <paramref name="path" /> übergeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-480">.NET Framework only: <see cref="F:System.String.Empty" /> was passed to <paramref name="path" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-481">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-481">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8f3af-482">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="8f3af-482">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8f3af-483">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="8f3af-483">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8f3af-484">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="8f3af-484">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8f3af-485">Gibt einen zufälligen Ordnernamen oder Dateinamen zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-485">Returns a random folder name or file name.</span></span></summary>
        <returns><span data-ttu-id="8f3af-486">Ein zufälliger Ordnername oder Dateiname.</span><span class="sxs-lookup"><span data-stu-id="8f3af-486">A random folder name or file name.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f3af-487">Die <xref:System.IO.Path.GetRandomFileName%2A>-Methode gibt eine kryptografisch starke, zufällige Zeichenfolge zurück, die entweder als Ordnername oder Dateiname verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="8f3af-487">The <xref:System.IO.Path.GetRandomFileName%2A> method returns a cryptographically strong, random string that can be used as either a folder name or a file name.</span></span> <span data-ttu-id="8f3af-488">Im Gegensatz zu <xref:System.IO.Path.GetTempFileName%2A>erstellt <xref:System.IO.Path.GetRandomFileName%2A> keine Datei.</span><span class="sxs-lookup"><span data-stu-id="8f3af-488">Unlike <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> does not create a file.</span></span> <span data-ttu-id="8f3af-489">Wenn die Sicherheit Ihres Dateisystems Vorrang hat, sollte diese Methode anstelle von <xref:System.IO.Path.GetTempFileName%2A>verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-489">When the security of your file system is paramount, this method should be used instead of <xref:System.IO.Path.GetTempFileName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f3af-490">Das folgende Beispiel zeigt die Ausgabe der <xref:System.IO.Path.GetRandomFileName%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="8f3af-490">The following example show output from the <xref:System.IO.Path.GetRandomFileName%2A> method.</span></span>  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="path" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="relativeTo"><span data-ttu-id="8f3af-491">Der Quellpfad, zu dem das Ergebnis relativ sein muss.</span><span class="sxs-lookup"><span data-stu-id="8f3af-491">The source path the result should be relative to.</span></span> <span data-ttu-id="8f3af-492">Dieser Pfad wird nicht immer als Verzeichnis betrachtet.</span><span class="sxs-lookup"><span data-stu-id="8f3af-492">This path is always considered to be a directory.</span></span></param>
        <param name="path"><span data-ttu-id="8f3af-493">Der Zielpfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-493">The destination path.</span></span></param>
        <summary><span data-ttu-id="8f3af-494">Gibt einen relativen Pfad von einem Pfad zu einem anderen zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-494">Returns a relative path from one path to another.</span></span></summary>
        <returns><span data-ttu-id="8f3af-495">Der relative Pfad oder <paramref name="path" />, wenn die Pfade nicht denselben Stamm aufweisen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-495">The relative path, or <paramref name="path" /> if the paths don't share the same root.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="8f3af-496">Pfade werden durch Aufrufen der <xref:System.IO.Path.GetFullPath%2A>-Methode aufgelöst, bevor die Differenz berechnet wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-496">Paths are resolved by calling the <xref:System.IO.Path.GetFullPath%2A> method before calculating the difference.</span></span> <span data-ttu-id="8f3af-497">Die-Methode verwendet den standardmäßigen Dateipfad Vergleich für die aktuelle Plattform (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> für Windows und MacOS <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> für Linux.</span><span class="sxs-lookup"><span data-stu-id="8f3af-497">The method uses the default file path comparison for the current platform (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for Windows and MacOs, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> for Linux.</span></span> 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f3af-498"><paramref name="relativeTo" /> oder <paramref name="path" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-498"><paramref name="relativeTo" /> or <paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-499">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-499">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8f3af-500">Erstellt eine eindeutig benannte temporäre Datei auf dem Datenträger mit einer Größe von 0 Byte und gibt den vollständigen Pfad dieser Datei zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-500">Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</span></span></summary>
        <returns><span data-ttu-id="8f3af-501">Der vollständige Pfad der temporären Datei.</span><span class="sxs-lookup"><span data-stu-id="8f3af-501">The full path of the temporary file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f3af-502">Diese Methode erstellt eine temporäre Datei mit einem. Tmp-Dateierweiterung.</span><span class="sxs-lookup"><span data-stu-id="8f3af-502">This method creates a temporary file with a .TMP file extension.</span></span> <span data-ttu-id="8f3af-503">Die temporäre Datei wird im temporären Ordner des Benutzers erstellt. Dies ist der Pfad, der von der <xref:System.IO.Path.GetTempPath%2A>-Methode zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-503">The temporary file is created within the user's temporary folder, which is the path returned by the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
 <span data-ttu-id="8f3af-504">Die <xref:System.IO.Path.GetTempFileName%2A>-Methode gibt eine <xref:System.IO.IOException> aus, wenn mehr als 65535 Dateien erstellt werden, ohne vorherige temporäre Dateien zu löschen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-504">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if it is used to create more than 65535 files without deleting previous temporary files.</span></span>  
  
 <span data-ttu-id="8f3af-505">Die <xref:System.IO.Path.GetTempFileName%2A>-Methode gibt eine <xref:System.IO.IOException> aus, wenn kein eindeutiger temporärer Dateiname verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-505">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if no unique temporary file name is available.</span></span> <span data-ttu-id="8f3af-506">Löschen Sie alle nicht benötigten temporären Dateien, um diesen Fehler zu beheben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-506">To resolve this error, delete all unneeded temporary files.</span></span>  
  
 <span data-ttu-id="8f3af-507">Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-507">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="8f3af-508">Ein E/A-Fehler tritt auf, z. B. ist kein eindeutiger temporärer Dateiname verfügbar.</span><span class="sxs-lookup"><span data-stu-id="8f3af-508">An I/O error occurs, such as no unique temporary file name is available.</span></span>  
  
<span data-ttu-id="8f3af-509">- oder -</span><span class="sxs-lookup"><span data-stu-id="8f3af-509">-or-</span></span>
  
 <span data-ttu-id="8f3af-510">Diese Methode konnte keine temporäre Datei erstellen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-510">This method was unable to create a temporary file.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="8f3af-511">zum Schreiben in das temporäre Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="8f3af-511">for writing to the temporary directory.</span></span> <span data-ttu-id="8f3af-512">Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span><span class="sxs-lookup"><span data-stu-id="8f3af-512">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8f3af-513">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="8f3af-513">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8f3af-514">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="8f3af-514">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8f3af-515">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="8f3af-515">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8f3af-516">Gibt den Pfad des temporären Ordners des aktuellen Benutzers zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-516">Returns the path of the current user's temporary folder.</span></span></summary>
        <returns><span data-ttu-id="8f3af-517">Der Pfad zum temporären Ordner, endend mit einem umgekehrten Schrägstrich.</span><span class="sxs-lookup"><span data-stu-id="8f3af-517">The path to the temporary folder, ending with a backslash.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f3af-518">Diese Methode überprüft, ob Umgebungsvariablen in der folgenden Reihenfolge vorhanden sind, und verwendet den ersten gefundenen Pfad:</span><span class="sxs-lookup"><span data-stu-id="8f3af-518">This method checks for the existence of environment variables in the following order and uses the first path found:</span></span>  
  
1.  <span data-ttu-id="8f3af-519">Der von der TMP-Umgebungsvariablen angegebene Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-519">The path specified by the TMP environment variable.</span></span>  
  
2.  <span data-ttu-id="8f3af-520">Der von der TEMP-Umgebungsvariablen angegebene Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-520">The path specified by the TEMP environment variable.</span></span>  
  
3.  <span data-ttu-id="8f3af-521">Der von der User Profile-Umgebungsvariablen angegebene Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-521">The path specified by the USERPROFILE environment variable.</span></span>  
  
4.  <span data-ttu-id="8f3af-522">Das Windows-Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="8f3af-522">The Windows directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f3af-523">Im folgenden Code wird das Aufrufen der <xref:System.IO.Path.GetTempPath%2A>-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-523">The following code shows how to call the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
```vb  
Dim result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 <span data-ttu-id="8f3af-524">Dieses Beispiel erzeugt eine Ausgabe ähnlich der folgenden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-524">This example produces output similar to the following.</span></span>  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="8f3af-525">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-525">The caller does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission"><span data-ttu-id="8f3af-526">für den uneingeschränkten Zugriff auf Umgebungsvariablen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-526">for unrestricted access to environment variables.</span></span> <span data-ttu-id="8f3af-527">Zugehörige Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="8f3af-527">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8f3af-528">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="8f3af-528">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8f3af-529">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="8f3af-529">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8f3af-530">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="8f3af-530">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-531">Der Pfad, in dem nach einer Erweiterung gesucht werden soll.</span><span class="sxs-lookup"><span data-stu-id="8f3af-531">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="8f3af-532">Legt fest, ob der Pfad, der durch die angegebene Zeichenspanne dargestellt wird, eine Erweiterung enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-532">Determines whether the path represented by the specified character span includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="8f3af-533"><see langword="true" />, wenn die Zeichen, die auf das letzte Verzeichnistrennzeichen oder Volumentrennzeichen im Pfad folgen, einen Punkt (.) gefolgt von einem oder mehreren Zeichen enthalten; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-533"><see langword="true" /> if the characters that follow the last directory separator character or volume separator in the path include a period (".") followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="8f3af-534">Ein nach stehender Zeitraum in `path` wird nicht als Erweiterung angesehen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-534">A trailing period in `path` is not considered an extension.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-535">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-535">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-536">Der Pfad, in dem nach einer Erweiterung gesucht werden soll.</span><span class="sxs-lookup"><span data-stu-id="8f3af-536">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="8f3af-537">Bestimmt, ob ein Pfad eine Dateierweiterung enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-537">Determines whether a path includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="8f3af-538"><see langword="true" />, wenn die Zeichen, die auf das letzte Verzeichnistrennzeichen (\\\ oder /) oder Volumentrennzeichen (:) im Pfad folgen, einen Punkt (.) gefolgt von einem oder mehreren Zeichen enthalten; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-538"><see langword="true" /> if the characters that follow the last directory separator (\\\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f3af-539">Beginnend ab dem Ende `path`sucht diese Methode nach einem Zeitraum (.), gefolgt von mindestens einem Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-539">Starting from the end of `path`, this method searches for a period (.) followed by at least one character.</span></span> <span data-ttu-id="8f3af-540">Wenn dieses Muster gefunden wird, bevor eine <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>oder <xref:System.IO.Path.VolumeSeparatorChar> Zeichen gefunden wird, gibt diese Methode `true`zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-540">If this pattern is found before a <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar> character is encountered, this method returns `true`.</span></span>  
  
 <span data-ttu-id="8f3af-541">Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-541">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f3af-542">Im folgenden Beispiel wird die Verwendung der `HasExtension`-Methode gezeigt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-542">The following example demonstrates the use of the `HasExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f3af-543"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-543"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-544">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-544">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8f3af-545">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="8f3af-545">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8f3af-546">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="8f3af-546">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8f3af-547">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="8f3af-547">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f3af-548">Stellt ein plattformspezifisches Array von Zeichen bereit, die nicht in Pfadzeichenfolgenargumenten angegeben werden können, die an Member der <see cref="T:System.IO.Path" />-Klasse übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-548">Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <see cref="T:System.IO.Path" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f3af-549">Das von dieser Methode zurückgegebene Array enthält nicht unbedingt den kompletten Satz von Zeichen, die in Datei-und Verzeichnisnamen ungültig sind.</span><span class="sxs-lookup"><span data-stu-id="8f3af-549">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="8f3af-550">Der vollständige Satz von ungültigen Zeichen kann je nach Dateisystem variieren.</span><span class="sxs-lookup"><span data-stu-id="8f3af-550">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="8f3af-551">Beispielsweise können auf Windows-basierten Desktop Plattformen ungültige Pfad Zeichen ASCII/Unicode-Zeichen 1 bis 31 sowie Anführungszeichen ("), kleiner als (\<), größer als (>), Pipe (&#124;), Rücktaste (\b), NULL (\ 0) und Tabulator (\t) enthalten.</span><span class="sxs-lookup"><span data-stu-id="8f3af-551">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8f3af-552">Verwenden Sie <xref:System.IO.Path.InvalidPathChars> nicht, wenn Sie der Ansicht sind, dass Ihr Code in derselben Anwendungsdomäne wie nicht vertrauenswürdiger Code ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="8f3af-552">Do not use <xref:System.IO.Path.InvalidPathChars> if you think your code might execute in the same application domain as untrusted code.</span></span> <span data-ttu-id="8f3af-553"><xref:System.IO.Path.InvalidPathChars> ist ein Array, sodass seine Elemente überschrieben werden können.</span><span class="sxs-lookup"><span data-stu-id="8f3af-553"><xref:System.IO.Path.InvalidPathChars> is an array, so its elements can be overwritten.</span></span> <span data-ttu-id="8f3af-554">Wenn nicht vertrauenswürdiger Code Elemente <xref:System.IO.Path.InvalidPathChars>überschreibt, kann dies dazu führen, dass der Code nicht mehr funktioniert.</span><span class="sxs-lookup"><span data-stu-id="8f3af-554">If untrusted code overwrites elements of <xref:System.IO.Path.InvalidPathChars>, it might cause your code to malfunction in ways that could be exploited.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f3af-555">Im folgenden Beispiel wird die Verwendung der `InvalidPathChars`-Eigenschaft veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-555">The following example demonstrates the use of the `InvalidPathChars` property.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8f3af-556">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="8f3af-556">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8f3af-557">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="8f3af-557">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8f3af-558">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="8f3af-558">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary><span data-ttu-id="8f3af-559">Gibt einen Wert zurück, der angibt, ob ein Dateipfad vollqualifiziert ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-559">Returns a value that indicates whether a file path is fully qualified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="8f3af-560">Die über Ladungen der `IsPathFullyQualified`-Methode behandeln Pfade, die sowohl die <xref:System.IO.Path.DirectorySeparatorChar> als auch die <xref:System.IO.Path.AltDirectorySeparatorChar> Zeichen verwenden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-560">The overloads of the `IsPathFullyQualified` method handle paths that use both the <xref:System.IO.Path.DirectorySeparatorChar> and the <xref:System.IO.Path.AltDirectorySeparatorChar> characters.</span></span> <span data-ttu-id="8f3af-561">Es wird keine Überprüfung des Pfads durchgeführt, der als Argument an ihn weitergeleitet wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-561">It does not perform any validation on the path that is passed to it as an argument.</span></span> <span data-ttu-id="8f3af-562">Demzufolge werden URIs als relative Pfade interpretiert und `false`zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-562">As a result, URIs are interpreted as relative paths and return `false`.</span></span> 

<span data-ttu-id="8f3af-563">Es gibt einen Unterschied zwischen einem voll qualifizierten Pfad (wie durch die `IsPathFullyQualified`-Methode angegeben) und einem Rootpfad (wie durch die <xref:System.IO.Path.IsPathRooted%2A>-Methode angegeben).</span><span class="sxs-lookup"><span data-stu-id="8f3af-563">There is a difference between a fully qualified path (as indicated by the `IsPathFullyQualified` method) and a rooted path (as indicated by the <xref:System.IO.Path.IsPathRooted%2A> method).</span></span> <span data-ttu-id="8f3af-564">Durch einen *voll qualifizierten Pfad* oder einen *absoluten Pfad* wird immer ein genauer Pfad von einem bestimmten Laufwerk oder Gerät zu einer Zieldatei oder einem Zielverzeichnis definiert, und es hängt nicht vom aktuellen Laufwerk oder aktuellen Verzeichnis ab.</span><span class="sxs-lookup"><span data-stu-id="8f3af-564">A *fully qualified path* or *absolute path* always defines an exact path from a particular drive or device to a target file or directory, and does not depend on the current drive or current directory.</span></span> <span data-ttu-id="8f3af-565">Auf Windows-Systemen definiert z. *b. C:/users/user1/Documents/Reports/2019/January/Highlights. PDF* einen absoluten Pfad vom Stamm des Laufwerks c: zur Zieldatei, *Highlights. PDF*.</span><span class="sxs-lookup"><span data-stu-id="8f3af-565">For example, on Windows systems, *C:/users/user1/documents/reports/2019/january/highlights.pdf* defines an absolute path from the root of the C: drive to the target file, *highlights.pdf*.</span></span> <span data-ttu-id="8f3af-566">Ein *Stammpfad* gibt entweder ein Start Laufwerk oder ein Stammverzeichnis an, hängt jedoch vom aktuellen Verzeichnis (wenn es sich um ein bestimmtes Laufwerk befindet) oder dem aktuellen Laufwerk (wenn es sich um ein Stammverzeichnis des Stamm Verzeichnisses befindet) ab.</span><span class="sxs-lookup"><span data-stu-id="8f3af-566">A *rooted path* specifies either a starting drive or root directory, but depends on either the current directory (if it is rooted by a specified drive) or the current drive (if it is rooted by the root directory).</span></span> <span data-ttu-id="8f3af-567">Im folgenden Beispiel wird der Unterschied zwischen voll qualifizierten Pfaden und rootpfaden veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-567">The following example illustrates the difference between fully qualified paths and rooted paths.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-568">Ein Dateipfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-568">A file path.</span></span></param>
        <summary><span data-ttu-id="8f3af-569">Gibt einen Wert zurück, der angibt, ob der durch die angegebene Zeichenspanne dargestellte Dateipfad auf ein bestimmtes Laufwerk oder einen UNC-Pfad festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-569">Returns a value that indicates whether the file path represented by the specified character span is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="8f3af-570"><see langword="true" />, wenn der Pfad auf ein bestimmtes Laufwerk oder einen UNC-Pfad festgelegt ist; <see langword="false" />, wenn der Pfad relativ zum aktuellen Laufwerk oder Arbeitsverzeichnis angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-570"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-571">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-571">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-572">Ein Dateipfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-572">A file path.</span></span></param>
        <summary><span data-ttu-id="8f3af-573">Gibt einen Wert zurück, der angibt, ob der angegebene Dateipfad auf ein bestimmtes Laufwerk oder einen UNC-Pfad festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-573">Returns a value that indicates whether the specified file path is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="8f3af-574"><see langword="true" />, wenn der Pfad auf ein bestimmtes Laufwerk oder einen UNC-Pfad festgelegt ist; <see langword="false" />, wenn der Pfad relativ zum aktuellen Laufwerk oder Arbeitsverzeichnis angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-574"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8f3af-575">Diese Methode verarbeitet Pfade, die das alternative Verzeichnis Trennzeichen verwenden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-575">This method handles paths that use the alternate directory separator.</span></span> <span data-ttu-id="8f3af-576">Es ist ein häufiger Fehler, zu vermuten, dass Stamm Pfade (<xref:System.IO.Path.IsPathRooted(System.String)>) nicht relativ sind.</span><span class="sxs-lookup"><span data-stu-id="8f3af-576">It's a frequent mistake to assume that rooted paths (<xref:System.IO.Path.IsPathRooted(System.String)>) aren't relative.</span></span> <span data-ttu-id="8f3af-577">Beispielsweise ist "c:a" das Laufwerk relativ, d. h., es wird anhand des aktuellen Verzeichnisses für C: (rooting, aber relativ) aufgelöst.</span><span class="sxs-lookup"><span data-stu-id="8f3af-577">For example, "C:a" is drive relative, that is, it's resolved against the current directory for C: (rooted, but relative).</span></span> <span data-ttu-id="8f3af-578">"C:\a" ist von einem Stamm und nicht relativ, d. h., das aktuelle Verzeichnis wird nicht zum Ändern des Pfads verwendet.</span><span class="sxs-lookup"><span data-stu-id="8f3af-578">"C:\a" is rooted and not relative, that is, the current directory isn't used to modify the path.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f3af-579"><paramref name="path" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-579"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-580">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-580">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary><span data-ttu-id="8f3af-581">Gibt einen Wert zurück, der angibt, ob ein Dateipfad einen Stamm enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-581">Returns a value that indicates whether a file path contains a root.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="8f3af-582">Ein **Stammpfad** ist ein Dateipfad, der auf einem bestimmten Laufwerk oder einem bestimmten Unic-Pfad korrigiert wird. Es steht im Gegensatz zu einem Pfad, der relativ zum aktuellen Laufwerk oder Arbeitsverzeichnis ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-582">A **rooted path** is file path that is fixed to a specific drive or UNIC path; it contrasts with a path that is relative to the current drive or working directory.</span></span> <span data-ttu-id="8f3af-583">Auf Windows-Systemen beginnt ein Stammpfad z. b. mit einem umgekehrten Schrägstrich (z. b. "\Documents") oder einem Laufwerk Buchstaben und Doppelpunkt (z. b. "c:Documents").</span><span class="sxs-lookup"><span data-stu-id="8f3af-583">For example, on Windows systems, a rooted path begins with a backslash (for example, "\Documents") or a drive letter and colon (for example, "C:Documents").</span></span> 

<span data-ttu-id="8f3af-584">Beachten Sie, dass Stamm Pfade entweder absolut (d. h. voll qualifiziert) oder relativ sind.</span><span class="sxs-lookup"><span data-stu-id="8f3af-584">Note that rooted paths can be either absolute (that is, fully qualified) or relative.</span></span> <span data-ttu-id="8f3af-585">Ein absoluter Stammpfad ist ein voll qualifizierter Pfad vom Stammverzeichnis eines Laufwerks zu einem bestimmten Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="8f3af-585">An absolute rooted path is a fully qualified path from the root of a drive to a specific directory.</span></span> <span data-ttu-id="8f3af-586">Ein relativer Stammpfad gibt ein Laufwerk an, aber der voll qualifizierte Pfad wird anhand des aktuellen Verzeichnisses aufgelöst.</span><span class="sxs-lookup"><span data-stu-id="8f3af-586">A relative rooted path specifies a drive, but its fully qualified path is resolved against the current directory.</span></span> <span data-ttu-id="8f3af-587">Der Unterschied wird im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-587">The following example illustrates the difference.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-588">Der zu testende Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-588">The path to test.</span></span></param>
        <summary><span data-ttu-id="8f3af-589">Gibt einen Wert zurück, der angibt, ob die angegebene Zeichenspanne zur Darstellung eines Dateipfads einen Stamm enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-589">Returns a value that indicates whether the specified character span that represents a file path contains a root.</span></span></summary>
        <returns><span data-ttu-id="8f3af-590"><see langword="true" />, wenn <paramref name="path" /> einen Stamm enthält, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-590"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-591">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-591">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-592">Der zu testende Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-592">The path to test.</span></span></param>
        <summary><span data-ttu-id="8f3af-593">Gibt einen Wert zurück, der angibt, ob die angegebene Pfadzeichenfolge einen Stamm enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-593">Returns a value indicating whether the specified path string contains a root.</span></span></summary>
        <returns><span data-ttu-id="8f3af-594"><see langword="true" />, wenn <paramref name="path" /> einen Stamm enthält, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-594"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f3af-595">Die <xref:System.IO.Path.IsPathRooted%2A>-Methode gibt `true` zurück, wenn das erste Zeichen ein Verzeichnis Trennzeichen wie z. b. "\\" ist, oder wenn der Pfad mit einem Laufwerk Buchstaben und einem Doppelpunkt (":)") beginnt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-595">The <xref:System.IO.Path.IsPathRooted%2A> method returns `true` if the first character is a directory separator character such as "\\", or if the path starts with a drive letter and colon (:).</span></span> <span data-ttu-id="8f3af-596">Er gibt z. b. `true` für `path` Zeichenfolgen zurück, z. b. "\\\meinredir\\\meineDatei.txt", "C:\\\meinredir" oder "c:MyDir".</span><span class="sxs-lookup"><span data-stu-id="8f3af-596">For example, it returns `true` for `path` strings such as "\\\MyDir\\\MyFile.txt", "C:\\\MyDir", or "C:MyDir".</span></span> <span data-ttu-id="8f3af-597">Sie gibt `false` für `path` Zeichenfolgen zurück, z. b. "MyDir".</span><span class="sxs-lookup"><span data-stu-id="8f3af-597">It returns `false` for `path` strings such as "MyDir".</span></span>  
  
 <span data-ttu-id="8f3af-598">Diese Methode überprüft nicht, ob der Pfad oder Dateiname vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-598">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="8f3af-599">Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-599">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  

## Examples  
 <span data-ttu-id="8f3af-600">Im folgenden Beispiel wird veranschaulicht, wie die `IsPathRooted`-Methode zum Testen von drei Zeichen folgen verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="8f3af-600">The following example demonstrates how the `IsPathRooted` method can be used to test three strings.</span></span>  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f3af-601"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-601"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-602">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-602">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8f3af-603">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="8f3af-603">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8f3af-604">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="8f3af-604">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8f3af-605">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="8f3af-605">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Join : string[] -&gt; string" Usage="System.IO.Path.Join paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths"><span data-ttu-id="8f3af-606">Ein Array von Pfaden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-606">An array of paths.</span></span></param>
        <summary><span data-ttu-id="8f3af-607">Verkettet ein Array von Pfaden zu einem einzelnen Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-607">Concatenates an array of paths into a single path.</span></span></summary>
        <returns><span data-ttu-id="8f3af-608">Der verkettete Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-608">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8f3af-609">Diese Methode verkettet einfach alle Zeichen folgen in `paths` und fügt ein Verzeichnis Trennzeichen zwischen allen Pfad Komponenten hinzu, wenn noch keines vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-609">This method simply concatenates all the strings in `paths` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="8f3af-610">Wenn die <xref:System.String.Length> eines der Pfade in `paths` 0 (null) ist, verkettet die Methode die restlichen Argumente.</span><span class="sxs-lookup"><span data-stu-id="8f3af-610">If the <xref:System.String.Length> of any of the paths in `paths` is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="8f3af-611">Wenn die resultierende verketteten Zeichen folgen Länge 0 (null) ist, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-611">If the resulting concatenated string's length is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="8f3af-612">Wenn einer der Pfade in `paths`, mit Ausnahme des letzten, mit einem Pfad Trennzeichen endet, das für die Zielplattform nicht geeignet ist, behält die `Join` Methode das ursprüngliche Pfad Trennzeichen bei und fügt die unterstützte Methode an.</span><span class="sxs-lookup"><span data-stu-id="8f3af-612">If any of the paths in `paths`, except for the last one, ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="8f3af-613">Dieses Problem tritt in hart codierten Pfaden auf, die den umgekehrten Schrägstrich ("\"") von Windows verwenden, der nicht als Pfad Trennzeichen auf UNIX-basierten Systemen erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-613">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="8f3af-614">Um dieses Problem zu umgehen, können Sie folgende Aktionen ausführen:</span><span class="sxs-lookup"><span data-stu-id="8f3af-614">To work around this issue, you can:</span></span>

- <span data-ttu-id="8f3af-615">Rufen Sie den Wert der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft ab, anstatt ein Verzeichnis Trennzeichen hart zu codieren.</span><span class="sxs-lookup"><span data-stu-id="8f3af-615">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="8f3af-616">Verwenden Sie einen Schrägstrich ("/") als Trennzeichen für das Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="8f3af-616">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="8f3af-617">Dieses Zeichen wird von der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf UNIX-basierten Systemen und von der <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf Windows-Systemen zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-617">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="8f3af-618">Anders als bei der <xref:System.IO.Path.Combine%2A>-Methode versucht die <xref:System.IO.Path.Join%2A>-Methode nicht, den zurückgegebenen Pfad zu verankern.</span><span class="sxs-lookup"><span data-stu-id="8f3af-618">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="8f3af-619">(Das heißt, wenn einer der Pfade in `paths`, mit Ausnahme des letzten, ein absoluter Pfad ist, werden die vorherigen Pfade von der `Join`-Methode nicht verworfen, wenn die <xref:System.IO.Path.Combine%2A>-Methode dies tut.</span><span class="sxs-lookup"><span data-stu-id="8f3af-619">(That is, if any of the paths in `paths`, except for the last one, is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="8f3af-620">Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Join`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="8f3af-620">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8f3af-621">Wenn `Path.Join("c:\\", "temp", "*.txt")` beispielsweise beim Erstellen einer Datei ungültig sein kann, ist Sie als Such Zeichenfolge gültig.</span><span class="sxs-lookup"><span data-stu-id="8f3af-621">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="8f3af-622">Diese Methode wird von der `Join`-Methode daher erfolgreich interpretiert.</span><span class="sxs-lookup"><span data-stu-id="8f3af-622">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8f3af-623">Eine Zeichenspanne, die den ersten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-623">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="8f3af-624">Eine Zeichenspanne, die den zweiten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-624">A character span that contains the second path to join.</span></span></param>
        <summary><span data-ttu-id="8f3af-625">Verkettet zwei Pfadkomponenten zu einem einzigen Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-625">Concatenates two path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="8f3af-626">Die kombinierten Pfade.</span><span class="sxs-lookup"><span data-stu-id="8f3af-626">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="8f3af-627">Mit dieser Methode werden einfach `path` und `path2` verkettet, und es wird ein Verzeichnis Trennzeichen zwischen den beiden Pfad Komponenten hinzugefügt, wenn am Ende der `path1` oder am Anfang `path2`nicht bereits vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-627">This method simply concatenates `path` and `path2` and adds a directory separator character between the two path components if one is not already present at the end of `path1` or the beginning of `path2`.</span></span> <span data-ttu-id="8f3af-628">Wenn die <xref:System.ReadOnlySpan%601.Length> von `path1` oder `path2` NULL ist, gibt die Methode den anderen Pfad zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-628">If the <xref:System.ReadOnlySpan%601.Length> of either `path1` or `path2` is zero, the method returns the other path.</span></span> <span data-ttu-id="8f3af-629">Wenn die <xref:System.ReadOnlySpan%601.Length> von `path1` und `path2` NULL ist, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-629">If the <xref:System.ReadOnlySpan%601.Length> of both `path1` and `path2` is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> 

<span data-ttu-id="8f3af-630">Wenn `path1` in einem Pfad Trennzeichen endet, das für die Zielplattform nicht geeignet ist, behält die `Join` Methode das ursprüngliche Pfad Trennzeichen bei und fügt das unterstützte ein.</span><span class="sxs-lookup"><span data-stu-id="8f3af-630">If `path1` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="8f3af-631">Dieses Problem tritt in hart codierten Pfaden auf, die den umgekehrten Schrägstrich ("\"") von Windows verwenden, der nicht als Pfad Trennzeichen auf UNIX-basierten Systemen erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-631">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="8f3af-632">Um dieses Problem zu umgehen, können Sie folgende Aktionen ausführen:</span><span class="sxs-lookup"><span data-stu-id="8f3af-632">To work around this issue, you can:</span></span>

- <span data-ttu-id="8f3af-633">Rufen Sie den Wert der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft ab, anstatt ein Verzeichnis Trennzeichen hart zu codieren.</span><span class="sxs-lookup"><span data-stu-id="8f3af-633">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="8f3af-634">Verwenden Sie einen Schrägstrich ("/") als Trennzeichen für das Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="8f3af-634">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="8f3af-635">Dieses Zeichen wird von der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf UNIX-basierten Systemen und von der <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf Windows-Systemen zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-635">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span> 

<span data-ttu-id="8f3af-636">Anders als bei der <xref:System.IO.Path.Combine%2A>-Methode versucht die <xref:System.IO.Path.Join%2A>-Methode nicht, den zurückgegebenen Pfad zu verankern.</span><span class="sxs-lookup"><span data-stu-id="8f3af-636">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="8f3af-637">(Das heißt, wenn `path2` ein absoluter Pfad ist, wird die `Join`-Methode nicht `path1` verworfen und `path2` zurückgegeben, wie die <xref:System.IO.Path.Combine%2A>-Methode dies tut.) Das folgende Beispiel veranschaulicht den Unterschied in den Pfaden, die von den beiden Methoden zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-637">(That is, if `path2` is an absolute path, the `Join` method does not discard `path1` and return `path2` as the <xref:System.IO.Path.Combine%2A> method does.) The following example illustrates the difference in the paths returned by the two methods.</span></span> <span data-ttu-id="8f3af-638">Wenn die Quelle von `path2` Benutzereingaben ist, ermöglicht die <xref:System.IO.Path.Combine%2A>-Methode einem Benutzer den Zugriff auf eine Dateisystem Ressource (z. *b. C:/users/user1/Documents/Financial/* im Fall des Beispiels), auf die die Anwendung nicht zugreifen konnte.</span><span class="sxs-lookup"><span data-stu-id="8f3af-638">If the source of `path2` is user input, the <xref:System.IO.Path.Combine%2A> method makes it possible for a user to access a file system resource (such as *C:/Users/User1/Documents/Financial/* in the case of the example) that the application did not intend to make accessible.</span></span>  

<span data-ttu-id="8f3af-639">Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Join`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="8f3af-639">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8f3af-640">Wenn `Path.Join("c:\\", "*.txt")` beispielsweise beim Erstellen einer Datei ungültig sein kann, ist Sie als Such Zeichenfolge gültig.</span><span class="sxs-lookup"><span data-stu-id="8f3af-640">For example, while `Path.Join("c:\\", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="8f3af-641">Diese Methode wird von der `Join`-Methode daher erfolgreich interpretiert.</span><span class="sxs-lookup"><span data-stu-id="8f3af-641">The `Join` method therefore successfully interprets it.</span></span> 

## <a name="example"></a><span data-ttu-id="8f3af-642">Beispiel</span><span class="sxs-lookup"><span data-stu-id="8f3af-642">Example</span></span>

<span data-ttu-id="8f3af-643">Das folgende Beispiel veranschaulicht den Unterschied in den Pfaden, die von den Methoden <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> und <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-643">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="8f3af-644">Wenn die erste Zeichenfolge ein voll qualifizierter Pfad ist, der ein Laufwerk und ein Stammverzeichnis enthält und der zweite ein relativer Pfad vom ersten Pfad ist, führen die beiden Methoden zu identischen Ergebnissen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-644">When the first string is an fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="8f3af-645">In den zweiten und dritten Aufrufen der `ShowPathInformation`-Methode weichen die von den beiden Methoden zurückgegebenen Zeichen folgen ab.</span><span class="sxs-lookup"><span data-stu-id="8f3af-645">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="8f3af-646">Beim zweiten Methoden aufrufist das erste Zeichen folgen Argument ein Laufwerk, während das zweite ein Stammverzeichnis ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-646">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="8f3af-647">Die `Join`-Methode verkettet die beiden Zeichen folgen und bewahrt doppelte Pfad Trennzeichen auf.</span><span class="sxs-lookup"><span data-stu-id="8f3af-647">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="8f3af-648">Mit der `Combine`-Methode wird das Laufwerk abgebrochen, und es wird ein Stammverzeichnis auf dem aktuellen Laufwerk zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-648">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="8f3af-649">Wenn das aktuelle Laufwerk der Anwendung C:\ ist und die Zeichenfolge wird für den Zugriff auf eine Datei oder auf Dateien im Verzeichnis verwendet. der Zugriff auf C: anstelle von d:.</span><span class="sxs-lookup"><span data-stu-id="8f3af-649">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="8f3af-650">Da beide Argumente im dritten `ShowPathInformation`-aufrufsstamm sind, fügt die `Join`-Methode Sie einfach an, um einen unsinnigen Dateipfad zu erstellen, während die `Combine`-Methode die erste Zeichenfolge verwirft und die zweite zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-650">Finally, because both arguments in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends them to create a nonsensical file path, while the `Combine` method discards the first string and returns the second.</span></span> <span data-ttu-id="8f3af-651">Wenn diese Zeichenfolge für den Dateizugriff verwendet wird, kann die Anwendung unbeabsichtigten Zugriff auf sensible Dateien erhalten.</span><span class="sxs-lookup"><span data-stu-id="8f3af-651">Using this string for file access could give the application unintended access to sensitive files.</span></span>  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-vb[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-652">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-652">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8f3af-653">Der erste Pfad für die Verknüpfung.</span><span class="sxs-lookup"><span data-stu-id="8f3af-653">The first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="8f3af-654">Der zweite Pfad für die Verknüpfung.</span><span class="sxs-lookup"><span data-stu-id="8f3af-654">The second path to join.</span></span></param>
        <summary><span data-ttu-id="8f3af-655">Verkettet zwei Pfade zu einem einzelnen Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-655">Concatenates two paths into a single path.</span></span></summary>
        <returns><span data-ttu-id="8f3af-656">Der verkettete Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-656">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8f3af-657">Mit dieser Methode werden einfach `path` und `path2` verkettet und ein Verzeichnis Trennzeichen zwischen den Pfad Komponenten hinzugefügt, sofern nicht bereits vorhanden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-657">This method simply concatenates `path` and `path2` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="8f3af-658">Wenn die Länge von `path1` oder `path2` 0 (null) ist, verkettet die Methode das verbleibende Argument.</span><span class="sxs-lookup"><span data-stu-id="8f3af-658">If the length of either `path1` or `path2` is zero, the method concatenates the remaining argument.</span></span> <span data-ttu-id="8f3af-659">Wenn die Länge der resultierenden verketteten Zeichenfolge 0 (null) ist, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-659">If the length of the resulting concatenated string is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="8f3af-660">Wenn `path1` in einem Pfad Trennzeichen endet, das für die Zielplattform nicht geeignet ist, behält die `Join` Methode das ursprüngliche Pfad Trennzeichen bei und fügt das unterstützte ein.</span><span class="sxs-lookup"><span data-stu-id="8f3af-660">If `path1` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="8f3af-661">Dieses Problem tritt in hart codierten Pfaden auf, die den umgekehrten Schrägstrich ("\"") von Windows verwenden, der nicht als Pfad Trennzeichen auf UNIX-basierten Systemen erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-661">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="8f3af-662">Um dieses Problem zu umgehen, können Sie folgende Aktionen ausführen:</span><span class="sxs-lookup"><span data-stu-id="8f3af-662">To work around this issue, you can:</span></span>

- <span data-ttu-id="8f3af-663">Rufen Sie den Wert der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft ab, anstatt ein Verzeichnis Trennzeichen hart zu codieren.</span><span class="sxs-lookup"><span data-stu-id="8f3af-663">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="8f3af-664">Verwenden Sie einen Schrägstrich ("/") als Trennzeichen für das Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="8f3af-664">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="8f3af-665">Dieses Zeichen wird von der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf UNIX-basierten Systemen und von der <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf Windows-Systemen zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-665">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="8f3af-666">Anders als bei der <xref:System.IO.Path.Combine%2A>-Methode versucht die <xref:System.IO.Path.Join%2A>-Methode nicht, den zurückgegebenen Pfad zu verankern.</span><span class="sxs-lookup"><span data-stu-id="8f3af-666">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="8f3af-667">(Das heißt, wenn `path2` ein absoluter Pfad ist, werden die vorherigen Pfade von der `Join`-Methode nicht verworfen, wenn die <xref:System.IO.Path.Combine%2A>-Methode dies tut.</span><span class="sxs-lookup"><span data-stu-id="8f3af-667">(That is, if `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="8f3af-668">Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Join`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="8f3af-668">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8f3af-669">Wenn `Path.Join("c:\\", "temp", "*.txt")` beispielsweise beim Erstellen einer Datei ungültig sein kann, ist Sie als Such Zeichenfolge gültig.</span><span class="sxs-lookup"><span data-stu-id="8f3af-669">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="8f3af-670">Diese Methode wird von der `Join`-Methode daher erfolgreich interpretiert.</span><span class="sxs-lookup"><span data-stu-id="8f3af-670">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8f3af-671">Eine Zeichenspanne, die den ersten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-671">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="8f3af-672">Eine Zeichenspanne, die den zweiten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-672">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="8f3af-673">Eine Zeichenspanne, die den dritten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-673">A character span that contains the third path to join.</span></span></param>
        <summary><span data-ttu-id="8f3af-674">Verkettet drei Pfadkomponenten zu einem einzigen Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-674">Concatenates three path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="8f3af-675">Der verkettete Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-675">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="8f3af-676">Mit dieser Methode werden einfach `path`, `path2`und `path3` verkettet, und es wird ein Verzeichnis Trennzeichen zwischen den Pfad Komponenten hinzugefügt, wenn noch keines vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-676">This method simply concatenates `path`, `path2`, and `path3` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="8f3af-677">Wenn die <xref:System.ReadOnlySpan%601.Length> eines `path1`-, `path2`-oder `path3`-Arguments 0 (null) ist, verkettet die Methode die restlichen Argumente.</span><span class="sxs-lookup"><span data-stu-id="8f3af-677">If the <xref:System.ReadOnlySpan%601.Length> of any of `path1`, `path2`, or `path3` arguments is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="8f3af-678">Wenn die <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> aller Komponenten 0 (null) ist, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-678">If the <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> of all components is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="8f3af-679">Wenn `path1` oder `path2` in einem Pfad Trennzeichen endet, das für die Zielplattform nicht geeignet ist, behält die `Join` Methode das ursprüngliche Pfad Trennzeichen bei und fügt das unterstützte ein.</span><span class="sxs-lookup"><span data-stu-id="8f3af-679">If `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="8f3af-680">Dieses Problem tritt in hart codierten Pfaden auf, die den umgekehrten Schrägstrich ("\"") von Windows verwenden, der nicht als Pfad Trennzeichen auf UNIX-basierten Systemen erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-680">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="8f3af-681">Um dieses Problem zu umgehen, können Sie folgende Aktionen ausführen:</span><span class="sxs-lookup"><span data-stu-id="8f3af-681">To work around this issue, you can:</span></span>

- <span data-ttu-id="8f3af-682">Rufen Sie den Wert der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft ab, anstatt ein Verzeichnis Trennzeichen hart zu codieren.</span><span class="sxs-lookup"><span data-stu-id="8f3af-682">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="8f3af-683">Verwenden Sie einen Schrägstrich ("/") als Trennzeichen für das Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="8f3af-683">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="8f3af-684">Dieses Zeichen wird von der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf UNIX-basierten Systemen und von der <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf Windows-Systemen zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-684">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="8f3af-685">Anders als bei der <xref:System.IO.Path.Combine%2A>-Methode versucht die <xref:System.IO.Path.Join%2A>-Methode nicht, den zurückgegebenen Pfad zu verankern.</span><span class="sxs-lookup"><span data-stu-id="8f3af-685">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="8f3af-686">(Das heißt, wenn `path2` oder `path2` ein absoluter Pfad ist, werden die vorherigen Pfade von der `Join`-Methode nicht verworfen, wenn die <xref:System.IO.Path.Combine%2A>-Methode dies tut.</span><span class="sxs-lookup"><span data-stu-id="8f3af-686">(That is, if `path2` or `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>
  
<span data-ttu-id="8f3af-687">Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Join`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="8f3af-687">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8f3af-688">Wenn `Path.Join("c:\\", "temp", "*.txt")` beispielsweise beim Erstellen einer Datei ungültig sein kann, ist Sie als Such Zeichenfolge gültig.</span><span class="sxs-lookup"><span data-stu-id="8f3af-688">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="8f3af-689">Diese Methode wird von der `Join`-Methode daher erfolgreich interpretiert.</span><span class="sxs-lookup"><span data-stu-id="8f3af-689">The `Join` method therefore successfully interprets it.</span></span>

## <a name="example"></a><span data-ttu-id="8f3af-690">Beispiel</span><span class="sxs-lookup"><span data-stu-id="8f3af-690">Example</span></span>

<span data-ttu-id="8f3af-691">Das folgende Beispiel veranschaulicht den Unterschied in den Pfaden, die von den Methoden <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> und <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-691">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="8f3af-692">Wenn die erste Zeichenfolge ein voll qualifizierter Pfad ist, der ein Laufwerk und ein Stammverzeichnis enthält und der zweite ein relativer Pfad vom ersten Pfad ist, führen die beiden Methoden zu identischen Ergebnissen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-692">When the first string is a fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="8f3af-693">In den zweiten und dritten Aufrufen der `ShowPathInformation`-Methode weichen die von den beiden Methoden zurückgegebenen Zeichen folgen ab.</span><span class="sxs-lookup"><span data-stu-id="8f3af-693">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="8f3af-694">Beim zweiten Methoden aufrufist das erste Zeichen folgen Argument ein Laufwerk, während das zweite ein Stammverzeichnis ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-694">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="8f3af-695">Die `Join`-Methode verkettet die beiden Zeichen folgen und bewahrt doppelte Pfad Trennzeichen auf.</span><span class="sxs-lookup"><span data-stu-id="8f3af-695">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="8f3af-696">Durch einen aufzurufenden <xref:System.IO.Path.GetFullPath%2A>-Methode wird die Duplizierung vermieden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-696">A call to the <xref:System.IO.Path.GetFullPath%2A> method would eliminate the duplication.</span></span> <span data-ttu-id="8f3af-697">Mit der `Combine`-Methode wird das Laufwerk abgebrochen, und es wird ein Stammverzeichnis auf dem aktuellen Laufwerk zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-697">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="8f3af-698">Wenn das aktuelle Laufwerk der Anwendung C:\ ist und die Zeichenfolge wird für den Zugriff auf eine Datei oder auf Dateien im Verzeichnis verwendet. der Zugriff auf C: anstelle von d:.</span><span class="sxs-lookup"><span data-stu-id="8f3af-698">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="8f3af-699">Da schließlich das letzte Argument im dritten `ShowPathInformation` Stamm ist, fügt die `Join`-Methode Sie einfach an die ersten beiden Argumente an, um einen unsinnigen Dateipfad zu erstellen, während die `Combine`-Methode die ersten beiden Zeichen folgen verwirft und die dritte zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-699">Finally, because the final argument in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends it to the first two arguments to create a nonsensical file path, while the `Combine` method discards the first two strings and returns the third.</span></span> <span data-ttu-id="8f3af-700">Wenn diese Zeichenfolge für den Dateizugriff verwendet wird, kann die Anwendung unbeabsichtigten Zugriff auf sensible Dateien erhalten.</span><span class="sxs-lookup"><span data-stu-id="8f3af-700">Using this string for file access could give the application unintended access to sensitive files.</span></span>

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)]
[!code-vb[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)]

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-701">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-701">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8f3af-702">Der erste Pfad für die Verknüpfung.</span><span class="sxs-lookup"><span data-stu-id="8f3af-702">The first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="8f3af-703">Der zweite Pfad für die Verknüpfung.</span><span class="sxs-lookup"><span data-stu-id="8f3af-703">The second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="8f3af-704">Der dritte Pfad für die Verknüpfung.</span><span class="sxs-lookup"><span data-stu-id="8f3af-704">The third path to join.</span></span></param>
        <summary><span data-ttu-id="8f3af-705">Verkettet drei Pfade zu einem einzelnen Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-705">Concatenates three paths into a single path.</span></span></summary>
        <returns><span data-ttu-id="8f3af-706">Der verkettete Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-706">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8f3af-707">Mit dieser Methode werden einfach `path`, `path2`und `path3` verkettet, und es wird ein Verzeichnis Trennzeichen zwischen den Pfad Komponenten hinzugefügt, wenn noch keines vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="8f3af-707">This method simply concatenates `path`, `path2`, and `path3` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="8f3af-708">Wenn die Länge eines `path1`, `path2` oder `path3` Arguments 0 (null) ist, verkettet die Methode die restlichen Argumente.</span><span class="sxs-lookup"><span data-stu-id="8f3af-708">If the length of any of `path1`, `path2` or `path3` argument is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="8f3af-709">Wenn die Länge der resultierenden verketteten Zeichenfolge 0 (null) ist, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-709">If the length of the resulting concatenated string is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="8f3af-710">Wenn `path1` oder `path2` in einem Pfad Trennzeichen endet, das für die Zielplattform nicht geeignet ist, behält die `Join` Methode das ursprüngliche Pfad Trennzeichen bei und fügt das unterstützte ein.</span><span class="sxs-lookup"><span data-stu-id="8f3af-710">If `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="8f3af-711">Dieses Problem tritt in hart codierten Pfaden auf, die den umgekehrten Schrägstrich ("\"") von Windows verwenden, der nicht als Pfad Trennzeichen auf UNIX-basierten Systemen erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-711">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="8f3af-712">Um dieses Problem zu umgehen, können Sie folgende Aktionen ausführen:</span><span class="sxs-lookup"><span data-stu-id="8f3af-712">To work around this issue, you can:</span></span>

- <span data-ttu-id="8f3af-713">Rufen Sie den Wert der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft ab, anstatt ein Verzeichnis Trennzeichen hart zu codieren.</span><span class="sxs-lookup"><span data-stu-id="8f3af-713">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="8f3af-714">Verwenden Sie einen Schrägstrich ("/") als Trennzeichen für das Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="8f3af-714">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="8f3af-715">Dieses Zeichen wird von der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf UNIX-basierten Systemen und von der <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf Windows-Systemen zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-715">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="8f3af-716">Anders als bei der <xref:System.IO.Path.Combine%2A>-Methode versucht die <xref:System.IO.Path.Join%2A>-Methode nicht, den zurückgegebenen Pfad zu verankern.</span><span class="sxs-lookup"><span data-stu-id="8f3af-716">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="8f3af-717">(Das heißt, wenn `path2` oder `path2` ein absoluter Pfad ist, werden die vorherigen Pfade von der `Join`-Methode nicht verworfen, wenn die <xref:System.IO.Path.Combine%2A>-Methode dies tut.</span><span class="sxs-lookup"><span data-stu-id="8f3af-717">(That is, if `path2` or `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="8f3af-718">Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Join`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="8f3af-718">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8f3af-719">Wenn `Path.Join("c:\\", "temp", "*.txt")` beispielsweise beim Erstellen einer Datei ungültig sein kann, ist Sie als Such Zeichenfolge gültig.</span><span class="sxs-lookup"><span data-stu-id="8f3af-719">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="8f3af-720">Diese Methode wird von der `Join`-Methode daher erfolgreich interpretiert.</span><span class="sxs-lookup"><span data-stu-id="8f3af-720">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.ReadOnlySpan`1&lt;char&gt; path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), path4 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="path4" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8f3af-721">Eine Zeichenspanne, die den ersten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-721">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="8f3af-722">Eine Zeichenspanne, die den zweiten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-722">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="8f3af-723">Eine Zeichenspanne, die den dritten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-723">A character span that contains the third path to join.</span></span></param>
        <param name="path4"><span data-ttu-id="8f3af-724">Eine Zeichenspanne, die den vierten zu verknüpfenden Pfad enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-724">A character span that contains the fourth path to join.</span></span></param>
        <summary><span data-ttu-id="8f3af-725">Verkettet vier Pfadkomponenten zu einem einzelnen Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-725">Concatenates four path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="8f3af-726">Der verkettete Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-726">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8f3af-727">Mit dieser Methode werden einfach `path`, `path2``path3` und `path4` verkettet, und es wird ein Verzeichnis Trennzeichen zwischen den Pfad Komponenten hinzugefügt, sofern nicht bereits vorhanden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-727">This method simply concatenates `path`, `path2`, `path3` and `path4` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="8f3af-728">Wenn die <xref:System.ReadOnlySpan%601.Length> eines `path1`, `path2`, `path3` oder `path4` Arguments 0 (null) ist, verkettet die Methode die restlichen Argumente.</span><span class="sxs-lookup"><span data-stu-id="8f3af-728">If the <xref:System.ReadOnlySpan%601.Length> of any of `path1`, `path2`, `path3` or `path4` argument is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="8f3af-729">Wenn die <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> aller Komponenten 0 (null) ist, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-729">If the <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> of all components is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="8f3af-730">Wenn `path1` oder `path2` oder `path3` in einem Pfad Trennzeichen endet, das für die Zielplattform nicht geeignet ist, behält die `Join` Methode das ursprüngliche Pfad Trennzeichen bei und fügt die unterstützte Methode an.</span><span class="sxs-lookup"><span data-stu-id="8f3af-730">If `path1` or `path2` or `path3` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="8f3af-731">Dieses Problem tritt in hart codierten Pfaden auf, die den umgekehrten Schrägstrich ("\"") von Windows verwenden, der nicht als Pfad Trennzeichen auf UNIX-basierten Systemen erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-731">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="8f3af-732">Um dieses Problem zu umgehen, können Sie folgende Aktionen ausführen:</span><span class="sxs-lookup"><span data-stu-id="8f3af-732">To work around this issue, you can:</span></span>

- <span data-ttu-id="8f3af-733">Rufen Sie den Wert der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft ab, anstatt ein Verzeichnis Trennzeichen hart zu codieren.</span><span class="sxs-lookup"><span data-stu-id="8f3af-733">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="8f3af-734">Verwenden Sie einen Schrägstrich ("/") als Trennzeichen für das Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="8f3af-734">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="8f3af-735">Dieses Zeichen wird von der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf UNIX-basierten Systemen und von der <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf Windows-Systemen zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-735">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="8f3af-736">Anders als bei der <xref:System.IO.Path.Combine%2A>-Methode versucht die <xref:System.IO.Path.Join%2A>-Methode nicht, den zurückgegebenen Pfad zu verankern.</span><span class="sxs-lookup"><span data-stu-id="8f3af-736">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="8f3af-737">(Das heißt, wenn `path2` oder `path2` oder `path3` ein absoluter Pfad ist, werden die vorherigen Pfade von der `Join`-Methode nicht verworfen, wenn die <xref:System.IO.Path.Combine%2A>-Methode dies tut.</span><span class="sxs-lookup"><span data-stu-id="8f3af-737">(That is, if `path2` or `path2` or `path3` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="8f3af-738">Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Join`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="8f3af-738">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8f3af-739">Wenn `Path.Join("c:\\", "temp", "*.txt")` beispielsweise beim Erstellen einer Datei ungültig sein kann, ist Sie als Such Zeichenfolge gültig.</span><span class="sxs-lookup"><span data-stu-id="8f3af-739">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="8f3af-740">Diese Methode wird von der `Join`-Methode daher erfolgreich interpretiert.</span><span class="sxs-lookup"><span data-stu-id="8f3af-740">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8f3af-741">Der erste Pfad für die Verknüpfung.</span><span class="sxs-lookup"><span data-stu-id="8f3af-741">The first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="8f3af-742">Der zweite Pfad für die Verknüpfung.</span><span class="sxs-lookup"><span data-stu-id="8f3af-742">The second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="8f3af-743">Der dritte Pfad für die Verknüpfung.</span><span class="sxs-lookup"><span data-stu-id="8f3af-743">The third path to join.</span></span></param>
        <param name="path4"><span data-ttu-id="8f3af-744">Der vierte Pfad für die Verknüpfung.</span><span class="sxs-lookup"><span data-stu-id="8f3af-744">The fourth path to join.</span></span></param>
        <summary><span data-ttu-id="8f3af-745">Verkettet vier Pfade zu einem einzelnen Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-745">Concatenates four paths into a single path.</span></span></summary>
        <returns><span data-ttu-id="8f3af-746">Der verkettete Pfad.</span><span class="sxs-lookup"><span data-stu-id="8f3af-746">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8f3af-747">Mit dieser Methode werden einfach `path`, `path2``path3` und `path4` verkettet, und es wird ein Verzeichnis Trennzeichen zwischen den Pfad Komponenten hinzugefügt, sofern nicht bereits vorhanden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-747">This method simply concatenates `path`, `path2`, `path3` and `path4` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="8f3af-748">Wenn die Länge eines `path1`-, `path2`-, `path3`-oder `path4`-Arguments 0 (null) ist, verkettet die Methode die restlichen Argumente.</span><span class="sxs-lookup"><span data-stu-id="8f3af-748">If the length of any of `path1`, `path2`, `path3` or `path4` argument is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="8f3af-749">Wenn die Länge der resultierenden verketteten Zeichenfolge 0 (null) ist, gibt die Methode <xref:System.String.Empty?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="8f3af-749">If the length of the resulting concatenated string is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="8f3af-750">Wenn `path1` oder `path2` oder `path3` in einem Pfad Trennzeichen endet, das für die Zielplattform nicht geeignet ist, behält die `Join` Methode das ursprüngliche Pfad Trennzeichen bei und fügt die unterstützte Methode an.</span><span class="sxs-lookup"><span data-stu-id="8f3af-750">If `path1` or `path2` or `path3` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="8f3af-751">Dieses Problem tritt in hart codierten Pfaden auf, die den umgekehrten Schrägstrich ("\"") von Windows verwenden, der nicht als Pfad Trennzeichen auf UNIX-basierten Systemen erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-751">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="8f3af-752">Um dieses Problem zu umgehen, können Sie folgende Aktionen ausführen:</span><span class="sxs-lookup"><span data-stu-id="8f3af-752">To work around this issue, you can:</span></span>

- <span data-ttu-id="8f3af-753">Rufen Sie den Wert der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft ab, anstatt ein Verzeichnis Trennzeichen hart zu codieren.</span><span class="sxs-lookup"><span data-stu-id="8f3af-753">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="8f3af-754">Verwenden Sie einen Schrägstrich ("/") als Trennzeichen für das Verzeichnis.</span><span class="sxs-lookup"><span data-stu-id="8f3af-754">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="8f3af-755">Dieses Zeichen wird von der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf UNIX-basierten Systemen und von der <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType>-Eigenschaft auf Windows-Systemen zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="8f3af-755">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="8f3af-756">Anders als bei der <xref:System.IO.Path.Combine%2A>-Methode versucht die <xref:System.IO.Path.Join%2A>-Methode nicht, den zurückgegebenen Pfad zu verankern.</span><span class="sxs-lookup"><span data-stu-id="8f3af-756">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="8f3af-757">(Das heißt, wenn `path2` oder `path2` oder `path3` ein absoluter Pfad ist, werden die vorherigen Pfade von der `Join`-Methode nicht verworfen, wenn die <xref:System.IO.Path.Combine%2A>-Methode dies tut.</span><span class="sxs-lookup"><span data-stu-id="8f3af-757">(That is, if `path2` or `path2` or `path3` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="8f3af-758">Nicht alle ungültigen Zeichen für Verzeichnis-und Dateinamen werden durch die `Join`-Methode als unzulässig interpretiert, da Sie diese Zeichen für Such Platzhalter Zeichen verwenden können.</span><span class="sxs-lookup"><span data-stu-id="8f3af-758">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="8f3af-759">Wenn `Path.Join("c:\\", "temp", "*.txt")` beispielsweise beim Erstellen einer Datei ungültig sein kann, ist Sie als Such Zeichenfolge gültig.</span><span class="sxs-lookup"><span data-stu-id="8f3af-759">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="8f3af-760">Diese Methode wird von der `Join`-Methode daher erfolgreich interpretiert.</span><span class="sxs-lookup"><span data-stu-id="8f3af-760">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f3af-761">Ein plattformspezifisches Trennzeichen, das zur Trennung von Pfadzeichenfolgen in Umgebungsvariablen verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="8f3af-761">A platform-specific separator character used to separate path strings in environment variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f3af-762">Auf Windows-basierten Desktop Plattformen ist der Wert dieses Felds das Semikolon (;) Standardmäßig können Sie sich jedoch auf anderen Plattformen unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-762">On Windows-based desktop platforms, the value of this field is the semicolon (;) by default, but might vary on other platforms.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f3af-763">Im folgenden Beispiel wird die Verwendung des Felds `PathSeparator` veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-763">The following example demonstrates the use of the `PathSeparator` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8f3af-764">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="8f3af-764">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8f3af-765">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="8f3af-765">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8f3af-766">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="8f3af-766">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEndingDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-767">Der Pfad, der zugeschnitten werden soll.</span><span class="sxs-lookup"><span data-stu-id="8f3af-767">The path to trim.</span></span></param>
        <summary><span data-ttu-id="8f3af-768">Schneidet ein nachstehendes Verzeichnistrennzeichen nach dem Stamm des angegebenen Pfads ab.</span><span class="sxs-lookup"><span data-stu-id="8f3af-768">Trims one trailing directory separator beyond the root of the specified path.</span></span></summary>
        <returns><span data-ttu-id="8f3af-769"><paramref name="path" /> ohne nachstehende Verzeichnistrennzeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-769">The <paramref name="path" /> without any trailing directory separators.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static string TrimEndingDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string TrimEndingDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ TrimEndingDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : string -&gt; string" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f3af-770">Der Pfad, der zugeschnitten werden soll.</span><span class="sxs-lookup"><span data-stu-id="8f3af-770">The path to trim.</span></span></param>
        <summary><span data-ttu-id="8f3af-771">Schneidet ein nachstehendes Verzeichnistrennzeichen nach dem Stamm des angegebenen Pfads ab.</span><span class="sxs-lookup"><span data-stu-id="8f3af-771">Trims one trailing directory separator beyond the root of the specified path.</span></span></summary>
        <returns><span data-ttu-id="8f3af-772"><paramref name="path" /> ohne nachstehende Verzeichnistrennzeichen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-772">The <paramref name="path" /> without any trailing directory separators.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary><span data-ttu-id="8f3af-773">Versucht, einzelne Pfadkomponenten zu einer vorbelegten Zeichenspanne zu verketten, und gibt einen Wert zurück, der den Erfolg des Vorgangs angibt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-773">Attempts to concatenate individual path components to a preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="8f3af-774">Die Ziel zeichenspanne muss groß genug sein, um den verketteten Pfad zu speichern.</span><span class="sxs-lookup"><span data-stu-id="8f3af-774">The destination character span must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="8f3af-775">Anschließend können Sie den verketteten Pfad abrufen, indem Sie die <xref:System.Span%601.Slice%2A?displayProperty=nameWithType>-Methode aufrufen, wie im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-775">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the following example illustrates.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * int -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8f3af-776">Eine Zeichenspanne, die den ersten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-776">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="8f3af-777">Eine Zeichenspanne, die den zweiten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-777">A character span that contains the second path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="8f3af-778">Eine Zeichenspanne, die den verketteten Pfad enthalten soll.</span><span class="sxs-lookup"><span data-stu-id="8f3af-778">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="8f3af-779">Ein Wert bei Rückgabe der Methode, der die Anzahl der Zeichen angibt, die in <paramref name="destination" /> geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-779">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="8f3af-780">Versucht, zwei Pfadkomponenten zu einer einzigen vorbelegten Zeichenspanne zu verketten, und gibt einen Wert zurück, der den Erfolg des Vorgangs angibt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-780">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="8f3af-781"><see langword="true" />, wenn die Verkettung erfolgreich ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-781"><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="8f3af-782">`destination` müssen groß genug sein, um den verketteten Pfad zu speichern.</span><span class="sxs-lookup"><span data-stu-id="8f3af-782">`destination` must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="8f3af-783">Anschließend können Sie den verketteten Pfad abrufen, indem Sie die <xref:System.Span%601.Slice%2A?displayProperty=nameWithType>-Methode aufrufen, wie im Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-783">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-784">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-784">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * int -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="8f3af-785">Eine Zeichenspanne, die den ersten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-785">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="8f3af-786">Eine Zeichenspanne, die den zweiten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-786">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="8f3af-787">Eine Zeichenspanne, die den dritten Pfad für die Verknüpfung enthält.</span><span class="sxs-lookup"><span data-stu-id="8f3af-787">A character span that contains the third path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="8f3af-788">Eine Zeichenspanne, die den verketteten Pfad enthalten soll.</span><span class="sxs-lookup"><span data-stu-id="8f3af-788">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="8f3af-789">Ein Wert bei Rückgabe der Methode, der die Anzahl der Zeichen angibt, die in <paramref name="destination" /> geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="8f3af-789">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="8f3af-790">Versucht, zwei Pfadkomponenten zu einer einzigen vorbelegten Zeichenspanne zu verketten, und gibt einen Wert zurück, der den Erfolg des Vorgangs angibt.</span><span class="sxs-lookup"><span data-stu-id="8f3af-790">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="8f3af-791"><see langword="true" />, wenn die Verkettung erfolgreich ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="8f3af-791"><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="8f3af-792">`destination` müssen groß genug sein, um den verketteten Pfad zu speichern.</span><span class="sxs-lookup"><span data-stu-id="8f3af-792">`destination` must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="8f3af-793">Anschließend können Sie den verketteten Pfad abrufen, indem Sie die <xref:System.Span%601.Slice%2A?displayProperty=nameWithType>-Methode aufrufen, wie im Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-793">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="8f3af-794">Formate von Dateipfaden unter Windows-Systemen</span><span class="sxs-lookup"><span data-stu-id="8f3af-794">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f3af-795">Stellt ein plattformspezifisches Volumetrennzeichen bereit.</span><span class="sxs-lookup"><span data-stu-id="8f3af-795">Provides a platform-specific volume separator character.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f3af-796">Der Wert dieses Felds ist ein Doppelpunkt (:) unter Windows und Macintosh und ein Schrägstrich (/) auf UNIX-Betriebssystemen.</span><span class="sxs-lookup"><span data-stu-id="8f3af-796">The value of this field is a colon (:) on Windows and Macintosh, and a slash (/) on UNIX operating systems.</span></span> <span data-ttu-id="8f3af-797">Dies ist besonders nützlich für das Durchsuchen von Pfaden, wie z. b. "c:\Windows" oder "MacVolume: System Ordner".</span><span class="sxs-lookup"><span data-stu-id="8f3af-797">This is most useful for parsing paths such as "c:\windows" or "MacVolume:System Folder".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f3af-798">Im folgenden Beispiel wird die Verwendung des Felds `VolumeSeparatorChar` veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="8f3af-798">The following example demonstrates the use of the `VolumeSeparatorChar` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="8f3af-799">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="8f3af-799">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="8f3af-800">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="8f3af-800">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="8f3af-801">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="8f3af-801">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
