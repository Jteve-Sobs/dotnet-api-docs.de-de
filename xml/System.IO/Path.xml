<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Path.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac550ebb5b074574504632faae02729178d34bf1194.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">50ebb5b074574504632faae02729178d34bf1194</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IO.Path">
          <source>Performs operations on <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> instances that contain file or directory path information.</source>
          <target state="translated">Führt Vorgänge für <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>-Instanzen aus, die Datei- oder Verzeichnispfadinformationen enthalten.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.IO.Path">
          <source>These operations are performed in a cross-platform manner.</source>
          <target state="translated">Diese Vorgänge werden plattformübergreifend durchgeführt.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework unterstützt keine direkten Zugriff auf physische Datenträger über Pfade, Gerätenamen, z. B. "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>A path is a string that provides the location of a file or directory.</source>
          <target state="translated">Ein Pfad ist eine Zeichenfolge, die den Speicherort einer Datei oder Verzeichnis bereitstellt.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>A path does not necessarily point to a location on disk; for example, a path might map to a location in memory or on a device.</source>
          <target state="translated">Ein Pfad zeigt nicht notwendigerweise an einen Speicherort auf dem Datenträger; Beispielsweise kann ein Pfad an einem Speicherort im Arbeitsspeicher oder auf einem Gerät zugeordnet.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The exact format of a path is determined by the current platform.</source>
          <target state="translated">Das genaue Format eines Pfads richtet sich nach der aktuellen Plattform.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, on some systems, a path can start with a drive or volume letter, while this element is not present in other systems.</source>
          <target state="translated">Beispielsweise kann auf einige Systeme ein Pfad mit einem Buchstaben Laufwerk oder Volume beginnen, während dieses Element nicht in andere Systeme vorhanden ist.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>On some systems, file paths can contain extensions, which indicate the type of information stored in the file.</source>
          <target state="translated">Auf einige Systeme können Dateipfade Erweiterungen enthalten, die was darauf hindeuten, der Typ der in der Datei gespeicherten Informationen dass.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The format of a file name extension is platform-dependent; for example, some systems limit extensions to three characters, and others do not.</source>
          <target state="translated">Das Format der Erweiterung ist plattformabhängig; Klicken Sie z. B. einige Systeme beschränken Erweiterungen auf drei Zeichen, und andere nicht.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The current platform also determines the set of characters used to separate the elements of a path, and the set of characters that cannot be used when specifying paths.</source>
          <target state="translated">Die aktuelle Plattform bestimmt auch den Satz von Zeichen verwendet, um die Elemente eines Pfads zu trennen und die Gruppe von Zeichen, die verwendet werden kann, wenn Sie Pfade angeben.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Because of these differences, the fields of the <ph id="ph1">`Path`</ph> class as well as the exact behavior of some members of the <ph id="ph2">`Path`</ph> class are platform-dependent.</source>
          <target state="translated">Aufgrund dieser Unterschiede, die Felder von der <ph id="ph1">`Path`</ph> sowie das genaue Verhalten einiger Member der Klasse die <ph id="ph2">`Path`</ph> Klasse hängen von der Plattform ab.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>A path can contain absolute or relative location information.</source>
          <target state="translated">Ein Pfad kann es sich um absolute oder relative Speicherortinformationen enthalten.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Absolute paths fully specify a location: the file or directory can be uniquely identified regardless of the current location.</source>
          <target state="translated">Absolute Pfade geben einen Speicherort vollständig an: die Datei oder das Verzeichnis eindeutig unabhängig von der aktuellen Position identifiziert werden kann.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Relative paths specify a partial location: the current location is used as the starting point when locating a file specified with a relative path.</source>
          <target state="translated">Relative Pfade geben Sie eine partielle an: der aktuelle Speicherort dient als Ausgangspunkt beim Suchen einer Datei mit einem relativen Pfad angegeben.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>To determine the current directory, call <ph id="ph1">&lt;xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Rufen Sie zum Bestimmen des aktuellen Verzeichnisses <ph id="ph1">&lt;xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Most members of the <ph id="ph1">`Path`</ph> class do not interact with the file system and do not verify the existence of the file specified by a path string.</source>
          <target state="translated">Die meisten Member aus, der die <ph id="ph1">`Path`</ph> Klasse interagieren nicht mit dem Dateisystem und nicht das Vorhandensein der Datei durch eine Pfadzeichenfolge im angegebene überprüfen.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source><ph id="ph1">`Path`</ph> class members that modify a path string, such as <ph id="ph2">&lt;xref:System.IO.Path.ChangeExtension%2A&gt;</ph>, have no effect on names of files in the file system.</source>
          <target state="translated"><ph id="ph1">`Path`</ph> Klassenmember, die z. B. eine Pfadzeichenfolge ändern <ph id="ph2">&lt;xref:System.IO.Path.ChangeExtension%2A&gt;</ph>, wirken sich nicht auf den Namen der Dateien im Dateisystem.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source><ph id="ph1">`Path`</ph> members do, however, validate the contents of a specified path string, and throw an <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> exception if the string contains characters that are not valid in path strings, as defined in the characters returned from the <ph id="ph3">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`Path`</ph> Elemente bewirken, allerdings überprüfen Sie den Inhalt der angegebenen Pfadzeichenfolge und lösen eine <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> -Ausnahme aus, wenn die Zeichenfolge Zeichen, die nicht in Pfadzeichenfolgen, gültig sind, die enthält von zurückgegebenen Zeichen gemäß der <ph id="ph3">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, on Windows-based desktop platforms, invalid path characters might include quote ("), less than (<ph id="ph1">\&lt;</ph>), greater than (&gt;), pipe (&amp;#124;), backspace (\b), null (\0), and Unicode characters 16 through 18 and 20 through 25.</source>
          <target state="translated">Z. B. auf Windows-basierten Desktopplattformen auf ungültige Pfadzeichen u. Anführungszeichen ("), kleiner als (<ph id="ph1">\&lt;</ph>), größer als (&gt;), Pipe (&amp;#124;), Rücktaste (\b), Null (\0) und Unicode-Zeichen 16 bis 18 und 20 bis 25.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The members of the <ph id="ph1">`Path`</ph> class enable you to quickly and easily perform common operations such as determining whether a file name extension is part of a path, and combining two strings into one path name.</source>
          <target state="translated">Die Mitglieder der <ph id="ph1">`Path`</ph> Klasse ermöglichen es Ihnen, schnell und einfach durchführen allgemeine Vorgänge, z. B. bestimmen, ob eine Dateinamenerweiterung Teil eines Pfads ist, und Kombinieren von zwei Zeichenfolgen in einem Pfadnamen.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>All members of the <ph id="ph1">`Path`</ph> class are static and can therefore be called without having an instance of a path.</source>
          <target state="translated">Alle Mitglieder der <ph id="ph1">`Path`</ph> -Klasse sind statisch und können daher ohne eine Instanz eines Pfads aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>In members that accept a path as an input string, that path must be well-formed or an exception is raised.</source>
          <target state="translated">Bei Membern, die einen Pfad als Eingabezeichenfolge akzeptieren, dass der Pfad muss wohlgeformt sein oder eine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class.</source>
          <target state="translated">Wenn ein Pfad vollqualifizierte ist aber mit einem Leerzeichen beginnt, wird der Pfad z. B. nicht in Methoden der Klasse gekürzt.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Therefore, the path is malformed and an exception is raised.</source>
          <target state="translated">Aus diesem Grund der Pfad ist falsch formatiert, und eine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Similarly, a path or a combination of paths cannot be fully qualified twice.</source>
          <target state="translated">Auf ähnliche Weise kann keinen Pfad oder eine Kombination von Pfaden zweimal vollqualifiziert sein.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, "c:\temp c:\windows" also raises an exception in most cases.</source>
          <target state="translated">So löst z. B. "c:\temp c:\windows" auch eine Ausnahme in den meisten Fällen.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Ensure that your paths are well-formed when using methods that accept a path string.</source>
          <target state="translated">Stellen Sie sicher, dass die Pfade wohlgeformt sind, wenn Sie Methoden verwenden, die eine Pfadzeichenfolge akzeptieren.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>In members that accept a path, the path can refer to a file or just a directory.</source>
          <target state="translated">Bei Membern, die einen Pfad zu akzeptieren, kann der Pfad in einer Datei oder einfach ein Verzeichnis verweisen.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name.</source>
          <target state="translated">Der angegebene Pfad kann auch auf einen relativen oder einen Pfad (UNC = Universal Naming Convention) für den Namen eines Servers und der freigabeeinstellungen verweisen.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, all the following are acceptable paths:</source>
          <target state="translated">Beispielsweise sind alle folgenden Pfade zulässig:</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>"c:<ph id="ph1">\\</ph>\MyDir<ph id="ph2">\\</ph>\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.</source>
          <target state="translated">"" c: "<ph id="ph1">\\</ph>\MyDir<ph id="ph2">\\</ph>\MyFile.txt" in C#- oder "c:\MyDir\MyFile.txt" in Visual Basic.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>"c:<ph id="ph1">\\</ph>\MyDir" in C#, or "c:\MyDir" in Visual Basic.</source>
          <target state="translated">"" c: "<ph id="ph1">\\</ph>\MyDir" in C#- oder "c:\MyDir" in Visual Basic.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>"MyDir<ph id="ph1">\\</ph>\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.</source>
          <target state="translated">"" MyDir "<ph id="ph1">\\</ph>\MySubdir" in C#- oder "MyDir\MySubDir" in Visual Basic.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>"<ph id="ph1">\\</ph><ph id="ph2">\\</ph><ph id="ph3">\\</ph>\MyServer<ph id="ph4">\\</ph>\MyShare" in C#, or "<ph id="ph5">\\</ph>\MyServer\MyShare" in Visual Basic.</source>
          <target state="translated">"<ph id="ph1">\\</ph><ph id="ph2">\\</ph><ph id="ph3">\\</ph>\MyServer<ph id="ph4">\\</ph>\MyShare" in C#- oder "<ph id="ph5">\\</ph>\MyServer\MyShare" in Visual Basic.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>Because all these operations are performed on strings, it is impossible to verify that the results are valid in all scenarios.</source>
          <target state="translated">Da alle diese Vorgänge bei Zeichenfolgen durchgeführt werden, ist es unmöglich, stellen Sie sicher, dass die Ergebnisse in allen Szenarien gültig sind.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For example, the <ph id="ph1">&lt;xref:System.IO.Path.GetExtension%2A&gt;</ph> method parses a string that you pass to it and returns the extension from that string.</source>
          <target state="translated">Z. B. die <ph id="ph1">&lt;xref:System.IO.Path.GetExtension%2A&gt;</ph> Methode analysiert eine Zeichenfolge, die an sie übergeben werden, und gibt die Erweiterung aus dieser Zeichenfolge zurück.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>However, this does not mean that a file with that extension exists on the disk.</source>
          <target state="translated">Dies bedeutet jedoch nicht, dass eine Datei mit dieser Erweiterung auf dem Datenträger vorhanden ist.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Eine Liste der allgemeinen e/a-Aufgaben finden Sie <bpt id="p1">[</bpt>allgemeine e/a-Aufgaben<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.Path">
          <source>The following code example demonstrates some of the main members of the <ph id="ph1">`Path`</ph> class.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht einige der wichtigsten Elemente der <ph id="ph1">`Path`</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</source>
          <target state="translated">Stellt ein plattformspezifisches, alternatives Zeichen bereit, das zur Trennung von Verzeichnisebenen in einer Pfadzeichenfolge verwendet wird und eine hierarchische Dateisystemorganisation wiedergibt.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>The character stored in this field cannot be in <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>.</source>
          <target state="translated">In diesem Feld gespeicherte Zeichen darf sich nicht in <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>This field can be set to the same value as <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>.</source>
          <target state="translated">Dieses Feld kann festgelegt werden, um den gleichen Wert wie <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source><ph id="ph1">`AltDirectorySeparatorChar`</ph> and <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> are both valid for separating directory levels in a path string.</source>
          <target state="translated"><ph id="ph1">`AltDirectorySeparatorChar`</ph> und <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> gelten sowohl für die Trennung von Verzeichnisebenen in einer Pfadzeichenfolge.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>The value of this field is a slash ('/') on Windows, UNIX and Macintosh operating systems.</source>
          <target state="translated">Der Wert dieses Felds ist ein Schrägstrich ('/') unter Windows, UNIX und Macintosh-Betriebssysteme.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.AltDirectorySeparatorChar">
          <source>The following code example demonstrates a use of the <ph id="ph1">`AltDirectorySeparatorChar`</ph> field.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">`AltDirectorySeparatorChar`</ph> Feld.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The path information to modify.</source>
          <target state="translated">Die zu ändernden Pfadinformationen.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The path cannot contain any of the characters defined in <ph id="ph1">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated">Der Pfad darf keines der in <ph id="ph1">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph> definierten Zeichen enthalten.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The new extension (with or without a leading period).</source>
          <target state="translated">Die neue Erweiterung (mit oder ohne führenden Punkt).</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>Specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> to remove an existing extension from <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Geben Sie <ph id="ph1">&lt;see langword="null" /&gt;</ph> an, um eine vorhandene Erweiterung aus <bpt id="p1">&lt;c&gt;</bpt>path<ept id="p1">&lt;/c&gt;</ept> zu entfernen.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>Changes the extension of a path string.</source>
          <target state="translated">Ändert die Erweiterung einer Pfadzeichenfolge.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The modified path information.</source>
          <target state="translated">Die geänderten Pfadinformationen.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>On Windows-based desktop platforms, if <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string (""), the path information is returned unmodified.</source>
          <target state="translated">Auf Desktopplattformen auf Grundlage von Windows werden die Pfadinformationen unverändert zurückgegeben, wenn <ph id="ph1">&lt;paramref name="path" /&gt;</ph> <ph id="ph2">&lt;see langword="null" /&gt;</ph> oder eine leere Zeichenfolge ("") ist.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="extension" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, the returned string contains the specified path with its extension removed.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="extension" /&gt;</ph> <ph id="ph2">&lt;see langword="null" /&gt;</ph> ist, enthält die zurückgegebene Zeichenfolge den angegebenen Pfad ohne die Erweiterung.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path" /&gt;</ph> has no extension, and <ph id="ph2">&lt;paramref name="extension" /&gt;</ph> is not <ph id="ph3">&lt;see langword="null" /&gt;</ph>, the returned path string contains <ph id="ph4">&lt;paramref name="extension" /&gt;</ph> appended to the end of <ph id="ph5">&lt;paramref name="path" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="path" /&gt;</ph> keine Erweiterung besitzt und <ph id="ph2">&lt;paramref name="extension" /&gt;</ph> nicht <ph id="ph3">&lt;see langword="null" /&gt;</ph> ist, enthält die zurückgegebene Pfadzeichenfolge <ph id="ph4">&lt;paramref name="extension" /&gt;</ph>, angefügt an das Ende von <ph id="ph5">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If neither <ph id="ph1">`path`</ph> nor <ph id="ph2">`extension`</ph> contains a period (.), <ph id="ph3">`ChangeExtension`</ph> adds the period.</source>
          <target state="translated">Wenn weder <ph id="ph1">`path`</ph> noch <ph id="ph2">`extension`</ph> enthält einen Punkt (.), <ph id="ph3">`ChangeExtension`</ph> fügt den Punkt hinzu.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The <ph id="ph1">`extension`</ph> parameter can contain multiple periods and any valid path characters, and can be any length.</source>
          <target state="translated">Die <ph id="ph1">`extension`</ph> Parameter kann mehrere Punkte und jedes gültige Pfadzeichen enthalten und darf eine beliebige Länge.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`extension`</ph> is <ph id="ph2">`null`</ph>, the returned string contains the contents of <ph id="ph3">`path`</ph> with the last period and all characters following it removed.</source>
          <target state="translated">Wenn <ph id="ph1">`extension`</ph> ist <ph id="ph2">`null`</ph>, enthält die zurückgegebene Zeichenfolge den Inhalt der <ph id="ph3">`path`</ph> mit den letzten Punkt und alle folgenden Zeichen entfernt.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`extension`</ph> is an empty string, the returned path string contains the contents of <ph id="ph2">`path`</ph> with any characters following the last period removed.</source>
          <target state="translated">Wenn <ph id="ph1">`extension`</ph> ist eine leere Zeichenfolge, enthält die zurückgegebene Pfadzeichenfolge den Inhalt der <ph id="ph2">`path`</ph> mit den letzten Punkt Zeichen entfernt.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`path`</ph> does not have an extension and <ph id="ph2">`extension`</ph> is not <ph id="ph3">`null`</ph>, the returned string contains <ph id="ph4">`path`</ph> followed by <ph id="ph5">`extension`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`path`</ph> verfügt nicht über eine Erweiterung und <ph id="ph2">`extension`</ph> nicht <ph id="ph3">`null`</ph>, enthält die zurückgegebene Zeichenfolge <ph id="ph4">`path`</ph> gefolgt von <ph id="ph5">`extension`</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`extension`</ph> is not <ph id="ph2">`null`</ph> and does not contain a leading period, the period is added.</source>
          <target state="translated">Wenn <ph id="ph1">`extension`</ph> nicht <ph id="ph2">`null`</ph> und enthält keine führenden Punkt, der Zeitraum hinzugefügt wird.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>If <ph id="ph1">`path`</ph> contains a multiple extension separated by multiple periods, the returned string contains the contents of <ph id="ph2">`path`</ph> with the last period and all characters following it replaced by <ph id="ph3">`extension`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`path`</ph> enthält mehrere Erweiterung durch mehrere Punkte getrennt, enthält die zurückgegebene Zeichenfolge den Inhalt der <ph id="ph2">`path`</ph> mit den letzten Punkt und alle folgenden Zeichen ersetzt durch <ph id="ph3">`extension`</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>For example, if <ph id="ph1">`path`</ph> is "\Dir1\examples\pathtests.csx.txt" and <ph id="ph2">`extension`</ph> is "cs", the modified path is "\Dir1\examples\pathtests.csx.cs".</source>
          <target state="translated">Z. B. wenn <ph id="ph1">`path`</ph> "\Dir1\examples\pathtests.csx.txt" und <ph id="ph2">`extension`</ph> "Cs", ist des geänderten Pfads "\Dir1\examples\pathtests.csx.cs".</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>It is not possible to verify that the returned results are valid in all scenarios.</source>
          <target state="translated">Es ist nicht möglich, um sicherzustellen, dass die zurückgegebenen Ergebnisse in allen Szenarien gültig sind.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>For example, if <ph id="ph1">`path`</ph> is empty, <ph id="ph2">`extension`</ph> is appended.</source>
          <target state="translated">Z. B. wenn <ph id="ph1">`path`</ph> ist leer, <ph id="ph2">`extension`</ph> angefügt ist.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Eine Liste der allgemeinen e/a-Aufgaben finden Sie <bpt id="p1">[</bpt>allgemeine e/a-Aufgaben<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source>The following code example demonstrates a use of the <ph id="ph1">`ChangeExtension`</ph> method.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">`ChangeExtension`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.IO.Path.ChangeExtension(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> enthält mindestens eines der in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph> definierten ungültigen Zeichen.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="T:System.IO.Path">
          <source>Combines strings into a path.</source>
          <target state="translated">Kombiniert Zeichenfolgen zu einem Pfad.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>An array of parts of the path.</source>
          <target state="translated">Ein Array der Teile des Pfads.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>Combines an array of strings into a path.</source>
          <target state="translated">Kombiniert ein Array von Zeichenfolgen zu einem Pfad.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>The combined paths.</source>
          <target state="translated">Die kombinierten Pfade.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source><ph id="ph1">`paths`</ph> should be an array of the parts of the path to combine.</source>
          <target state="translated"><ph id="ph1">`paths`</ph> sollte ein Array der Teile der zu kombinierende Pfad.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>If the one of the subsequent paths is an absolute path, then the combine operation resets starting with that absolute path, discarding all previous combined paths.</source>
          <target state="translated">Wenn einer der nachfolgenden Pfade ein absoluter Pfad ist, setzt der Vorgang kombinieren, beginnend mit diesem absoluten Pfad, verwerfen alle vorherigen kombinierten Pfade.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>Zero-length strings are omitted from the combined path.</source>
          <target state="translated">Leere Zeichenfolgen werden aus den kombinierten Pfad weggelassen.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>The parameters are not parsed if they have white space.</source>
          <target state="translated">Die Parameter nicht analysiert, wenn sie Leerzeichen aufweisen.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>Not all invalid characters for directory and file names are interpreted as unacceptable by the <ph id="ph1">`Combine`</ph> method, because you can use these characters for search wildcard characters.</source>
          <target state="translated">Nicht alle ungültige Zeichen für Verzeichnis-und Dateinamen interpretiert werden als nicht akzeptabel, indem Sie die <ph id="ph1">`Combine`</ph> -Methode, da Sie diese Zeichen als Platzhalterzeichen Search verwenden können.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>For example, while <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> might be invalid if you were to create a file from it, it is valid as a search string.</source>
          <target state="translated">Während beispielsweise <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> möglicherweise ungültig, wenn Sie eine Datei daraus erstellt wurden, wird als eine Suchzeichenfolge gültig.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>It is therefore successfully interpreted by the <ph id="ph1">`Combine`</ph> method.</source>
          <target state="translated">Es ist daher erfolgreich interpretiert, von der <ph id="ph1">`Combine`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String[])">
          <source>The following example combines an array of strings into a path.</source>
          <target state="translated">Das folgende Beispiel kombiniert ein Array von Zeichenfolgen zu einem Pfad.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>One of the strings in the array contains one or more of the invalid characters defined in <ph id="ph1">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated">Eine der Zeichenfolgen im Array enthält eines oder mehrere der ungültigen Zeichen, die in <ph id="ph1">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph> definiert sind.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String[])">
          <source>One of the strings in the array is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Eine der Zeichenfolgen im Array ist <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The first path to combine.</source>
          <target state="translated">Der erste zu kombinierende Pfad.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The second path to combine.</source>
          <target state="translated">Der zweite zu kombinierende Pfad.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>Combines two strings into a path.</source>
          <target state="translated">Kombiniert zwei Zeichenfolgen zu einem Pfad.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The combined paths.</source>
          <target state="translated">Die kombinierten Pfade.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If one of the specified paths is a zero-length string, this method returns the other path.</source>
          <target state="translated">Wenn einer der beiden angegebenen Pfade eine Zeichenfolge der Länge 0 ist, gibt diese Methode den anderen Pfad zurück.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path2" /&gt;</ph> contains an absolute path, this method returns <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="path2" /&gt;</ph> einen absoluten Pfad enthält, gibt diese Methode <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If <ph id="ph1">`path1`</ph> is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> is appended to <ph id="ph6">`path1`</ph> before concatenation.</source>
          <target state="translated">Wenn <ph id="ph1">`path1`</ph> ist kein Laufwerkverweis (d. h. "C:" oder "D:") und endet nicht mit einem gültigen Trennzeichen, gemäß <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, oder <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> angehängt <ph id="ph6">`path1`</ph> vor der Verkettung.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> does not include a root (for example, if <ph id="ph2">`path2`</ph> does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</source>
          <target state="translated">Wenn <ph id="ph1">`path2`</ph> enthält keinen Stamm (z. B. wenn <ph id="ph2">`path2`</ph> beginnt nicht mit einem Trennzeichen oder einen Laufwerksangabe), das Ergebnis ist eine Verkettung der beiden Pfade mit einem Trennzeichen dazwischen.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> includes a root, <ph id="ph2">`path2`</ph> is returned.</source>
          <target state="translated">Wenn <ph id="ph1">`path2`</ph> ein Stammverzeichnis enthält <ph id="ph2">`path2`</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The parameters are not parsed if they have white space.</source>
          <target state="translated">Die Parameter nicht analysiert, wenn sie Leerzeichen aufweisen.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>Therefore, if <ph id="ph1">`path2`</ph> includes white space (for example, " \file.txt "), the <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> method appends <ph id="ph3">`path2`</ph> to <ph id="ph4">`path1`</ph> instead of returning only <ph id="ph5">`path2`</ph>.</source>
          <target state="translated">Aus diesem Grund Wenn <ph id="ph1">`path2`</ph> Leerzeichen (z. B. "\file.txt"), enthält die <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> Methode fügt <ph id="ph3">`path2`</ph> auf <ph id="ph4">`path1`</ph> anstatt nur <ph id="ph5">`path2`</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>Not all invalid characters for directory and file names are interpreted as unacceptable by the <ph id="ph1">`Combine`</ph> method, because you can use these characters for search wildcard characters.</source>
          <target state="translated">Nicht alle ungültige Zeichen für Verzeichnis-und Dateinamen interpretiert werden als nicht akzeptabel, indem Sie die <ph id="ph1">`Combine`</ph> -Methode, da Sie diese Zeichen als Platzhalterzeichen Search verwenden können.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>For example, while <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> might be invalid if you were to create a file from it, it is valid as a search string.</source>
          <target state="translated">Während beispielsweise <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> möglicherweise ungültig, wenn Sie eine Datei daraus erstellt wurden, wird als eine Suchzeichenfolge gültig.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>It is therefore successfully interpreted by the <ph id="ph1">`Combine`</ph> method.</source>
          <target state="translated">Es ist daher erfolgreich interpretiert, von der <ph id="ph1">`Combine`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Eine Liste der allgemeinen e/a-Aufgaben finden Sie <bpt id="p1">[</bpt>allgemeine e/a-Aufgaben<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source>The following code example demonstrates using the <ph id="ph1">`Combine`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung der <ph id="ph1">`Combine`</ph> Methode auf einer Windows-basierten desktop-Plattform.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph3">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> enthält mindestens eines der in <ph id="ph3">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph> definierten ungültigen Zeichen.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> ist <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The first path to combine.</source>
          <target state="translated">Der erste zu kombinierende Pfad.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The second path to combine.</source>
          <target state="translated">Der zweite zu kombinierende Pfad.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The third path to combine.</source>
          <target state="translated">Der dritte zu kombinierende Pfad.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>Combines three strings into a path.</source>
          <target state="translated">Kombiniert drei Zeichenfolgen zu einem Pfad.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The combined paths.</source>
          <target state="translated">Die kombinierten Pfade.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source><ph id="ph1">`path1`</ph> should be an absolute path (for example, "d:\archives" or "<ph id="ph2">\\</ph>\archives\public").</source>
          <target state="translated"><ph id="ph1">`path1`</ph> muss ein absoluter Pfad sein (z. B. "d:\archives" oder "<ph id="ph2">\\</ph>\archives\public").</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> or <ph id="ph2">`path3`</ph> is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</source>
          <target state="translated">Wenn <ph id="ph1">`path2`</ph> oder <ph id="ph2">`path3`</ph> ist auch ein absoluter Pfad, kombinieren Vorgang verwirft alle zuvor kombinierten Pfade und Zurücksetzen von Kennwörtern zu diesem absoluten Pfad.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>Zero-length strings are omitted from the combined path.</source>
          <target state="translated">Leere Zeichenfolgen werden aus den kombinierten Pfad weggelassen.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path1`</ph> is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> is appended to <ph id="ph6">`path1`</ph> before concatenation.</source>
          <target state="translated">Wenn <ph id="ph1">`path1`</ph> ist kein Laufwerkverweis (d. h. "C:" oder "D:") und endet nicht mit einem gültigen Trennzeichen, gemäß <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, oder <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> angehängt <ph id="ph6">`path1`</ph> vor der Verkettung.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> does not include a root (for example, if <ph id="ph2">`path2`</ph> does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</source>
          <target state="translated">Wenn <ph id="ph1">`path2`</ph> enthält keinen Stamm (z. B. wenn <ph id="ph2">`path2`</ph> beginnt nicht mit einem Trennzeichen oder einen Laufwerksangabe), das Ergebnis ist eine Verkettung der beiden Pfade mit einem Trennzeichen dazwischen.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> includes a root, <ph id="ph2">`path2`</ph> is returned.</source>
          <target state="translated">Wenn <ph id="ph1">`path2`</ph> ein Stammverzeichnis enthält <ph id="ph2">`path2`</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The parameters are not parsed if they have white space.</source>
          <target state="translated">Die Parameter nicht analysiert, wenn sie Leerzeichen aufweisen.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>Therefore, if <ph id="ph1">`path2`</ph> includes white space (for example, " \file.txt "), the <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> method appends <ph id="ph3">`path2`</ph> to <ph id="ph4">`path1`</ph>.</source>
          <target state="translated">Aus diesem Grund Wenn <ph id="ph1">`path2`</ph> Leerzeichen (z. B. "\file.txt"), enthält die <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> Methode fügt <ph id="ph3">`path2`</ph> auf <ph id="ph4">`path1`</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>Not all invalid characters for directory and file names are interpreted as unacceptable by the <ph id="ph1">`Combine`</ph> method, because you can use these characters for search wildcard characters.</source>
          <target state="translated">Nicht alle ungültige Zeichen für Verzeichnis-und Dateinamen interpretiert werden als nicht akzeptabel, indem Sie die <ph id="ph1">`Combine`</ph> -Methode, da Sie diese Zeichen als Platzhalterzeichen Search verwenden können.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>For example, while <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> might be invalid if you were to create a file from it, it is valid as a search string.</source>
          <target state="translated">Während beispielsweise <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> möglicherweise ungültig, wenn Sie eine Datei daraus erstellt wurden, wird als eine Suchzeichenfolge gültig.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>It is therefore successfully interpreted by the <ph id="ph1">`Combine`</ph> method.</source>
          <target state="translated">Es ist daher erfolgreich interpretiert, von der <ph id="ph1">`Combine`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source>The following example combines three paths.</source>
          <target state="translated">Im folgende Beispiel werden drei Pfade kombiniert.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph4">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> enthält mindestens ein ungültiges Zeichen gemäß der Definition in <ph id="ph4">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph> oder <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> ist <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The first path to combine.</source>
          <target state="translated">Der erste zu kombinierende Pfad.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The second path to combine.</source>
          <target state="translated">Der zweite zu kombinierende Pfad.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The third path to combine.</source>
          <target state="translated">Der dritte zu kombinierende Pfad.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The fourth path to combine.</source>
          <target state="translated">Der vierte zu kombinierende Pfad.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>Combines four strings into a path.</source>
          <target state="translated">Kombiniert vier Zeichenfolgen zu einem Pfad.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The combined paths.</source>
          <target state="translated">Die kombinierten Pfade.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source><ph id="ph1">`path1`</ph> should be an absolute path (for example, "d:\archives" or "<ph id="ph2">\\</ph>\archives\public").If one of the subsequent paths is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</source>
          <target state="translated"><ph id="ph1">`path1`</ph> muss ein absoluter Pfad sein (z. B. "d:\archives" oder "<ph id="ph2">\\</ph>\archives\public"). Wenn einer der nachfolgenden Pfade auch ein absoluter Pfad ist, wird der Vorgang kombinieren verwirft alle zuvor kombinierten Pfade und setzt auf dieser absolute Pfad zurück.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>Zero-length strings are omitted from the combined path.</source>
          <target state="translated">Leere Zeichenfolgen werden aus den kombinierten Pfad weggelassen.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path1`</ph> is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> is appended to <ph id="ph6">`path1`</ph> before concatenation.</source>
          <target state="translated">Wenn <ph id="ph1">`path1`</ph> ist kein Laufwerkverweis (d. h. "C:" oder "D:") und endet nicht mit einem gültigen Trennzeichen, gemäß <ph id="ph2">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, oder <ph id="ph4">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> angehängt <ph id="ph6">`path1`</ph> vor der Verkettung.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> does not include a root (for example, if <ph id="ph2">`path2`</ph> does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</source>
          <target state="translated">Wenn <ph id="ph1">`path2`</ph> enthält keinen Stamm (z. B. wenn <ph id="ph2">`path2`</ph> beginnt nicht mit einem Trennzeichen oder einen Laufwerksangabe), das Ergebnis ist eine Verkettung der beiden Pfade mit einem Trennzeichen dazwischen.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>If <ph id="ph1">`path2`</ph> includes a root, <ph id="ph2">`path2`</ph> is returned.</source>
          <target state="translated">Wenn <ph id="ph1">`path2`</ph> ein Stammverzeichnis enthält <ph id="ph2">`path2`</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The parameters are not parsed if they have white space.</source>
          <target state="translated">Die Parameter nicht analysiert, wenn sie Leerzeichen aufweisen.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>Therefore, if <ph id="ph1">`path2`</ph> includes white space (for example, " \file.txt "), the <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> method appends <ph id="ph3">`path2`</ph> to <ph id="ph4">`path1`</ph>.</source>
          <target state="translated">Aus diesem Grund Wenn <ph id="ph1">`path2`</ph> Leerzeichen (z. B. "\file.txt"), enthält die <ph id="ph2">&lt;xref:System.IO.Path.Combine%2A&gt;</ph> Methode fügt <ph id="ph3">`path2`</ph> auf <ph id="ph4">`path1`</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>Not all invalid characters for directory and file names are interpreted as unacceptable by the <ph id="ph1">`Combine`</ph> method, because you can use these characters for search wildcard characters.</source>
          <target state="translated">Nicht alle ungültige Zeichen für Verzeichnis-und Dateinamen interpretiert werden als nicht akzeptabel, indem Sie die <ph id="ph1">`Combine`</ph> -Methode, da Sie diese Zeichen als Platzhalterzeichen Search verwenden können.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>For example, while <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> might be invalid if you were to create a file from it, it is valid as a search string.</source>
          <target state="translated">Während beispielsweise <ph id="ph1">`Path.Combine("c:\\", "*.txt")`</ph> möglicherweise ungültig, wenn Sie eine Datei daraus erstellt wurden, wird als eine Suchzeichenfolge gültig.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>It is therefore successfully interpreted by the <ph id="ph1">`Combine`</ph> method.</source>
          <target state="translated">Es ist daher erfolgreich interpretiert, von der <ph id="ph1">`Combine`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source>The following example combines four paths.</source>
          <target state="translated">Im folgende Beispiel werden vier Pfade kombiniert.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, <ph id="ph3">&lt;paramref name="path3" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="path4" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph5">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> oder <ph id="ph4">&lt;paramref name="path4" /&gt;</ph> enthält mindestens eines der in <ph id="ph5">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph> definierten ungültigen Zeichen.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, <ph id="ph3">&lt;paramref name="path3" /&gt;</ph>, or <ph id="ph4">&lt;paramref name="path4" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="path2" /&gt;</ph>, <ph id="ph3">&lt;paramref name="path3" /&gt;</ph> oder <ph id="ph4">&lt;paramref name="path4" /&gt;</ph> ist <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="F:System.IO.Path.DirectorySeparatorChar">
          <source>Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</source>
          <target state="translated">Stellt ein plattformspezifisches Zeichen bereit, das zur Trennung von Verzeichnisebenen in einer Pfadzeichenfolge verwendet wird und eine hierarchische Dateisystemorganisation wiedergibt.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.DirectorySeparatorChar">
          <source>The character stored in this field cannot be in <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>.</source>
          <target state="translated">In diesem Feld gespeicherte Zeichen darf sich nicht in <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.DirectorySeparatorChar">
          <source><ph id="ph1">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph> and <ph id="ph2">`DirectorySeparatorChar`</ph> are both valid for separating directory levels in a path string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph> und <ph id="ph2">`DirectorySeparatorChar`</ph> gelten sowohl für die Trennung von Verzeichnisebenen in einer Pfadzeichenfolge.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.DirectorySeparatorChar">
          <source>The following code example demonstrates the use of the <ph id="ph1">`DirectorySeparatorChar`</ph> field.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von der <ph id="ph1">`DirectorySeparatorChar`</ph> Feld.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>The path of a file or directory.</source>
          <target state="translated">Der Pfad einer Datei oder eines Verzeichnisses.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Returns the directory information for the specified path string.</source>
          <target state="translated">Gibt die Verzeichnisinformationen für die angegebene Pfadzeichenfolge zurück.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Directory information for <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if <ph id="ph3">&lt;paramref name="path" /&gt;</ph> denotes a root directory or is null.</source>
          <target state="translated">Verzeichnisinformationen für <ph id="ph1">&lt;paramref name="path" /&gt;</ph> oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn <ph id="ph3">&lt;paramref name="path" /&gt;</ph> ein Stammverzeichnis bezeichnet oder NULL ist.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Returns <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph2">&lt;paramref name="path" /&gt;</ph> does not contain directory information.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> zurück, wenn <ph id="ph2">&lt;paramref name="path" /&gt;</ph> keine Verzeichnisinformationen enthält.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>In most cases, the string returned by this method consists of all characters in the path up to but not including the last <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> or <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>.</source>
          <target state="translated">In den meisten Fällen besteht die Zeichenfolge, die von dieser Methode zurückgegebene alle Zeichen im Pfad bis zur, aber nicht einschließlich dem letzten <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> oder <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>If the path consists of a root directory, such as "c:<ph id="ph1">\\</ph>", null is returned.</source>
          <target state="translated">Wenn der Pfad z. B. ein Stammverzeichnis besteht aus "" c: "<ph id="ph1">\\</ph>", wird Null zurückgegeben.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Note that this method does not support paths using "file:".</source>
          <target state="translated">Beachten Sie, dass diese Methode mithilfe von Pfaden nicht unterstützt "Datei:".</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Because the returned path does not include the <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> or <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, passing the returned path back into the <ph id="ph3">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> method will result in the truncation of one folder level per subsequent call on the result string.</source>
          <target state="translated">Da der zurückgegebene Pfad nicht enthalten ist die <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> oder <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, die Übergabe des zurückgegebenen Pfads zurück in die <ph id="ph3">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> Methode führt dazu, eine Ordnerebene pro nachfolgenden Aufruf in die Ergebniszeichenfolge wird abgeschnitten.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>For example, passing the path "C:\Directory\SubDirectory\test.txt" into the <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> method will return "C:\Directory\SubDirectory".</source>
          <target state="translated">Beispielsweise die Übergabe des Pfads "C:\Directory\SubDirectory\test.txt" in der <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> Methode "C:\Directory\SubDirectory" zurück.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>Passing that string, "C:\Directory\SubDirectory", into <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> will result in "C:\Directory".</source>
          <target state="translated">Übergeben die Zeichenfolge, die "C:\Directory\SubDirectory", in <ph id="ph1">&lt;xref:System.IO.Path.GetDirectoryName%2A&gt;</ph> führt zu "C:\Directory".</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Eine Liste der allgemeinen e/a-Aufgaben finden Sie <bpt id="p1">[</bpt>allgemeine e/a-Aufgaben<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>The following code example demonstrates using the <ph id="ph1">`GetDirectoryName`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung der <ph id="ph1">`GetDirectoryName`</ph> Methode auf einer Windows-basierten desktop-Plattform.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter contains invalid characters, is empty, or contains only white spaces.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="path" /&gt;</ph>-Parameter enthält nur ungültige Zeichen, ist leer oder enthält nur Leerzeichen.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">Fangen Sie in <bpt id="p1">[</bpt>.NET für Windows Store-Apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> oder der <bpt id="p2">[</bpt>portablen Klassenbibliothek<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept> stattdessen die Basisklassenausnahme <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetDirectoryName(System.String)">
          <source>The <ph id="ph1">&lt;paramref name="path" /&gt;</ph> parameter is longer than the system-defined maximum length.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="path" /&gt;</ph>-Parameter überschreitet die vom System definierte Maximallänge.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>The path string from which to get the extension.</source>
          <target state="translated">Die Pfadzeichenfolge, aus der die Erweiterung abgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>Returns the extension of the specified path string.</source>
          <target state="translated">Gibt die Erweiterung der angegebenen Pfadzeichenfolge zurück.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>The extension of the specified path (including the period "."), or <ph id="ph1">&lt;see langword="null" /&gt;</ph>, or <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Die Erweiterung des angegebenen Pfads (einschließlich des Punkts ".") oder <ph id="ph1">&lt;see langword="null" /&gt;</ph> oder <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.IO.Path.GetExtension(System.String)" /&gt;</ph> returns <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="path" /&gt;</ph> gleich <ph id="ph2">&lt;see langword="null" /&gt;</ph> ist, gibt <ph id="ph3">&lt;see cref="M:System.IO.Path.GetExtension(System.String)" /&gt;</ph> <ph id="ph4">&lt;see langword="null" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path" /&gt;</ph> does not have extension information, <ph id="ph2">&lt;see cref="M:System.IO.Path.GetExtension(System.String)" /&gt;</ph> returns <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="path" /&gt;</ph> keine Informationen über die Erweiterung enthält, gibt <ph id="ph2">&lt;see cref="M:System.IO.Path.GetExtension(System.String)" /&gt;</ph><ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>The extension of <ph id="ph1">`path`</ph> is obtained by searching <ph id="ph2">`path`</ph> for a period (.), starting with the last character in path and continuing toward the start of path.</source>
          <target state="translated">Die Erweiterung der <ph id="ph1">`path`</ph> erhalten, indem suchen <ph id="ph2">`path`</ph> für einen Punkt (.), das letzte Zeichen im Pfad zum Anfang des Pfads ab.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>If a period is found before a <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> or <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph> character, the returned string contains the period and the characters after it; otherwise, <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph> is returned.</source>
          <target state="translated">Wenn ein Punkt, bevor gefunden wird eine <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> oder <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph> Zeichen ist, enthält die zurückgegebene Zeichenfolge den Zeitraum und die Zeichen nach, wie Sie dies hingegen <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph> wird zurückgegeben.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Eine Liste der allgemeinen e/a-Aufgaben finden Sie <bpt id="p1">[</bpt>allgemeine e/a-Aufgaben<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetExtension(System.String)">
          <source>The following code example demonstrates using the <ph id="ph1">`GetExtension`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung der <ph id="ph1">`GetExtension`</ph> Methode auf einer Windows-basierten desktop-Plattform.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetExtension(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> enthält mindestens eines der in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph> definierten ungültigen Zeichen.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The path string from which to obtain the file name and extension.</source>
          <target state="translated">Die Pfadzeichenfolge, aus der der Dateiname und die Erweiterung abgerufen werden sollen.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>Returns the file name and extension of the specified path string.</source>
          <target state="translated">Gibt den Dateinamen und die Erweiterung der angegebenen Pfadzeichenfolge zurück.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The characters after the last directory character in <ph id="ph1">&lt;paramref name="path" /&gt;</ph>.</source>
          <target state="translated">Die Zeichen nach dem letzten Verzeichniszeichen in <ph id="ph1">&lt;paramref name="path" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>If the last character of <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is a directory or volume separator character, this method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Wenn das letzte Zeichen von <ph id="ph1">&lt;paramref name="path" /&gt;</ph> ein Verzeichnis- bzw. Volumetrennzeichen ist, gibt diese Methode <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, this method returns <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="path" /&gt;</ph> gleich <ph id="ph2">&lt;see langword="null" /&gt;</ph> ist, gibt die Methode <ph id="ph3">&lt;see langword="null" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The returned value is <ph id="ph1">`null`</ph> if the file path is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Der zurückgegebene Wert ist <ph id="ph1">`null`</ph> ist der Dateipfad <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The separator characters used to determine the start of the file name are <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>.</source>
          <target state="translated">Die Trennzeichen verwendet, um den Anfang des Dateinamens bestimmen sind <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph> und <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Eine Liste der allgemeinen e/a-Aufgaben finden Sie <bpt id="p1">[</bpt>allgemeine e/a-Aufgaben<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileName(System.String)">
          <source>The following code example demonstrates the behavior of the <ph id="ph1">`GetFileName`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht das Verhalten der <ph id="ph1">`GetFileName`</ph> Methode auf einer Windows-basierten Desktopcomputer Plattform.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileName(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> enthält mindestens eines der in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph> definierten ungültigen Zeichen.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>The path of the file.</source>
          <target state="translated">Der Pfad der Datei.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>Returns the file name of the specified path string without the extension.</source>
          <target state="translated">Gibt den Dateinamen der angegebenen Pfadzeichenfolge ohne Erweiterung zurück.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>The string returned by <ph id="ph1">&lt;see cref="M:System.IO.Path.GetFileName(System.String)" /&gt;</ph>, minus the last period (.) and all characters following it.</source>
          <target state="translated">Die von <ph id="ph1">&lt;see cref="M:System.IO.Path.GetFileName(System.String)" /&gt;</ph> zurückgegebene Zeichenfolge ohne den letzten Punkt (.) und alle folgenden Zeichen.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>This method does not verify that the path or file name exists.</source>
          <target state="translated">Diese Methode überprüft nicht, dass der Pfad oder Dateiname vorhanden ist.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Eine Liste der allgemeinen e/a-Aufgaben finden Sie <bpt id="p1">[</bpt>allgemeine e/a-Aufgaben<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source>The following code example demonstrates a use of the <ph id="ph1">`GetFileNameWithoutExtension`</ph> method.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">`GetFileNameWithoutExtension`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFileNameWithoutExtension(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> enthält mindestens eines der in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph> definierten ungültigen Zeichen.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The file or directory for which to obtain absolute path information.</source>
          <target state="translated">Die Datei oder das Verzeichnis, für das die absoluten Pfadinformationen abgerufen werden sollen.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>Returns the absolute path for the specified path string.</source>
          <target state="translated">Gibt den absoluten Pfad für die angegebene Pfadzeichenfolge zurück.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The fully qualified location of <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, such as "C:\MyFile.txt".</source>
          <target state="translated">Der vollqualifizierte Speicherort von <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, z. B. "C:\MyFile.txt".</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework unterstützt keine direkten Zugriff auf physische Datenträger über Pfade, Gerätenamen, z. B. "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The absolute path includes all information required to locate a file or directory on a system.</source>
          <target state="translated">Der absolute Pfad enthält alle Informationen, die erforderlich sind, um eine Datei oder ein Verzeichnis auf einem System zu suchen.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The file or directory specified by <ph id="ph1">`path`</ph> is not required to exist.</source>
          <target state="translated">Die Datei oder das Verzeichnis, die gemäß <ph id="ph1">`path`</ph> muss nicht vorhanden.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>For example, if c:\temp\newdir is the current directory, calling <ph id="ph1">`GetFullPath`</ph> on a file name such as test.txt returns c:\temp\newdir\test.txt.</source>
          <target state="translated">Wenn c:\temp\newdir das aktuelle Verzeichnis ist, z. B. beim Aufrufen <ph id="ph1">`GetFullPath`</ph> auf eine Datei gibt Namen, z. B. "Test.txt" c:\temp\newdir\test.txt zurück.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The file need not exist.</source>
          <target state="translated">Die Datei muss nicht vorhanden sein.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>However, if <ph id="ph1">`path`</ph> does exist, the caller must have permission to obtain path information for <ph id="ph2">`path`</ph>.</source>
          <target state="translated">Jedoch wenn <ph id="ph1">`path`</ph> vorhanden ist, der Aufrufer über die Berechtigung für den Pfad zu erhalten <ph id="ph2">`path`</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>Note that unlike most members of the <ph id="ph1">&lt;xref:System.IO.Path&gt;</ph> class, this method accesses the file system.</source>
          <target state="translated">Beachten Sie, dass im Gegensatz zu den meisten Elementen von der <ph id="ph1">&lt;xref:System.IO.Path&gt;</ph> Klasse, die diese Methode greift auf das Dateisystem.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>This method uses current directory and current volume information to fully qualify <ph id="ph1">`path`</ph>.</source>
          <target state="translated">Diese Methode verwendet das aktuelle Verzeichnis und aktuelle Informationen über Volume vollqualifiziert <ph id="ph1">`path`</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>If you specify a file name only in <ph id="ph1">`path`</ph>, <ph id="ph2">`GetFullPath`</ph> returns the fully qualified path of the current directory.</source>
          <target state="translated">Wenn Sie angeben, dass eine Datei nur im Namen <ph id="ph1">`path`</ph>, <ph id="ph2">`GetFullPath`</ph> gibt den vollqualifizierten Pfad des aktuellen Verzeichnisses zurück.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>If you pass in a short file name, it is expanded to a long file name.</source>
          <target state="translated">Wenn Sie einen kurzen Dateinamen übergeben, wird er zu einer langen Dateinamen erweitert.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>If a path contains no significant characters it is invalid unless it contains one or more "." characters followed by any number of spaces, then it will be parsed as either "." or "..".</source>
          <target state="translated">Wenn ein Pfad keine signifikanten Zeichen enthält ist ungültig, wenn sie eine oder mehrere enthält "."Zeichen, gefolgt von einer beliebigen Anzahl von Leerzeichen, und es wird analysiert, entweder als"."oder"..".</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Eine Liste der allgemeinen e/a-Aufgaben finden Sie <bpt id="p1">[</bpt>allgemeine e/a-Aufgaben<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The following code example demonstrates the <ph id="ph1">`GetFullPath`</ph> method on a Windows-based desktop platform.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">`GetFullPath`</ph> Methode auf einer Windows-basierten Desktopcomputer Plattform.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> ist eine Zeichenfolge der Länge 0 (null), besteht nur aus Leerraum oder enthält mindestens eines der in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph> definierten ungültige Zeichen.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The system could not retrieve the absolute path.</source>
          <target state="translated">Das System konnte den absoluten Pfad nicht abrufen.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The caller does not have the required permissions.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains a colon (":") that is not part of a volume identifier (for example, "c:<ph id="ph2">\\</ph>").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> enthält einen Doppelpunkt („:“), der kein Teil eines Volumenbezeichners (z.B. „c:<ph id="ph2">\\</ph>“) ist.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>The specified path, file name, or both exceed the system-defined maximum length.</source>
          <target state="translated">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than 260 characters.</source>
          <target state="translated">Beispielsweise müssen auf Windows-basierten Plattformen Pfade weniger als 248 Zeichen und Dateinamen weniger als 260 Zeichen enthalten.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetFullPath(System.String)">
          <source>for access to the path.</source>
          <target state="translated">für den Zugriff auf den Pfad.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>Gets an array containing the characters that are not allowed in file names.</source>
          <target state="translated">Ruft ein Array ab, das die Zeichen enthält, die in Dateinamen nicht zulässig sind.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>An array containing the characters that are not allowed in file names.</source>
          <target state="translated">Ein Array, das die Zeichen enthält, die in Dateinamen nicht zulässig sind.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</source>
          <target state="translated">Das von dieser Methode zurückgegebene Array ist nicht unbedingt den vollständigen Satz von Zeichen enthalten, die in Datei- und Verzeichnisnamen ungültig sind.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>The full set of invalid characters can vary by file system.</source>
          <target state="translated">Der vollständige Satz von ungültigen Zeichen kann je nach Dateisystem variieren.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (<ph id="ph1">\&lt;</ph>), greater than (&gt;), pipe (&amp;#124;), backspace (\b), null (\0) and tab (\t).</source>
          <target state="translated">Z. B. auf Windows-basierten Desktopplattformen auf ungültige Pfadzeichen möglicherweise ASCII/Unicode-Zeichen 1 bis 31 sowie Anführungszeichen ("), kleiner als (<ph id="ph1">\&lt;</ph>), größer als (&gt;), Pipe (&amp;#124;), Rücktaste (\b), Null (\0) und Tabulator (\t).</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidFileNameChars">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.IO.Path.GetInvalidFileNameChars%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> method to retrieve invalid characters.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">&lt;xref:System.IO.Path.GetInvalidFileNameChars%2A&gt;</ph> Methode und die <ph id="ph2">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> Methode, um ungültige Zeichen abzurufen.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>Gets an array containing the characters that are not allowed in path names.</source>
          <target state="translated">Ruft ein Array ab, das die Zeichen enthält, die in Pfadnamen nicht zulässig sind.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>An array containing the characters that are not allowed in path names.</source>
          <target state="translated">Ein Array, das die Zeichen enthält, die in Pfadnamen nicht zulässig sind.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</source>
          <target state="translated">Das von dieser Methode zurückgegebene Array ist nicht unbedingt den vollständigen Satz von Zeichen enthalten, die in Datei- und Verzeichnisnamen ungültig sind.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>The full set of invalid characters can vary by file system.</source>
          <target state="translated">Der vollständige Satz von ungültigen Zeichen kann je nach Dateisystem variieren.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (<ph id="ph1">\&lt;</ph>), greater than (&gt;), pipe (&amp;#124;), backspace (\b), null (\0) and tab (\t).</source>
          <target state="translated">Z. B. auf Windows-basierten Desktopplattformen auf ungültige Pfadzeichen möglicherweise ASCII/Unicode-Zeichen 1 bis 31 sowie Anführungszeichen ("), kleiner als (<ph id="ph1">\&lt;</ph>), größer als (&gt;), Pipe (&amp;#124;), Rücktaste (\b), Null (\0) und Tabulator (\t).</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetInvalidPathChars">
          <source>The following code example demonstrates the <ph id="ph1">&lt;xref:System.IO.Path.GetInvalidFileNameChars%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> method to retrieve invalid characters.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">&lt;xref:System.IO.Path.GetInvalidFileNameChars%2A&gt;</ph> Methode und die <ph id="ph2">&lt;xref:System.IO.Path.GetInvalidPathChars%2A&gt;</ph> Methode, um ungültige Zeichen abzurufen.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>The path from which to obtain root directory information.</source>
          <target state="translated">Der Pfad, von dem Informationen über das Stammverzeichnis abgerufen werden sollen.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>Gets the root directory information of the specified path.</source>
          <target state="translated">Ruft die Informationen über das Stammverzeichnis des angegebenen Pfads ab.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>The root directory of <ph id="ph1">&lt;paramref name="path" /&gt;</ph>, such as "C:<ph id="ph2">\\</ph>", or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if <ph id="ph4">&lt;paramref name="path" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>, or an empty string if <ph id="ph6">&lt;paramref name="path" /&gt;</ph> does not contain root directory information.</source>
          <target state="translated">Das Stammverzeichnis von <ph id="ph1">&lt;paramref name="path" /&gt;</ph> (z.B. „C:<ph id="ph2">\\</ph>“) oder <ph id="ph3">&lt;see langword="null" /&gt;</ph>, wenn <ph id="ph4">&lt;paramref name="path" /&gt;</ph> <ph id="ph5">&lt;see langword="null" /&gt;</ph> ist, oder eine leere Zeichenfolge, wenn <ph id="ph6">&lt;paramref name="path" /&gt;</ph> keine Informationen über das Stammverzeichnis enthält.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>This method does not verify that the path or file name exists.</source>
          <target state="translated">Diese Methode überprüft nicht, dass der Pfad oder Dateiname vorhanden ist.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>Possible patterns for the string returned by this method are as follows:</source>
          <target state="translated">Mögliche Muster für die Zeichenfolge, die von dieser Methode zurückgegebene lauten wie folgt:</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>An empty string (<ph id="ph1">`path`</ph> specified a relative path on the current drive or volume).</source>
          <target state="translated">Eine leere Zeichenfolge (<ph id="ph1">`path`</ph> einen relativen Pfad angegeben, auf das aktuelle Laufwerk oder Volume).</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>"/" (<ph id="ph1">`path`</ph> specified an absolute path on the current drive).</source>
          <target state="translated">"/" (<ph id="ph1">`path`</ph> einen absoluten Pfad für das aktuelle Laufwerk angegeben).</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>"X:" (<ph id="ph1">`path`</ph> specified a relative path on a drive, where X represents a drive or volume letter).</source>
          <target state="translated">"X:" (<ph id="ph1">`path`</ph> gibt einen relativen Pfad auf einem Laufwerk, wobei X ein Laufwerk oder Volume darstellt).</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>"X:/" (<ph id="ph1">`path`</ph> specified an absolute path on a given drive).</source>
          <target state="translated">"" X: "/" (<ph id="ph1">`path`</ph> einen absoluten Pfad auf einem bestimmten Laufwerk angegeben).</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>"<ph id="ph1">\\</ph>\ComputerName\SharedFolder" (a UNC path).</source>
          <target state="translated">"<ph id="ph1">\\</ph>\ComputerName\SharedFolder" (ein UNC-Pfad).</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>The .NET Framework does not support direct access to physical disks through paths that are device names, such as "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>.\PHYSICALDRIVE0 ".</source>
          <target state="translated">.NET Framework unterstützt keine direkten Zugriff auf physische Datenträger über Pfade, Gerätenamen, z. B. "<ph id="ph1">\\</ph><ph id="ph2">\\</ph>. \PHYSICALDRIVE0".</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Eine Liste der allgemeinen e/a-Aufgaben finden Sie <bpt id="p1">[</bpt>allgemeine e/a-Aufgaben<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>The following code example demonstrates a use of the <ph id="ph1">`GetPathRoot`</ph> method.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die <ph id="ph1">`GetPathRoot`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> enthält mindestens eines der in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph> definierten ungültigen Zeichen.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetPathRoot(System.String)">
          <source><ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> was passed to <ph id="ph2">&lt;paramref name="path" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> wurde an <ph id="ph2">&lt;paramref name="path" /&gt;</ph> übergeben.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetRandomFileName">
          <source>Returns a random folder name or file name.</source>
          <target state="translated">Gibt einen zufälligen Ordnernamen oder Dateinamen zurück.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetRandomFileName">
          <source>A random folder name or file name.</source>
          <target state="translated">Ein zufälliger Ordnername oder Dateiname.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetRandomFileName">
          <source>The <ph id="ph1">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> method returns a cryptographically strong, random string that can be used as either a folder name or a file name.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> Methodenrückgabe eine kryptografisch starke, zufällige Zeichenfolge, die als einen Ordnernamen oder ein Dateiname verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetRandomFileName">
          <source>Unlike <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> does not create a file.</source>
          <target state="translated">Im Gegensatz zu <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> erstellt eine Datei nicht.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetRandomFileName">
          <source>When the security of your file system is paramount, this method should be used instead of <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph>.</source>
          <target state="translated">Wenn die Sicherheit des Dateisystems im Vordergrund ist, sollte diese Methode verwendet werden, anstelle von <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetRandomFileName">
          <source>The following example show output from the <ph id="ph1">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> method.</source>
          <target state="translated">Das folgende Beispiel zeigt die Ausgabe der <ph id="ph1">&lt;xref:System.IO.Path.GetRandomFileName%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source>Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</source>
          <target state="translated">Erstellt eine eindeutig benannte temporäre Datei auf dem Datenträger mit einer Größe von 0 Byte und gibt den vollständigen Pfad dieser Datei zurück.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source>The full path of the temporary file.</source>
          <target state="translated">Der vollständige Pfad der temporären Datei.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>This method creates a temporary file with a .TMP file extension.</source>
          <target state="translated">Diese Methode erstellt eine temporäre Datei mit ein. Erweiterung der TMP-Datei.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>The temporary file is created within the user’s temporary folder, which is the path returned by the <ph id="ph1">&lt;xref:System.IO.Path.GetTempPath%2A&gt;</ph> method.</source>
          <target state="translated">Die temporäre Datei wird erstellt, in den temporären Ordner des Benutzers, der der Pfad ist zurückgegebenes die <ph id="ph1">&lt;xref:System.IO.Path.GetTempPath%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>The <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph> method will raise an <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> if it is used to create more than 65535 files without deleting previous temporary files.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph> Methode löst eine <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> Wenn es verwendet wird, um mehr als 65535 Dateien zu erstellen, ohne vorherige temporäre Dateien zu löschen.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>The <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph> method will raise an <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> if no unique temporary file name is available.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.IO.Path.GetTempFileName%2A&gt;</ph> Methode löst eine <ph id="ph2">&lt;xref:System.IO.IOException&gt;</ph> ist kein eindeutiger temporärer Dateiname verfügbar.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>To resolve this error, delete all unneeded temporary files.</source>
          <target state="translated">Um diesen Fehler zu beheben, löschen Sie alle nicht benötigte temporäre Dateien.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Eine Liste der allgemeinen e/a-Aufgaben finden Sie <bpt id="p1">[</bpt>allgemeine e/a-Aufgaben<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source>An I/O error occurs, such as no unique temporary file name is available.</source>
          <target state="translated">Ein E/A-Fehler tritt auf, z. B. ist kein eindeutiger temporärer Dateiname verfügbar.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempFileName">
          <source>This method was unable to create a temporary file.</source>
          <target state="translated">Diese Methode konnte keine temporäre Datei erstellen.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>for writing to the temporary directory.</source>
          <target state="translated">zum Schreiben in das temporäre Verzeichnis.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempFileName">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempPath">
          <source>Returns the path of the current user's temporary folder.</source>
          <target state="translated">Gibt den Pfad des temporären Ordners des aktuellen Benutzers zurück.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempPath">
          <source>The path to the temporary folder, ending with a backslash.</source>
          <target state="translated">Der Pfad zum temporären Ordner, endend mit einem umgekehrten Schrägstrich.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>This method checks for the existence of environment variables in the following order and uses the first path found:</source>
          <target state="translated">Diese Methode überprüft das Vorhandensein von Umgebungsvariablen in der folgenden Reihenfolge und verwendet den ersten gefundenen Pfad:</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The path specified by the TMP environment variable.</source>
          <target state="translated">Der Pfad, der durch die TMP-Umgebungsvariable angegeben wird.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The path specified by the TEMP environment variable.</source>
          <target state="translated">Der Pfad, der durch die Umgebungsvariable TEMP angegeben wird.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The path specified by the USERPROFILE environment variable.</source>
          <target state="translated">Der Pfad, der durch die USERPROFILE-Umgebungsvariable angegeben wird.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The Windows directory.</source>
          <target state="translated">Das Windows-Verzeichnis.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>The following code shows how to call the <ph id="ph1">&lt;xref:System.IO.Path.GetTempPath%2A&gt;</ph> method.</source>
          <target state="translated">Im folgenden Code wird das Aufrufen der <ph id="ph1">&lt;xref:System.IO.Path.GetTempPath%2A&gt;</ph>-Methode veranschaulicht.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>This example produces output similar to the following.</source>
          <target state="translated">Dieses Beispiel erzeugt die Ausgabe ähnlich der folgenden.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.IO.Path.GetTempPath">
          <source>The caller does not have the required permissions.</source>
          <target state="translated">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>for unrestricted access to environment variables.</source>
          <target state="translated">für den uneingeschränkten Zugriff auf Umgebungsvariablen.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.GetTempPath">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>The path to search for an extension.</source>
          <target state="translated">Der Pfad, in dem nach einer Erweiterung gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>Determines whether a path includes a file name extension.</source>
          <target state="translated">Bestimmt, ob ein Pfad eine Dateierweiterung enthält.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.IO.Path.HasExtension(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the characters that follow the last directory separator (<ph id="ph2">\\</ph>\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die Zeichen, die auf das letzte Verzeichnistrennzeichen (<ph id="ph2">\\</ph>\ oder /) oder Volumentrennzeichen (:) im Pfad folgen, einen Punkt (.) gefolgt von einem oder mehreren Zeichen enthalten; andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>Starting from the end of <ph id="ph1">`path`</ph>, this method searches for a period (.) followed by at least one character.</source>
          <target state="translated">Beginnend mit dem Ende des <ph id="ph1">`path`</ph>, diese Methode sucht nach einem Punkt (.) gefolgt von mindestens einem Zeichen.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>If this pattern is found before a <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, or <ph id="ph3">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph> character is encountered, this method returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Wenn dieses Muster, bevor gefunden wird eine <ph id="ph1">&lt;xref:System.IO.Path.DirectorySeparatorChar&gt;</ph>, <ph id="ph2">&lt;xref:System.IO.Path.AltDirectorySeparatorChar&gt;</ph>, oder <ph id="ph3">&lt;xref:System.IO.Path.VolumeSeparatorChar&gt;</ph> Zeichen festgestellt wird, gibt diese Methode zurück <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Eine Liste der allgemeinen e/a-Aufgaben finden Sie <bpt id="p1">[</bpt>allgemeine e/a-Aufgaben<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.HasExtension(System.String)">
          <source>The following code example demonstrates the use of the <ph id="ph1">`HasExtension`</ph> method.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von der <ph id="ph1">`HasExtension`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.IO.Path.HasExtension(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> enthält mindestens eines der in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph> definierten ungültigen Zeichen.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="F:System.IO.Path.InvalidPathChars">
          <source>Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <ph id="ph1">&lt;see cref="T:System.IO.Path" /&gt;</ph> class.</source>
          <target state="translated">Stellt ein plattformspezifisches Array von Zeichen bereit, die nicht in Pfadzeichenfolgenargumenten angegeben werden können, die an Member der <ph id="ph1">&lt;see cref="T:System.IO.Path" /&gt;</ph>-Klasse übergeben werden.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</source>
          <target state="translated">Das von dieser Methode zurückgegebene Array ist nicht unbedingt den vollständigen Satz von Zeichen enthalten, die in Datei- und Verzeichnisnamen ungültig sind.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>The full set of invalid characters can vary by file system.</source>
          <target state="translated">Der vollständige Satz von ungültigen Zeichen kann je nach Dateisystem variieren.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (<ph id="ph1">\&lt;</ph>), greater than (&gt;), pipe (&amp;#124;), backspace (\b), null (\0) and tab (\t).</source>
          <target state="translated">Z. B. auf Windows-basierten Desktopplattformen auf ungültige Pfadzeichen möglicherweise ASCII/Unicode-Zeichen 1 bis 31 sowie Anführungszeichen ("), kleiner als (<ph id="ph1">\&lt;</ph>), größer als (&gt;), Pipe (&amp;#124;), Rücktaste (\b), Null (\0) und Tabulator (\t).</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>Do not use <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph> if you think your code might execute in the same application domain as untrusted code.</source>
          <target state="translated">Verwenden Sie keine <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph> Wenn Sie vermuten, dass möglicherweise der Code in derselben Anwendungsdomäne wie nicht vertrauenswürdigem Code ausgeführt.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source><ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph> is an array, so its elements can be overwritten.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph> ein Array ist, damit seine Elemente überschrieben werden können.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>If untrusted code overwrites elements of <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>, it might cause your code to malfunction in ways that could be exploited.</source>
          <target state="translated">Wenn nicht vertrauenswürdiger Code Elemente überschreibt <ph id="ph1">&lt;xref:System.IO.Path.InvalidPathChars&gt;</ph>, es treten Codes zu Fehlfunktionen, die missbraucht werden könnten.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.InvalidPathChars">
          <source>The following code example demonstrates the use of the <ph id="ph1">`InvalidPathChars`</ph> property.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von der <ph id="ph1">`InvalidPathChars`</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>The path to test.</source>
          <target state="translated">Der zu testende Pfad.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>Gets a value indicating whether the specified path string contains a root.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob die angegebene Pfadzeichenfolge einen Stamm enthält.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="path" /&gt;</ph> contains a root; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="path" /&gt;</ph> einen Stamm enthält, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.IO.Path.IsPathRooted%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> if the first character is a directory separator character such as "<ph id="ph3">\\</ph>", or if the path starts with a drive letter and colon (:).</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.IO.Path.IsPathRooted%2A&gt;</ph> -Methode zurückkehrt <ph id="ph2">`true`</ph> , wenn das erste Zeichen wie z. B. einem Verzeichnistrennzeichen ist "<ph id="ph3">\\</ph>", oder wenn der Pfad mit einem Laufwerkbuchstaben und Doppelpunkt (:)) beginnt.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>For example, it returns <ph id="ph1">`true`</ph> for <ph id="ph2">`path`</ph> strings such as "<ph id="ph3">\\</ph>\MyDir<ph id="ph4">\\</ph>\MyFile.txt", "C:<ph id="ph5">\\</ph>\MyDir", or "C:MyDir".</source>
          <target state="translated">Es gibt z. B. <ph id="ph1">`true`</ph> für <ph id="ph2">`path`</ph> Zeigern auf Zeichenfolgen, z. B. "<ph id="ph3">\\</ph>\MyDir<ph id="ph4">\\</ph>\MyFile.txt", "" c: "<ph id="ph5">\\</ph>\MyDir", oder "C:MyDir".</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>It returns <ph id="ph1">`false`</ph> for <ph id="ph2">`path`</ph> strings such as "MyDir".</source>
          <target state="translated">Es gibt <ph id="ph1">`false`</ph> für <ph id="ph2">`path`</ph> Zeichenfolgen wie "MyDir".</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>This method does not verify that the path or file name exists.</source>
          <target state="translated">Diese Methode überprüft nicht, dass der Pfad oder Dateiname vorhanden ist.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>For a list of common I/O tasks, see <bpt id="p1">[</bpt>Common I/O Tasks<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</source>
          <target state="translated">Eine Liste der allgemeinen e/a-Aufgaben finden Sie <bpt id="p1">[</bpt>allgemeine e/a-Aufgaben<ept id="p1">](~/docs/standard/io/common-i-o-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source>The following code example demonstrates how the <ph id="ph1">`IsPathRooted`</ph> method can be used to test three strings.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie die <ph id="ph1">`IsPathRooted`</ph> Methode kann verwendet werden, um drei Zeichenfolgen zu testen.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.IO.Path.IsPathRooted(System.String)">
          <source><ph id="ph1">&lt;paramref name="path" /&gt;</ph> contains one or more of the invalid characters defined in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="path" /&gt;</ph> enthält mindestens eines der in <ph id="ph2">&lt;see cref="M:System.IO.Path.GetInvalidPathChars" /&gt;</ph> definierten ungültigen Zeichen.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="F:System.IO.Path.PathSeparator">
          <source>A platform-specific separator character used to separate path strings in environment variables.</source>
          <target state="translated">Ein plattformspezifisches Trennzeichen, das zur Trennung von Pfadzeichenfolgen in Umgebungsvariablen verwendet wird.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.PathSeparator">
          <source>On Windows-based desktop platforms, the value of this field is the semicolon (;) by default, but might vary on other platforms.</source>
          <target state="translated">Auf Windows-basierten PC-Plattformen ist der Wert dieses Felds das Semikolon (;) in der Standardeinstellung jedoch auf anderen Plattformen variieren kann.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.PathSeparator">
          <source>The following code example demonstrates the use of the <ph id="ph1">`PathSeparator`</ph> field.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von der <ph id="ph1">`PathSeparator`</ph> Feld.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="F:System.IO.Path.VolumeSeparatorChar">
          <source>Provides a platform-specific volume separator character.</source>
          <target state="translated">Stellt ein plattformspezifisches Volumetrennzeichen bereit.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.VolumeSeparatorChar">
          <source>The value of this field is a colon (:) on Windows and Macintosh, and a slash (/) on UNIX operating systems.</source>
          <target state="translated">Der Wert dieses Felds ist ein Doppelpunkt (:) unter Windows und Macintosh und ein Schrägstrich (/) für UNIX-Betriebssystemen.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.VolumeSeparatorChar">
          <source>This is most useful for parsing paths such as "c:\windows" or "MacVolume:System Folder".</source>
          <target state="translated">Dies ist besonders hilfreich für die Analyse von Pfaden, z. B. "c:\windows" oder "MacVolume: Ordner".</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.IO.Path.VolumeSeparatorChar">
          <source>The following code example demonstrates the use of the <ph id="ph1">`VolumeSeparatorChar`</ph> field.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von der <ph id="ph1">`VolumeSeparatorChar`</ph> Feld.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>