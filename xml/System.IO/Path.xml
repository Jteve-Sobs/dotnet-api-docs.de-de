<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7ee477deba03f922a5b4875f5fa99e93f9edcc64" /><Meta Name="ms.sourcegitcommit" Value="24dc380b0d43e8919d4e0d50409e8f0aeae98713" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="06/27/2019" /><Meta Name="ms.locfileid" Value="67411290" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Führt Vorgänge für <see cref="T:System.String" />-Instanzen aus, die Datei- oder Verzeichnispfadinformationen enthalten. Diese Vorgänge werden plattformübergreifend durchgeführt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Ein Pfad ist eine Zeichenfolge, die den Speicherort einer Datei oder Verzeichnis bereitstellt. Ein Pfad verweist nicht unbedingt auf einen Speicherort auf dem Datenträger; Beispielsweise kann ein Pfad an einem Speicherort im Arbeitsspeicher oder auf einem Gerät zugeordnet. Das genaue Format eines Pfads richtet sich nach der aktuellen Plattform. Beispielsweise kann bei einigen Systemen ein Pfad mit einem Buchstaben Laufwerk oder Volume beginnen, während dieses Element nicht in anderen Systemen vorhanden ist. Bei einigen Systemen können Dateipfade Erweiterungen enthalten den Typ der in der Datei gespeicherten Informationen angeben. Das Format der Erweiterung ist plattformabhängig; Klicken Sie z. B. einige Systeme beschränken Erweiterungen auf drei Zeichen, und andere nicht. Die aktuelle Plattform bestimmt auch den Satz von Zeichen verwendet, um die Elemente eines Pfads zu trennen und die Gruppe von Zeichen, die beim Angeben von Pfaden verwendet werden kann. Aufgrund dieser Unterschiede, die Felder der `Path` sowie das genaue Verhalten einiger Member der Klasse die `Path` Klasse hängen von der Plattform ab.  
  
 Ein Pfad kann absolut oder relativ Standortinformationen enthalten. Absolute Pfade vollständig Geben Sie einen Speicherort: Datei oder des Verzeichnisses eindeutig unabhängig von der aktuellen Position identifiziert werden kann. Relative Pfade geben Sie einen teilweise Ort: der aktuelle Speicherort dient als Ausgangspunkt beim Suchen einer Datei mit einem relativen Pfad angegeben. Um das aktuelle Verzeichnis zu ermitteln, rufen <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.  

 .NET Core 1.1 und höher und .NET Framework 4.6.2 und höher unterstützen auch den Zugriff auf Dateisystemobjekte, die Namen der Geräte, wie z. B. "\\? \C:\".

Weitere Informationen zu Path-Dateiformaten in Windows finden Sie unter [Pfad Dateiformate auf Windows-Systemen](~/docs/standard/io/file-path-formats.md).

 Die meisten Personen in der `Path` Klasse nicht mit dem Dateisystem und das Vorhandensein von einer Pfadzeichenfolge für den angegebene Datei nicht überprüfen. `Path` Klassenmember, die eine Pfadzeichenfolge, z. B. ändern <xref:System.IO.Path.ChangeExtension%2A>, wirken sich nicht auf den Namen der Dateien im Dateisystem. `Path` Elemente, jedoch überprüft den Inhalt einer angegebenen Pfadzeichenfolge und löst eine <xref:System.ArgumentException> -Ausnahme aus, wenn die Zeichenfolge Zeichen, die nicht in Pfadzeichenfolgen gültig sind, die enthält von zurückgegebenen Zeichen gemäß der <xref:System.IO.Path.GetInvalidPathChars%2A> Methode. Beispielsweise auf Windows-basierten desktop-Plattformen, ungültige Pfadzeichen sind Anführungszeichen ("), kleiner als (\<), größer als (>), Pipe (&#124;), Rücktaste (\b), Null (\0) und Unicode-Zeichen 16 bis 18 und 20 bis 25.  
  
 Die Mitglieder der `Path` Klasse ermöglichen es Ihnen, schnell und einfach Ausführen allgemeiner Vorgänge wie z. B. ermitteln, ob eine Dateinamenerweiterung Teil eines Pfads ist, und Kombinieren von zwei Zeichenfolgen in einem Pfadnamen.  
  
 Alle Mitglieder der `Path` -Klasse sind statisch und können daher ohne eine Instanz eines Pfads aufgerufen werden.  
  
> [!NOTE]
>  Klicken Sie im Member, die einen Pfad als eine Eingabezeichenfolge akzeptieren, dass der Pfad muss wohlgeformt sein, oder eine Ausnahme ausgelöst. Wenn ein Pfad vollständig qualifiziert ist, aber mit einem Leerzeichen beginnt, wird der Pfad beispielsweise nicht in Methoden der Klasse gekürzt. Aus diesem Grund wird der Pfad ist falsch formatiert, und wird eine Ausnahme ausgelöst. Auf ähnliche Weise kann keinen Pfad oder eine Kombination von Pfaden zweimal vollqualifiziert sein. Eine Ausnahme in den meisten Fällen wird in "c:\temp c:\windows" z. B. auch auslöst. Stellen Sie sicher, dass die Pfade wohlgeformt sind, bei Verwendung von Methoden, die eine Pfadzeichenfolge akzeptieren.  
  
 Bei Membern, die einen Pfad zu akzeptieren, kann der Pfad zu einer Datei oder nur ein Verzeichnis verweisen. Der angegebene Pfad kann auch auf einen relativen Pfad oder ein Universal Naming Convention (UNC)-Pfad für den Namen eines Servers und der freigabeeinstellungen verweisen. Beispielsweise sind alle folgenden Pfade zulässig:  
  
-   "c:\\\MyDir\\\MyFile.txt" in C#- oder "c:\MyDir\MyFile.txt" in Visual Basic.  
  
-   "c:\\\MyDir" in C#- oder "c:\MyDir" in Visual Basic.  
  
-   "" MyDir "\\\MySubdir" in C#- oder "MyDir\MySubDir" in Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" in c# oder "\\\MyServer\MyShare" in Visual Basic.  
  
 Da alle diese Vorgänge für Zeichenfolgen ausgeführt werden, ist es unmöglich, stellen Sie sicher, dass die Ergebnisse in allen Szenarien gültig sind. Z. B. die <xref:System.IO.Path.GetExtension%2A> -Methode analysiert eine Zeichenfolge, die an sie übergeben werden, und gibt die Erweiterung aus dieser Zeichenfolge. Dies bedeutet jedoch nicht, dass eine Datei mit dieser Erweiterung auf dem Datenträger vorhanden ist.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).   
  
## Examples  
 Das folgende Beispiel zeigt einige der wichtigsten Elemente der `Path` Klasse.  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Gewusst wie: Lesen und Schreiben einer neu erstellten Datendatei</related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt ein plattformspezifisches, alternatives Zeichen bereit, das zur Trennung von Verzeichnisebenen in einer Pfadzeichenfolge verwendet wird und eine hierarchische Dateisystemorganisation wiedergibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
In diesem Feld haben den gleichen Wert wie <xref:System.IO.Path.DirectorySeparatorChar>. `AltDirectorySeparatorChar` und <xref:System.IO.Path.DirectorySeparatorChar> gelten sowohl für die Trennung von Verzeichnisebenen in einer Pfadzeichenfolge.  
  
Der Wert dieses Felds ist ein Schrägstrich ("/") auf Windows und Unix-Betriebssystemen.  
  
## Examples  

Das folgende Beispiel zeigt <xref:System.IO.Path> Feldwerte auf Windows und Unix-basierte Systeme. Beachten Sie, dass Windows entweder den Schrägstrich unterstützt (die von zurückgegeben wird die <xref:System.IO.Path.AltDirectorySeparatorChar> Feld) oder den umgekehrten Schrägstrich (die von zurückgegeben wird die <xref:System.IO.Path.DirectorySeparatorChar> Feld) als Trennzeichen Pfadzeichen, während der Unix-basierten Systemen nur einen Schrägstrich unterstützen.

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die zu ändernden Pfadinformationen. Der Pfad darf keines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten Zeichen enthalten.</param>
        <param name="extension">Die neue Erweiterung (mit oder ohne führenden Punkt). Geben Sie <see langword="null" /> an, um eine vorhandene Erweiterung aus <paramref name="path" /> zu entfernen.</param>
        <summary>Ändert die Erweiterung einer Pfadzeichenfolge.</summary>
        <returns>Die geänderten Pfadinformationen.  
  
Auf Desktopplattformen auf Grundlage von Windows werden die Pfadinformationen unverändert zurückgegeben, wenn <paramref name="path" /> <see langword="null" /> oder eine leere Zeichenfolge ("") ist. Wenn <paramref name="extension" /><see langword="null" /> ist, enthält die zurückgegebene Zeichenfolge den angegebenen Pfad ohne die Erweiterung. Wenn <paramref name="path" /> keine Erweiterung besitzt und <paramref name="extension" /> nicht <see langword="null" /> ist, enthält die zurückgegebene Pfadzeichenfolge <paramref name="extension" />, angefügt an das Ende von <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn weder `path` noch `extension` enthält einen Punkt (.), `ChangeExtension` fügt den Punkt hinzu.  
  
 Die `extension` Parameter kann mehrere Punkte und keine gültigen Pfad-Zeichen enthalten und kann eine beliebige Länge aufweisen. Wenn `extension` ist `null`, die zurückgegebene Zeichenfolge enthält den Inhalt der `path` mit den letzten Punkt und alle folgenden Zeichen entfernt.  
  
 Wenn `extension` ist eine leere Zeichenfolge, die zurückgegebene Pfadzeichenfolge enthält den Inhalt der `path` mit jedem Zeichen, die nach dem letzten Punkt entfernt.  
  
 Wenn `path` verfügt nicht über eine Erweiterung und `extension` nicht `null`, enthält die zurückgegebene Zeichenfolge `path` gefolgt von `extension`.  
  
 Wenn `extension` nicht `null` und enthält keine führenden Punkt, der Zeitraum hinzugefügt wird.  
  
 Wenn `path` eine mehrfache Erweiterung durch mehrere Punkte getrennt, enthält die zurückgegebene Zeichenfolge enthält den Inhalt der `path` mit den letzten Punkt und alle folgenden Zeichen durch ersetzt `extension`. Z. B. wenn `path` "\Dir1\examples\pathtests.csx.txt" und `extension` "Cs", ist des geänderten Pfads "\Dir1\examples\pathtests.csx.cs".  
  
 Es ist nicht möglich, um sicherzustellen, dass die zurückgegebenen Ergebnisse in allen Szenarien gültig sind. Z. B. wenn `path` ist leer, `extension` angefügt wird.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung des der `ChangeExtension` Methode.  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kombiniert Zeichenfolgen zu einem Pfad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

Diese Methode ist vorgesehen, um die einzelne Zeichenfolgen in einer einzelnen Zeichenfolge zu verketten, die einen Dateipfad darstellt. Wenn nicht das erste Argument um einen Stammpfad enthält, allerdings werden alle vorherigen Pfadkomponenten ignoriert, und die zurückgegebene Zeichenfolge beginnt mit dieser Komponente Stammpfad. Als Alternative zu den `Combine` -Methode, erwägen Sie die Verwendung der <xref:System.IO.Path.Join%2A> oder <xref:System.IO.Path.TryJoin%2A> Methoden.

> [!IMPORTANT]
> Diese Methode wird davon ausgegangen, dass das erste Argument ein absoluter Pfad ist und die folgenden Argumente oder Argumente relative Pfade sind. Wenn dies nicht der Fall ist, und insbesondere, wenn nachfolgende Argumente, Zeichenfolgen, die vom Benutzer eingegebene sind, rufen Sie die <xref:System.IO.Path.Join%2A> oder <xref:System.IO.Path.TryJoin%2A> Methode stattdessen.

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths">Ein Array der Teile des Pfads.</param>
        <summary>Kombiniert ein Array von Zeichenfolgen zu einem Pfad.</summary>
        <returns>Die kombinierten Pfade.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

`paths` sollte ein Array der Teile der zu kombinierende Pfad. Wenn eine der nachfolgenden Pfade ein absoluter Pfad ist, setzt der Gruppierungsvorgang durchgeführt, beginnend mit diesem absoluten Pfad, verwerfen alle vorherigen kombinierten Pfade.  

Wenn jedes Element in `paths` jedoch die letzte Lektion ist kein Laufwerk, und endet nicht mit der <xref:System.IO.Path.DirectorySeparatorChar> oder die <xref:System.IO.Path.AltDirectorySeparatorChar> Zeichen, die `Combine` Methode fügt eine <xref:System.IO.Path.DirectorySeparatorChar> zwischen diesem Element und den darauffolgenden Zeichen. Beachten Sie, dass, wenn das Element in einem Pfadtrennzeichen beendet wird, die nicht geeignet für die Zielplattform ist die `Combine` Methode behält die ursprünglichen Pfadtrennzeichen und fügt Sie unterstützte Formate. Im folgenden Beispiel wird das Ergebnis auf Windows und Unix-basierte Systeme, bei der umgekehrten Schrägstrich als eine Pfadtrennzeichen.

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 Leere Zeichenfolgen werden aus den kombinierten Pfad weggelassen.  
  
 Wenn sie Leerzeichen haben die Parameter nicht analysiert.  
  
 Nicht alle für Verzeichnis-und Dateinamen ungültige Zeichen interpretiert werden als inakzeptabel ist, indem die `Combine` -Methode, da Sie diese Zeichen nach den Platzhalterzeichen suchen können. Während beispielsweise `Path.Combine("c:\\", "*.txt")` ist möglicherweise ungültig würden Sie eine Datei erstellen, es gilt als eine Suchzeichenfolge ein. Es ist daher erfolgreich von interpretiert die `Combine` Methode.  
  
## Examples  
 Das folgende Beispiel kombiniert ein Array von Zeichenfolgen zu einem Pfad.  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Eine der Zeichenfolgen im Array enthält eines oder mehrere der ungültigen Zeichen, die in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definiert sind.</exception>
        <exception cref="T:System.ArgumentNullException">Eine der Zeichenfolgen im Array ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Der erste zu kombinierende Pfad.</param>
        <param name="path2">Der zweite zu kombinierende Pfad.</param>
        <summary>Kombiniert zwei Zeichenfolgen zu einem Pfad.</summary>
        <returns>Die kombinierten Pfade. Wenn einer der beiden angegebenen Pfade eine Zeichenfolge der Länge 0 ist, gibt diese Methode den anderen Pfad zurück. Wenn <paramref name="path2" /> einen absoluten Pfad enthält, gibt diese Methode <paramref name="path2" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `path1` ist kein Laufwerkverweis (d. h. "C:" oder "D:") und endet nicht mit einem gültigen Trennzeichen, gemäß <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, oder <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> wird angefügt `path1` vor der Verkettung. Beachten Sie, dass bei `path1` endet in einem Pfadtrennzeichen, die nicht geeignet für die Zielplattform ist die `Combine` Methode behält die ursprünglichen Pfadtrennzeichen und fügt Sie unterstützte Formate. Im folgenden Beispiel wird das Ergebnis auf Windows und Unix-basierte Systeme, bei der umgekehrten Schrägstrich als eine Pfadtrennzeichen.  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 Wenn `path2` enthält keinen Stamm (z. B. wenn `path2` beginnt nicht mit einem Trennzeichen oder eine Laufwerkangabe), das Ergebnis ist eine Verkettung der beiden Pfade mit einem Trennzeichen dazwischen. Wenn `path2` ein Stammverzeichnis enthält, `path2` zurückgegeben wird.  
  
 Wenn sie Leerzeichen haben die Parameter nicht analysiert. Aus diesem Grund Wenn `path2` enthält Leerzeichen (z. B. "\file.txt"), die <xref:System.IO.Path.Combine%2A> Methode fügt `path2` zu `path1` anstatt nur `path2`.  
  
 Nicht alle für Verzeichnis-und Dateinamen ungültige Zeichen interpretiert werden als inakzeptabel ist, indem die `Combine` -Methode, da Sie diese Zeichen nach den Platzhalterzeichen suchen können. Während beispielsweise `Path.Combine("c:\\", "*.txt")` ist möglicherweise ungültig würden Sie eine Datei erstellen, es gilt als eine Suchzeichenfolge ein. Es ist daher erfolgreich von interpretiert die `Combine` Methode.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der `Combine` Methode für eine Windows-basierte desktop-Plattform.  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" /> oder <paramref name="path2" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" /> oder <paramref name="path2" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">Der erste zu kombinierende Pfad.</param>
        <param name="path2">Der zweite zu kombinierende Pfad.</param>
        <param name="path3">Der dritte zu kombinierende Pfad.</param>
        <summary>Kombiniert drei Zeichenfolgen zu einem Pfad.</summary>
        <returns>Die kombinierten Pfade.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1` sollte ein absoluter Pfad sein (z. B. "d:\archives" oder "\\\archives\public"). Wenn `path2` oder `path3` ist auch ein absoluter Pfad sein, kombinieren Vorgang verwirft alle zuvor kombiniert Pfade und Zurücksetzen von Kennwörtern zu diesem absoluten Pfad.  
  
 Leere Zeichenfolgen werden aus den kombinierten Pfad weggelassen.  
  
 Wenn `path1` oder `path2` ist kein Laufwerkverweis (d. h. "C:" oder "D:") und endet nicht mit einem gültigen Trennzeichen, gemäß <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, oder <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> wird angefügt `path1` oder `path2` vor der Verkettung. Beachten Sie, dass bei `path1` oder `path2` endet in einem Pfadtrennzeichen, die nicht geeignet für die Zielplattform ist die `Combine` Methode behält die ursprünglichen Pfadtrennzeichen und fügt Sie unterstützte Formate. Im folgenden Beispiel wird das Ergebnis auf Windows und Unix-basierte Systeme, bei der umgekehrten Schrägstrich als eine Pfadtrennzeichen. 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 Wenn `path2` enthält keinen Stamm (z. B. wenn `path2` beginnt nicht mit einem Trennzeichen oder eine Laufwerkangabe), das Ergebnis ist eine Verkettung der beiden Pfade mit einem Trennzeichen dazwischen. Wenn `path2` ein Stammverzeichnis enthält, `path2` zurückgegeben wird.  
  
 Wenn sie Leerzeichen haben die Parameter nicht analysiert. Aus diesem Grund Wenn `path2` enthält Leerzeichen (z. B. "\file.txt"), die <xref:System.IO.Path.Combine%2A> Methode fügt `path2` zu `path1`.  
  
 Nicht alle für Verzeichnis-und Dateinamen ungültige Zeichen interpretiert werden als inakzeptabel ist, indem die `Combine` -Methode, da Sie diese Zeichen nach den Platzhalterzeichen suchen können. Während beispielsweise `Path.Combine("c:\\", "*.txt")` ist möglicherweise ungültig würden Sie eine Datei erstellen, es gilt als eine Suchzeichenfolge ein. Es ist daher erfolgreich von interpretiert die `Combine` Methode.  
  
   
  
## Examples  
 Das folgende Beispiel kombiniert die Pfade an.  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" />, <paramref name="path2" /> oder <paramref name="path3" /> enthält mindestens ein ungültiges Zeichen gemäß der Definition in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" />, <paramref name="path2" /> oder <paramref name="path3" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Der erste zu kombinierende Pfad.</param>
        <param name="path2">Der zweite zu kombinierende Pfad.</param>
        <param name="path3">Der dritte zu kombinierende Pfad.</param>
        <param name="path4">Der vierte zu kombinierende Pfad.</param>
        <summary>Kombiniert vier Zeichenfolgen zu einem Pfad.</summary>
        <returns>Die kombinierten Pfade.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1` sollte ein absoluter Pfad sein (z. B. "d:\archives" oder "\\\archives\public"). Wenn einer der folgenden Pfade auch einen absoluten Pfad ist, wird der Gruppierungsvorgang durchgeführt verwirft alle zuvor kombinierten Pfade, und klicken Sie auf diesem absoluten Pfad zurückgesetzt.  
  
 Leere Zeichenfolgen werden aus den kombinierten Pfad weggelassen.  
  
 Wenn `path1`, `path2`, oder `path3` ist kein Laufwerkverweis (d. h. "C:" oder "D:") und endet nicht mit einem gültigen Trennzeichen, gemäß <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, oder <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> angefügt ist vor der Verkettung. Beachten Sie, dass bei `path1`, `path2`, oder `path3` endet in einem Pfadtrennzeichen, die nicht geeignet für die Zielplattform ist die `Combine` Methode behält die ursprünglichen Pfadtrennzeichen und fügt Sie unterstützte Formate. Im folgenden Beispiel wird das Ergebnis auf Windows und Unix-basierte Systeme, bei der umgekehrten Schrägstrich als eine Pfadtrennzeichen. 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 Wenn `path2` enthält keinen Stamm (z. B. wenn `path2` beginnt nicht mit einem Trennzeichen oder eine Laufwerkangabe), das Ergebnis ist eine Verkettung der beiden Pfade mit einem Trennzeichen dazwischen. Wenn `path2` ein Stammverzeichnis enthält, `path2` zurückgegeben wird.  
  
 Wenn sie Leerzeichen haben die Parameter nicht analysiert. Aus diesem Grund Wenn `path2` enthält Leerzeichen (z. B. "\file.txt"), die <xref:System.IO.Path.Combine%2A> Methode fügt `path2` zu `path1`.  
  
 Nicht alle für Verzeichnis-und Dateinamen ungültige Zeichen interpretiert werden als inakzeptabel ist, indem die `Combine` -Methode, da Sie diese Zeichen nach den Platzhalterzeichen suchen können. Während beispielsweise `Path.Combine("c:\\", "*.txt")` ist möglicherweise ungültig würden Sie eine Datei erstellen, es gilt als eine Suchzeichenfolge ein. Es ist daher erfolgreich von interpretiert die `Combine` Methode.  
  
   
  
## Examples  
 Im folgende Beispiel werden vier Pfade kombiniert.  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> oder <paramref name="path4" /> enthält mindestens ein ungültiges Zeichen gemäß der Definition in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" /> oder <paramref name="path4" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt ein plattformspezifisches Zeichen bereit, das zur Trennung von Verzeichnisebenen in einer Pfadzeichenfolge verwendet wird und eine hierarchische Dateisystemorganisation wiedergibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.IO.Path.AltDirectorySeparatorChar> und `DirectorySeparatorChar` gelten sowohl für die Trennung von Verzeichnisebenen in einer Pfadzeichenfolge.  
  
Wenn Sie .NET Core verwenden zum Entwickeln von Anwendungen, die auf mehreren Plattformen ausgeführt werden:

- Wenn Sie, das Verzeichnistrennzeichen zu programmieren lieber, verwenden Sie einen Schrägstrich (`/`) Zeichen. Dabei handelt es sich dem nur bekannte Verzeichnistrennzeichen auf Unix-Systemen, wie die Ausgabe des Beispiels zeigt, ist die <xref:System.IO.Path.AltDirectorySeparatorChar> auf Windows.

- Verwenden Sie Verketten von Zeichenfolgen, um dynamisch das Pfadtrennzeichen zur Laufzeit abrufen und in Dateisystempfaden einbinden. Ein auf ein Objekt angewendeter 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```
   ```vb
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ``` 
   Sie können auch abrufen, den Wert aus der <xref:System.IO.Path.AltDirectorySeparatorChar> -Eigenschaft, da es auf Windows und Unx-basierte Systeme identisch ist.

- Abrufen der <xref:System.IO.Path.AltDirectorySeparatorChar> Eigenschaft

Wenn Ihre Anwendung nicht plattformübergreifend ist, können Sie das Trennzeichen, die für Ihr Betriebssystem.

## Examples  

Das folgende Beispiel zeigt <xref:System.IO.Path> Feldwerte auf Windows und Unix-basierte Systeme. Beachten Sie, dass Windows entweder den Schrägstrich unterstützt (die von zurückgegeben wird die <xref:System.IO.Path.AltDirectorySeparatorChar> Feld) oder den umgekehrten Schrägstrich (die von zurückgegeben wird die <xref:System.IO.Path.DirectorySeparatorChar> Feld) als Trennzeichen Pfadzeichen, während der Unix-basierten Systemen nur einen Schrägstrich unterstützen.  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : string -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>Gibt die Verzeichnisinformationen für den angegebenen Pfad in Form einer Zeichenspanne zurück.</summary>
        <returns>Verzeichnisinformationen für <paramref name="path" /> oder eine leere Spanne, wenn <paramref name="path" /> <see langword="null" /> ist, eine leere Spanne oder ein Stamm (wie \, C: oder \\server\share).</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad einer Datei oder eines Verzeichnisses.</param>
        <summary>Gibt die Verzeichnisinformationen für die angegebene Pfadzeichenfolge zurück.</summary>
        <returns>Verzeichnisinformationen für <paramref name="path" /> oder <see langword="null" />, wenn <paramref name="path" /> ein Stammverzeichnis bezeichnet oder NULL ist. Gibt <see cref="F:System.String.Empty" /> zurück, wenn <paramref name="path" /> keine Verzeichnisinformationen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In den meisten Fällen, die von dieser Methode zurückgegebene Zeichenfolge enthält alle Zeichen im Pfad bis, jedoch nicht einschließlich dem letzten <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>. Wenn der Pfad des ein Stammverzeichnis, z. B. besteht aus "c:\\", wird Null zurückgegeben. Beachten Sie, dass es sich bei dieser Methode mithilfe von Pfaden nicht unterstützt "Datei:". Da keine der zurückgegebene Pfad enthält die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, übergeben die zurückgegebenen Pfad zurück in die <xref:System.IO.Path.GetDirectoryName%2A> Methode führt dazu, in das Abschneiden von eine Ordnerebene pro nachfolgenden Aufruf der Ergebniszeichenfolge. Beispielsweise der Pfad "C:\Directory\SubDirectory\test.txt" übergeben, in der <xref:System.IO.Path.GetDirectoryName%2A> "C:\Directory\SubDirectory"-Methode zurück. Übergeben an dieser Begriff "C:\Directory\SubDirectory" <xref:System.IO.Path.GetDirectoryName%2A> führt zu "C:\Directory".  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der `GetDirectoryName` Methode für eine Windows-basierte desktop-Plattform.  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" />-Parameter enthält nur ungültige Zeichen, ist leer oder enthält nur Leerzeichen.</exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.IO.IOException" /> ab.  
  
</para>
          </block>  
  
 Der <paramref name="path" />-Parameter überschreitet die vom System definierte Maximallänge.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Der Dateipfad, aus dem die Erweiterung abgerufen werden soll.</param>
        <summary>Gibt die Erweiterung eines Dateipfads zurück, der durch eine schreibgeschützte Zeichenspanne dargestellt wird.</summary>
        <returns>Die Erweiterung des angegebenen Pfads (einschließlich des Punkts „.“) oder <see cref="P:System.ReadOnlySpan`1.Empty" />, falls <paramref name="path" /> keine Erweiterungsinformationen umfasst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Diese Methode ruft die Erweiterung der `path` Überwachungspakete `path` für einen bestimmten Zeitraum ("."), beginnend mit dem letzten Zeichen in der Spanne schreibgeschützt und auf das erste Zeichen fortfahren. Wenn ein Punkt gefunden wird, bevor Sie eine <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar> Zeichen, die zurückgegebene schreibgeschützten Spanne enthält den Zeitraum und die Zeichen nach ist, andernfalls <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> zurückgegeben wird.  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Pfadzeichenfolge, aus der die Erweiterung abgerufen werden soll.</param>
        <summary>Gibt die Erweiterung (einschließlich des Punkts „.“) der angegebenen Pfadzeichenfolge zurück.</summary>
        <returns>Die Erweiterung des angegebenen Pfads (einschließlich des Punkts ".") oder <see langword="null" /> oder <see cref="F:System.String.Empty" />. Wenn <paramref name="path" /> gleich <see langword="null" /> ist, gibt <see cref="M:System.IO.Path.GetExtension(System.String)" /> <see langword="null" /> zurück. Wenn <paramref name="path" /> keine Informationen über die Erweiterung enthält, gibt <see cref="M:System.IO.Path.GetExtension(System.String)" /><see cref="F:System.String.Empty" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Diese Methode ruft die Erweiterung der `path` Überwachungspakete `path` für einen Punkt (.), beginnend mit dem letzten Zeichen in `path` und auf das erste Zeichen fortgesetzt. Wenn ein Punkt gefunden wird, bevor Sie eine <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar> Zeichen ist, enthält die zurückgegebene Zeichenfolge den Zeitraum und die Zeichen nach dem ist, andernfalls <xref:System.String.Empty?displayProperty=nameWithType> zurückgegeben wird.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).
 
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der `GetExtension` Methode für eine Windows-basierte desktop-Plattform.  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Eine schreibgeschützte Spanne, die den Pfad enthält, aus dem der Dateiname und die Erweiterung abgerufen werden sollen.</param>
        <summary>Gibt den Dateinamen und die Erweiterung eines Dateipfads zurück, der durch eine schreibgeschützte Zeichenspanne dargestellt wird.</summary>
        <returns>Die Zeichen nach dem letzten Verzeichnistrennzeichen in <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Die zurückgegebene schreibgeschützten Spanne enthält die Zeichen des Pfads, der das letzte Trennzeichen in folgen `path`. Wenn das letzte Zeichen in `path` ein Volume oder das Verzeichnis Volumetrennzeichen ist, gibt die Methode zurück <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>. Wenn `path` enthält keine Zeichen als Trennzeichen, gibt die Methode zurück `path`.

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Pfadzeichenfolge, aus der der Dateiname und die Erweiterung abgerufen werden sollen.</param>
        <summary>Gibt den Dateinamen und die Erweiterung der angegebenen Pfadzeichenfolge zurück.</summary>
        <returns>Die Zeichen nach dem letzten Verzeichnistrennzeichen in <paramref name="path" />. Wenn das letzte Zeichen von <paramref name="path" /> ein Verzeichnis- bzw. Volumetrennzeichen ist, gibt diese Methode <see cref="F:System.String.Empty" /> zurück. Wenn <paramref name="path" /> gleich <see langword="null" /> ist, gibt die Methode <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Der zurückgegebene Wert ist `null` ist der Dateipfad `null`.  
  
Die Trennzeichen verwendet, um den Anfang des Dateinamens bestimmen sind <xref:System.IO.Path.DirectorySeparatorChar> und <xref:System.IO.Path.AltDirectorySeparatorChar>.  

Da *\\* ist ein zulässiger Dateiname unter Unix `GetFileName` unter UNIX-Plattformen ausgeführt kann nicht ordnungsgemäß gibt den Dateinamen zurück, aus einem Windows-basierten Pfad wie *C:\\"MyDir"\\myfile.ext*, aber `GetFileName` Ausführung unter Windows-basierten Plattformen kann ordnungsgemäß den Dateinamen aus einem Unix-basierte Pfad wie zurückgeben */tmp/myfile.ext*, sodass das Verhalten der `GetFileName` Methode ist nicht unbedingt mit auf Unix-basierte und Windows-basierten Plattformen identisch.

Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Verhalten der `GetFileName` Methode für eine Windows-basierte desktop-Plattform.  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Eine schreibgeschützte Spanne, die den Pfad enthält, aus dem der Dateiname ohne die Erweiterung abgerufen werden soll.</param>
        <summary>Gibt den Dateinamen ohne die Erweiterung eines Dateipfads zurück, der durch eine schreibgeschützte Zeichenspanne dargestellt wird.</summary>
        <returns>Die von <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" /> zurückgegebenen Zeichen in der schreibgeschützten Spanne ohne den letzten Punkt (.) und alle folgenden Zeichen.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad der Datei.</param>
        <summary>Gibt den Dateinamen der angegebenen Pfadzeichenfolge ohne Erweiterung zurück.</summary>
        <returns>Die von <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" /> zurückgegebene Zeichenfolge ohne den letzten Punkt (.) und alle folgenden Zeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überprüft nicht, dass der Pfad oder Dateiname vorhanden ist.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung des der `GetFileNameWithoutExtension` Methode.  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für das die absoluten Pfadinformationen abgerufen werden sollen.</param>
        <summary>Gibt den absoluten Pfad für die angegebene Pfadzeichenfolge zurück.</summary>
        <returns>Der vollqualifizierte Speicherort von <paramref name="path" />, z. B. "C:\MyFile.txt".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Der absolute Pfad enthält alle Informationen, um eine Datei oder ein Verzeichnis auf einem System zu suchen.  
  
 Die Datei oder das Verzeichnis, die anhand des `path` muss nicht vorhanden. Z. B. wenn *c:\temp\newdir* ist das Verzeichnis des aktuelle Aufrufen `GetFullPath` auf einen Dateinamen ein, z. B. *"Test.txt"* gibt *c:\temp\newdir\test.txt*. Die Datei muss nicht vorhanden sein.  

> [!IMPORTANT]
> Wenn `path` ist ein relativer Pfad, diese Überladung gibt einen vollqualifizierten Pfad, der auf das aktuelle Laufwerk und das aktuelle Verzeichnis basieren kann. Das aktuelle Laufwerk und das aktuelle Verzeichnis können sich jederzeit ändern, wie eine Anwendung ausgeführt wird. Daher kann der von dieser Überladung zurückgegebene Pfad im Voraus bestimmt werden. Rufen Sie zum Zurückgeben eines deterministischen Pfads der <xref:System.IO.Path.GetFullPath(System.String,System.String)> überladen. Sie können auch Aufrufen der <xref:System.IO.Path.IsPathFullyQualified%2A> Methode, um zu bestimmen, ob ein Pfad voll qualifiziert ist oder einen Pfad relativ und somit auch, ob ein Aufruf zum `GetFullPath` ist erforderlich.

 Aber wenn `path` vorhanden ist, der Aufrufer muss über die Berechtigung zum Abrufen von Informationen über Pfade für `path`. Beachten Sie, dass im Gegensatz zu den meisten Elementen von der <xref:System.IO.Path> Klasse diese Methode greift auf das Dateisystem.  
  
 Diese Methode verwendet das aktuelle Verzeichnis und das aktuelle Volumeinformationen zur vollständigen Qualifizierung `path`. Bei Angabe eine Datei nur im Namen `path`, `GetFullPath` gibt den vollqualifizierten Pfad des aktuellen Verzeichnisses.  
  
 Wenn Sie in einem kurzen Dateinamen übergeben, wird er zu einer langen Dateinamen erweitert.  
  
 Wenn ein Pfad keine signifikanten Zeichen enthält, ist ungültig, wenn sie eine oder mehrere enthält "." Zeichen, gefolgt von einer beliebigen Anzahl von Leerzeichen und es entweder als analysiert werden "."oder"..".  

.NET Core 1.1 und höher und .NET Framework 4.6.2 und höher unterstützen auch die Pfade, die Gerätenamen, z. B. enthalten "\\? \C:\".

Weitere Informationen zu Path-Dateiformaten in Windows finden Sie unter [Pfad Dateiformate auf Windows-Systemen](~/docs/standard/io/file-path-formats.md). Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).
  
## Examples  
 Das folgende Beispiel zeigt die `GetFullPath` Methode für eine Windows-basierte desktop-Plattform.  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), besteht nur aus Leerraum oder enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültige Zeichen.  
  
- oder - 
Das System konnte den absoluten Pfad nicht abrufen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> enthält einen Doppelpunkt („:“), der kein Teil eines Volumenbezeichners (z.B. „c:\\“) ist.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf den Pfad.</permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="basePath" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer Pfad zum Verketten mit <paramref name="basePath" />.</param>
        <param name="basePath">Der Anfang eines vollqualifizierten Pfads.</param>
        <summary>Gibt einen absoluten Pfad aus einem vollqualifizierten Basispfad und einem relativen Pfad zurück.</summary>
        <returns>Der absolute Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Wenn `path` ist ein leerer Pfad, der Methodenrückgabe `basePath`. Wenn `path` ist ein vollqualifizierter Pfad, der Methode übergibt `path` auf die <xref:System.IO.Path.GetFullPath(System.String)> Methode und gibt das Ergebnis zurück.

Verwenden Sie diese Methode zurückgegeben wird, einen deterministischen Pfad basierend auf ein angegebenes Volume und wurden die nutzungsbeschränkungen entfernt Verzeichnis auf, wenn Sie relative Pfade verwenden. Verwenden eine vordefinierte `basePath` anstelle basierend auf den aktuellen Laufwerk Directory dient als Schutz vor unerwünschter Dateipfade, die durch unerwartete Änderungen in das aktuelle Laufwerk und Verzeichnis verursacht werden. 

## <a name="example"></a>Beispiel

Im folgende Beispiel wird eine Variable, `basePath`, um das aktuelle Verzeichnis einer Anwendung repräsentiert. Anschließend übergibt es an der `GetFullPath` Methode, um einen vollqualifizierten Pfad zum Datenverzeichnis der Anwendung abzurufen.

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-vb[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> oder <paramref name="basePath" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="basePath" /> ist kein vollqualifizierter Pfad.

- oder -

<paramref name="path" /> oder <paramref name="basePath" /> enthält ungültige Pfadzeichen, z. B. U+0000.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein Array ab, das die Zeichen enthält, die in Dateinamen nicht zulässig sind.</summary>
        <returns>Ein Array, das die Zeichen enthält, die in Dateinamen nicht zulässig sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von dieser Methode zurückgegebenen Arrays wird nicht unbedingt den vollständigen Satz von Zeichen enthalten, die in Datei- und Verzeichnisnamen ungültig sind. Der vollständige Satz von ungültigen Zeichen kann je nach Dateisystem variieren. Z. B. auf Windows-basierte desktop-Plattformen ungültige Pfadzeichen möglicherweise ASCII-/Unicode-Zeichen 1 bis 31 sowie Anführungszeichen ("), kleiner als (\<), größer als (>), Pipe (&#124;), Rücktaste (\b), Null (\0) und Tabulator (\t).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.IO.Path.GetInvalidFileNameChars%2A> Methode und die <xref:System.IO.Path.GetInvalidPathChars%2A> Methode, um ungültige Zeichen abzurufen.  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein Array ab, das die Zeichen enthält, die in Pfadnamen nicht zulässig sind.</summary>
        <returns>Ein Array, das die Zeichen enthält, die in Pfadnamen nicht zulässig sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von dieser Methode zurückgegebenen Arrays wird nicht unbedingt den vollständigen Satz von Zeichen enthalten, die in Datei- und Verzeichnisnamen ungültig sind. Der vollständige Satz von ungültigen Zeichen kann je nach Dateisystem variieren. Z. B. auf Windows-basierte desktop-Plattformen ungültige Pfadzeichen möglicherweise ASCII-/Unicode-Zeichen 1 bis 31 sowie Anführungszeichen ("), kleiner als (\<), größer als (>), Pipe (&#124;), Rücktaste (\b), Null (\0) und Tabulator (\t).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.IO.Path.GetInvalidFileNameChars%2A> Methode und die <xref:System.IO.Path.GetInvalidPathChars%2A> Methode, um ungültige Zeichen abzurufen.  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad, von dem Informationen über das Stammverzeichnis abgerufen werden sollen.</param>
        <summary>Ruft Informationen über das Stammverzeichnis aus dem Pfad ab, der in der angegebenen Zeichenspanne enthalten ist.</summary>
        <returns>Eine Zeichenspanne mit dem Stammverzeichnis von `path`.</returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad, von dem Informationen über das Stammverzeichnis abgerufen werden sollen.</param>
        <summary>Ruft die Informationen über das Stammverzeichnis des angegebenen Pfads ab.</summary>
        <returns>Das Stammverzeichnis von <paramref name="path" /> oder <see langword="null" />, wenn <paramref name="path" /> <see langword="null" /> ist, oder eine leere Zeichenfolge, wenn <paramref name="path" /> keine Informationen über das Stammverzeichnis enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überprüft nicht, dass der Pfad oder Dateiname vorhanden ist.  
  
 Mögliche Muster für die Zeichenfolge, die von dieser Methode zurückgegebene lauten wie folgt aus:  
  
- Eine leere Zeichenfolge (`path` gibt einen relativen Pfad auf dem aktuellen Laufwerk oder Volume).  
  
- "\" (`path` einen absoluten Pfad für das aktuelle Laufwerk angegeben).  
  
- "X" (`path` gibt einen relativen Pfad auf einem Laufwerk, wobei X ein Laufwerk oder Volume darstellt).  
  
- "X:\" (`path` gibt einen absoluten Pfad auf einem bestimmten Laufwerk).  
  
- "\\\ComputerName\SharedFolder" (ein UNC-Pfad).  
  
- "\\\\\?\C:" (eine DOS-Gerätepfad, in .NET Core 1.1 und höher und in .NET Framework 4.6.2 und höher unterstützt)
   
 Weitere Informationen zu Dateipfade unter Windows, finden Sie unter [Pfad Dateiformate auf Windows-Systemen](~/docs/standard/io/file-path-formats.md). Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung des der `GetPathRoot` Methode.  
  
 [!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
 [!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
 [!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.  
  
- oder - 
 <see cref="F:System.String.Empty" /> wurde an <paramref name="path" /> übergeben.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen zufälligen Ordnernamen oder Dateinamen zurück.</summary>
        <returns>Ein zufälliger Ordnername oder Dateiname.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Path.GetRandomFileName%2A> Methode gibt eine kryptografisch starke, zufällige Zeichenfolge, die als einen Ordnernamen oder ein Dateiname verwendet werden kann. Im Gegensatz zu <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> erstellt eine Datei nicht. Wenn die Sicherheit Ihres Dateisystems entscheidend ist, sollte diese Methode verwendet werden, anstelle von <xref:System.IO.Path.GetTempFileName%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Ausgabe der <xref:System.IO.Path.GetRandomFileName%2A> Methode.  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="relativeTo">Der Quellpfad, zu dem das Ergebnis relativ sein muss. Dieser Pfad wird nicht immer als Verzeichnis betrachtet.</param>
        <param name="path">Der Zielpfad.</param>
        <summary>Gibt einen relativen Pfad von einem Pfad zu einem anderen zurück.</summary>
        <returns>Der relative Pfad oder <paramref name="path" />, wenn die Pfade nicht denselben Stamm aufweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Pfade aufgelöst werden, durch den Aufruf der <xref:System.IO.Path.GetFullPath%2A> Methode vor dem Berechnen der Differenz. Die Methode verwendet den Pfad den Standardvergleich-Datei für die aktuelle Plattform (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> für Windows und MacOs <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> für Linux. 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relativeTo" /> oder <paramref name="path" /> ist <see langword="null" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine eindeutig benannte temporäre Datei auf dem Datenträger mit einer Größe von 0 Byte und gibt den vollständigen Pfad dieser Datei zurück.</summary>
        <returns>Der vollständige Pfad der temporären Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine temporäre Datei mit ein. TMP-Dateierweiterung. Die temporäre Datei wird erstellt, in den temporären Ordner des Benutzers, der der Pfad ist zurückgegebenes der <xref:System.IO.Path.GetTempPath%2A> Methode.  
  
 Die <xref:System.IO.Path.GetTempFileName%2A> Methode löst eine <xref:System.IO.IOException> Wenn es verwendet wird, um mehr als 65535 Dateien zu erstellen, ohne vorherige temporäre Dateien zu löschen.  
  
 Die <xref:System.IO.Path.GetTempFileName%2A> Methode löst eine <xref:System.IO.IOException> ist kein eindeutiger temporärer Dateiname verfügbar. Um diesen Fehler zu beheben, löschen Sie alle nicht benötigte temporäre Dateien.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler tritt auf, z. B. ist kein eindeutiger temporärer Dateiname verfügbar.  
  
- oder -
  
 Diese Methode konnte keine temporäre Datei erstellen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in das temporäre Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Pfad des temporären Ordners des aktuellen Benutzers zurück.</summary>
        <returns>Der Pfad zum temporären Ordner, endend mit einem umgekehrten Schrägstrich.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird das Vorhandensein von Umgebungsvariablen in der folgenden Reihenfolge überprüft und verwendet den ersten Pfad gefunden:  
  
1.  Der Pfad, der durch die TMP-Umgebungsvariable angegeben wird.  
  
2.  Der Pfad, der durch die Umgebungsvariable TEMP angegeben wird.  
  
3.  Der Pfad, der durch die Umgebungsvariable USERPROFILE angegeben wird.  
  
4.  Das Windows-Verzeichnis.  
  
   
  
## Examples  
 Im folgenden Code wird das Aufrufen der <xref:System.IO.Path.GetTempPath%2A>-Methode veranschaulicht.  
  
```vb  
result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 In diesem Beispiel wird die Ausgabe ähnlich der folgenden.  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">für einen uneingeschränkten Zugriff auf Umgebungsvariablen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad, in dem nach einer Erweiterung gesucht werden soll.</param>
        <summary>Legt fest, ob der Pfad, der durch die angegebene Zeichenspanne dargestellt wird, eine Erweiterung enthält.</summary>
        <returns><see langword="true" />, wenn die Zeichen, die auf das letzte Verzeichnistrennzeichen oder Volumentrennzeichen im Pfad folgen, einen Punkt (.) gefolgt von einem oder mehreren Zeichen enthalten; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

In einen abschließenden Punkt `path` ist eine Erweiterung nicht berücksichtigt.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad, in dem nach einer Erweiterung gesucht werden soll.</param>
        <summary>Bestimmt, ob ein Pfad eine Dateierweiterung enthält.</summary>
        <returns><see langword="true" />, wenn die Zeichen, die auf das letzte Verzeichnistrennzeichen (\\\ oder /) oder Volumentrennzeichen (:) im Pfad folgen, einen Punkt (.) gefolgt von einem oder mehreren Zeichen enthalten; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ab dem Ende des `path`, diese Methode sucht nach einem Punkt (.) gefolgt von mindestens einem Zeichen. Wenn dieses Muster, bevor gefunden wird eine <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, oder <xref:System.IO.Path.VolumeSeparatorChar> Zeichen festgestellt wird, gibt diese Methode zurück `true`.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `HasExtension`-Methode gezeigt.  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt ein plattformspezifisches Array von Zeichen bereit, die nicht in Pfadzeichenfolgenargumenten angegeben werden können, die an Member der <see cref="T:System.IO.Path" />-Klasse übergeben werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von dieser Methode zurückgegebenen Arrays wird nicht unbedingt den vollständigen Satz von Zeichen enthalten, die in Datei- und Verzeichnisnamen ungültig sind. Der vollständige Satz von ungültigen Zeichen kann je nach Dateisystem variieren. Z. B. auf Windows-basierte desktop-Plattformen ungültige Pfadzeichen möglicherweise ASCII-/Unicode-Zeichen 1 bis 31 sowie Anführungszeichen ("), kleiner als (\<), größer als (>), Pipe (&#124;), Rücktaste (\b), Null (\0) und Tabulator (\t).  
  
> [!CAUTION]
>  Verwenden Sie keine <xref:System.IO.Path.InvalidPathChars> sollten Sie Ihren Code in der gleichen Anwendungsdomäne als nicht vertrauenswürdigen Code ausführen kann. <xref:System.IO.Path.InvalidPathChars> ist ein Array, an, damit seine Elemente überschrieben werden können. Wenn nicht vertrauenswürdiger Code Elemente überschreibt <xref:System.IO.Path.InvalidPathChars>, kann dies in Ihrem Code zu Fehlfunktionen, die ausgenutzt werden könnten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung der `InvalidPathChars` Eigenschaft.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob ein Dateipfad vollqualifiziert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

Die Überladungen von der `IsPathFullyQualified` Methode Handle Pfade, die sowohl die <xref:System.IO.Path.DirectorySeparatorChar> und die <xref:System.IO.Path.AltDirectorySeparatorChar> Zeichen. Es führt keine Validierung für den Pfad, der als Argument übergeben wird. Daher URIs werden als relative Pfade interpretiert und zurückgeben `false`. 

Besteht ein Unterschied zwischen einem vollqualifizierten Pfad (wie durch die `IsPathFullyQualified` Methode) und einen vollständigen Pfad (wie durch die <xref:System.IO.Path.IsPathRooted%2A> Methode). Ein *vollständig qualifizierten Pfad* oder *absoluten Pfad* immer definiert einen genauen Pfad von einem bestimmten Gerät oder auf eine Zieldatei oder das Verzeichnis, und ist nicht auf dem aktuellen Laufwerk oder das aktuelle Verzeichnis abhängig. Auf Windows-Systemen, z. B. *C:/users/user1/documents/reports/2019/january/highlights.pdf* definiert einen absoluten Pfad vom Stamm von Laufwerk C: auf die Zieldatei *highlights.pdf*. Ein *Stammpfad* gibt entweder einen ab Laufwerk oder ein Stammverzeichnis hängt jedoch von entweder im aktuellen Verzeichnis (falls es von einem angegebenen Laufwerk als Stamm verknüpft ist) oder das aktuelle Laufwerk (wenn es durch das Root-Verzeichnis als Stamm verknüpft ist). Das folgende Beispiel veranschaulicht den Unterschied zwischen vollqualifizierte Pfade und Pfade mit entfernten nutzungsbeschränkungen.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Ein Dateipfad.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der durch die angegebene Zeichenspanne dargestellte Dateipfad auf ein bestimmtes Laufwerk oder einen UNC-Pfad festgelegt ist.</summary>
        <returns><see langword="true" />, wenn der Pfad auf ein bestimmtes Laufwerk oder einen UNC-Pfad festgelegt ist; <see langword="false" />, wenn der Pfad relativ zum aktuellen Laufwerk oder Arbeitsverzeichnis angegeben ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Ein Dateipfad.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der angegebene Dateipfad auf ein bestimmtes Laufwerk oder einen UNC-Pfad festgelegt ist.</summary>
        <returns><see langword="true" />, wenn der Pfad auf ein bestimmtes Laufwerk oder einen UNC-Pfad festgelegt ist; <see langword="false" />, wenn der Pfad relativ zum aktuellen Laufwerk oder Arbeitsverzeichnis angegeben ist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob ein Dateipfad einen Stamm enthält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

Ein **Stammpfad** Dateipfad ist, ist für ein bestimmtes Laufwerk oder einen UNIC Pfad festgelegt, im Gegensatz dazu mit einem Pfad, der relativ zum aktuellen Laufwerk oder Arbeitsverzeichnis ist. Beispielsweise startet ein Stammpfad auf Windows-Systemen mit einem umgekehrten Schrägstrich (z. B. "\Documents") oder einem Laufwerkbuchstaben und Doppelpunkt (z. B. "C:Documents"). 

Beachten Sie, dass mit entfernten nutzungsbeschränkungen Pfade entweder Absolute (die voll qualifiziert ist,) oder einen Pfad relativ. Ein absoluter Pfad Stammpfad ist es sich um einen vollqualifizierten Pfad vom Stamm des Laufwerks auf ein bestimmtes Verzeichnis. Ein relativer Pfad für die mit entfernten nutzungsbeschränkungen gibt an, ein Laufwerk, aber der vollständig qualifizierte Pfad wird für das aktuelle Verzeichnis aufgelöst. Der Unterschied wird im folgenden Beispiel veranschaulicht.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Der zu testende Pfad.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Zeichenspanne zur Darstellung eines Dateipfads einen Stamm enthält.</summary>
        <returns><see langword="true" />, wenn <paramref name="path" /> einen Stamm enthält, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der zu testende Pfad.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Pfadzeichenfolge einen Stamm enthält.</summary>
        <returns><see langword="true" />, wenn <paramref name="path" /> einen Stamm enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Path.IsPathRooted%2A> Methodenrückgabe `true` ist das erste Zeichen einem Verzeichnistrennzeichen wie z. B. "\\", oder wenn der Pfad mit einem Laufwerkbuchstaben und Doppelpunkt (:) beginnt. Es gibt z. B. `true` für `path` Zeichenfolgen wie "\\\MyDir\\\MyFile.txt", "C:\\\MyDir", oder "C:MyDir". Es gibt `false` für `path` Zeichenfolgen wie "MyDir".  
  
 Diese Methode überprüft nicht, dass der Pfad oder Dateiname vorhanden ist.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  

## Examples  
 Im folgende Beispiel wird veranschaulicht, wie die `IsPathRooted` Methode kann verwendet werden, um die drei Zeichenfolgen zu testen.  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> enthält mindestens eines der in <see cref="M:System.IO.Path.GetInvalidPathChars" /> definierten ungültigen Zeichen.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Join : string[] -&gt; string" Usage="System.IO.Path.Join paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="netcore-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Eine Zeichenspanne, die den ersten Pfad für die Verknüpfung enthält.</param>
        <param name="path2">Eine Zeichenspanne, die den zweiten Pfad für die Verknüpfung enthält.</param>
        <summary>Verkettet zwei Pfadkomponenten zu einem einzigen Pfad.</summary>
        <returns>Die kombinierten Pfade.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Diese Methode einfach verkettet `path` und `path2` und fügt Sie einem Verzeichnistrennzeichen zwischen den zwei Pfadkomponenten aus, wenn nicht bereits vorhanden ist, am Ende ist `path1` oder der Anfang des `path2`. Wenn die <xref:System.ReadOnlySpan%601.Length> entweder `path1` oder `path2` 0 (null), wird die Methode gibt den anderen Pfad zurück. Wenn die <xref:System.ReadOnlySpan%601.Length> beider `path1` und `path2` NULL ist, gibt die Methode zurück <xref:System.String.Empty?displayProperty=nameWithType>. 

Wenn `path1` endet in einem Pfadtrennzeichen, die nicht geeignet für die Zielplattform ist die `Join` Methode behält die ursprünglichen Pfadtrennzeichen und fügt Sie unterstützt. Dieses Problem tritt in hartcodierte Pfade, mit denen den Windows-umgekehrte Schrägstrich ("\")-Zeichen, die als Pfadtrennzeichen auf Unix-basierten Systemen nicht erkannt wird. Um dieses Problem zu umgehen, können Sie folgende Aktionen ausführen:

- Abrufen des Werts der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> Eigenschaft statt einem Verzeichnistrennzeichen fest zu programmieren.

- Verwenden Sie einen Schrägstrich ("/"), als dem Verzeichnistrennzeichen. Dieses Zeichen wird zurückgegeben, durch die <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> Eigenschaft auf Unix-basierte Systeme und von der <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> Eigenschaft, die auf Windows-Systemen. 

Im Gegensatz zu den <xref:System.IO.Path.Combine%2A> -Methode, die <xref:System.IO.Path.Join%2A> Methode wird nicht versucht, den zurückgegebenen Pfad als Stamm. (D. h., wenn `path2` ist ein absoluter Pfad, der `Join` -Methode verwirft keine `path1` und zurückgeben `path2` als die <xref:System.IO.Path.Combine%2A> Methode.) Das folgende Beispiel veranschaulicht den Unterschied in den Pfaden, die mithilfe der beiden Methoden zurückgegeben werden. Wenn die Quelle der `path2` Benutzereingabe, wird die <xref:System.IO.Path.Combine%2A> Methode ermöglicht es einem Benutzer auf einer Dateisystemressource (z. B. *C:/Benutzer / "user1" /Dokumente/Finanz-/* im Beispiel), die die Anwendung nicht zugänglich machen möchten.  

Nicht alle für Verzeichnis-und Dateinamen ungültige Zeichen interpretiert werden als inakzeptabel ist, indem die `Join` -Methode, da Sie diese Zeichen nach den Platzhalterzeichen suchen können. Während beispielsweise `Path.Join("c:\\", "*.txt")` möglicherweise werden ungültige bei Erstellen einer Datei, es gilt als eine Suchzeichenfolge ein. Die `Join` Methode erfolgreich interpretiert es. 

## <a name="example"></a>Beispiel

Das folgende Beispiel veranschaulicht den Unterschied in den Pfaden, die zurückgegeben werden, indem die <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> und <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> Methoden. Wenn die erste Zeichenfolge ist ein vollständig qualifizierten Pfad an, der ein Laufwerk und den Root-Verzeichnis enthält, und das zweite der erste Pfad ein relativer Pfad ist, werden die beiden Methoden identische Ergebnisse erzielt. In den zweiten und dritten Aufrufen der `ShowPathInformation` -Methode, die mithilfe der beiden Methoden zurückgegebenen Zeichenfolgen voneinander abweichen. In der zweiten Methodenaufruf wird die erste Zeichenfolge Argument ist ein Laufwerk, während das zweite ein Verzeichnis mit entfernten nutzungsbeschränkungen. Die `Join` Methode verkettet die beiden Zeichenfolgen und behält doppelt vorhandene Pfadtrennzeichen. Die `Combine` Methode bricht ab dem Laufwerk, und gibt ein Verzeichnis mit entfernten nutzungsbeschränkungen auf das aktuelle Laufwerk zurück. Wenn der Anwendung aktuelle Laufwerk C:\ ist. und diese Zeichenfolge wird verwendet, den Zugriff auf eine Datei oder Dateien im Verzeichnis, würden sie "c:" anstelle von "d:" zugreifen. Abschließend da beide Argumente im dritten Aufruf `ShowPathInformation` als Stamm sind, die `Join` Methode fügt diese einfach um einen unsinnig Dateipfad zu erstellen, während er sich die `Combine` -Methode verwirft die erste Zeichenfolge und gibt die Sekunde zurück. Verwenden diese Zeichenfolge für den Zugriff auf Dateien gewähren, die Anwendung beispielsweise unerwünschten Zugriff auf vertrauliche Dateien.  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-csharp[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Eine Zeichenspanne, die den ersten Pfad für die Verknüpfung enthält.</param>
        <param name="path2">Eine Zeichenspanne, die den zweiten Pfad für die Verknüpfung enthält.</param>
        <param name="path3">Eine Zeichenspanne, die den dritten Pfad für die Verknüpfung enthält.</param>
        <summary>Verkettet drei Pfadkomponenten zu einem einzigen Pfad.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Diese Methode einfach verkettet `path`, `path2`, und `path3` und fügt Sie einem Verzeichnistrennzeichen zwischen von Pfadkomponenten, sofern nicht bereits vorhanden. Wenn die <xref:System.ReadOnlySpan%601.Length> aller `path1`, `path2`, oder `path3` Argument ist 0 (null) ist, verkettet die übrigen Argumente der Methode. Wenn die <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> aller Komponenten ist 0 (null), die der Methodenrückgabe <xref:System.String.Empty?displayProperty=nameWithType>.    

Wenn `path1` oder `path2` endet in einem Pfadtrennzeichen, die nicht geeignet für die Zielplattform ist die `Join` Methode behält die ursprünglichen Pfadtrennzeichen und fügt Sie unterstützt. Dieses Problem tritt in hartcodierte Pfade, mit denen den Windows-umgekehrte Schrägstrich ("\")-Zeichen, die als Pfadtrennzeichen auf Unix-basierten Systemen nicht erkannt wird. Um dieses Problem zu umgehen, können Sie folgende Aktionen ausführen:

- Abrufen des Werts der <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> Eigenschaft statt einem Verzeichnistrennzeichen fest zu programmieren.

- Verwenden Sie einen Schrägstrich ("/"), als dem Verzeichnistrennzeichen. Dieses Zeichen wird zurückgegeben, durch die <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> Eigenschaft auf Unix-basierte Systeme und von der <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> Eigenschaft, die auf Windows-Systemen. 

Im Gegensatz zu den <xref:System.IO.Path.Combine%2A> -Methode, die <xref:System.IO.Path.Join%2A> Methode wird nicht versucht, den zurückgegebenen Pfad als Stamm. (D. h., wenn `path2` oder `path2` ist ein absoluter Pfad, der `Join` -Methode verwirft keine der vorherigen Pfade wie die <xref:System.IO.Path.Combine%2A> Methode.  
  
Nicht alle für Verzeichnis-und Dateinamen ungültige Zeichen interpretiert werden als inakzeptabel ist, indem die `Join` -Methode, da Sie diese Zeichen nach den Platzhalterzeichen suchen können. Während beispielsweise `Path.Join("c:\\", "temp", "*.txt")` möglicherweise werden ungültige bei Erstellen einer Datei, es gilt als eine Suchzeichenfolge ein. Die `Join` Methode erfolgreich interpretiert es. 

## <a name="example"></a>Beispiel

Das folgende Beispiel veranschaulicht den Unterschied in den Pfaden, die zurückgegeben werden, indem die <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> und <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> Methoden. Wenn die erste Zeichenfolge ist ein vollständig qualifizierten Pfad an, der ein Laufwerk und den Root-Verzeichnis enthält, und das zweite der erste Pfad ein relativer Pfad ist, werden die beiden Methoden identische Ergebnisse erzielt. In den zweiten und dritten Aufrufen der `ShowPathInformation` -Methode, die mithilfe der beiden Methoden zurückgegebenen Zeichenfolgen voneinander abweichen. In der zweiten Methodenaufruf wird die erste Zeichenfolge Argument ist ein Laufwerk, während das zweite ein Verzeichnis mit entfernten nutzungsbeschränkungen. Die `Join` Methode verkettet die beiden Zeichenfolgen und behält doppelt vorhandene Pfadtrennzeichen. Ein Aufruf der <xref:System.IO.Path.GetFullPath%2A> Methode wäre keine doppelte codierungskosten vermeiden. Die `Combine` Methode bricht ab dem Laufwerk, und gibt ein Verzeichnis mit entfernten nutzungsbeschränkungen auf das aktuelle Laufwerk zurück. Wenn der Anwendung aktuelle Laufwerk C:\ ist. und diese Zeichenfolge wird verwendet, den Zugriff auf eine Datei oder Dateien im Verzeichnis, würden sie "c:" anstelle von "d:" zugreifen. Schließlich da das letzte Argument im dritten Aufruf `ShowPathInformation` als Stamm sind, die `Join` Methode fügt diese einfach an die ersten beiden Argumente einen unsinnig Dateipfad erstellen während der `Combine` -Methode verwirft die ersten zwei Zeichenfolgen und gibt zurück die dritte. Verwenden diese Zeichenfolge für den Zugriff auf Dateien gewähren, die Anwendung beispielsweise unerwünschten Zugriff auf vertrauliche Dateien.  

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)] 
[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)] 

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="path3">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.ReadOnlySpan`1&lt;char&gt; path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), path4 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path4" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="path3">To be added.</param>
        <param name="path4">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">To be added.</param>
        <param name="path2">To be added.</param>
        <param name="path3">To be added.</param>
        <param name="path4">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ein plattformspezifisches Trennzeichen, das zur Trennung von Pfadzeichenfolgen in Umgebungsvariablen verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Auf Windows-basierte desktop-Plattformen ist der Wert dieses Felds das Semikolon (;) wird standardmäßig, sondern auf anderen Plattformen zu variieren.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung der `PathSeparator` Feld.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEndingDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static string TrimEndingDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string TrimEndingDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ TrimEndingDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : string -&gt; string" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary>Versucht, einzelne Pfadkomponenten zu einer vorbelegten Zeichenspanne zu verketten, und gibt einen Wert zurück, der den Erfolg des Vorgangs angibt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

Die Spanne der Ziel-Zeichen muss groß genug für den verketteten Pfad sein. Sie können dann den verketteten Pfad abrufen, durch den Aufruf der <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> -Methode, wie im folgenden Beispiel veranschaulicht.

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Eine Zeichenspanne, die den ersten Pfad für die Verknüpfung enthält.</param>
        <param name="path2">Eine Zeichenspanne, die den zweiten Pfad für die Verknüpfung enthält.</param>
        <param name="destination">Eine Zeichenspanne, die den verketteten Pfad enthalten soll.</param>
        <param name="charsWritten">Ein Wert bei Rückgabe der Methode, der die Anzahl der Zeichen angibt, die in <paramref name="destination" /> geschrieben werden.</param>
        <summary>Versucht, zwei Pfadkomponenten zu einer einzigen vorbelegten Zeichenspanne zu verketten, und gibt einen Wert zurück, der den Erfolg des Vorgangs angibt.</summary>
        <returns><see langword="true" />, wenn die Verkettung erfolgreich ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

`destination` muss groß genug für den verketteten Pfad sein. Sie können dann den verketteten Pfad abrufen, durch den Aufruf der <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> -Methode, wie im Beispiel veranschaulicht.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; *  -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">Eine Zeichenspanne, die den ersten Pfad für die Verknüpfung enthält.</param>
        <param name="path2">Eine Zeichenspanne, die den zweiten Pfad für die Verknüpfung enthält.</param>
        <param name="path3">Eine Zeichenspanne, die den dritten Pfad für die Verknüpfung enthält.</param>
        <param name="destination">Eine Zeichenspanne, die den verketteten Pfad enthalten soll.</param>
        <param name="charsWritten">Ein Wert bei Rückgabe der Methode, der die Anzahl der Zeichen angibt, die in <paramref name="destination" /> geschrieben werden.</param>
        <summary>Versucht, zwei Pfadkomponenten zu einer einzigen vorbelegten Zeichenspanne zu verketten, und gibt einen Wert zurück, der den Erfolg des Vorgangs angibt.</summary>
        <returns><see langword="true" />, wenn die Verkettung erfolgreich ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

`destination` muss groß genug für den verketteten Pfad sein. Sie können dann den verketteten Pfad abrufen, durch den Aufruf der <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> -Methode, wie im Beispiel veranschaulicht.

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Formate von Dateipfaden unter Windows-Systemen</related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt ein plattformspezifisches Volumetrennzeichen bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieses Felds ist ein Doppelpunkt (:)) auf Windows und Macintosh sowie ein Schrägstrich (/) für UNIX-Betriebssystemen. Dies ist besonders hilfreich für die Analyse von Pfaden, z. B. "c:\windows" oder "MacVolume: Ordner".  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung der `VolumeSeparatorChar` Feld.  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
  </Members>
</Type>
