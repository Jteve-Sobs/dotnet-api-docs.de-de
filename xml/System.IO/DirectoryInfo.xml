<Type Name="DirectoryInfo" FullName="System.IO.DirectoryInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ee7337ccc6c96bb640c53a20b24c9f0109663a52" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83484393" /></Metadata><TypeSignature Language="C#" Value="public sealed class DirectoryInfo : System.IO.FileSystemInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DirectoryInfo extends System.IO.FileSystemInfo" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.IO.DirectoryInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DirectoryInfo&#xA;Inherits FileSystemInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DirectoryInfo sealed : System::IO::FileSystemInfo" />
  <TypeSignature Language="F#" Value="type DirectoryInfo = class&#xA;    inherit FileSystemInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit DirectoryInfo extends System.IO.FileSystemInfo" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.IO.FileSystem" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.IO.FileSystemInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Macht Instanzmethoden zum Erstellen, Verschieben und Auflisten in Verzeichnissen und Unterverzeichnissen verfügbar. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.IO.DirectoryInfo>-Klasse für typische Vorgänge wie das Kopieren, verschieben, umbenennen, erstellen und Löschen von Verzeichnissen.  
  
 Wenn Sie ein Objekt mehrmals wieder verwenden möchten, sollten Sie die Instanzmethode <xref:System.IO.DirectoryInfo> anstelle der entsprechenden statischen Methoden der <xref:System.IO.Directory> Klasse verwenden, da eine Sicherheitsüberprüfung nicht immer erforderlich ist.  
  
> [!NOTE]
>  In Membern, die einen Pfad als Eingabe Zeichenfolge akzeptieren, muss dieser Pfad wohl geformt sein, oder es wird eine Ausnahme ausgelöst. Wenn ein Pfad z. b. voll qualifiziert ist, aber mit einem Leerzeichen beginnt, wird der Pfad nicht in den Methoden der Klasse gekürzt. Daher ist der Pfad falsch formatiert, und es wird eine Ausnahme ausgelöst. Ebenso kann ein Pfad oder eine Kombination von Pfaden nicht zweimal voll qualifiziert werden. Beispielsweise löst "c:\temp c:\Windows" in den meisten Fällen auch eine Ausnahme aus. Stellen Sie sicher, dass die Pfade wohl geformt sind, wenn Sie Methoden verwenden, die eine Pfad Zeichenfolge akzeptieren.  
  
 In Membern, die einen Pfad akzeptieren, kann der Pfad auf eine Datei oder nur auf ein Verzeichnis verweisen. Der angegebene Pfad kann auch auf einen relativen Pfad oder einen Universal Naming Convention Pfad (UNC-Pfad) für einen Server und einen Freigabe Namen verweisen. Die folgenden Pfade sind beispielsweise zulässig:  
  
-   "c:\\\meindir\\\meineDatei.txt C#" in, oder "c:\mydir\meinedatei.txt" in Visual Basic.  
  
-   "c:\\\meinedir" C#in, oder "c:\meinedir" in Visual Basic.  
  
-   "Mydir\\\meinsubdir" in C#, oder "mydir\meinsubdir" in Visual Basic.  
  
-   "\\\\\\\meinserver\meineserver\\C#\meinefreigabe" in, oder "\\\meinserver\meinefreigabe" in Visual Basic.  
  
 Standardmäßig wird allen Benutzern der vollständige Lese-/Schreibzugriff auf neue Verzeichnisse gewährt.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel werden einige der Hauptmember der `DirectoryInfo`-Klasse veranschaulicht.  
  
 [!code-cpp[DirInfo Class Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Class Example/CPP/dirinfo class example.cpp#1)]
 [!code-csharp[DirInfo Class Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Class Example/CS/dirinfo class example.cs#1)]
 [!code-vb[DirInfo Class Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Class Example/VB/dirinfo class example.vb#1)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie ein Verzeichnis und dessen Inhalt kopiert werden.  
  
 [!code-csharp[IO.DirectoryInfo-CopyDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DirectoryInfo-CopyDir/cs/copydir.cs#1)]
 [!code-vb[IO.DirectoryInfo-CopyDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DirectoryInfo-CopyDir/vb/CopyDir.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="P:System.IO.FileSystemInfo.Attributes" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <altmember cref="T:System.IO.Directory" />
    <altmember cref="T:System.IO.Path" />
    <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Gewusst wie: Lesen und Schreiben einer neu erstellten Datendatei</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DirectoryInfo (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DirectoryInfo(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.DirectoryInfo : string -&gt; System.IO.DirectoryInfo" Usage="new System.IO.DirectoryInfo path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Eine Zeichenfolge, die den Pfad angibt, auf dem die <see langword="DirectoryInfo" /> erstellt werden sollen.</param>
        <summary>	Initialisiert eine neue Instanz der <see cref="T:System.IO.DirectoryInfo" />-Klasse im angegebenen Pfad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor prüft nicht, ob ein Verzeichnis vorhanden ist. Dieser Konstruktor ist ein Platzhalter für eine Zeichenfolge, die für den Zugriff auf den Datenträger in nachfolgenden Vorgängen verwendet wird.  
  
 Der `path`-Parameter kann ein Dateiname sein, einschließlich einer Datei auf einer Universal Naming Convention Freigabe (UNC).  
  
> [!CAUTION]
>  Wenn Sie einen Zeichensatz mit einer bestimmten Kultur Einstellung kompilieren und dieselben Zeichen mit einer anderen Kultur Einstellung abrufen, sind die Zeichen möglicherweise nicht interpretierbar und können dazu führen, dass eine Ausnahme ausgelöst wird.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird dieser Konstruktor zum Erstellen des angegebenen Verzeichnisses und des angegebenen Unterverzeichnisses verwendet, und es wird veranschaulicht, dass ein Verzeichnis, das Unterverzeichnisse enthält, nicht gelöscht werden kann.  
  
 [!code-cpp[DirInfo Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Ctor/CPP/dirinfo ctor.cpp#1)]
 [!code-csharp[DirInfo Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Ctor/CS/dirinfo ctor.cs#1)]
 [!code-vb[DirInfo Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Ctor/VB/dirinfo ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> enthält ungültige Zeichen, z.B. ", &lt;, &gt; oder |.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <altmember cref="T:System.IO.DriveInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein Verzeichnis.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Create" />
      <MemberSignature Language="VB.NET" Value="Public Sub Create ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Create();" />
      <MemberSignature Language="F#" Value="member this.Create : unit -&gt; unit" Usage="directoryInfo.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Verzeichnis bereits vorhanden ist, führt diese Methode keine Aktion aus.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird überprüft, ob ein angegebenes Verzeichnis vorhanden ist, das Verzeichnis wird erstellt, wenn es nicht vorhanden ist, und das Verzeichnis wird gelöscht.  
  
 [!code-cpp[DirInfo Create#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Create/CPP/dirinfo create.cpp#1)]
 [!code-csharp[DirInfo Create#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Create/CS/dirinfo create.cs#1)]
 [!code-vb[DirInfo Create#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Create/VB/dirinfo create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Das Verzeichnis kann nicht erstellt werden.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create (System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create(class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Create (directorySecurity As DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Create(System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.Create : System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="directoryInfo.Create directorySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="directorySecurity">Die Zugriffssteuerung, die auf das Verzeichnis angewendet werden soll.</param>
        <summary>Erstellt mithilfe eines <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekts ein Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methoden Überladung, um ein Verzeichnis mit Zugriffs Steuerung zu erstellen. Daher besteht keine Chance, dass auf das Verzeichnis zugegriffen werden kann, bevor die Sicherheit angewendet wird.  
  
 Wenn das Verzeichnis bereits vorhanden ist, führt diese Methode keine Aktion aus.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
> [!IMPORTANT]
> Diese Methode wurde in .net Core 3,1 als Erweiterungsmethode der `FileSystemAclExtensions`-Klasse als Teil der `System.Security.AccessControl` Assembly: <xref:System.IO.FileSystemAclExtensions.Create(System.IO.DirectoryInfo,System.Security.AccessControl.DirectorySecurity)>portiert.

## Examples

Im folgenden Codebeispiel wird ein neues Verzeichnis im temporären Ordner des Benutzers mit den angegebenen Verzeichnis Sicherheits Attributen erstellt:

```csharp
using System.IO;
using System.Security.AccessControl;
using System.Security.Principal;
namespace ConsoleApp
{
    class Program
    {
        static void Main()
        {
            DirectorySecurity security = new DirectorySecurity();
            SecurityIdentifier identity = new SecurityIdentifier(WellKnownSidType.BuiltinUsersSid, null);
            FileSystemAccessRule accessRule = new FileSystemAccessRule(identity, FileSystemRights.FullControl, AccessControlType.Allow);
            security.AddAccessRule(accessRule);
            string path = Path.Combine(Path.GetTempPath(), "directoryToCreate");
            DirectoryInfo dirInfo = new DirectoryInfo(path);
            dirInfo.Create(security);
        }
    }
}
```

 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Das von <paramref name="path" /> angegebene Verzeichnis ist schreibgeschützt oder nicht leer.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.NotSupportedException">Es wurde versucht, ein Verzeichnis ausschließlich mit dem Doppelpunkt (:) zu erstellen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSubdirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein oder mehrere Unterverzeichnisse im angegebenen Pfad. Der angegebene Pfad kann zu dieser Instanz der <see cref="T:System.IO.DirectoryInfo" />-Klasse relativ sein.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSubdirectory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo CreateSubdirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo CreateSubdirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubdirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ CreateSubdirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.CreateSubdirectory : string -&gt; System.IO.DirectoryInfo" Usage="directoryInfo.CreateSubdirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der angegebene Pfad. Dieser kann nicht ein anderer Datenträgervolumename oder ein anderer UNC-Name (Universal Naming Convention) sein.</param>
        <summary>Erstellt ein oder mehrere Unterverzeichnisse im angegebenen Pfad. Der angegebene Pfad kann zu dieser Instanz der <see cref="T:System.IO.DirectoryInfo" />-Klasse relativ sein.</summary>
        <returns>Das letzte im <paramref name="path" /> angegebene Verzeichnis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle in `path` angegebenen Verzeichnisse werden erstellt, es sei denn, ein Teil `path` ist ungültig. Der `path`-Parameter gibt einen Verzeichnispfad und keinen Dateipfad an. Wenn das Unterverzeichnis bereits vorhanden ist, führt diese Methode keine Aktion aus.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Erstellen eines Unterverzeichnisses veranschaulicht. In diesem Beispiel werden die erstellten Verzeichnisse entfernt, nachdem Sie erstellt wurden. Um dieses Beispiel zu testen, kommentieren Sie aus diesem Grund die Lösch Zeilen im Code aus.  
  
 [!code-cpp[directoryinfocreatesub#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfocreatesub/CPP/directoryinfocreatesub.cpp#1)]
 [!code-csharp[directoryinfocreatesub#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfocreatesub/CS/directoryinfocreatesub.cs#1)]
 [!code-vb[directoryinfocreatesub#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfocreatesub/VB/directoryinfocreatesub.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> gibt keinen gültigen Dateipfad an oder enthält ungültige <see langword="DirectoryInfo" />-Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.IO.IOException">Das Unterverzeichnis kann nicht erstellt werden.  
  
Oder 
Eine Datei oder ein Verzeichnis weist bereits den durch <paramref name="path" /> angegebenen Namen auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die Codezugriffsberechtigung zum Erstellen des Verzeichnisses.  
  
Oder 
Der Aufrufer verfügt nicht über die Codezugriffsberechtigung zum Lesen des Verzeichnisses, das vom zurückgegebenen <see cref="T:System.IO.DirectoryInfo" />-Objekt beschrieben wird.  Dies kann der Fall sein, wenn der <paramref name="path" />-Parameter ein vorhandenes Verzeichnis beschreibt.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> enthält einen Doppelpunkt (:), der nicht Teil einer Laufwerksbezeichnung ist („C:\\“).</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="CreateSubdirectory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo CreateSubdirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo CreateSubdirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubdirectory (path As String, directorySecurity As DirectorySecurity) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ CreateSubdirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.CreateSubdirectory : string * System.Security.AccessControl.DirectorySecurity -&gt; System.IO.DirectoryInfo" Usage="directoryInfo.CreateSubdirectory (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Der angegebene Pfad. Dieser kann nicht ein anderer Datenträgervolumename oder ein anderer UNC-Name (Universal Naming Convention) sein.</param>
        <param name="directorySecurity">Die anzuwendende Sicherheit.</param>
        <summary>Erstellt ein oder mehrere Unterverzeichnisse im angegebenen Pfad mit der angegebenen Sicherheit. Der angegebene Pfad kann zu dieser Instanz der <see cref="T:System.IO.DirectoryInfo" />-Klasse relativ sein.</summary>
        <returns>Das letzte im <paramref name="path" /> angegebene Verzeichnis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle in `path` angegebenen Verzeichnisse werden erstellt, es sei denn, ein Teil `path` ist ungültig. Der `path`-Parameter gibt einen Verzeichnispfad und keinen Dateipfad an. Wenn das Unterverzeichnis bereits vorhanden ist, führt diese Methode keine Aktion aus.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> gibt keinen gültigen Dateipfad an oder enthält ungültige <see langword="DirectoryInfo" />-Zeichen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.IO.IOException">Das Unterverzeichnis kann nicht erstellt werden.  
  
Oder 
Eine Datei oder ein Verzeichnis weist bereits den durch <paramref name="path" /> angegebenen Namen auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die Codezugriffsberechtigung zum Erstellen des Verzeichnisses.  
  
Oder 
Der Aufrufer verfügt nicht über die Codezugriffsberechtigung zum Lesen des Verzeichnisses, das vom zurückgegebenen <see cref="T:System.IO.DirectoryInfo" />-Objekt beschrieben wird.  Dies kann der Fall sein, wenn der <paramref name="path" />-Parameter ein vorhandenes Verzeichnis beschreibt.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> enthält einen Doppelpunkt (:), der nicht Teil einer Laufwerksbezeichnung ist („C:\\“).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht ein <see cref="T:System.IO.DirectoryInfo" /> und dessen Inhalt aus einem Pfad.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public override void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Delete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Delete();" />
      <MemberSignature Language="F#" Value="override this.Delete : unit -&gt; unit" Usage="directoryInfo.Delete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht diese <see cref="T:System.IO.DirectoryInfo" />, wenn diese leer sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Ausnahme ausgelöst, wenn Sie versuchen, ein Verzeichnis zu löschen, das nicht leer ist.  
  
 [!code-cpp[DirInfo Delete1#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Delete1/CPP/dirinfo delete1.cpp#1)]
 [!code-csharp[DirInfo Delete1#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Delete1/CS/dirinfo delete1.cs#1)]
 [!code-vb[DirInfo Delete1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Delete1/VB/dirinfo delete1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Das Verzeichnis enthält eine schreibgeschützte Datei.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das von diesem <see cref="T:System.IO.DirectoryInfo" />-Objekt beschriebene Verzeichnis ist nicht vorhanden oder konnte nicht gefunden werden.</exception>
        <exception cref="T:System.IO.IOException">Das Verzeichnis ist nicht leer.  
  
Oder 
Das Verzeichnis ist das aktuelle Arbeitsverzeichnis der Anwendung.  
  
Oder 
Es liegt ein geöffnetes Handle für das Verzeichnis vor und das Betriebssystem ist Windows XP oder früher. Dieses geöffnete Handle kann vom Auflisten von Verzeichnissen stammen. Weitere Informationen finden Sie unter [Auflisten von Verzeichnissen und Dateien](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public void Delete (bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Delete(bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Delete(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Delete (recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Delete(bool recursive);" />
      <MemberSignature Language="F#" Value="override this.Delete : bool -&gt; unit" Usage="directoryInfo.Delete recursive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="recursive"><see langword="true" />, um dieses Verzeichnis, seine Unterverzeichnisse und alle Dateien zu löschen, andernfalls <see langword="false" />.</param>
        <summary>Löscht diese Instanz von <see cref="T:System.IO.DirectoryInfo" /> und gibt an, ob Unterverzeichnisse und Dateien gelöscht werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `DirectoryInfo` keine Dateien oder Unterverzeichnisse enthält, löscht diese Methode die `DirectoryInfo` auch dann, wenn `recursive` `false`ist. Wenn Sie versuchen, eine `DirectoryInfo` zu löschen, die nicht leer ist, wenn `recursive` ist `false` wird ein <xref:System.IO.IOException>ausgelöst.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Löschen eines Verzeichnisses veranschaulicht. Da das Verzeichnis entfernt wird, kommentieren Sie zunächst die `Delete` Zeile aus, um zu testen, ob das Verzeichnis vorhanden ist. Entfernen Sie dann die Auskommentierung der Codezeile, um zu testen, ob das Verzeichnis erfolgreich entfernt wurde.  
  
 [!code-cpp[directoryinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfodelete/CPP/directoryinfodelete.cpp#1)]
 [!code-csharp[directoryinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfodelete/CS/directoryinfodelete.cs#1)]
 [!code-vb[directoryinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfodelete/VB/directoryinfodelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Das Verzeichnis enthält eine schreibgeschützte Datei.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das von diesem <see cref="T:System.IO.DirectoryInfo" />-Objekt beschriebene Verzeichnis ist nicht vorhanden oder konnte nicht gefunden werden.</exception>
        <exception cref="T:System.IO.IOException">Das Verzeichnis ist schreibgeschützt.  
  
Oder 
Das Verzeichnis enthält mindestens eine Datei oder ein Unterverzeichnis, und <paramref name="recursive" /> ist <see langword="false" />.  
  
Oder 
Das Verzeichnis ist das aktuelle Arbeitsverzeichnis der Anwendung.  
  
Oder 
Es liegt ein geöffnetes Handle für das Verzeichnis oder eines seiner Dateien vor, und das Betriebssystem ist Windows XP oder früher. Dieses geöffnete Handle kann vom Auflisten von Verzeichnissen und Dateien stammen. Weitere Informationen finden Sie unter [Auflisten von Verzeichnissen und Dateien](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine aufzählbare Auflistung von Verzeichnisinformationen im aktuellen Verzeichnis zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories () As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories();" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : unit -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine aufzählbare Auflistung von Verzeichnisinformationen im aktuellen Verzeichnis zurück.</summary>
        <returns>Eine aufzählbare Auflistung der Verzeichnisse im aktuellen Verzeichnis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> und <xref:System.IO.DirectoryInfo.GetDirectories%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.DirectoryInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetDirectories%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.DirectoryInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.DirectoryInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Unterverzeichnisse unter dem Verzeichnis "c:\Program Files" aufgelistet, und es wird eine LINQ-Abfrage verwendet, um die Namen aller Verzeichnisse zurückzugeben, die vor 2009 erstellt wurden, indem der Wert der <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>-Eigenschaft überprüft wird.  
  
 Wenn Sie nur die Namen der Unterverzeichnisse benötigen, verwenden Sie die statische <xref:System.IO.Directory>-Klasse, um die Leistung zu verbessern. Ein Beispiel finden Sie in der <xref:System.IO.Directory.EnumerateDirectories%28System.String%29>-Methode.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumDirs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumdirs/cs/program.cs)]
 [!code-vb[System.IO.DirectoryInfo.EnumDirs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumdirs/vb/module1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der im <see cref="T:System.IO.DirectoryInfo" />-Objekt gekapselte Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories (searchPattern As String) As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Verzeichnissen auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <summary>Gibt eine aufzählbare Auflistung von Verzeichnisinformationen zurück, die einem angegebenen Suchmuster entsprechen.</summary>
        <returns>Eine aufzählbare Auflistung von Verzeichnissen, die <paramref name="searchPattern" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Stimmt überein|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> und <xref:System.IO.DirectoryInfo.GetDirectories%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.DirectoryInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetDirectories%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.DirectoryInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.DirectoryInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der im <see cref="T:System.IO.DirectoryInfo" />-Objekt gekapselte Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories (searchPattern As String, enumerationOptions As EnumerationOptions) As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Verzeichnissen auf Übereinstimmungen. Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="enumerationOptions">Ein Objekt, das die zu verwendende Such- und Enumerationskonfiguration beschreibt.</param>
        <summary>Gibt eine aufzählbare Sammlung von Verzeichnisinformationen zurück, die dem angegebenen Suchmuster und der angegebenen Option entspricht</summary>
        <returns>Eine aufzählbare Auflistung von Verzeichnissen, die <paramref name="searchPattern" /> und <paramref name="enumerationOptions" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Stimmt überein|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> und <xref:System.IO.DirectoryInfo.GetDirectories%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.DirectoryInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetDirectories%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.DirectoryInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.DirectoryInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der im <see cref="T:System.IO.DirectoryInfo" />-Objekt gekapselte Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories (searchPattern As String, searchOption As SearchOption) As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string * System.IO.SearchOption -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Verzeichnissen auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen. Standardwert: <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Gibt eine aufzählbare Auflistung von Verzeichnisinformationen zurück, die einem angegebenen Suchmuster und einer angegebenen Option zum Durchsuchen von Unterverzeichnissen entspricht.</summary>
        <returns>Eine aufzählbare Auflistung von Verzeichnissen, die <paramref name="searchPattern" /> und <paramref name="searchOption" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Stimmt überein|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> und <xref:System.IO.DirectoryInfo.GetDirectories%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.DirectoryInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetDirectories%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.DirectoryInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.DirectoryInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel, beginnend bei einem angegebenen Verzeichnis, werden diese Methode und die <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>-Methode verwendet, um die Dateien und Verzeichnisse im Start Verzeichnis aufzulisten und Details von Dateien mit einer Größe von mehr als 10 MB anzuzeigen.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumerateDirectories#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumeratedirectories/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumerateDirectories#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumeratedirectories/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der im <see cref="T:System.IO.DirectoryInfo" />-Objekt gekapselte Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine aufzählbare Auflistung von Dateiinformationen im aktuellen Verzeichnis zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles () As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles();" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : unit -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine aufzählbare Auflistung von Dateiinformationen im aktuellen Verzeichnis zurück.</summary>
        <returns>Eine aufzählbare Auflistung der Dateien im aktuellen Verzeichnis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> und <xref:System.IO.DirectoryInfo.GetFiles%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Dateien unter einem angegebenen Verzeichnis aufgelistet und eine LINQ-Abfrage verwendet, um die Namen aller Dateien zurückzugeben, die vor 2009 erstellt wurden, indem der Wert der <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>-Eigenschaft überprüft wird.  
  
 Wenn Sie nur die Namen der Dateien benötigen, verwenden Sie die statische <xref:System.IO.Directory>-Klasse, um die Leistung zu verbessern. Ein Beispiel finden Sie in der <xref:System.IO.Directory.EnumerateFiles%28System.String%29?displayProperty=nameWithType>-Methode.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module1.vb#1)]  
  
 Im folgenden Beispiel wird gezeigt, wie Dateien in einem Verzeichnis mithilfe verschiedener Suchoptionen aufgelistet werden. Im Beispiel wird davon ausgegangen, dass ein Verzeichnis mit Dateien namens log1. txt, log2. txt, test1. txt, test2. txt, "test3". txt und ein Unterverzeichnis mit der Datei "subfile. txt" enthält.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der im <see cref="T:System.IO.DirectoryInfo" />-Objekt gekapselte Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles (searchPattern As String) As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <summary>Gibt eine aufzählbare Auflistung von Dateiinformationen zurück, die einem Suchmuster entsprechen.</summary>
        <returns>Eine aufzählbare Auflistung von Dateien, die <paramref name="searchPattern" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Stimmt überein|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> und <xref:System.IO.DirectoryInfo.GetFiles%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Dateien in einem Verzeichnis mithilfe verschiedener Suchoptionen aufgelistet werden. Im Beispiel wird davon ausgegangen, dass ein Verzeichnis mit Dateien namens log1. txt, log2. txt, test1. txt, test2. txt, "test3". txt und ein Unterverzeichnis mit der Datei "subfile. txt" enthält.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der im <see cref="T:System.IO.DirectoryInfo" />-Objekt gekapselte Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles (searchPattern As String, enumerationOptions As EnumerationOptions) As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien auf Übereinstimmungen. Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="enumerationOptions">Ein Objekt, das die zu verwendende Such- und Enumerationskonfiguration beschreibt.</param>
        <summary>Gibt eine aufzählbare Sammlung von Dateiinformationen zurück, die dem angegebenen Suchmuster und der angegebenen Enumerationsoptionen entspricht</summary>
        <returns>Eine aufzählbare Auflistung von Dateien, die <paramref name="searchPattern" /> und <paramref name="enumerationOptions" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Stimmt überein|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> und <xref:System.IO.DirectoryInfo.GetFiles%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der im <see cref="T:System.IO.DirectoryInfo" />-Objekt gekapselte Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles (searchPattern As String, searchOption As SearchOption) As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string * System.IO.SearchOption -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen. Standardwert: <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Gibt eine aufzählbare Auflistung von Dateiinformationen zurück, die einem angegebenen Suchmuster und einer angegebenen Option zum Durchsuchen von Unterverzeichnissen entspricht.</summary>
        <returns>Eine aufzählbare Auflistung von Dateien, die <paramref name="searchPattern" /> und <paramref name="searchOption" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Stimmt überein|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> und <xref:System.IO.DirectoryInfo.GetFiles%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Dateien in einem Verzeichnis mithilfe verschiedener Suchoptionen aufgelistet werden. Im Beispiel wird davon ausgegangen, dass ein Verzeichnis mit Dateien namens log1. txt, log2. txt, test1. txt, test2. txt, "test3". txt und ein Unterverzeichnis mit der Datei "subfile. txt" enthält.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der im <see cref="T:System.IO.DirectoryInfo" />-Objekt gekapselte Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemInfos">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine aufzählbare Auflistung von Systeminformationen im aktuellen Verzeichnis zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos () As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos();" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : unit -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine aufzählbare Auflistung von Systeminformationen im aktuellen Verzeichnis zurück.</summary>
        <returns>Eine aufzählbare Auflistung von Systeminformationen im aktuellen Verzeichnis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> und <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileSystemInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileSystemInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileSystemInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der im <see cref="T:System.IO.DirectoryInfo" />-Objekt gekapselte Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos (searchPattern As String) As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Verzeichnissen auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <summary>Gibt eine aufzählbare Auflistung von Dateisysteminformationen zurück, die einem angegebenen Suchmuster entsprechen.</summary>
        <returns>Eine aufzählbare Auflistung von Objekten mit Dateisysteminformationen, die <paramref name="searchPattern" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Stimmt überein|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> und <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileSystemInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileSystemInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileSystemInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der im <see cref="T:System.IO.DirectoryInfo" />-Objekt gekapselte Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos (searchPattern As String, enumerationOptions As EnumerationOptions) As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Verzeichnissen auf Übereinstimmungen. Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="enumerationOptions">Ein Objekt, das die zu verwendende Such- und Enumerationskonfiguration beschreibt.</param>
        <summary>Gibt eine aufzählbare Sammlung von Dateisysteminformationen zurück, die dem angegebenen Suchmuster und der angegebenen Enumerationsoptionen entspricht</summary>
        <returns>Eine aufzählbare Auflistung von Objekten mit Dateisysteminformationen, die <paramref name="searchPattern" /> und <paramref name="enumerationOptions" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Stimmt überein|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> und <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileSystemInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileSystemInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileSystemInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der im <see cref="T:System.IO.DirectoryInfo" />-Objekt gekapselte Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos (searchPattern As String, searchOption As SearchOption) As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string * System.IO.SearchOption -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Verzeichnissen auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen. Standardwert: <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Gibt eine aufzählbare Auflistung von Dateisysteminformationen zurück, die einem angegebenen Suchmuster und einer angegebenen Option zum Durchsuchen von Unterverzeichnissen entspricht.</summary>
        <returns>Eine aufzählbare Auflistung von Objekten mit Dateisysteminformationen, die <paramref name="searchPattern" /> und <paramref name="searchOption" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Stimmt überein|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> und <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileSystemInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileSystemInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileSystemInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der im <see cref="T:System.IO.DirectoryInfo" />-Objekt gekapselte Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public override bool Exists { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Exists" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Exists" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Exists As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Exists { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Exists : bool" Usage="System.IO.DirectoryInfo.Exists" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Verzeichnis vorhanden ist.</summary>
        <value><see langword="true" />, wenn das Verzeichnis vorhanden ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.DirectoryInfo.Exists%2A>-Eigenschaft gibt `false` zurück, wenn bei dem Versuch, festzustellen, ob die angegebene Datei vorhanden ist, ein Fehler auftritt. Dies kann in Situationen auftreten, in denen Ausnahmen ausgelöst werden, z. b. das Übergeben eines Datei namens mit ungültigen Zeichen oder zu vielen Zeichen, einem fehlerhaften oder fehlenden Datenträger oder, wenn der Aufrufer nicht über die Berechtigung zum Lesen der Datei verfügt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der `Exists`-Eigenschaft im Kontext des Kopierens eines Quell Verzeichnisses in ein Zielverzeichnis.  
  
 [!code-cpp[DirectoryInfo Usage Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirectoryInfo Usage Example/CPP/copydirectory.cpp#1)]
 [!code-csharp[DirectoryInfo Usage Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirectoryInfo Usage Example/CS/copydirectory.cs#1)]
 [!code-vb[DirectoryInfo Usage Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirectoryInfo Usage Example/VB/copydirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.IO.DirectoryInfo.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den vollständigen Pfad des Verzeichnisses ab.</summary>
        <value>Eine Zeichenfolge mit dem vollständigen Pfad.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die Einträge in der Zugriffssteuerungsliste für das aktuelle Verzeichnis ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie <xref:System.IO.DirectoryInfo.GetAccessControl%2A> Methoden, um die Einträge in der Zugriffs Steuerungs Liste (ACL) für die aktuelle Datei abzurufen.  
  
 Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.DirectorySecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.DirectorySecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::DirectorySecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.DirectorySecurity" Usage="directoryInfo.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt ab, das die Einträge in der Zugriffssteuerungsliste für das Verzeichnis kapselt, das vom aktuellen <see cref="T:System.IO.DirectoryInfo" />-Objekt beschrieben wird.</summary>
        <returns>Ein <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt, das die Zugriffssteuerungsregeln für das Verzeichnis kapselt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Methoden Überladung entspricht dem Aufrufen der <xref:System.IO.Directory.GetAccessControl%2A>-Methoden Überladung und der Angabe der &#124; Zugriffs &#124; Steuerungs Abschnitte <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> (<xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>`Or`<xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>`Or`<xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> in Visual Basic).  
  
 Verwenden Sie die <xref:System.IO.DirectoryInfo.GetAccessControl%2A>-Methode, um die Einträge in der Zugriffs Steuerungs Liste (ACL) für die aktuelle Datei abzurufen.  
  
 Eine ACL beschreibt Personen und/oder Gruppen, die über Rechte für bestimmte Aktionen in der angegebenen Datei oder dem angegebenen Verzeichnis verfügen oder diese nicht besitzen. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Methoden <xref:System.IO.DirectoryInfo.GetAccessControl%2A> und <xref:System.IO.DirectoryInfo.SetAccessControl%2A> verwendet, um einen Eintrag in einer Zugriffs Steuerungs Liste (ACL) aus einem Verzeichnis hinzuzufügen und daraus zu entfernen.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">Das Verzeichnis wurde nicht gefunden und konnte nicht geändert werden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Das Verzeichnis ist schreibgeschützt.  
  
 Oder  
  
 Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  
  
 Oder  
  
 Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler beim Öffnen des Verzeichnisses.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.DirectorySecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.DirectorySecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.DirectorySecurity" Usage="directoryInfo.GetAccessControl includeSections" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="includeSections">Einer der <see cref="T:System.Security.AccessControl.AccessControlSections" />-Werte, der den Typ der zu empfangenden ACL-Informationen angibt.</param>
        <summary>Ruft ein <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt ab, das den angegebenen Typ der Einträge in der Zugriffssteuerungsliste für das Verzeichnis kapselt, das vom aktuellen <see cref="T:System.IO.DirectoryInfo" />-Objekt beschrieben wird.</summary>
        <returns>Ein <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt, das die Zugriffssteuerungsregeln für die vom <paramref name="path" />-Parameter beschriebene Datei kapselt.  
  
Ausnahmen 
 <list type="table"><listheader><term> Ausnahmetyp 
 </term><description> Bedingung 
 </description></listheader><item><term><see cref="T:System.SystemException" /></term><description> Das Verzeichnis wurde nicht gefunden und konnte nicht geändert werden.  
  
 </description></item><item><term><see cref="T:System.UnauthorizedAccessException" /></term><description> Der aktuelle Prozess hat keinen Zugriff zum Öffnen des Verzeichnisses.  
  
 </description></item><item><term><see cref="T:System.IO.IOException" /></term><description> E/A-Fehler beim Öffnen des Verzeichnisses.  
  
 </description></item><item><term><see cref="T:System.UnauthorizedAccessException" /></term><description> Das Verzeichnis ist schreibgeschützt.  
  
Oder 
Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  
  
Oder 
Der Aufrufer verfügt nicht über die erforderliche Berechtigung.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.IO.DirectoryInfo.GetAccessControl%2A>-Methode, um die Einträge in der Zugriffs Steuerungs Liste (ACL) für die aktuelle Datei abzurufen.  
  
 Eine ACL beschreibt Personen und/oder Gruppen, die über Rechte für bestimmte Aktionen in der angegebenen Datei oder dem angegebenen Verzeichnis verfügen oder diese nicht besitzen. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die Unterverzeichnisse des aktuellen Verzeichnisses zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories () As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories();" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : unit -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Unterverzeichnisse des aktuellen Verzeichnisses zurück.</summary>
        <returns>Ein Array von <see cref="T:System.IO.DirectoryInfo" />-Objekten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn keine Unterverzeichnisse vorhanden sind, gibt diese Methode ein leeres Array zurück. Diese Methode ist nicht rekursiv.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.DirectoryInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Verzeichnisse im Stammverzeichnis abgerufen, und die Verzeichnisnamen werden angezeigt.  
  
 [!code-cpp[directoryinfogetdirectories#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfogetdirectories/CPP/directoryinfogetdirectories.cpp#1)]
 [!code-csharp[directoryinfogetdirectories#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetdirectories/CS/directoryinfogetdirectories.cs#1)]
 [!code-vb[directoryinfogetdirectories#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetdirectories/VB/directoryinfogetdirectories.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der im <see cref="T:System.IO.DirectoryInfo" />-Objekt gekapselte Pfad ist ungültig, da er sich z. B. auf einem nicht zugeordneten Laufwerk befindet.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (searchPattern As String) As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Verzeichnissen auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <summary>Gibt ein Array von Verzeichnissen im aktuellen <see cref="T:System.IO.DirectoryInfo" /> zurück, die den angegebenen Suchkriterien entsprechen.</summary>
        <returns>Ein Array vom Typ <see langword="DirectoryInfo" />, der <paramref name="searchPattern" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Stimmt überein|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.DirectoryInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Verzeichnisse in einem Pfad gezählt, der den angegebenen Buchstaben enthält.  
  
 [!code-cpp[DirInfo GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo GetDirs2/CPP/dirinfo getdirs2.cpp#1)]
 [!code-csharp[DirInfo GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo GetDirs2/CS/dirinfo getdirs2.cs#1)]
 [!code-vb[DirInfo GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo GetDirs2/VB/dirinfo getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> enthält mindestens ein ungültiges Zeichen gemäß der Definition der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der im <see langword="DirectoryInfo" />-Objekt gekapselte Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (searchPattern As String, enumerationOptions As EnumerationOptions) As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string * System.IO.EnumerationOptions -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Verzeichnissen auf Übereinstimmungen. Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="enumerationOptions">Ein Objekt, das die zu verwendende Such- und Enumerationskonfiguration beschreibt.</param>
        <summary>Gibt ein Array von Verzeichnissen im aktuellen <see cref="T:System.IO.DirectoryInfo" /> zurück, das dem angegebenen Suchmuster und den angegebenen Enumerationsoptionen entspricht.</summary>
        <returns>Ein Array vom Typ <see langword="DirectoryInfo" />, das <paramref name="searchPattern" /> und <paramref name="enumerationOptions" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Stimmt überein|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.DirectoryInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> enthält mindestens ein ungültiges Zeichen gemäß der Definition der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der im <see langword="DirectoryInfo" />-Objekt gekapselte Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (searchPattern As String, searchOption As SearchOption) As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string * System.IO.SearchOption -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Verzeichnissen auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen.</param>
        <summary>Gibt ein Array von Verzeichnissen im aktuellen <see cref="T:System.IO.DirectoryInfo" /> zurück, die den angegebenen Suchkriterien entsprechen. Anhand eines Werts wird bestimmt, ob in Unterverzeichnissen gesucht wird.</summary>
        <returns>Ein Array vom Typ <see langword="DirectoryInfo" />, der <paramref name="searchPattern" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Stimmt überein|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Wenn keine Unterverzeichnisse vorhanden sind oder keine Unterverzeichnisse mit dem `searchPattern`-Parameter identisch sind, gibt diese Methode ein leeres Array zurück.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.DirectoryInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Verzeichnisse und Dateien aufgelistet, die mit dem Buchstaben "c" in "c:\\" beginnen.  
  
 [!code-cpp[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/cpp/searchoption.cpp#00)]
 [!code-csharp[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/cs/searchoption.cs#00)]
 [!code-vb[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/vb/searchoption.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> enthält mindestens ein ungültiges Zeichen gemäß der Definition der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der im <see langword="DirectoryInfo" />-Objekt gekapselte Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Dateiliste des aktuellen Verzeichnisses zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles () As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="member this.GetFiles : unit -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Dateiliste des aktuellen Verzeichnisses zurück.</summary>
        <returns>Ein Array des Typs <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> und <xref:System.IO.DirectoryInfo.GetFiles%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> effizienter sein.  
  
 Wenn der <xref:System.IO.DirectoryInfo>keine Dateien enthält, gibt diese Methode ein leeres Array zurück.  
  
 Die Reihenfolge der zurückgegebenen Dateinamen ist nicht garantiert. Verwenden Sie die <xref:System.Array.Sort%2A>-Methode, wenn eine bestimmte Sortierreihenfolge erforderlich ist.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie eine Liste von Dateien aus einem Verzeichnis mithilfe verschiedener Suchoptionen erhalten. Im Beispiel wird davon ausgegangen, dass ein Verzeichnis mit Dateien namens log1. txt, log2. txt, test1. txt, test2. txt, "test3". txt und ein Unterverzeichnis mit der Datei "subfile. txt" enthält.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der Pfad ist ungültig, weil er sich beispielsweise auf einem nicht zugeordneten Laufwerk befindet.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (searchPattern As String) As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <summary>Gibt eine Dateiliste des aktuellen Verzeichnisses zurück, das dem angegebenen Suchmuster entspricht.</summary>
        <returns>Ein Array des Typs <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Stimmt überein|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> und <xref:System.IO.DirectoryInfo.GetFiles%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> effizienter sein.  
  
 Wenn der <xref:System.IO.DirectoryInfo>keine Dateien enthält, gibt diese Methode ein leeres Array zurück.  
  
 Die folgenden Platzhalter Spezifizierer sind im `searchPattern`-Parameter zulässig.  
  
|Platzhalter|BESCHREIBUNG|  
|------------------------|-----------------|  
|*|NULL oder mehr Zeichen.|  
|?|Genau null oder ein Zeichen.|  
  
 Die Reihenfolge der zurückgegebenen Dateinamen ist nicht garantiert. Verwenden Sie die <xref:System.Array.Sort%2A>-Methode, wenn eine bestimmte Sortierreihenfolge erforderlich ist.  
  
 Platzhalter sind zulässig. Beispielsweise sucht die `searchPattern` Zeichenfolge "*. txt" nach allen Dateinamen, die die Erweiterung "txt" aufweisen. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Dateinamen, die mit dem Buchstaben "s" beginnen. Wenn keine Dateien vorhanden sind oder keine Dateien vorhanden sind, die mit der `searchPattern` Zeichenfolge im <xref:System.IO.DirectoryInfo>identisch sind, gibt diese Methode ein leeres Array zurück.  
  
> [!NOTE]
>  Wenn Sie das Platzhalter Zeichen Sternchen in einem `searchPattern` verwenden (z. b. "*. txt"), variiert das übereinstimmende Verhalten in Abhängigkeit von der Länge der angegebenen Dateierweiterung. Ein `searchPattern` mit einer Dateierweiterung von genau drei Zeichen gibt Dateien mit einer Erweiterung von drei oder mehr Zeichen zurück, wobei die ersten drei Zeichen mit der im `searchPattern`angegebenen Dateierweiterung übereinstimmen. Ein `searchPattern` mit einer Dateierweiterung von einem, zwei oder mehr als drei Zeichen gibt nur Dateien mit der Erweiterung genau dieser Länge zurück, die mit der Dateierweiterung übereinstimmen, die in der `searchPattern`angegeben ist. Wenn Sie das Fragezeichen-Platzhalter Zeichen verwenden, gibt diese Methode nur die Dateien zurück, die der angegebenen Dateierweiterung entsprechen. Angenommen, es gibt zwei Dateien in einem Verzeichnis: "file1. txt" und "file1. txtother", das Suchmuster "file?". txt "gibt nur die erste Datei zurück, während das Suchmuster" File\*. txt "beide Dateien zurückgibt.  
  
> [!NOTE]
>  Da diese Methode Dateinamen sowohl mit dem Dateinamen Format 8,3 als auch mit dem langen Dateinamen Format überprüft, kann ein Suchmuster ähnlich "* 1\*. txt" unerwartete Dateinamen zurückgeben. Wenn Sie z. b. ein Suchmuster von "\*1\*. txt" verwenden, wird "longfilename. txt" zurückgegeben, da das entsprechende Format für den 8,3-Dateinamen "longf ~ 1. txt" lauten würde.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie eine Liste von Dateien aus einem Verzeichnis mithilfe verschiedener Suchoptionen erhalten. Im Beispiel wird davon ausgegangen, dass ein Verzeichnis mit Dateien namens log1. txt, log2. txt, test1. txt, test2. txt, "test3". txt und ein Unterverzeichnis mit der Datei "subfile. txt" enthält.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> enthält mindestens ein ungültiges Zeichen gemäß der Definition der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (searchPattern As String, enumerationOptions As EnumerationOptions) As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string * System.IO.EnumerationOptions -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien auf Übereinstimmungen. Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="enumerationOptions">Ein Objekt, das die zu verwendende Such- und Enumerationskonfiguration beschreibt.</param>
        <summary>Gibt eine Liste der Dateien im aktuellen Verzeichnis zurück, die dem angegebenen Suchmuster und den angegebenen Enumerationsoptionen entsprechen.</summary>
        <returns>Ein Array von stark typisierten <see cref="T:System.IO.FileInfo" />-Objekten, die <paramref name="searchPattern" /> und <paramref name="enumerationOptions" /> entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Stimmt überein|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> und <xref:System.IO.DirectoryInfo.GetFiles%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> effizienter sein.  
  
 Wenn der <xref:System.IO.DirectoryInfo>keine Dateien enthält, gibt diese Methode ein leeres Array zurück.  
  
 Die folgenden Platzhalter Spezifizierer sind im `searchPattern`-Parameter zulässig.  
  
|Platzhalter|BESCHREIBUNG|  
|------------------------|-----------------|  
|*|NULL oder mehr Zeichen.|  
|?|Genau null oder ein Zeichen.|  
  
 Die Reihenfolge der zurückgegebenen Dateinamen ist nicht garantiert. Verwenden Sie die <xref:System.Array.Sort%2A>-Methode, wenn eine bestimmte Sortierreihenfolge erforderlich ist.  
  
 Platzhalter sind zulässig. Beispielsweise sucht die `searchPattern` Zeichenfolge "*. txt" nach allen Dateinamen, die die Erweiterung "txt" aufweisen. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Dateinamen, die mit dem Buchstaben "s" beginnen. Wenn keine Dateien vorhanden sind oder keine Dateien vorhanden sind, die mit der `searchPattern` Zeichenfolge im <xref:System.IO.DirectoryInfo>identisch sind, gibt diese Methode ein leeres Array zurück.  
  
> [!NOTE]
>  Wenn Sie das Platzhalter Zeichen Sternchen in einem `searchPattern` verwenden (z. b. "*. txt"), variiert das übereinstimmende Verhalten in Abhängigkeit von der Länge der angegebenen Dateierweiterung. Ein `searchPattern` mit einer Dateierweiterung von genau drei Zeichen gibt Dateien mit einer Erweiterung von drei oder mehr Zeichen zurück, wobei die ersten drei Zeichen mit der im `searchPattern`angegebenen Dateierweiterung übereinstimmen. Ein `searchPattern` mit einer Dateierweiterung von einem, zwei oder mehr als drei Zeichen gibt nur Dateien mit der Erweiterung genau dieser Länge zurück, die mit der Dateierweiterung übereinstimmen, die in der `searchPattern`angegeben ist. Wenn Sie das Fragezeichen-Platzhalter Zeichen verwenden, gibt diese Methode nur die Dateien zurück, die der angegebenen Dateierweiterung entsprechen. Angenommen, es gibt zwei Dateien in einem Verzeichnis: "file1. txt" und "file1. txtother", das Suchmuster "file?". txt "gibt nur die erste Datei zurück, während das Suchmuster" File\*. txt "beide Dateien zurückgibt.  
  
> [!NOTE]
>  Da diese Methode Dateinamen sowohl mit dem Dateinamen Format 8,3 als auch mit dem langen Dateinamen Format überprüft, kann ein Suchmuster ähnlich "* 1\*. txt" unerwartete Dateinamen zurückgeben. Wenn Sie z. b. ein Suchmuster von "\*1\*. txt" verwenden, wird "longfilename. txt" zurückgegeben, da das entsprechende Format für den 8,3-Dateinamen "longf ~ 1. txt" lauten würde.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> enthält mindestens ein ungültiges Zeichen gemäß der Definition der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (searchPattern As String, searchOption As SearchOption) As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string * System.IO.SearchOption -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen.</param>
        <summary>Gibt eine Dateiliste des aktuellen Verzeichnisses zurück, das dem angegebenen Suchmuster entspricht. Anhand eines Werts wird bestimmt, ob in Unterverzeichnissen gesucht wird.</summary>
        <returns>Ein Array des Typs <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> und <xref:System.IO.DirectoryInfo.GetFiles%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> effizienter sein.  
  
 Wenn der <xref:System.IO.DirectoryInfo>keine Dateien enthält, gibt diese Methode ein leeres Array zurück.  
  
 Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter|BESCHREIBUNG|  
|------------------------|-----------------|  
|\* (Sternchen)|NULL oder mehr Zeichen.|  
|? (Fragezeichen)|Genau null oder ein Zeichen.|  
  
 Die Reihenfolge der zurückgegebenen Dateinamen ist nicht garantiert. Verwenden Sie die <xref:System.Array.Sort%2A>-Methode, wenn eine bestimmte Sortierreihenfolge erforderlich ist.  
  
 Platzhalter sind zulässig. Beispielsweise sucht die `searchPattern` Zeichenfolge "*. txt" nach allen Dateinamen, die die Erweiterung "txt" aufweisen. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Dateinamen, die mit dem Buchstaben "s" beginnen. Wenn keine Dateien vorhanden sind oder keine Dateien vorhanden sind, die mit der `searchPattern` Zeichenfolge im <xref:System.IO.DirectoryInfo>identisch sind, gibt diese Methode ein leeres Array zurück.  
  
> [!NOTE]
>  Wenn Sie das Platzhalter Zeichen Sternchen in einem `searchPattern` verwenden (z. b. "*. txt"), variiert das übereinstimmende Verhalten in Abhängigkeit von der Länge der angegebenen Dateierweiterung. Ein `searchPattern` mit einer Dateierweiterung von genau drei Zeichen gibt Dateien mit einer Erweiterung von drei oder mehr Zeichen zurück, wobei die ersten drei Zeichen mit der im `searchPattern`angegebenen Dateierweiterung übereinstimmen. Ein `searchPattern` mit einer Dateierweiterung von einem, zwei oder mehr als drei Zeichen gibt nur Dateien mit der Erweiterung genau dieser Länge zurück, die mit der Dateierweiterung übereinstimmen, die in der `searchPattern`angegeben ist. Wenn Sie das Fragezeichen-Platzhalter Zeichen verwenden, gibt diese Methode nur die Dateien zurück, die der angegebenen Dateierweiterung entsprechen. Angenommen, es gibt zwei Dateien in einem Verzeichnis: "file1. txt" und "file1. txtother", das Suchmuster "file?". txt "gibt nur die erste Datei zurück, während das Suchmuster" File\*. txt "beide Dateien zurückgibt.  
  
 In der folgenden Liste wird das Verhalten unterschiedlicher Längen für den `searchPattern`-Parameter angezeigt:  
  
-   "*. ABC" gibt Dateien mit der Erweiterung ". ABC", ". abcd", ". abcde", ". abcdef" usw. zurück.  
  
-   "*. abcd" gibt nur Dateien mit der Erweiterung ". abcd" zurück.  
  
-   "*. abcde" gibt nur Dateien mit der Erweiterung ". abcde" zurück.  
  
-   "*. abcdef" gibt nur Dateien mit der Erweiterung ". abcdef" zurück.  
  
> [!NOTE]
>  Da diese Methode Dateinamen sowohl mit dem Dateinamen Format 8,3 als auch mit dem langen Dateinamen Format überprüft, kann ein Suchmuster ähnlich "* 1\*. txt" unerwartete Dateinamen zurückgeben. Wenn Sie z. b. ein Suchmuster von "\*1\*. txt" verwenden, wird "longfilename. txt" zurückgegeben, da das entsprechende Format für den 8,3-Dateinamen "longf ~ 1. txt" lauten würde.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileInfo> Eigenschaften vorab auf:  
  
1.  <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
2.  <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
3.  <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
4.  <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
5.  <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
6.  <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
7.  <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
8.  <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie eine Liste von Dateien aus einem Verzeichnis mithilfe verschiedener Suchoptionen erhalten. Im Beispiel wird davon ausgegangen, dass ein Verzeichnis mit Dateien namens log1. txt, log2. txt, test1. txt, test2. txt, "test3". txt und ein Unterverzeichnis mit der Datei "subfile. txt" enthält.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> enthält mindestens ein ungültiges Zeichen gemäß der Definition der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemInfos">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ein Array von stark typisierten <see cref="T:System.IO.FileSystemInfo" />-Objekten ab, das Dateien und Unterverzeichnisse des aktuellen Verzeichnisses darstellt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos () As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos();" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : unit -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array von stark typisierten <see cref="T:System.IO.FileSystemInfo" />-Einträgen zurück, das alle Dateien und Unterverzeichnisse in einem Verzeichnis darstellt.</summary>
        <returns>	Ein Array von stark typisierten <see cref="T:System.IO.FileSystemInfo" />-Einträgen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn keine Dateien oder Verzeichnisse in der <xref:System.IO.DirectoryInfo>vorhanden sind, gibt diese Methode ein leeres Array zurück. Diese Methode ist nicht rekursiv.  
  
 Für Unterverzeichnisse können die von dieser Methode zurückgegebenen <xref:System.IO.FileSystemInfo> Objekte in die abgeleitete Klasse <xref:System.IO.DirectoryInfo>umgewandelt werden. Verwenden Sie den <xref:System.IO.FileAttributes> Wert, der von der <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird, um zu bestimmen, ob der <xref:System.IO.FileSystemInfo> eine Datei oder ein Verzeichnis darstellt  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileSystemInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Dateien und Verzeichnisse im angegebenen Verzeichnis gezählt.  
  
 [!code-csharp[FSizeSort#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSizeSort/CS/fsizesort.cs#1)]
 [!code-vb[FSizeSort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSizeSort/VB/fsizesort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos (searchPattern As String) As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Verzeichnissen und Dateien auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <summary>Ruft ein Array von stark typisierten <see cref="T:System.IO.FileSystemInfo" />-Objekten ab, das die Dateien und Unterverzeichnisse darstellt, die den angegebenen Suchkriterien entsprechen.</summary>
        <returns>Ein Array von stark typisierten <see langword="FileSystemInfo" />-Objekten, die den Suchkriterien entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Stimmt überein|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Diese Methode ist nicht rekursiv.  
  
 Für Unterverzeichnisse können die von dieser Methode zurückgegebenen <xref:System.IO.FileSystemInfo> Objekte in die abgeleitete Klasse <xref:System.IO.DirectoryInfo>umgewandelt werden. Verwenden Sie den <xref:System.IO.FileAttributes> Wert, der von der <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird, um zu bestimmen, ob der <xref:System.IO.FileSystemInfo> eine Datei oder ein Verzeichnis darstellt  
  
 Platzhalter sind zulässig. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Verzeichnisnamen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Verzeichnisnamen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Zeichenfolge ".." kann nur in `searchPattern` verwendet werden, wenn Sie als Teil eines gültigen Verzeichnis namens angegeben wird, z. b. im Verzeichnisnamen "a.". b ". Sie kann nicht verwendet werden, um die Verzeichnishierarchie nach oben zu verschieben. Wenn keine Dateien oder Verzeichnisse vorhanden sind oder keine Dateien oder Verzeichnisse vorhanden sind, die mit der `searchPattern` Zeichenfolge im <xref:System.IO.DirectoryInfo>identisch sind, gibt diese Methode ein leeres Array zurück.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileSystemInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Dateien und Verzeichnisse gezählt, die dem angegebenen Suchmuster entsprechen.  
  
 [!code-csharp[DirInfo GetFileSysInfos2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo GetFileSysInfos2/CS/dirinfo getfilesysinfos2.cs#1)]
 [!code-vb[DirInfo GetFileSysInfos2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo GetFileSysInfos2/VB/dirinfo getfilesysinfos2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> enthält mindestens ein ungültiges Zeichen gemäß der Definition der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos (searchPattern As String, enumerationOptions As EnumerationOptions) As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string * System.IO.EnumerationOptions -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Verzeichnissen und Dateien auf Übereinstimmungen. Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="enumerationOptions">Ein Objekt, das die zu verwendende Such- und Enumerationskonfiguration beschreibt.</param>
        <summary>Ruft ein Array von stark typisierten <see cref="T:System.IO.FileSystemInfo" />-Objekten ab, das die Dateien und Unterverzeichnisse darstellt, die dem angegebenen Suchmuster und den angegebenen Enumerationsoptionen entsprechen.</summary>
        <returns>Ein Array von stark typisierten <see langword="FileSystemInfo" />-Objekten, die <paramref name="searchPattern" /> und <paramref name="enumerationOptions" /> entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Stimmt überein|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Diese Methode ist nicht rekursiv.  
  
 Für Unterverzeichnisse können die von dieser Methode zurückgegebenen <xref:System.IO.FileSystemInfo> Objekte in die abgeleitete Klasse <xref:System.IO.DirectoryInfo>umgewandelt werden. Verwenden Sie den <xref:System.IO.FileAttributes> Wert, der von der <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird, um zu bestimmen, ob der <xref:System.IO.FileSystemInfo> eine Datei oder ein Verzeichnis darstellt  
  
 Platzhalter sind zulässig. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Verzeichnisnamen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Verzeichnisnamen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Zeichenfolge ".." kann nur in `searchPattern` verwendet werden, wenn Sie als Teil eines gültigen Verzeichnis namens angegeben wird, z. b. im Verzeichnisnamen "a.". b ". Sie kann nicht verwendet werden, um die Verzeichnishierarchie nach oben zu verschieben. Wenn keine Dateien oder Verzeichnisse vorhanden sind oder keine Dateien oder Verzeichnisse vorhanden sind, die mit der `searchPattern` Zeichenfolge im <xref:System.IO.DirectoryInfo>identisch sind, gibt diese Methode ein leeres Array zurück.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileSystemInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> enthält mindestens ein ungültiges Zeichen gemäß der Definition der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> ist <see langword="null" /></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos (searchPattern As String, searchOption As SearchOption) As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string * System.IO.SearchOption -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Verzeichnissen und Dateien auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen. Standardwert: <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Ruft ein Array von <see cref="T:System.IO.FileSystemInfo" />-Objekten ab, die die Dateien und Unterverzeichnisse darstellen, die den angegebenen Suchkriterien entsprechen.</summary>
        <returns>Ein Array von Dateisystemeinträgen, die den Suchkriterien entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Stimmt überein|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Für Unterverzeichnisse können die von dieser Methode zurückgegebenen <xref:System.IO.FileSystemInfo> Objekte in die abgeleitete Klasse <xref:System.IO.DirectoryInfo>umgewandelt werden. Verwenden Sie den <xref:System.IO.FileAttributes> Wert, der von der <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird, um zu bestimmen, ob der <xref:System.IO.FileSystemInfo> eine Datei oder ein Verzeichnis darstellt  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileSystemInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> enthält mindestens ein ungültiges Zeichen gemäß der Definition der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.MoveTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::String ^ destDirName);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : string -&gt; unit" Usage="directoryInfo.MoveTo destDirName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destDirName">Der Name und Pfad des Verzeichnisses, in das das Verzeichnis verschoben werden soll. Das Ziel darf kein anderes Datenträgervolume und kein Verzeichnis mit dem gleichen Namen sein. Es kann ein vorhandenes Verzeichnis sein, dem dieses Verzeichnis als Unterverzeichnis hinzugefügt werden soll.</param>
        <summary>Verschiebt eine <see cref="T:System.IO.DirectoryInfo" />-Instanz und deren Inhalt in einen neuen Pfad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode löst eine <xref:System.IO.IOException> aus, wenn Sie z. b. versuchen, c:\meinedir nach c:\Public zu verschieben, und c:\Public bereits vorhanden ist. Sie müssen "c:\\\Public\\\MyDir" als `destDirName` Parameter angeben oder einen neuen Verzeichnisnamen angeben, z. b. "c:\\\newdir".  
  
 Diese Methode ermöglicht das Verschieben eines Verzeichnisses in ein Schreib geschütztes Verzeichnis. Das Attribut mit Lese-/Schreibzugriff ist von keinem der Verzeichnisse betroffen.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Verschieben eines Verzeichnisses veranschaulicht.  
  
 [!code-cpp[directoryinfomoveto#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfomoveto/CPP/directoryinfomoveto.cpp#1)]
 [!code-csharp[directoryinfomoveto#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfomoveto/CS/directoryinfomoveto.cs#1)]
 [!code-vb[directoryinfomoveto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfomoveto/VB/directoryinfomoveto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destDirName" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="destDirName" /> ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.IO.IOException">Es wurde versucht, ein Verzeichnis auf ein anderes Volume zu verschieben.  
  
Oder 
 <paramref name="destDirName" /> ist bereits vorhanden.  
  
Oder 
Sie sind nicht autorisiert, auf diesen Pfad zuzugreifen.  
  
Oder 
Das verschobene Verzeichnis und das Zielverzeichnis haben denselben Namen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Zielverzeichnis kann nicht gefunden werden.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.DirectoryInfo.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen dieser <see cref="T:System.IO.DirectoryInfo" />-Instanz ab.</summary>
        <value>Der Verzeichnisname.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese <xref:System.IO.DirectoryInfo.Name%2A> Eigenschaft gibt nur den Namen des Verzeichnisses zurück, z. b. "bin". Um den vollständigen Pfad, z. b. "c:\public\Bin", zu erhalten, verwenden Sie die <xref:System.IO.FileSystemInfo.FullName%2A>-Eigenschaft.  
  
 Die <xref:System.IO.DirectoryInfo.Name%2A>-Eigenschaft einer <xref:System.IO.DirectoryInfo> erfordert keine Berechtigung (über die Read-Berechtigung für das Verzeichnis, das zum Erstellen des <xref:System.IO.DirectoryInfo.Exists%2A>erforderlich ist), kann jedoch den Verzeichnisnamen abgeben. Wenn eine <xref:System.IO.DirectoryInfo> an ein geschütztes Verzeichnis mit einem kryptografisch sicheren Namen übergeben werden muss, erstellen Sie ein dummyverzeichnis für die Verwendung durch den nicht vertrauenswürdigen Code.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird nur der Name der aktuellen `DirectoryInfo`-Instanz angezeigt.  
  
 [!code-cpp[Classic DirectoryInfo.Name Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DirectoryInfo.Name Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/CS/source.cs#1)]
 [!code-vb[Classic DirectoryInfo.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemInfo.FullName" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Parent" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Parent { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.IO.DirectoryInfo" Usage="System.IO.DirectoryInfo.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das übergeordnete Verzeichnis eines angegebenen Unterverzeichnisses ab.</summary>
        <value>Das übergeordnete Verzeichnis oder <see langword="null" />, wenn der Pfad NULL ist oder wenn der Dateipfad einen Stamm (z. b. `\`, `C:\`oder `\\server\share`) angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!IMPORTANT]
> In .NET Framework gibt `Parent` einen relativen Pfad zurück.
> In .net Core gibt `Parent` einen voll qualifizierten Pfad zurück.

Um ein konsistentes Verhalten über mehrere Versionen hinweg sicherzustellen und ihre Absicht explizit zu machen, rufen Sie den Wert einer der folgenden Eigenschaften auf der <xref:System.IO.DirectoryInfo> Instanz ab, die von `Parent`zurückgegeben wird.
- <xref:System.IO.DirectoryInfo.Name>, die den einfachen Namen des Verzeichnisses zurückgibt (z. b. `bin`).
- <xref:System.IO.DirectoryInfo.FullName>, die den absoluten Pfad des Verzeichnisses zurückgibt. 


Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.


## Examples

Im folgenden Beispiel wird auf das übergeordnete Verzeichnis eines angegebenen Verzeichnisses verwiesen.

[!code-cpp[directoryinfoparent#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfoparent/CPP/directoryinfoparent.cpp#1)]
[!code-csharp[directoryinfoparent#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfoparent/CS/directoryinfoparent.cs#1)]
[!code-vb[directoryinfoparent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfoparent/VB/directoryinfoparent.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Root">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Root { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Root" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Root" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Root As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Root { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Root : System.IO.DirectoryInfo" Usage="System.IO.DirectoryInfo.Root" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Stammteil des Verzeichnisses ab.</summary>
        <value>Ein Objekt, das den Stamm des Verzeichnisses darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel werden die Stamm Speicherorte für angegebene Verzeichnisse angezeigt.  
  
 [!code-csharp[directoryinforoot#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinforoot/CS/directoryinforoot2.cs#2)]
 [!code-vb[directoryinforoot#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinforoot/VB/directoryinforoot2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (directorySecurity As DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="directoryInfo.SetAccessControl directorySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="directorySecurity">Ein Objekt, das einen Eintrag in einer Zugriffssteuerungsliste beschreibt, der auf das vom <paramref name="path" />-Parameter beschriebene Verzeichnis angewendet werden soll.</param>
        <summary>Wendet von einem <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt beschriebene Einträge in Zugriffssteuerungslisten auf die Datei an, die vom aktuellen <see cref="T:System.IO.DirectoryInfo" />-Objekt beschrieben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In einer Zugriffs Steuerungs Liste (Access Control List, ACL) werden Personen und/oder Gruppen beschrieben, die bzw. die über keine Rechte für bestimmte Aktionen in der angegebenen Datei oder dem angegebenen Verzeichnis verfügen. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Die <xref:System.IO.DirectoryInfo.SetAccessControl%2A>-Methode wendet ACL-Einträge auf eine Datei an, die die nicht geerbte ACL-Liste darstellt.  
  
> [!CAUTION]
>  Die für `directorySecurity` angegebene ACL ersetzt die vorhandene ACL für das Verzeichnis. Um Berechtigungen für einen neuen Benutzer hinzuzufügen, verwenden Sie die <xref:System.IO.DirectoryInfo.GetAccessControl%2A>-Methode, um die vorhandene ACL abzurufen und zu ändern.  
  
 Die <xref:System.IO.DirectoryInfo.SetAccessControl%2A>-Methode speichert nur <xref:System.Security.AccessControl.DirectorySecurity> Objekte, die nach der Objekt Erstellung geändert wurden.  Wenn ein <xref:System.Security.AccessControl.DirectorySecurity> Objekt nicht geändert wurde, wird es nicht in einer Datei persistent gespeichert.  Aus diesem Grund ist es nicht möglich, ein <xref:System.Security.AccessControl.DirectorySecurity> Objekt aus einer Datei abzurufen und das gleiche Objekt erneut auf eine andere Datei anzuwenden.  
  
 So kopieren Sie ACL-Informationen aus einer Datei in eine andere:  
  
1.  Verwenden Sie die <xref:System.IO.DirectoryInfo.GetAccessControl%2A>-Methode, um das <xref:System.Security.AccessControl.DirectorySecurity> Objekt aus der Quelldatei abzurufen.  
  
2.  Erstellen Sie ein neues <xref:System.Security.AccessControl.DirectorySecurity>-Objekt für die Zieldatei.  
  
3.  Verwenden Sie die <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A>-oder <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>-Methode des Quell <xref:System.Security.AccessControl.DirectorySecurity> Objekts, um die ACL-Informationen abzurufen.  
  
4.  Verwenden Sie die Methode <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> oder <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>, um die in Schritt 3 abgerufenen Informationen in das Ziel <xref:System.Security.AccessControl.DirectorySecurity> Objekt zu kopieren.  
  
5.  Legen Sie das Ziel <xref:System.Security.AccessControl.DirectorySecurity> Objekt mithilfe der <xref:System.IO.DirectoryInfo.SetAccessControl%2A>-Methode auf die Zieldatei fest.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Methoden <xref:System.IO.DirectoryInfo.GetAccessControl%2A> und <xref:System.IO.DirectoryInfo.SetAccessControl%2A> verwendet, um einen Eintrag in einer Zugriffs Steuerungs Liste (ACL) aus einem Verzeichnis hinzuzufügen und daraus zu entfernen.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="directorySecurity" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Die Datei konnte nicht gefunden oder geändert werden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der aktuelle Prozess hat keinen Zugriff zum Öffnen der Datei.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="directoryInfo.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den ursprünglichen Pfad zurück, der an den Konstruktor <see cref="T:System.IO.DirectoryInfo" /> übergeben wurde. Verwenden Sie die Eigenschaft <see cref="P:System.IO.DirectoryInfo.FullName" /> bzw. <see cref="P:System.IO.DirectoryInfo.Name" /> für den vollständigen Pfad bzw. den Datei- und Verzeichnisnamen anstatt dieser Methode.</summary>
        <returns>Der ursprüngliche Pfad, der vom Benutzer übergeben wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!IMPORTANT]
> Die von der <xref:System.IO.DirectoryInfo.ToString%2A>-Methode zurückgegebene Zeichenfolge stellt den Pfad dar, der an den <xref:System.IO.DirectoryInfo>-Konstruktor übergeben wurde. Anstatt die `ToString`-Methode aufrufen zu können, sollten Sie den Wert einer der folgenden Eigenschaften abhängig von ihrer Absicht abrufen:
> - <xref:System.IO.DirectoryInfo.Name>, um den Namen des Verzeichnisses ohne Informationen über den übergeordneten Pfad zu erhalten.
> - <xref:System.IO.DirectoryInfo.FullName>, um den voll qualifizierten Pfad des Verzeichnisses zu erhalten.

          ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
  </Members>
</Type>
