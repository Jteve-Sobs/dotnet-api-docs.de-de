<Type Name="DirectoryInfo" FullName="System.IO.DirectoryInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f5205a327f40e6d4e37c451f4d85bac47f1b7b58" /><Meta Name="ms.sourcegitcommit" Value="385ff23cc00fe9aa1c93460c62603b45c2041d0b" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/22/2019" /><Meta Name="ms.locfileid" Value="74385477" /></Metadata><TypeSignature Language="C#" Value="public sealed class DirectoryInfo : System.IO.FileSystemInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit DirectoryInfo extends System.IO.FileSystemInfo" />
  <TypeSignature Language="DocId" Value="T:System.IO.DirectoryInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DirectoryInfo&#xA;Inherits FileSystemInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DirectoryInfo sealed : System::IO::FileSystemInfo" />
  <TypeSignature Language="F#" Value="type DirectoryInfo = class&#xA;    inherit FileSystemInfo" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileSystemInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Exposes instance methods for creating, moving, and enumerating through directories and subdirectories. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.IO.DirectoryInfo>-Klasse für typische Vorgänge wie das Kopieren, verschieben, umbenennen, erstellen und Löschen von Verzeichnissen.  
  
 Wenn Sie ein Objekt mehrmals wieder verwenden möchten, sollten Sie die Instanzmethode <xref:System.IO.DirectoryInfo> anstelle der entsprechenden statischen Methoden der <xref:System.IO.Directory> Klasse verwenden, da eine Sicherheitsüberprüfung nicht immer erforderlich ist.  
  
> [!NOTE]
>  In Membern, die einen Pfad als Eingabe Zeichenfolge akzeptieren, muss dieser Pfad wohl geformt sein, oder es wird eine Ausnahme ausgelöst. Wenn ein Pfad z. b. voll qualifiziert ist, aber mit einem Leerzeichen beginnt, wird der Pfad nicht in den Methoden der Klasse gekürzt. Daher ist der Pfad falsch formatiert, und es wird eine Ausnahme ausgelöst. Ebenso kann ein Pfad oder eine Kombination von Pfaden nicht zweimal voll qualifiziert werden. Beispielsweise löst "c:\temp c:\Windows" in den meisten Fällen auch eine Ausnahme aus. Stellen Sie sicher, dass die Pfade wohl geformt sind, wenn Sie Methoden verwenden, die eine Pfad Zeichenfolge akzeptieren.  
  
 In Membern, die einen Pfad akzeptieren, kann der Pfad auf eine Datei oder nur auf ein Verzeichnis verweisen. Der angegebene Pfad kann auch auf einen relativen Pfad oder einen Universal Naming Convention Pfad (UNC-Pfad) für einen Server und einen Freigabe Namen verweisen. Die folgenden Pfade sind beispielsweise zulässig:  
  
-   "c:\\\meindir\\\meineDatei.txt C#" in, oder "c:\mydir\meinedatei.txt" in Visual Basic.  
  
-   "c:\\\meinedir" C#in, oder "c:\meinedir" in Visual Basic.  
  
-   "Mydir\\\meinsubdir" in C#, oder "mydir\meinsubdir" in Visual Basic.  
  
-   "\\\\\\\meinserver\meineserver\\C#\meinefreigabe" in, oder "\\\meinserver\meinefreigabe" in Visual Basic.  
  
 Standardmäßig wird allen Benutzern der vollständige Lese-/Schreibzugriff auf neue Verzeichnisse gewährt.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel werden einige der Hauptmember der `DirectoryInfo`-Klasse veranschaulicht.  
  
 [!code-cpp[DirInfo Class Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Class Example/CPP/dirinfo class example.cpp#1)]
 [!code-csharp[DirInfo Class Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Class Example/CS/dirinfo class example.cs#1)]
 [!code-vb[DirInfo Class Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Class Example/VB/dirinfo class example.vb#1)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie ein Verzeichnis und dessen Inhalt kopiert werden.  
  
 [!code-csharp[IO.DirectoryInfo-CopyDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DirectoryInfo-CopyDir/cs/copydir.cs#1)]
 [!code-vb[IO.DirectoryInfo-CopyDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DirectoryInfo-CopyDir/vb/CopyDir.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="P:System.IO.FileSystemInfo.Attributes" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <altmember cref="T:System.IO.Directory" />
    <altmember cref="T:System.IO.Path" />
    <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Gewusst wie: Lesen und Schreiben einer neu erstellten Datendatei</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DirectoryInfo (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DirectoryInfo(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.DirectoryInfo : string -&gt; System.IO.DirectoryInfo" Usage="new System.IO.DirectoryInfo path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">A string specifying the path on which to create the <see langword="DirectoryInfo" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.DirectoryInfo" /> class on the specified path.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor prüft nicht, ob ein Verzeichnis vorhanden ist. Dieser Konstruktor ist ein Platzhalter für eine Zeichenfolge, die für den Zugriff auf den Datenträger in nachfolgenden Vorgängen verwendet wird.  
  
 Der `path`-Parameter kann ein Dateiname sein, einschließlich einer Datei auf einer Universal Naming Convention Freigabe (UNC).  
  
> [!CAUTION]
>  Wenn Sie einen Zeichensatz mit einer bestimmten Kultur Einstellung kompilieren und dieselben Zeichen mit einer anderen Kultur Einstellung abrufen, sind die Zeichen möglicherweise nicht interpretierbar und können dazu führen, dass eine Ausnahme ausgelöst wird.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird dieser Konstruktor zum Erstellen des angegebenen Verzeichnisses und des angegebenen Unterverzeichnisses verwendet, und es wird veranschaulicht, dass ein Verzeichnis, das Unterverzeichnisse enthält, nicht gelöscht werden kann.  
  
 [!code-cpp[DirInfo Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Ctor/CPP/dirinfo ctor.cpp#1)]
 [!code-csharp[DirInfo Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Ctor/CS/dirinfo ctor.cs#1)]
 [!code-vb[DirInfo Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Ctor/VB/dirinfo ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contains invalid characters such as ", &lt;, &gt;, or |.</exception>
        <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen aus Dateien und Verzeichnissen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DriveInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a directory.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Create" />
      <MemberSignature Language="VB.NET" Value="Public Sub Create ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Create();" />
      <MemberSignature Language="F#" Value="member this.Create : unit -&gt; unit" Usage="directoryInfo.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a directory.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Verzeichnis bereits vorhanden ist, führt diese Methode keine Aktion aus.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird überprüft, ob ein angegebenes Verzeichnis vorhanden ist, das Verzeichnis wird erstellt, wenn es nicht vorhanden ist, und das Verzeichnis wird gelöscht.  
  
 [!code-cpp[DirInfo Create#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Create/CPP/dirinfo create.cpp#1)]
 [!code-csharp[DirInfo Create#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Create/CS/dirinfo create.cs#1)]
 [!code-vb[DirInfo Create#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Create/VB/dirinfo create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">The directory cannot be created.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben von Dateien. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create (System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create(class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Create(System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.Create : System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="directoryInfo.Create directorySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="directorySecurity">The access control to apply to the directory.</param>
        <summary>Creates a directory using a <see cref="T:System.Security.AccessControl.DirectorySecurity" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methoden Überladung, um ein Verzeichnis mit Zugriffs Steuerung zu erstellen. Daher besteht keine Chance, dass auf das Verzeichnis zugegriffen werden kann, bevor die Sicherheit angewendet wird.  
  
 Wenn das Verzeichnis bereits vorhanden ist, führt diese Methode keine Aktion aus.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">The directory specified by <paramref name="path" /> is read-only or is not empty.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The caller does not have the required permission.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> is a zero-length string, contains only white space, or contains one or more invalid characters as defined by <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
        <exception cref="T:System.NotSupportedException">Creating a directory with only the colon (:) character was attempted.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Berechtigung zum Erstellen eines Verzeichnisses. Sicherheitsmaßnahme: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSubdirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a subdirectory or subdirectories on the specified path. The specified path can be relative to this instance of the <see cref="T:System.IO.DirectoryInfo" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSubdirectory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo CreateSubdirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo CreateSubdirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubdirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ CreateSubdirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.CreateSubdirectory : string -&gt; System.IO.DirectoryInfo" Usage="directoryInfo.CreateSubdirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The specified path. This cannot be a different disk volume or Universal Naming Convention (UNC) name.</param>
        <summary>Creates a subdirectory or subdirectories on the specified path. The specified path can be relative to this instance of the <see cref="T:System.IO.DirectoryInfo" /> class.</summary>
        <returns>The last directory specified in <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle in `path` angegebenen Verzeichnisse werden erstellt, es sei denn, ein Teil `path` ist ungültig. Der `path`-Parameter gibt einen Verzeichnispfad und keinen Dateipfad an. Wenn das Unterverzeichnis bereits vorhanden ist, führt diese Methode keine Aktion aus.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Erstellen eines Unterverzeichnisses veranschaulicht. In diesem Beispiel werden die erstellten Verzeichnisse entfernt, nachdem Sie erstellt wurden. Um dieses Beispiel zu testen, kommentieren Sie aus diesem Grund die Lösch Zeilen im Code aus.  
  
 [!code-cpp[directoryinfocreatesub#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfocreatesub/CPP/directoryinfocreatesub.cpp#1)]
 [!code-csharp[directoryinfocreatesub#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfocreatesub/CS/directoryinfocreatesub.cs#1)]
 [!code-vb[directoryinfocreatesub#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfocreatesub/VB/directoryinfocreatesub.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> does not specify a valid file path or contains invalid <see langword="DirectoryInfo" /> characters.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
        <exception cref="T:System.IO.IOException">The subdirectory cannot be created.  
  
-or- 
A file or directory already has the name specified by <paramref name="path" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have code access permission to create the directory.  
  
-or- 
The caller does not have code access permission to read the directory described by the returned <see cref="T:System.IO.DirectoryInfo" /> object.  This can occur when the <paramref name="path" /> parameter describes an existing directory.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> contains a colon character (:) that is not part of a drive label ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen und Schreiben von Dateien. Zugehörige Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /><see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="CreateSubdirectory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo CreateSubdirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo CreateSubdirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ CreateSubdirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.CreateSubdirectory : string * System.Security.AccessControl.DirectorySecurity -&gt; System.IO.DirectoryInfo" Usage="directoryInfo.CreateSubdirectory (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">The specified path. This cannot be a different disk volume or Universal Naming Convention (UNC) name.</param>
        <param name="directorySecurity">The security to apply.</param>
        <summary>Creates a subdirectory or subdirectories on the specified path with the specified security. The specified path can be relative to this instance of the <see cref="T:System.IO.DirectoryInfo" /> class.</summary>
        <returns>The last directory specified in <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle in `path` angegebenen Verzeichnisse werden erstellt, es sei denn, ein Teil `path` ist ungültig. Der `path`-Parameter gibt einen Verzeichnispfad und keinen Dateipfad an. Wenn das Unterverzeichnis bereits vorhanden ist, führt diese Methode keine Aktion aus.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> does not specify a valid file path or contains invalid <see langword="DirectoryInfo" /> characters.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, such as being on an unmapped drive.</exception>
        <exception cref="T:System.IO.IOException">The subdirectory cannot be created.  
  
-or- 
A file or directory already has the name specified by <paramref name="path" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have code access permission to create the directory.  
  
-or- 
The caller does not have code access permission to read the directory described by the returned <see cref="T:System.IO.DirectoryInfo" /> object.  This can occur when the <paramref name="path" /> parameter describes an existing directory.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> contains a colon character (:) that is not part of a drive label ("C:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen und Schreiben von Dateien. Zugehörige Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /><see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Deletes a <see cref="T:System.IO.DirectoryInfo" /> and its contents from a path.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public override void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Delete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Delete();" />
      <MemberSignature Language="F#" Value="override this.Delete : unit -&gt; unit" Usage="directoryInfo.Delete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deletes this <see cref="T:System.IO.DirectoryInfo" /> if it is empty.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Ausnahme ausgelöst, wenn Sie versuchen, ein Verzeichnis zu löschen, das nicht leer ist.  
  
 [!code-cpp[DirInfo Delete1#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Delete1/CPP/dirinfo delete1.cpp#1)]
 [!code-csharp[DirInfo Delete1#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Delete1/CS/dirinfo delete1.cs#1)]
 [!code-vb[DirInfo Delete1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Delete1/VB/dirinfo delete1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The directory contains a read-only file.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The directory described by this <see cref="T:System.IO.DirectoryInfo" /> object does not exist or could not be found.</exception>
        <exception cref="T:System.IO.IOException">The directory is not empty.  
  
-or- 
The directory is the application's current working directory.  
  
-or- 
There is an open handle on the directory, and the operating system is Windows XP or earlier. This open handle can result from enumerating directories. For more information, see [How to: Enumerate Directories and Files](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben von Verzeichnissen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public void Delete (bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Delete(bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Delete(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Delete (recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Delete(bool recursive);" />
      <MemberSignature Language="F#" Value="override this.Delete : bool -&gt; unit" Usage="directoryInfo.Delete recursive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="recursive"><see langword="true" /> to delete this directory, its subdirectories, and all files; otherwise, <see langword="false" />.</param>
        <summary>Deletes this instance of a <see cref="T:System.IO.DirectoryInfo" />, specifying whether to delete subdirectories and files.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `DirectoryInfo` keine Dateien oder Unterverzeichnisse enthält, löscht diese Methode die `DirectoryInfo` auch dann, wenn `recursive` `false`ist. Wenn Sie versuchen, eine `DirectoryInfo` zu löschen, die nicht leer ist, wenn `recursive` ist `false` wird ein <xref:System.IO.IOException>ausgelöst.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Löschen eines Verzeichnisses veranschaulicht. Da das Verzeichnis entfernt wird, kommentieren Sie zunächst die `Delete` Zeile aus, um zu testen, ob das Verzeichnis vorhanden ist. Entfernen Sie dann die Auskommentierung der Codezeile, um zu testen, ob das Verzeichnis erfolgreich entfernt wurde.  
  
 [!code-cpp[directoryinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfodelete/CPP/directoryinfodelete.cpp#1)]
 [!code-csharp[directoryinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfodelete/CS/directoryinfodelete.cs#1)]
 [!code-vb[directoryinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfodelete/VB/directoryinfodelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The directory contains a read-only file.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The directory described by this <see cref="T:System.IO.DirectoryInfo" /> object does not exist or could not be found.</exception>
        <exception cref="T:System.IO.IOException">The directory is read-only.  
  
-or- 
The directory contains one or more files or subdirectories and <paramref name="recursive" /> is <see langword="false" />.  
  
-or- 
The directory is the application's current working directory.  
  
-or- 
There is an open handle on the directory or on one of its files, and the operating system is Windows XP or earlier. This open handle can result from enumerating directories and files. For more information, see [How to: Enumerate Directories and Files](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Das Schreib Flag ist für die Schreib Berechtigung für die <see langword="DirectoryInfo" /> und Unterverzeichnisse erforderlich, die gelöscht werden sollen.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns an enumerable collection of directory information in the current directory.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories () As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories();" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : unit -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerable collection of directory information in the current directory.</summary>
        <returns>An enumerable collection of directories in the current directory.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> und <xref:System.IO.DirectoryInfo.GetDirectories%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.DirectoryInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetDirectories%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.DirectoryInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.DirectoryInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Unterverzeichnisse unter dem Verzeichnis "c:\Program Files" aufgelistet, und es wird eine LINQ-Abfrage verwendet, um die Namen aller Verzeichnisse zurückzugeben, die vor 2009 erstellt wurden, indem der Wert der <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>-Eigenschaft überprüft wird.  
  
 Wenn Sie nur die Namen der Unterverzeichnisse benötigen, verwenden Sie die statische <xref:System.IO.Directory>-Klasse, um die Leistung zu verbessern. Ein Beispiel finden Sie in der <xref:System.IO.Directory.EnumerateDirectories%28System.String%29>-Methode.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumDirs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumdirs/cs/program.cs)]
 [!code-vb[System.IO.DirectoryInfo.EnumDirs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumdirs/vb/module1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path encapsulated in the <see cref="T:System.IO.DirectoryInfo" /> object is invalid (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories (searchPattern As String) As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">The search string to match against the names of directories.  This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</param>
        <summary>Returns an enumerable collection of directory information that matches a specified search pattern.</summary>
        <returns>An enumerable collection of directories that matches <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> und <xref:System.IO.DirectoryInfo.GetDirectories%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.DirectoryInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetDirectories%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.DirectoryInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.DirectoryInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path encapsulated in the <see cref="T:System.IO.DirectoryInfo" /> object is invalid (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="searchPattern">The search string to match against the names of directories. This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</param>
        <param name="enumerationOptions">An object that describes the search and enumeration configuration to use.</param>
        <summary>Returns an enumerable collection of directory information that matches the specified search pattern and enumeration options.</summary>
        <returns>An enumerable collection of directories that matches <paramref name="searchPattern" /> and <paramref name="enumerationOptions" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> und <xref:System.IO.DirectoryInfo.GetDirectories%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.DirectoryInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetDirectories%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.DirectoryInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.DirectoryInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path encapsulated in the <see cref="T:System.IO.DirectoryInfo" /> object is invalid (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string * System.IO.SearchOption -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">The search string to match against the names of directories.  This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</param>
        <param name="searchOption">One of the enumeration values that specifies whether the search operation should include only the current directory or all subdirectories. The default value is <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Returns an enumerable collection of directory information that matches a specified search pattern and search subdirectory option.</summary>
        <returns>An enumerable collection of directories that matches <paramref name="searchPattern" /> and <paramref name="searchOption" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> und <xref:System.IO.DirectoryInfo.GetDirectories%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.DirectoryInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetDirectories%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.DirectoryInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.DirectoryInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel, beginnend bei einem angegebenen Verzeichnis, werden diese Methode und die <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>-Methode verwendet, um die Dateien und Verzeichnisse im Start Verzeichnis aufzulisten und Details von Dateien mit einer Größe von mehr als 10 MB anzuzeigen.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumerateDirectories#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumeratedirectories/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumerateDirectories#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumeratedirectories/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> is not a valid <see cref="T:System.IO.SearchOption" /> value.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path encapsulated in the <see cref="T:System.IO.DirectoryInfo" /> object is invalid (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns an enumerable collection of file information in the current directory.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles () As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles();" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : unit -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerable collection of file information in the current directory.</summary>
        <returns>An enumerable collection of the files in the current directory.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> und <xref:System.IO.DirectoryInfo.GetFiles%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Dateien unter einem angegebenen Verzeichnis aufgelistet und eine LINQ-Abfrage verwendet, um die Namen aller Dateien zurückzugeben, die vor 2009 erstellt wurden, indem der Wert der <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>-Eigenschaft überprüft wird.  
  
 Wenn Sie nur die Namen der Dateien benötigen, verwenden Sie die statische <xref:System.IO.Directory>-Klasse, um die Leistung zu verbessern. Ein Beispiel finden Sie in der <xref:System.IO.Directory.EnumerateFiles%28System.String%29?displayProperty=nameWithType>-Methode.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module1.vb#1)]  
  
 Im folgenden Beispiel wird gezeigt, wie Dateien in einem Verzeichnis mithilfe verschiedener Suchoptionen aufgelistet werden. Im Beispiel wird davon ausgegangen, dass ein Verzeichnis mit Dateien namens log1. txt, log2. txt, test1. txt, test2. txt, "test3". txt und ein Unterverzeichnis mit der Datei "subfile. txt" enthält.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path encapsulated in the <see cref="T:System.IO.DirectoryInfo" /> object is invalid (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles (searchPattern As String) As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">The search string to match against the names of files.  This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</param>
        <summary>Returns an enumerable collection of file information that matches a search pattern.</summary>
        <returns>An enumerable collection of files that matches <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> und <xref:System.IO.DirectoryInfo.GetFiles%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Dateien in einem Verzeichnis mithilfe verschiedener Suchoptionen aufgelistet werden. Im Beispiel wird davon ausgegangen, dass ein Verzeichnis mit Dateien namens log1. txt, log2. txt, test1. txt, test2. txt, "test3". txt und ein Unterverzeichnis mit der Datei "subfile. txt" enthält.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path encapsulated in the <see cref="T:System.IO.DirectoryInfo" /> object is invalid, (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="searchPattern">The search string to match against the names of files. This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</param>
        <param name="enumerationOptions">An object that describes the search and enumeration configuration to use.</param>
        <summary>Returns an enumerable collection of file information that matches the specified search pattern and enumeration options.</summary>
        <returns>An enumerable collection of files that matches <paramref name="searchPattern" /> and <paramref name="enumerationOptions" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> und <xref:System.IO.DirectoryInfo.GetFiles%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path encapsulated in the <see cref="T:System.IO.DirectoryInfo" /> object is invalid, (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string * System.IO.SearchOption -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">The search string to match against the names of files.  This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</param>
        <param name="searchOption">One of the enumeration values that specifies whether the search operation should include only the current directory or all subdirectories. The default value is <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Returns an enumerable collection of file information that matches a specified search pattern and search subdirectory option.</summary>
        <returns>An enumerable collection of files that matches <paramref name="searchPattern" /> and <paramref name="searchOption" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> und <xref:System.IO.DirectoryInfo.GetFiles%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Dateien in einem Verzeichnis mithilfe verschiedener Suchoptionen aufgelistet werden. Im Beispiel wird davon ausgegangen, dass ein Verzeichnis mit Dateien namens log1. txt, log2. txt, test1. txt, test2. txt, "test3". txt und ein Unterverzeichnis mit der Datei "subfile. txt" enthält.  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> is not a valid <see cref="T:System.IO.SearchOption" /> value.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path encapsulated in the <see cref="T:System.IO.DirectoryInfo" /> object is invalid (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemInfos">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns an enumerable collection of file system information in the current directory.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos () As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos();" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : unit -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerable collection of file system information in the current directory.</summary>
        <returns>An enumerable collection of file system information in the current directory.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> und <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileSystemInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileSystemInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileSystemInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path encapsulated in the <see cref="T:System.IO.DirectoryInfo" /> object is invalid (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos (searchPattern As String) As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">The search string to match against the names of directories.  This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</param>
        <summary>Returns an enumerable collection of file system information that matches a specified search pattern.</summary>
        <returns>An enumerable collection of file system information objects that matches <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> und <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileSystemInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileSystemInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileSystemInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path encapsulated in the <see cref="T:System.IO.DirectoryInfo" /> object is invalid (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="searchPattern">The search string to match against the names of directories. This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</param>
        <param name="enumerationOptions">An object that describes the search and enumeration configuration to use.</param>
        <summary>Returns an enumerable collection of file system information that matches the specified search pattern and enumeration options.</summary>
        <returns>An enumerable collection of file system information objects that matches <paramref name="searchPattern" /> and <paramref name="enumerationOptions" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> und <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileSystemInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileSystemInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileSystemInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path encapsulated in the <see cref="T:System.IO.DirectoryInfo" /> object is invalid (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string * System.IO.SearchOption -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">The search string to match against the names of directories.  This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</param>
        <param name="searchOption">One of the enumeration values that specifies whether the search operation should include only the current directory or all subdirectories. The default value is <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Returns an enumerable collection of file system information that matches a specified search pattern and search subdirectory option.</summary>
        <returns>An enumerable collection of file system information objects that matches <paramref name="searchPattern" /> and <paramref name="searchOption" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> und <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileSystemInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileSystemInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> effizienter sein.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileSystemInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>-Methode für die Auflistung startet eine neue-Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> is not a valid <see cref="T:System.IO.SearchOption" /> value.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path encapsulated in the <see cref="T:System.IO.DirectoryInfo" /> object is invalid (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public override bool Exists { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Exists" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Exists" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Exists As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Exists { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Exists : bool" Usage="System.IO.DirectoryInfo.Exists" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the directory exists.</summary>
        <value><see langword="true" />, wenn das Verzeichnis vorhanden ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.DirectoryInfo.Exists%2A>-Eigenschaft gibt `false` zurück, wenn bei dem Versuch, festzustellen, ob die angegebene Datei vorhanden ist, ein Fehler auftritt. Dies kann in Situationen auftreten, in denen Ausnahmen ausgelöst werden, z. b. das Übergeben eines Datei namens mit ungültigen Zeichen oder zu vielen Zeichen, einem fehlerhaften oder fehlenden Datenträger oder, wenn der Aufrufer nicht über die Berechtigung zum Lesen der Datei verfügt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der `Exists`-Eigenschaft im Kontext des Kopierens eines Quell Verzeichnisses in ein Zielverzeichnis.  
  
 [!code-cpp[DirectoryInfo Usage Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirectoryInfo Usage Example/CPP/copydirectory.cpp#1)]
 [!code-csharp[DirectoryInfo Usage Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirectoryInfo Usage Example/CS/copydirectory.cs#1)]
 [!code-vb[DirectoryInfo Usage Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirectoryInfo Usage Example/VB/copydirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.IO.DirectoryInfo.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the full path of the directory.</summary>
        <value>Eine Zeichenfolge mit dem vollständigen Pfad.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the access control list (ACL) entries for the current directory.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie <xref:System.IO.DirectoryInfo.GetAccessControl%2A> Methoden, um die Einträge in der Zugriffs Steuerungs Liste (ACL) für die aktuelle Datei abzurufen.  
  
 Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.DirectorySecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.DirectorySecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::DirectorySecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.DirectorySecurity" Usage="directoryInfo.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a <see cref="T:System.Security.AccessControl.DirectorySecurity" /> object that encapsulates the access control list (ACL) entries for the directory described by the current <see cref="T:System.IO.DirectoryInfo" /> object.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.DirectorySecurity" /> object that encapsulates the access control rules for the directory.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Methoden Überladung entspricht dem Aufrufen der <xref:System.IO.Directory.GetAccessControl%2A>-Methoden Überladung und der Angabe der &#124; Zugriffs &#124; Steuerungs Abschnitte <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> (<xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>`Or`<xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>`Or`<xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> in Visual Basic).  
  
 Verwenden Sie die <xref:System.IO.DirectoryInfo.GetAccessControl%2A>-Methode, um die Einträge in der Zugriffs Steuerungs Liste (ACL) für die aktuelle Datei abzurufen.  
  
 Eine ACL beschreibt Personen und/oder Gruppen, die über Rechte für bestimmte Aktionen in der angegebenen Datei oder dem angegebenen Verzeichnis verfügen oder diese nicht besitzen. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Methoden <xref:System.IO.DirectoryInfo.GetAccessControl%2A> und <xref:System.IO.DirectoryInfo.SetAccessControl%2A> verwendet, um einen Eintrag in einer Zugriffs Steuerungs Liste (ACL) aus einem Verzeichnis hinzuzufügen und daraus zu entfernen.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">The directory could not be found or modified.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The directory is read-only.  
  
 -or-  
  
 This operation is not supported on the current platform.  
  
 -or-  
  
 The caller does not have the required permission.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred while opening the directory.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The current operating system is not Microsoft Windows 2000 or later.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Berechtigung zum Auflisten einer Zugriffs Steuerungs Liste (Access Control List, ACL) für ein Verzeichnis. Sicherheitsmaßnahme: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugehörige Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /><see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.DirectorySecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.DirectorySecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.DirectorySecurity" Usage="directoryInfo.GetAccessControl includeSections" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="includeSections">One of the <see cref="T:System.Security.AccessControl.AccessControlSections" /> values that specifies the type of access control list (ACL) information to receive.</param>
        <summary>Gets a <see cref="T:System.Security.AccessControl.DirectorySecurity" /> object that encapsulates the specified type of access control list (ACL) entries for the directory described by the current <see cref="T:System.IO.DirectoryInfo" /> object.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.DirectorySecurity" /> object that encapsulates the access control rules for the file described by the <paramref name="path" /> parameter.  
  
Exceptions 
 <list type="table"><listheader><term> Exception type 
 </term><description> Condition 
 </description></listheader><item><term><see cref="T:System.SystemException" /></term><description> The directory could not be found or modified.  
  
 </description></item><item><term><see cref="T:System.UnauthorizedAccessException" /></term><description> The current process does not have access to open the directory.  
  
 </description></item><item><term><see cref="T:System.IO.IOException" /></term><description> An I/O error occurred while opening the directory.  
  
 </description></item><item><term><see cref="T:System.PlatformNotSupportedException" /></term><description> The current operating system is not Microsoft Windows 2000 or later.  
  
 </description></item><item><term><see cref="T:System.UnauthorizedAccessException" /></term><description> The directory is read-only.  
  
-or- 
This operation is not supported on the current platform.  
  
-or- 
The caller does not have the required permission.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.IO.DirectoryInfo.GetAccessControl%2A>-Methode, um die Einträge in der Zugriffs Steuerungs Liste (ACL) für die aktuelle Datei abzurufen.  
  
 Eine ACL beschreibt Personen und/oder Gruppen, die über Rechte für bestimmte Aktionen in der angegebenen Datei oder dem angegebenen Verzeichnis verfügen oder diese nicht besitzen. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Berechtigung zum Auflisten einer Zugriffs Steuerungs Liste (Access Control List, ACL) für ein Verzeichnis. Sicherheitsmaßnahme: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugehörige Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /><see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the subdirectories of the current directory.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories () As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories();" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : unit -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the subdirectories of the current directory.</summary>
        <returns>An array of <see cref="T:System.IO.DirectoryInfo" /> objects.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn keine Unterverzeichnisse vorhanden sind, gibt diese Methode ein leeres Array zurück. Diese Methode ist nicht rekursiv.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.DirectoryInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Verzeichnisse im Stammverzeichnis abgerufen, und die Verzeichnisnamen werden angezeigt.  
  
 [!code-cpp[directoryinfogetdirectories#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfogetdirectories/CPP/directoryinfogetdirectories.cpp#1)]
 [!code-csharp[directoryinfogetdirectories#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetdirectories/CS/directoryinfogetdirectories.cs#1)]
 [!code-vb[directoryinfogetdirectories#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetdirectories/VB/directoryinfogetdirectories.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path encapsulated in the <see cref="T:System.IO.DirectoryInfo" /> object is invalid, such as being on an unmapped drive.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen von Verzeichnissen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (searchPattern As String) As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">The search string to match against the names of directories.  This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</param>
        <summary>Returns an array of directories in the current <see cref="T:System.IO.DirectoryInfo" /> matching the given search criteria.</summary>
        <returns>An array of type <see langword="DirectoryInfo" /> matching <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.DirectoryInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Verzeichnisse in einem Pfad gezählt, der den angegebenen Buchstaben enthält.  
  
 [!code-cpp[DirInfo GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo GetDirs2/CPP/dirinfo getdirs2.cpp#1)]
 [!code-csharp[DirInfo GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo GetDirs2/CS/dirinfo getdirs2.cs#1)]
 [!code-vb[DirInfo GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo GetDirs2/VB/dirinfo getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> contains one or more invalid characters defined by the <see cref="M:System.IO.Path.GetInvalidPathChars" /> method.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path encapsulated in the <see langword="DirectoryInfo" /> object is invalid (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen aus Dateien und Verzeichnissen und für den Zugriff auf den Pfad. Zugehörige Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /><see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string * System.IO.EnumerationOptions -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="searchPattern">The search string to match against the names of directories. This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</param>
        <param name="enumerationOptions">An object that describes the search and enumeration configuration to use.</param>
        <summary>Returns an array of directories in the current <see cref="T:System.IO.DirectoryInfo" /> matching the specified search pattern and enumeration options.</summary>
        <returns>An array of type <see langword="DirectoryInfo" /> matching <paramref name="searchPattern" /> and <paramref name="enumerationOptions" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.DirectoryInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> contains one or more invalid characters defined by the <see cref="M:System.IO.Path.GetInvalidPathChars" /> method.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path encapsulated in the <see langword="DirectoryInfo" /> object is invalid (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The caller does not have the required permission.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string * System.IO.SearchOption -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">The search string to match against the names of directories.  This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</param>
        <param name="searchOption">One of the enumeration values that specifies whether the search operation should include only the current directory or all subdirectories.</param>
        <summary>Returns an array of directories in the current <see cref="T:System.IO.DirectoryInfo" /> matching the given search criteria and using a value to determine whether to search subdirectories.</summary>
        <returns>An array of type <see langword="DirectoryInfo" /> matching <paramref name="searchPattern" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Wenn keine Unterverzeichnisse vorhanden sind oder keine Unterverzeichnisse mit dem `searchPattern`-Parameter identisch sind, gibt diese Methode ein leeres Array zurück.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.DirectoryInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Verzeichnisse und Dateien aufgelistet, die mit dem Buchstaben "c" in "c:\\" beginnen.  
  
 [!code-cpp[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/cpp/searchoption.cpp#00)]
 [!code-csharp[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/cs/searchoption.cs#00)]
 [!code-vb[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/vb/searchoption.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> contains one or more invalid characters defined by the <see cref="M:System.IO.Path.GetInvalidPathChars" /> method.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> is not a valid <see cref="T:System.IO.SearchOption" /> value.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path encapsulated in the <see langword="DirectoryInfo" /> object is invalid (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.UnauthorizedAccessException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen aus Dateien und Verzeichnissen und für den Zugriff auf den Pfad. Zugehörige Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /><see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a file list from the current directory.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles () As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="member this.GetFiles : unit -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a file list from the current directory.</summary>
        <returns>An array of type <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> und <xref:System.IO.DirectoryInfo.GetFiles%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> effizienter sein.  
  
 Wenn der <xref:System.IO.DirectoryInfo>keine Dateien enthält, gibt diese Methode ein leeres Array zurück.  
  
 Die Reihenfolge der zurückgegebenen Dateinamen ist nicht garantiert. Verwenden Sie die <xref:System.Array.Sort%2A>-Methode, wenn eine bestimmte Sortierreihenfolge erforderlich ist.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie eine Liste von Dateien aus einem Verzeichnis mithilfe verschiedener Suchoptionen erhalten. Im Beispiel wird davon ausgegangen, dass ein Verzeichnis mit Dateien namens log1. txt, log2. txt, test1. txt, test2. txt, "test3". txt und ein Unterverzeichnis mit der Datei "subfile. txt" enthält.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path is invalid, such as being on an unmapped drive.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen von Verzeichnissen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (searchPattern As String) As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">The search string to match against the names of files.  This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</param>
        <summary>Returns a file list from the current directory matching the given search pattern.</summary>
        <returns>An array of type <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> und <xref:System.IO.DirectoryInfo.GetFiles%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> effizienter sein.  
  
 Wenn der <xref:System.IO.DirectoryInfo>keine Dateien enthält, gibt diese Methode ein leeres Array zurück.  
  
 Die folgenden Platzhalter Spezifizierer sind im `searchPattern`-Parameter zulässig.  
  
|Platzhalter Zeichen|Beschreibung|  
|------------------------|-----------------|  
|*|NULL oder mehr Zeichen.|  
|?|Genau null oder ein Zeichen.|  
  
 Die Reihenfolge der zurückgegebenen Dateinamen ist nicht garantiert. Verwenden Sie die <xref:System.Array.Sort%2A>-Methode, wenn eine bestimmte Sortierreihenfolge erforderlich ist.  
  
 Platzhalter sind zulässig. Beispielsweise sucht die `searchPattern` Zeichenfolge "*. txt" nach allen Dateinamen, die die Erweiterung "txt" aufweisen. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Dateinamen, die mit dem Buchstaben "s" beginnen. Wenn keine Dateien vorhanden sind oder keine Dateien vorhanden sind, die mit der `searchPattern` Zeichenfolge im <xref:System.IO.DirectoryInfo>identisch sind, gibt diese Methode ein leeres Array zurück.  
  
> [!NOTE]
>  Wenn Sie das Platzhalter Zeichen Sternchen in einem `searchPattern` verwenden (z. b. "*. txt"), variiert das übereinstimmende Verhalten in Abhängigkeit von der Länge der angegebenen Dateierweiterung. Ein `searchPattern` mit einer Dateierweiterung von genau drei Zeichen gibt Dateien mit einer Erweiterung von drei oder mehr Zeichen zurück, wobei die ersten drei Zeichen mit der im `searchPattern`angegebenen Dateierweiterung übereinstimmen. Ein `searchPattern` mit einer Dateierweiterung von einem, zwei oder mehr als drei Zeichen gibt nur Dateien mit der Erweiterung genau dieser Länge zurück, die mit der Dateierweiterung übereinstimmen, die in der `searchPattern`angegeben ist. Wenn Sie das Fragezeichen-Platzhalter Zeichen verwenden, gibt diese Methode nur die Dateien zurück, die der angegebenen Dateierweiterung entsprechen. Angenommen, es gibt zwei Dateien in einem Verzeichnis: "file1. txt" und "file1. txtother", das Suchmuster "file?". txt "gibt nur die erste Datei zurück, während das Suchmuster" File\*. txt "beide Dateien zurückgibt.  
  
> [!NOTE]
>  Da diese Methode Dateinamen sowohl mit dem Dateinamen Format 8,3 als auch mit dem langen Dateinamen Format überprüft, kann ein Suchmuster ähnlich "* 1\*. txt" unerwartete Dateinamen zurückgeben. Wenn Sie z. b. ein Suchmuster von "\*1\*. txt" verwenden, wird "longfilename. txt" zurückgegeben, da das entsprechende Format für den 8,3-Dateinamen "longf ~ 1. txt" lauten würde.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie eine Liste von Dateien aus einem Verzeichnis mithilfe verschiedener Suchoptionen erhalten. Im Beispiel wird davon ausgegangen, dass ein Verzeichnis mit Dateien namens log1. txt, log2. txt, test1. txt, test2. txt, "test3". txt und ein Unterverzeichnis mit der Datei "subfile. txt" enthält.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> contains one or more invalid characters defined by the <see cref="M:System.IO.Path.GetInvalidPathChars" /> method.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path is invalid (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf den Pfad und zum Lesen aus Dateien und Verzeichnissen. Zugehörige Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /><see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string * System.IO.EnumerationOptions -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="searchPattern">The search string to match against the names of files. This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</param>
        <param name="enumerationOptions">An object that describes the search and enumeration configuration to use.</param>
        <summary>Returns a file list from the current directory matching the specified search pattern and enumeration options.</summary>
        <returns>An array of strongly typed <see cref="T:System.IO.FileInfo" /> objects that match <paramref name="searchPattern" /> and <paramref name="enumerationOptions" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> und <xref:System.IO.DirectoryInfo.GetFiles%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> effizienter sein.  
  
 Wenn der <xref:System.IO.DirectoryInfo>keine Dateien enthält, gibt diese Methode ein leeres Array zurück.  
  
 Die folgenden Platzhalter Spezifizierer sind im `searchPattern`-Parameter zulässig.  
  
|Platzhalter Zeichen|Beschreibung|  
|------------------------|-----------------|  
|*|NULL oder mehr Zeichen.|  
|?|Genau null oder ein Zeichen.|  
  
 Die Reihenfolge der zurückgegebenen Dateinamen ist nicht garantiert. Verwenden Sie die <xref:System.Array.Sort%2A>-Methode, wenn eine bestimmte Sortierreihenfolge erforderlich ist.  
  
 Platzhalter sind zulässig. Beispielsweise sucht die `searchPattern` Zeichenfolge "*. txt" nach allen Dateinamen, die die Erweiterung "txt" aufweisen. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Dateinamen, die mit dem Buchstaben "s" beginnen. Wenn keine Dateien vorhanden sind oder keine Dateien vorhanden sind, die mit der `searchPattern` Zeichenfolge im <xref:System.IO.DirectoryInfo>identisch sind, gibt diese Methode ein leeres Array zurück.  
  
> [!NOTE]
>  Wenn Sie das Platzhalter Zeichen Sternchen in einem `searchPattern` verwenden (z. b. "*. txt"), variiert das übereinstimmende Verhalten in Abhängigkeit von der Länge der angegebenen Dateierweiterung. Ein `searchPattern` mit einer Dateierweiterung von genau drei Zeichen gibt Dateien mit einer Erweiterung von drei oder mehr Zeichen zurück, wobei die ersten drei Zeichen mit der im `searchPattern`angegebenen Dateierweiterung übereinstimmen. Ein `searchPattern` mit einer Dateierweiterung von einem, zwei oder mehr als drei Zeichen gibt nur Dateien mit der Erweiterung genau dieser Länge zurück, die mit der Dateierweiterung übereinstimmen, die in der `searchPattern`angegeben ist. Wenn Sie das Fragezeichen-Platzhalter Zeichen verwenden, gibt diese Methode nur die Dateien zurück, die der angegebenen Dateierweiterung entsprechen. Angenommen, es gibt zwei Dateien in einem Verzeichnis: "file1. txt" und "file1. txtother", das Suchmuster "file?". txt "gibt nur die erste Datei zurück, während das Suchmuster" File\*. txt "beide Dateien zurückgibt.  
  
> [!NOTE]
>  Da diese Methode Dateinamen sowohl mit dem Dateinamen Format 8,3 als auch mit dem langen Dateinamen Format überprüft, kann ein Suchmuster ähnlich "* 1\*. txt" unerwartete Dateinamen zurückgeben. Wenn Sie z. b. ein Suchmuster von "\*1\*. txt" verwenden, wird "longfilename. txt" zurückgegeben, da das entsprechende Format für den 8,3-Dateinamen "longf ~ 1. txt" lauten würde.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> contains one or more invalid characters defined by the <see cref="M:System.IO.Path.GetInvalidPathChars" /> method.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path is invalid (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string * System.IO.SearchOption -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">The search string to match against the names of files.  This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</param>
        <param name="searchOption">One of the enumeration values that specifies whether the search operation should include only the current directory or all subdirectories.</param>
        <summary>Returns a file list from the current directory matching the given search pattern and using a value to determine whether to search subdirectories.</summary>
        <returns>An array of type <see cref="T:System.IO.FileInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> und <xref:System.IO.DirectoryInfo.GetFiles%2A> unterscheiden sich wie folgt:  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>verwenden, können Sie mit dem Auflisten der Auflistung von <xref:System.IO.FileInfo> Objekten beginnen, bevor die gesamte Auflistung zurückgegeben wird.  
  
-   Wenn Sie <xref:System.IO.DirectoryInfo.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von <xref:System.IO.FileInfo> Objekten zurückgegeben wird, bevor Sie auf das Array zugreifen können.  
  
 Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.DirectoryInfo.EnumerateFiles%2A> effizienter sein.  
  
 Wenn der <xref:System.IO.DirectoryInfo>keine Dateien enthält, gibt diese Methode ein leeres Array zurück.  
  
 Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Zeichen|Beschreibung|  
|------------------------|-----------------|  
|\* (Sternchen)|NULL oder mehr Zeichen.|  
|? (Fragezeichen)|Genau null oder ein Zeichen.|  
  
 Die Reihenfolge der zurückgegebenen Dateinamen ist nicht garantiert. Verwenden Sie die <xref:System.Array.Sort%2A>-Methode, wenn eine bestimmte Sortierreihenfolge erforderlich ist.  
  
 Platzhalter sind zulässig. Beispielsweise sucht die `searchPattern` Zeichenfolge "*. txt" nach allen Dateinamen, die die Erweiterung "txt" aufweisen. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Dateinamen, die mit dem Buchstaben "s" beginnen. Wenn keine Dateien vorhanden sind oder keine Dateien vorhanden sind, die mit der `searchPattern` Zeichenfolge im <xref:System.IO.DirectoryInfo>identisch sind, gibt diese Methode ein leeres Array zurück.  
  
> [!NOTE]
>  Wenn Sie das Platzhalter Zeichen Sternchen in einem `searchPattern` verwenden (z. b. "*. txt"), variiert das übereinstimmende Verhalten in Abhängigkeit von der Länge der angegebenen Dateierweiterung. Ein `searchPattern` mit einer Dateierweiterung von genau drei Zeichen gibt Dateien mit einer Erweiterung von drei oder mehr Zeichen zurück, wobei die ersten drei Zeichen mit der im `searchPattern`angegebenen Dateierweiterung übereinstimmen. Ein `searchPattern` mit einer Dateierweiterung von einem, zwei oder mehr als drei Zeichen gibt nur Dateien mit der Erweiterung genau dieser Länge zurück, die mit der Dateierweiterung übereinstimmen, die in der `searchPattern`angegeben ist. Wenn Sie das Fragezeichen-Platzhalter Zeichen verwenden, gibt diese Methode nur die Dateien zurück, die der angegebenen Dateierweiterung entsprechen. Angenommen, es gibt zwei Dateien in einem Verzeichnis: "file1. txt" und "file1. txtother", das Suchmuster "file?". txt "gibt nur die erste Datei zurück, während das Suchmuster" File\*. txt "beide Dateien zurückgibt.  
  
 In der folgenden Liste wird das Verhalten unterschiedlicher Längen für den `searchPattern`-Parameter angezeigt:  
  
-   "*. ABC" gibt Dateien mit der Erweiterung ". ABC", ". abcd", ". abcde", ". abcdef" usw. zurück.  
  
-   "*. abcd" gibt nur Dateien mit der Erweiterung ". abcd" zurück.  
  
-   "*. abcde" gibt nur Dateien mit der Erweiterung ". abcde" zurück.  
  
-   "*. abcdef" gibt nur Dateien mit der Erweiterung ". abcdef" zurück.  
  
> [!NOTE]
>  Da diese Methode Dateinamen sowohl mit dem Dateinamen Format 8,3 als auch mit dem langen Dateinamen Format überprüft, kann ein Suchmuster ähnlich "* 1\*. txt" unerwartete Dateinamen zurückgeben. Wenn Sie z. b. ein Suchmuster von "\*1\*. txt" verwenden, wird "longfilename. txt" zurückgegeben, da das entsprechende Format für den 8,3-Dateinamen "longf ~ 1. txt" lauten würde.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileInfo> Eigenschaften vorab auf:  
  
1.  <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
2.  <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
3.  <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
4.  <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
5.  <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
6.  <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
7.  <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
8.  <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie eine Liste von Dateien aus einem Verzeichnis mithilfe verschiedener Suchoptionen erhalten. Im Beispiel wird davon ausgegangen, dass ein Verzeichnis mit Dateien namens log1. txt, log2. txt, test1. txt, test2. txt, "test3". txt und ein Unterverzeichnis mit der Datei "subfile. txt" enthält.  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> contains one or more invalid characters defined by the <see cref="M:System.IO.Path.GetInvalidPathChars" /> method.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> is not a valid <see cref="T:System.IO.SearchOption" /> value.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path is invalid (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf den Pfad und zum Lesen aus Dateien und Verzeichnissen. Zugehörige Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /><see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemInfos">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retrieves an array of strongly typed <see cref="T:System.IO.FileSystemInfo" /> objects representing files and subdirectories of the current directory.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos () As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos();" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : unit -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an array of strongly typed <see cref="T:System.IO.FileSystemInfo" /> entries representing all the files and subdirectories in a directory.</summary>
        <returns>An array of strongly typed <see cref="T:System.IO.FileSystemInfo" /> entries.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn keine Dateien oder Verzeichnisse in der <xref:System.IO.DirectoryInfo>vorhanden sind, gibt diese Methode ein leeres Array zurück. Diese Methode ist nicht rekursiv.  
  
 Für Unterverzeichnisse können die von dieser Methode zurückgegebenen <xref:System.IO.FileSystemInfo> Objekte in die abgeleitete Klasse <xref:System.IO.DirectoryInfo>umgewandelt werden. Verwenden Sie den <xref:System.IO.FileAttributes> Wert, der von der <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird, um zu bestimmen, ob der <xref:System.IO.FileSystemInfo> eine Datei oder ein Verzeichnis darstellt  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileSystemInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Dateien und Verzeichnisse im angegebenen Verzeichnis gezählt.  
  
 [!code-csharp[FSizeSort#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSizeSort/CS/fsizesort.cs#1)]
 [!code-vb[FSizeSort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSizeSort/VB/fsizesort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">The path is invalid (for example, it is on an unmapped drive).</exception>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos (searchPattern As String) As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">The search string to match against the names of directories and files.  This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</param>
        <summary>Retrieves an array of strongly typed <see cref="T:System.IO.FileSystemInfo" /> objects representing the files and subdirectories that match the specified search criteria.</summary>
        <returns>An array of strongly typed <see langword="FileSystemInfo" /> objects matching the search criteria.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Diese Methode ist nicht rekursiv.  
  
 Für Unterverzeichnisse können die von dieser Methode zurückgegebenen <xref:System.IO.FileSystemInfo> Objekte in die abgeleitete Klasse <xref:System.IO.DirectoryInfo>umgewandelt werden. Verwenden Sie den <xref:System.IO.FileAttributes> Wert, der von der <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird, um zu bestimmen, ob der <xref:System.IO.FileSystemInfo> eine Datei oder ein Verzeichnis darstellt  
  
 Platzhalter sind zulässig. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Verzeichnisnamen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Verzeichnisnamen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Zeichenfolge ".." kann nur in `searchPattern` verwendet werden, wenn Sie als Teil eines gültigen Verzeichnis namens angegeben wird, z. b. im Verzeichnisnamen "a.". b ". Sie kann nicht verwendet werden, um die Verzeichnishierarchie nach oben zu verschieben. Wenn keine Dateien oder Verzeichnisse vorhanden sind oder keine Dateien oder Verzeichnisse vorhanden sind, die mit der `searchPattern` Zeichenfolge im <xref:System.IO.DirectoryInfo>identisch sind, gibt diese Methode ein leeres Array zurück.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileSystemInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Dateien und Verzeichnisse gezählt, die dem angegebenen Suchmuster entsprechen.  
  
 [!code-csharp[DirInfo GetFileSysInfos2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo GetFileSysInfos2/CS/dirinfo getfilesysinfos2.cs#1)]
 [!code-vb[DirInfo GetFileSysInfos2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo GetFileSysInfos2/VB/dirinfo getfilesysinfos2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> contains one or more invalid characters defined by the <see cref="M:System.IO.Path.GetInvalidPathChars" /> method.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen aus Dateien und Verzeichnissen und für den Zugriff auf den Pfad. Zugehörige Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /><see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string * System.IO.EnumerationOptions -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="searchPattern">The search string to match against the names of directories and files. This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</param>
        <param name="enumerationOptions">An object that describes the search and enumeration configuration to use.</param>
        <summary>Retrieves an array of strongly typed <see cref="T:System.IO.FileSystemInfo" /> objects representing the files and subdirectories that match the specified search pattern and enumeration options.</summary>
        <returns>An array of strongly typed <see langword="FileSystemInfo" /> objects matching <paramref name="searchPattern" /> and <paramref name="enumerationOptions" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Diese Methode ist nicht rekursiv.  
  
 Für Unterverzeichnisse können die von dieser Methode zurückgegebenen <xref:System.IO.FileSystemInfo> Objekte in die abgeleitete Klasse <xref:System.IO.DirectoryInfo>umgewandelt werden. Verwenden Sie den <xref:System.IO.FileAttributes> Wert, der von der <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird, um zu bestimmen, ob der <xref:System.IO.FileSystemInfo> eine Datei oder ein Verzeichnis darstellt  
  
 Platzhalter sind zulässig. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Verzeichnisnamen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Verzeichnisnamen in `path` beginnend mit dem Buchstaben "s".  
  
 Die Zeichenfolge ".." kann nur in `searchPattern` verwendet werden, wenn Sie als Teil eines gültigen Verzeichnis namens angegeben wird, z. b. im Verzeichnisnamen "a.". b ". Sie kann nicht verwendet werden, um die Verzeichnishierarchie nach oben zu verschieben. Wenn keine Dateien oder Verzeichnisse vorhanden sind oder keine Dateien oder Verzeichnisse vorhanden sind, die mit der `searchPattern` Zeichenfolge im <xref:System.IO.DirectoryInfo>identisch sind, gibt diese Methode ein leeres Array zurück.  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileSystemInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> contains one or more invalid characters defined by the <see cref="M:System.IO.Path.GetInvalidPathChars" /> method.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string * System.IO.SearchOption -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="searchPattern">The search string to match against the names of directories and files.  This parameter can contain a combination of valid literal path and wildcard (* and ?) characters, but it doesn't support regular expressions.</param>
        <param name="searchOption">One of the enumeration values that specifies whether the search operation should include only the current directory or all subdirectories. The default value is <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Retrieves an array of <see cref="T:System.IO.FileSystemInfo" /> objects that represent the files and subdirectories matching the specified search criteria.</summary>
        <returns>An array of file system entries that match the search criteria.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Die Zeichenfolge "\*t" sucht z. b. nach allen Namen, die mit dem Buchstaben "t" enden. ". Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 Für Unterverzeichnisse können die von dieser Methode zurückgegebenen <xref:System.IO.FileSystemInfo> Objekte in die abgeleitete Klasse <xref:System.IO.DirectoryInfo>umgewandelt werden. Verwenden Sie den <xref:System.IO.FileAttributes> Wert, der von der <xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType>-Eigenschaft zurückgegeben wird, um zu bestimmen, ob der <xref:System.IO.FileSystemInfo> eine Datei oder ein Verzeichnis darstellt  
  
 Diese Methode füllt die Werte der folgenden <xref:System.IO.FileSystemInfo> Eigenschaften vorab auf:  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="searchPattern" /> contains one or more invalid characters defined by the <see cref="M:System.IO.Path.GetInvalidPathChars" /> method.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> is not a valid <see cref="T:System.IO.SearchOption" /> value.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid (for example, it is on an unmapped drive).</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.MoveTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::String ^ destDirName);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : string -&gt; unit" Usage="directoryInfo.MoveTo destDirName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destDirName">The name and path to which to move this directory. The destination cannot be another disk volume or a directory with the identical name. It can be an existing directory to which you want to add this directory as a subdirectory.</param>
        <summary>Moves a <see cref="T:System.IO.DirectoryInfo" /> instance and its contents to a new path.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode löst eine <xref:System.IO.IOException> aus, wenn Sie z. b. versuchen, c:\meinedir nach c:\Public zu verschieben, und c:\Public bereits vorhanden ist. Sie müssen "c:\\\Public\\\MyDir" als `destDirName` Parameter angeben oder einen neuen Verzeichnisnamen angeben, z. b. "c:\\\newdir".  
  
 Diese Methode ermöglicht das Verschieben eines Verzeichnisses in ein Schreib geschütztes Verzeichnis. Das Attribut mit Lese-/Schreibzugriff ist von keinem der Verzeichnisse betroffen.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Verschieben eines Verzeichnisses veranschaulicht.  
  
 [!code-cpp[directoryinfomoveto#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfomoveto/CPP/directoryinfomoveto.cpp#1)]
 [!code-csharp[directoryinfomoveto#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfomoveto/CS/directoryinfomoveto.cs#1)]
 [!code-vb[directoryinfomoveto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfomoveto/VB/directoryinfomoveto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destDirName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="destDirName" /> is an empty string (''").</exception>
        <exception cref="T:System.IO.IOException">An attempt was made to move a directory to a different volume.  
  
-or- 
 <paramref name="destDirName" /> already exists.  
  
-or- 
You are not authorized to access this path.  
  
-or- 
The directory being moved and the destination directory have the same name.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">The destination directory cannot be found.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen und Schreiben von Dateien und Verzeichnissen und für den Zugriff auf das Zielverzeichnis. Sicherheitsmaßnahme: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugehörige Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /><see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.DirectoryInfo.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of this <see cref="T:System.IO.DirectoryInfo" /> instance.</summary>
        <value>Der Name des Verzeichnisses.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese <xref:System.IO.DirectoryInfo.Name%2A> Eigenschaft gibt nur den Namen des Verzeichnisses zurück, z. b. "bin". Um den vollständigen Pfad, z. b. "c:\public\Bin", zu erhalten, verwenden Sie die <xref:System.IO.FileSystemInfo.FullName%2A>-Eigenschaft.  
  
 Die <xref:System.IO.DirectoryInfo.Name%2A>-Eigenschaft einer <xref:System.IO.DirectoryInfo> erfordert keine Berechtigung (über die Read-Berechtigung für das Verzeichnis, das zum Erstellen des <xref:System.IO.DirectoryInfo.Exists%2A>erforderlich ist), kann jedoch den Verzeichnisnamen abgeben. Wenn eine <xref:System.IO.DirectoryInfo> an ein geschütztes Verzeichnis mit einem kryptografisch sicheren Namen übergeben werden muss, erstellen Sie ein dummyverzeichnis für die Verwendung durch den nicht vertrauenswürdigen Code.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird nur der Name der aktuellen `DirectoryInfo`-Instanz angezeigt.  
  
 [!code-cpp[Classic DirectoryInfo.Name Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DirectoryInfo.Name Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/CS/source.cs#1)]
 [!code-vb[Classic DirectoryInfo.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemInfo.FullName" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Parent" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Parent { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.IO.DirectoryInfo" Usage="System.IO.DirectoryInfo.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the parent directory of a specified subdirectory.</summary>
        <value>Das übergeordnete Verzeichnis oder <see langword="null" />, wenn der Pfad NULL ist oder wenn der Dateipfad einen Stamm (z. b. `\`, `C:\`oder `\\server\share`) angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!IMPORTANT]
> In .NET Framework gibt `Parent` einen relativen Pfad zurück.
> In .net Core gibt `Parent` einen voll qualifizierten Pfad zurück.

Um ein konsistentes Verhalten über mehrere Versionen hinweg sicherzustellen und ihre Absicht explizit zu machen, rufen Sie den Wert einer der folgenden Eigenschaften auf der <xref:System.IO.DirectoryInfo> Instanz ab, die von `Parent`zurückgegeben wird.
- <xref:System.IO.DirectoryInfo.Name>, die den einfachen Namen des Verzeichnisses zurückgibt (z. b. `bin`).
- <xref:System.IO.DirectoryInfo.FullName>, die den absoluten Pfad des Verzeichnisses zurückgibt. 


Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.


## Examples

Im folgenden Beispiel wird auf das übergeordnete Verzeichnis eines angegebenen Verzeichnisses verwiesen.

[!code-cpp[directoryinfoparent#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfoparent/CPP/directoryinfoparent.cpp#1)]
[!code-csharp[directoryinfoparent#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfoparent/CS/directoryinfoparent.cs#1)]
[!code-vb[directoryinfoparent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfoparent/VB/directoryinfoparent.vb#1)]

          ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen aus Dateien und Verzeichnissen und für den Zugriff auf den Pfad. Zugehörige Enumerationen: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /><see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Root">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Root { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Root" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Root" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Root As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Root { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Root : System.IO.DirectoryInfo" Usage="System.IO.DirectoryInfo.Root" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the root portion of the directory.</summary>
        <value>Ein Objekt, das den Stamm des Verzeichnisses darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel werden die Stamm Speicherorte für angegebene Verzeichnisse angezeigt.  
  
 [!code-csharp[directoryinforoot#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinforoot/CS/directoryinforoot2.cs#2)]
 [!code-vb[directoryinforoot#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinforoot/VB/directoryinforoot2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen aus Dateien und Verzeichnissen und für den Zugriff auf den Pfad. Zugehörige Enumerationen: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /><see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="directoryInfo.SetAccessControl directorySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="directorySecurity">An object that describes an ACL entry to apply to the directory described by the <paramref name="path" /> parameter.</param>
        <summary>Applies access control list (ACL) entries described by a <see cref="T:System.Security.AccessControl.DirectorySecurity" /> object to the directory described by the current <see cref="T:System.IO.DirectoryInfo" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In einer Zugriffs Steuerungs Liste (Access Control List, ACL) werden Personen und/oder Gruppen beschrieben, die bzw. die über keine Rechte für bestimmte Aktionen in der angegebenen Datei oder dem angegebenen Verzeichnis verfügen. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Die <xref:System.IO.DirectoryInfo.SetAccessControl%2A>-Methode wendet ACL-Einträge auf eine Datei an, die die nicht geerbte ACL-Liste darstellt.  
  
> [!CAUTION]
>  Die für `directorySecurity` angegebene ACL ersetzt die vorhandene ACL für das Verzeichnis. Um Berechtigungen für einen neuen Benutzer hinzuzufügen, verwenden Sie die <xref:System.IO.DirectoryInfo.GetAccessControl%2A>-Methode, um die vorhandene ACL abzurufen und zu ändern.  
  
 Die <xref:System.IO.DirectoryInfo.SetAccessControl%2A>-Methode speichert nur <xref:System.Security.AccessControl.DirectorySecurity> Objekte, die nach der Objekt Erstellung geändert wurden.  Wenn ein <xref:System.Security.AccessControl.DirectorySecurity> Objekt nicht geändert wurde, wird es nicht in einer Datei persistent gespeichert.  Aus diesem Grund ist es nicht möglich, ein <xref:System.Security.AccessControl.DirectorySecurity> Objekt aus einer Datei abzurufen und das gleiche Objekt erneut auf eine andere Datei anzuwenden.  
  
 So kopieren Sie ACL-Informationen aus einer Datei in eine andere:  
  
1.  Verwenden Sie die <xref:System.IO.DirectoryInfo.GetAccessControl%2A>-Methode, um das <xref:System.Security.AccessControl.DirectorySecurity> Objekt aus der Quelldatei abzurufen.  
  
2.  Erstellen Sie ein neues <xref:System.Security.AccessControl.DirectorySecurity>-Objekt für die Zieldatei.  
  
3.  Verwenden Sie die <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A>-oder <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>-Methode des Quell <xref:System.Security.AccessControl.DirectorySecurity> Objekts, um die ACL-Informationen abzurufen.  
  
4.  Verwenden Sie die Methode <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> oder <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>, um die in Schritt 3 abgerufenen Informationen in das Ziel <xref:System.Security.AccessControl.DirectorySecurity> Objekt zu kopieren.  
  
5.  Legen Sie das Ziel <xref:System.Security.AccessControl.DirectorySecurity> Objekt mithilfe der <xref:System.IO.DirectoryInfo.SetAccessControl%2A>-Methode auf die Zieldatei fest.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Methoden <xref:System.IO.DirectoryInfo.GetAccessControl%2A> und <xref:System.IO.DirectoryInfo.SetAccessControl%2A> verwendet, um einen Eintrag in einer Zugriffs Steuerungs Liste (ACL) aus einem Verzeichnis hinzuzufügen und daraus zu entfernen.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="directorySecurity" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">The file could not be found or modified.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The current process does not have access to open the file.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The current operating system is not Microsoft Windows 2000 or later.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">, um die Zugriffs Steuerungs Liste (ACL) für ein Verzeichnis aufzuzählen. Sicherheitsmaßnahme: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugehörige Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /><see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="directoryInfo.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the original path that was passed to the <see cref="T:System.IO.DirectoryInfo" /> constructor. Use the <see cref="P:System.IO.DirectoryInfo.FullName" /> or <see cref="P:System.IO.DirectoryInfo.Name" /> properties for the full path or file/directory name instead of this method.</summary>
        <returns>The original path that was passed by the user.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!IMPORTANT]
> Die von der <xref:System.IO.DirectoryInfo.ToString%2A>-Methode zurückgegebene Zeichenfolge stellt den Pfad dar, der an den <xref:System.IO.DirectoryInfo>-Konstruktor übergeben wurde. Anstatt die `ToString`-Methode aufrufen zu können, sollten Sie den Wert einer der folgenden Eigenschaften abhängig von ihrer Absicht abrufen:
> - <xref:System.IO.DirectoryInfo.Name>, um den Namen des Verzeichnisses ohne Informationen über den übergeordneten Pfad zu erhalten.
> - <xref:System.IO.DirectoryInfo.FullName>, um den voll qualifizierten Pfad des Verzeichnisses zu erhalten.

          ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
  </Members>
</Type>
