<Type Name="StreamWriter" FullName="System.IO.StreamWriter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2eb1329977e386e6b88f9ade3497cfed0d377862" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48645629" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class StreamWriter : System.IO.TextWriter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit StreamWriter extends System.IO.TextWriter" />
  <TypeSignature Language="DocId" Value="T:System.IO.StreamWriter" />
  <TypeSignature Language="VB.NET" Value="Public Class StreamWriter&#xA;Inherits TextWriter" />
  <TypeSignature Language="C++ CLI" Value="public ref class StreamWriter : System::IO::TextWriter" />
  <TypeSignature Language="F#" Value="type StreamWriter = class&#xA;    inherit TextWriter" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.TextWriter</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementiert einen <see cref="T:System.IO.TextWriter" /> zum Schreiben von Zeichen in einen Stream in einer bestimmten Codierung.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.StreamWriter> ist für die Ausgabe von Zeichen in eine bestimmte Codierung vorgesehen, während Klassen abgeleitete <xref:System.IO.Stream> sind für die Byte-ein- und Ausgabe vorgesehen.  
  
> [!IMPORTANT]
>  Dieser Typ implementiert die <xref:System.IDisposable> Schnittstelle. Wenn Sie mit dem Typ haben, sollten Sie es entweder direkt oder indirekt freigeben. Damit des Typs direkt freigegeben werden, rufen Sie die <xref:System.IDisposable.Dispose%2A> -Methode in einer `try` / `catch` Block. Um sie indirekt löschen, verwenden Sie ein Sprachkonstrukt wie `using` (in c#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt "mithilfe von ein-Objekt, das implementiert" IDisposable "" in der <xref:System.IDisposable> schnittstellenthema.  
  
 <xref:System.IO.StreamWriter> Der Standardwert ist mit einer Instanz der <xref:System.Text.UTF8Encoding> sofern nicht anders angegeben. Diese Instanz von `UTF8Encoding` wird erstellt, ohne eine bytereihenfolgemarkierung (BOM), also die <xref:System.Text.Encoding.GetPreamble%2A> Methode gibt ein leeres Byte-Array zurück. Die Standard-UTF-8-Codierung für diesen Konstruktor löst eine Ausnahme für ungültige Bytes. Dieses Verhalten unterscheidet sich vom Verhalten des Codierungsobjekts in gebotenen die <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> Eigenschaft. Geben Sie eine Bytereihenfolge-Marke, und bestimmen, ob eine Ausnahme, auf das ungültige Bytes ausgelöst wird, verwenden Sie einen Konstruktor, der ein Codierungsobjekt als Parameter, z.B. akzeptiert <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Text.Encoding%29> oder <xref:System.IO.StreamWriter.%23ctor%2A>.  
  
 Standardmäßig eine <xref:System.IO.StreamWriter> ist nicht threadsicher. Finden Sie unter <xref:System.IO.TextWriter.Synchronized%2A?displayProperty=nameWithType> für ein threadsicherer Wrapper.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit einem <xref:System.IO.StreamWriter> Objekt, das eine Datei zu schreiben, führt die Verzeichnisse auf Laufwerk C, und verwendet dann, ein <xref:System.IO.StreamReader> Objekt zum Lesen und Anzeigen jedes Verzeichnisname. Eine bewährte Methode ist die Verwendung diese Objekte in einem `using` Anweisung, damit die nicht verwalteten Ressourcen ordnungsgemäß freigegeben werden. Die `using` Anweisung ruft automatisch <xref:System.IDisposable.Dispose%2A> für das Objekt nach Abschluss der Code, der es verwendet wird. In diesem Beispiel verwendete Konstruktor wird nicht unterstützt, für die Verwendung in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] Apps.  
  
 [!code-csharp[StreamReadWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/streamreadwrite/cs/program.cs#1)]
 [!code-vb[StreamReadWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/streamreadwrite/vb/module1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.Stream" />
    <altmember cref="T:System.IO.StreamReader" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Encoding" />
    <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Gewusst wie: Lesen und Schreiben einer neu erstellten Datendatei</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.StreamWriter" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamWriter (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamWriter(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamWriter : System.IO.Stream -&gt; System.IO.StreamWriter" Usage="new System.IO.StreamWriter stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Der Stream, in den geschrieben werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.StreamWriter" />-Klasse für den angegebenen Stream unter Verwendung der UTF-8-Codierung und der Standardpuffergröße.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein <xref:System.IO.StreamWriter> mit UTF-8-Codierung ohne eine Bytereihenfolge-Marke (BOM), also die <xref:System.Text.Encoding.GetPreamble%2A> Methode gibt ein leeres Byte-Array zurück. Die Standard-UTF-8-Codierung für diesen Konstruktor löst eine Ausnahme für ungültige Bytes. Dieses Verhalten unterscheidet sich vom Verhalten des Codierungsobjekts in gebotenen die <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> Eigenschaft. Verwenden Sie einen Konstruktor, der ein Codierungsobjekt als Parameter, z.B. akzeptiert, um anzugeben, ob eine Ausnahme, auf das ungültige Bytes ausgelöst wird <xref:System.IO.StreamWriter.%23ctor%2A>. Die <xref:System.IO.StreamWriter.BaseStream%2A> Eigenschaft initialisiert wird, mit der `stream` Parameter. Die Position des Streams wird nicht zurückgesetzt werden.  
  
 Die <xref:System.IO.StreamWriter> -Objekt ruft <xref:System.IO.Stream.Dispose> für das bereitgestellte <xref:System.IO.Stream> Objekt beim <xref:System.IO.StreamWriter.Dispose%2A?displayProperty=nameWithType> aufgerufen wird.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht diesen Konstruktor an.  
  
 [!code-csharp[System.IO.StreamWriter.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.streamwriter.ctor/cs/program1.cs#1)]
 [!code-vb[System.IO.StreamWriter.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.streamwriter.ctor/vb/program1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> kann nicht geschrieben werden.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamWriter (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamWriter(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamWriter : string -&gt; System.IO.StreamWriter" Usage="new System.IO.StreamWriter path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der vollständige Dateipfad, in den geschrieben werden soll. <c>path</c> kann ein Dateiname sein.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.StreamWriter" />-Klasse für die angegebene Datei unter Verwendung der Standardcodierung und -puffergröße.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein <xref:System.IO.StreamWriter> mit UTF-8-Codierung ohne eine Bytereihenfolge-Marke (BOM), also die <xref:System.Text.Encoding.GetPreamble%2A> Methode gibt ein leeres Byte-Array zurück. Die Standard-UTF-8-Codierung für diesen Konstruktor löst eine Ausnahme für ungültige Bytes. Dieses Verhalten unterscheidet sich vom Verhalten des Codierungsobjekts in gebotenen die <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> Eigenschaft. Geben Sie eine Bytereihenfolge-Marke, und bestimmen, ob eine Ausnahme, auf das ungültige Bytes ausgelöst wird, verwenden Sie einen Konstruktor, der ein Codierungsobjekt als Parameter, z.B. akzeptiert <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Text.Encoding%29>.  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe Universal Naming Convention (UNC) sein. Wenn die Datei vorhanden ist, wird sie überschrieben; Andernfalls wird eine neue Datei erstellt.  
  
 Die `path` Parameter ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden; er kann einen beliebigen Teil eines Systems, der Zugriff mithilfe von Streams unterstützt.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht diesen Konstruktor an.  
  
 [!code-csharp[System.IO.StreamWriter.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.streamwriter.ctor/cs/program5.cs#5)]
 [!code-vb[System.IO.StreamWriter.ctor#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.streamwriter.ctor/vb/program5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff wird verweigert.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge ("").  
  
- oder -  
 <paramref name="path" /> enthält den Namen eines Systemgeräts (com1, com2 usw.).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> enthält eine falsche oder ungültige Syntax für den Dateinamen, Verzeichnisnamen oder die Volumebezeichnung.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen und Schreiben von Dateien. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamWriter (System.IO.Stream stream, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamWriter(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamWriter : System.IO.Stream * System.Text.Encoding -&gt; System.IO.StreamWriter" Usage="new System.IO.StreamWriter (stream, encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream">Der Stream, in den geschrieben werden soll.</param>
        <param name="encoding">Die zu verwendende Zeichencodierung.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.StreamWriter" />-Klasse für den angegebenen Stream unter Verwendung der angegebenen Codierung und der Standardpuffergröße.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert die <xref:System.IO.StreamWriter.Encoding%2A> Eigenschaft mithilfe des encoding-Parameters, und die <xref:System.IO.StreamWriter.BaseStream%2A> Eigenschaft mit den Stream-Parameter. Die Position des Streams wird nicht zurückgesetzt werden. Weitere Informationen finden Sie unter <xref:System.IO.TextWriter.Encoding%2A>.  
  
 Die <xref:System.IO.StreamWriter> -Objekt ruft <xref:System.IO.Stream.Dispose> für das bereitgestellte <xref:System.IO.Stream> Objekt beim <xref:System.IO.StreamWriter.Dispose%2A?displayProperty=nameWithType> aufgerufen wird.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgende Beispiel wird dieses Konstruktors veranschaulicht.  
  
 [!code-csharp[System.IO.StreamWriter.ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.streamwriter.ctor/cs/program2.cs#2)]
 [!code-vb[System.IO.StreamWriter.ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.streamwriter.ctor/vb/program2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> oder <paramref name="encoding" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> kann nicht geschrieben werden.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamWriter (string path, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamWriter(System::String ^ path, bool append);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamWriter : string * bool -&gt; System.IO.StreamWriter" Usage="new System.IO.StreamWriter (path, append)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der vollständige Dateipfad, in den geschrieben werden soll.</param>
        <param name="append">
          <see langword="true" />, wenn Daten an die Datei angefügt werden sollen, <see langword="false" />, wenn die Datei überschrieben werden soll. Wenn die angegebene Datei nicht vorhanden ist, hat dieser Parameter keine Auswirkungen, und der Konstruktor erstellt eine neue Datei.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.StreamWriter" />-Klasse für die angegebene Datei unter Verwendung der Standardcodierung und -puffergröße. Wenn die Datei vorhanden ist, kann sie überschrieben oder an sie angefügt werden. Wenn die Datei nicht vorhanden ist, erstellt dieser Konstruktor eine neue Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt ein <xref:System.IO.StreamWriter> mit UTF-8-Codierung ohne eine Bytereihenfolge-Marke (BOM), also die <xref:System.Text.Encoding.GetPreamble%2A> Methode gibt ein leeres Byte-Array zurück. Die Standard-UTF-8-Codierung für diesen Konstruktor löst eine Ausnahme für ungültige Bytes. Dieses Verhalten unterscheidet sich vom Verhalten des Codierungsobjekts in gebotenen die <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> Eigenschaft. Geben Sie eine Bytereihenfolge-Marke, und bestimmen, ob eine Ausnahme, auf das ungültige Bytes ausgelöst wird, verwenden Sie einen Konstruktor, der ein Codierungsobjekt als Parameter, z.B. akzeptiert <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Text.Encoding%29>.  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe Universal Naming Convention (UNC) sein.  
  
 Die `path` Parameter ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden; er kann einen beliebigen Teil eines Systems, der Zugriff mithilfe von Streams unterstützt.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht diesen Konstruktor an.  
  
 [!code-csharp[System.IO.StreamWriter.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.streamwriter.ctor/cs/program6.cs#6)]
 [!code-vb[System.IO.StreamWriter.ctor#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.streamwriter.ctor/vb/program6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff wird verweigert.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist leer.  
  
- oder -  
 <paramref name="path" /> enthält den Namen eines Systemgeräts (com1, com2 usw.).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> enthält eine falsche oder ungültige Syntax für den Dateinamen, Verzeichnisnamen oder die Volumebezeichnung.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen und Schreiben von Dateien. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamWriter (System.IO.Stream stream, System.Text.Encoding encoding, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.#ctor(System.IO.Stream,System.Text.Encoding,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamWriter(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamWriter : System.IO.Stream * System.Text.Encoding * int -&gt; System.IO.StreamWriter" Usage="new System.IO.StreamWriter (stream, encoding, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream">Der Stream, in den geschrieben werden soll.</param>
        <param name="encoding">Die zu verwendende Zeichencodierung.</param>
        <param name="bufferSize">Die Puffergröße in Byte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.StreamWriter" />-Klasse für den angegebenen Stream unter Verwendung der angegebenen Codierung und Puffergröße.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert die <xref:System.IO.StreamWriter.Encoding%2A> Eigenschaft mithilfe der `encoding` -Parameter und die <xref:System.IO.StreamWriter.BaseStream%2A> Eigenschaft mithilfe der `stream` Parameter. Die Position des Streams wird nicht zurückgesetzt werden. Weitere Informationen finden Sie unter <xref:System.IO.TextWriter.Encoding%2A>.  
  
 Die <xref:System.IO.StreamWriter> -Objekt ruft <xref:System.IO.Stream.Dispose> für das bereitgestellte <xref:System.IO.Stream> Objekt beim <xref:System.IO.StreamWriter.Dispose%2A?displayProperty=nameWithType> aufgerufen wird.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgende Beispiel wird dieses Konstruktors veranschaulicht.  
  
 [!code-csharp[System.IO.StreamWriter.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.streamwriter.ctor/cs/program3.cs#3)]
 [!code-vb[System.IO.StreamWriter.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.streamwriter.ctor/vb/program3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> oder <paramref name="encoding" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> kann nicht geschrieben werden.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamWriter (string path, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.#ctor(System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamWriter(System::String ^ path, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamWriter : string * bool * System.Text.Encoding -&gt; System.IO.StreamWriter" Usage="new System.IO.StreamWriter (path, append, encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">Der vollständige Dateipfad, in den geschrieben werden soll.</param>
        <param name="append">
          <see langword="true" />, wenn Daten an die Datei angefügt werden sollen, <see langword="false" />, wenn die Datei überschrieben werden soll. Wenn die angegebene Datei nicht vorhanden ist, hat dieser Parameter keine Auswirkungen, und der Konstruktor erstellt eine neue Datei.</param>
        <param name="encoding">Die zu verwendende Zeichencodierung.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.StreamWriter" />-Klasse für die angegebene Datei unter Verwendung der angegebenen Codierung und Standardpuffergröße. Wenn die Datei vorhanden ist, kann sie überschrieben oder an sie angefügt werden. Wenn die Datei nicht vorhanden ist, erstellt dieser Konstruktor eine neue Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert die <xref:System.IO.StreamWriter.Encoding%2A> Eigenschaft mithilfe des encoding-Parameters. Weitere Informationen finden Sie unter <xref:System.IO.TextWriter.Encoding%2A>.  
  
 `path` kann ein Dateiname, einschließlich einer Datei auf einer Freigabe Universal Naming Convention (UNC) sein.  
  
 `path` ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden. Sie können einen beliebigen Teil eines Systems sein, die Zugriff über Streams unterstützt.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgende Beispiel wird dieses Konstruktors veranschaulicht.  
  
 [!code-csharp[System.IO.StreamWriter.ctor#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.streamwriter.ctor/cs/program7.cs#7)]
 [!code-vb[System.IO.StreamWriter.ctor#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.streamwriter.ctor/vb/program7.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff wird verweigert.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist leer.  
  
- oder -  
 <paramref name="path" /> enthält den Namen eines Systemgeräts (com1, com2 usw.).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> enthält eine falsche oder ungültige Syntax für den Dateinamen, Verzeichnisnamen oder die Volumebezeichnung.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen und Schreiben von Dateien. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamWriter (System.IO.Stream stream, System.Text.Encoding encoding, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, int32 bufferSize, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.#ctor(System.IO.Stream,System.Text.Encoding,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamWriter(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamWriter : System.IO.Stream * System.Text.Encoding * int * bool -&gt; System.IO.StreamWriter" Usage="new System.IO.StreamWriter (stream, encoding, bufferSize, leaveOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Der Stream, in den geschrieben werden soll.</param>
        <param name="encoding">Die zu verwendende Zeichencodierung.</param>
        <param name="bufferSize">Die Puffergröße in Byte.</param>
        <param name="leaveOpen">
          <see langword="true" />, um den Datenstrom geöffnet zu lassen, nach dem das <see cref="T:System.IO.StreamWriter" />-Objekt freigegeben wurde; andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.StreamWriter" />-Klasse für den angegebenen Stream unter Verwendung der angegebenen Codierung und Puffergröße und lässt optional den Stream geöffnet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie festlegen, die `leaveOpen` Parameter, um `true`, <xref:System.IO.StreamWriter> -Objekt ruft <xref:System.IO.Stream.Dispose> für das bereitgestellte <xref:System.IO.Stream> Objekt beim <xref:System.IO.StreamWriter.Dispose%2A?displayProperty=nameWithType> aufgerufen wird.  
  
 Dieser Konstruktor initialisiert die <xref:System.IO.StreamWriter.Encoding%2A> -Eigenschaft mithilfe der `encoding` -Parameter und initialisiert die <xref:System.IO.StreamWriter.BaseStream%2A> -Eigenschaft mithilfe der `stream` Parameter. Die Position des Streams wird nicht zurückgesetzt werden. Weitere Informationen finden Sie unter den <xref:System.IO.TextWriter.Encoding%2A> Eigenschaft.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
   
  
## Examples  
 Im folgende Beispiel wird dieses Konstruktors veranschaulicht.  
  
 [!code-csharp[System.IO.StreamWriter.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.streamwriter.ctor/cs/program4.cs#4)]
 [!code-vb[System.IO.StreamWriter.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.streamwriter.ctor/vb/program4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> oder <paramref name="encoding" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> kann nicht geschrieben werden.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamWriter (string path, bool append, System.Text.Encoding encoding, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool append, class System.Text.Encoding encoding, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.#ctor(System.String,System.Boolean,System.Text.Encoding,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamWriter(System::String ^ path, bool append, System::Text::Encoding ^ encoding, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamWriter : string * bool * System.Text.Encoding * int -&gt; System.IO.StreamWriter" Usage="new System.IO.StreamWriter (path, append, encoding, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Der vollständige Dateipfad, in den geschrieben werden soll.</param>
        <param name="append">
          <see langword="true" />, wenn Daten an die Datei angefügt werden sollen, <see langword="false" />, wenn die Datei überschrieben werden soll. Wenn die angegebene Datei nicht vorhanden ist, hat dieser Parameter keine Auswirkungen, und der Konstruktor erstellt eine neue Datei.</param>
        <param name="encoding">Die zu verwendende Zeichencodierung.</param>
        <param name="bufferSize">Die Puffergröße in Byte.</param>
        <summary>Initialisiert für die angegebene Datei im angegebenen Pfad eine neue Instanz der <see cref="T:System.IO.StreamWriter" />-Klasse unter Verwendung der angegebenen Codierung und Puffergröße. Wenn die Datei vorhanden ist, kann sie überschrieben oder an sie angefügt werden. Wenn die Datei nicht vorhanden ist, erstellt dieser Konstruktor eine neue Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert die <xref:System.IO.StreamWriter.Encoding%2A> Eigenschaft mithilfe des encoding-Parameters. Weitere Informationen finden Sie unter <xref:System.IO.TextWriter.Encoding%2A>.  
  
 `path` kann ein Dateiname, einschließlich einer Datei auf einer Freigabe Universal Naming Convention (UNC) sein.  
  
 `path` ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden. Sie können einen beliebigen Teil eines Systems sein, die Zugriff über Streams unterstützt.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgende Beispiel wird dieses Konstruktors veranschaulicht.  
  
 [!code-csharp[System.IO.StreamWriter.ctor#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.streamwriter.ctor/cs/program8.cs#8)]
 [!code-vb[System.IO.StreamWriter.ctor#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.streamwriter.ctor/vb/program8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge ("").  
  
- oder -  
 <paramref name="path" /> enthält den Namen eines Systemgeräts (com1, com2 usw.).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> oder <paramref name="encoding" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> enthält eine falsche oder ungültige Syntax für den Dateinamen, Verzeichnisnamen oder die Volumebezeichnung.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff wird verweigert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen und Schreiben von Dateien. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="AutoFlush">
      <MemberSignature Language="C#" Value="public virtual bool AutoFlush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoFlush" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamWriter.AutoFlush" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoFlush { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoFlush : bool with get, set" Usage="System.IO.StreamWriter.AutoFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.IO.StreamWriter" /> nach jedem Aufruf von <see cref="M:System.IO.StreamWriter.Write(System.Char)" /> den Puffer in den zugrunde liegenden Stream wegschreibt, oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />, um <see cref="T:System.IO.StreamWriter" /> zum Entleeren des Puffers zu zwingen, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Leeren der Datenstrom wird die zugrunde liegende Encoder nicht geleert, es sei denn, Sie explizit aufrufen, <xref:System.IO.StreamWriter.Flush%2A> oder <xref:System.IO.StreamWriter.Close%2A>. Festlegen von <xref:System.IO.StreamWriter.AutoFlush%2A> zu `true` ist, werden Daten weggeschrieben aus dem Puffer in den Stream nach jedem Schreibvorgang, aber der Encoderzustand wird nicht geleert. Dadurch wird den Encoder auf seinen Zustand (partielle Zeichen) beibehalten, sodass den nächsten Block Zeichen richtig codiert werden können. Dieses Szenario betrifft, UTF8 und UTF7, in denen bestimmte Zeichen nur verschlüsselt werden können, nachdem der Encoder das bzw. der angrenzenden Zeichen empfangen.  
  
 Wenn `AutoFlush` nastaven NA hodnotu `false`, `StreamWriter` erfolgt eine begrenzte Menge an Pufferung intern und möglicherweise auch im Encoder aus der übergebenen Codierung aus. Sie erhalten eine bessere Leistung durch Festlegen von `AutoFlush` zu `false`, vorausgesetzt, dass Sie immer Aufrufen `Close` (oder zumindest `Flush`) Wenn Sie fertig sind Schreiben mit einer `StreamWriter`.  
  
 Legen Sie z. B. `AutoFlush` zu `true` beim Schreiben auf einem Gerät, bei denen der Benutzer sofort ein Feedback erwartet. `Console.Out` ist einer der folgenden Fälle: die `StreamWriter` wird intern verwendet, für das Schreiben in `Console` Leert alle seinen internen Status, ausgenommen dem Status des Encoders nach jedem Aufruf von <xref:System.IO.StreamWriter.Write%2A?displayProperty=nameWithType>.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Syntax zum Verwenden der `AutoFlush` Eigenschaft.  
  
 [!code-cpp[System.IO.StreamWriter#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamWriter/CPP/logger.cpp#5)]
 [!code-csharp[System.IO.StreamWriter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamWriter/CS/logger.cs#5)]
 [!code-vb[System.IO.StreamWriter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamWriter/VB/logger.vb#5)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamWriter.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseStream : System.IO.Stream" Usage="System.IO.StreamWriter.BaseStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zugrunde liegenden Stream ab, der eine Schnittstelle zu einem Sicherungsspeicher bildet.</summary>
        <value>Der Stream, in den dieser <see langword="StreamWriter" /> schreibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="streamWriter.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt das aktuelle <see langword="StreamWriter" />-Objekt und den zugrunde liegenden Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType>.  
  
 Diese Implementierung der <xref:System.IO.StreamWriter.Close%2A> Aufrufe der <xref:System.IO.StreamWriter.Dispose%2A> -Methode und übergeben Sie einen `true` Wert.  
  
 Rufen Sie <xref:System.IO.StreamWriter.Close%2A> um sicherzustellen, dass alle Daten ordnungsgemäß in den zugrunde liegenden Stream geschrieben. Nach einem Aufruf von <xref:System.IO.StreamWriter.Close%2A>, alle Vorgänge für die <xref:System.IO.StreamWriter> möglicherweise Ausnahmen ausgelöst. Wenn nicht genügend Speicherplatz auf dem Datenträger vorhanden ist, wird beim Aufrufen <xref:System.IO.StreamWriter.Close%2A> wird eine Ausnahme ausgelöst.  
  
 Das Leeren der Datenstrom wird die zugrunde liegende Encoder nicht geleert, es sei denn, Sie explizit aufrufen, <xref:System.IO.StreamWriter.Flush%2A> oder <xref:System.IO.StreamWriter.Close%2A>. Festlegen von <xref:System.IO.StreamWriter.AutoFlush%2A> zu `true` bedeutet, die Daten werden in den Stream, aus dem Puffer geleert werden, aber der Encoderzustand wird nicht geleert. Dadurch wird den Encoder auf seinen Zustand (partielle Zeichen) beibehalten, sodass den nächsten Block Zeichen richtig codiert werden können. Dieses Szenario betrifft, UTF8 und UTF7, in denen bestimmte Zeichen nur verschlüsselt werden können, nachdem der Encoder das bzw. der angrenzenden Zeichen empfangen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die `Close` Methode.  
  
 [!code-cpp[System.IO.StreamWriter#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamWriter/CPP/logger.cpp#17)]
 [!code-csharp[System.IO.StreamWriter#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamWriter/CS/logger.cs#17)]
 [!code-vb[System.IO.StreamWriter#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamWriter/VB/logger.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Text.EncoderFallbackException">Die aktuelle Codierung unterstützt das Anzeigen einer Hälfte eines Unicode-Ersatzzeichenpaars nicht.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="streamWriter.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.IO.StreamWriter" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.IO.StreamWriter> verweist. Diese Methode ruft die `Dispose`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Text.EncoderFallbackException">Die aktuelle Codierung unterstützt das Anzeigen einer Hälfte eines Unicode-Ersatzzeichenpaars nicht.</exception>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see langword="Dispose" />, werden Sie darauf achten, nicht auf Objekte verweisen, die zuvor in einen früheren Aufruf von freigegeben wurden <see langword="Dispose" />.  
  
Diese Methode ruft die Dispose-Methode der Basisklasse, <see cref="M:System.IO.TextWriter.Dispose(System.Boolean)" />.</para>
        </block>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public override System.Text.Encoding Encoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding Encoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamWriter.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Encoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Text::Encoding ^ Encoding { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Encoding : System.Text.Encoding" Usage="System.IO.StreamWriter.Encoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Text.Encoding" /> ab, in der die Ausgabe geschrieben wird.</summary>
        <value>Die im Konstruktor für die aktuelle Instanz angegebene <see cref="T:System.Text.Encoding" /> oder <see cref="T:System.Text.UTF8Encoding" />, sofern keine Codierung angegeben wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist erforderlich für einige XML-Szenarien, in denen ein Header geschrieben werden muss, enthält die Codierung von verwendet, die <xref:System.IO.StreamWriter>. Dadurch wird den XML-Code einen beliebigen nutzen <xref:System.IO.StreamWriter> und generieren Sie den richtigen XML-Header.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel ruft die Codierung des angegebenen <xref:System.IO.StreamWriter> Instanz.  
  
 [!code-cpp[System.IO.StreamWriter#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamWriter/CPP/logger.cpp#11)]
 [!code-csharp[System.IO.StreamWriter#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamWriter/CS/logger.cs#11)]
 [!code-vb[System.IO.StreamWriter#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamWriter/VB/logger.vb#11)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~StreamWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!StreamWriter ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="streamWriter.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="streamWriter.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht sämtliche Puffer für den aktuellen Writer und veranlasst die Ausgabe aller gepufferten Daten an den zugrunde liegenden Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.TextWriter.Flush%2A?displayProperty=nameWithType>.  
  
 Das Leeren der Datenstrom wird die zugrunde liegende Encoder nicht geleert, es sei denn, Sie explizit aufrufen, `Flush` oder <xref:System.IO.StreamWriter.Close%2A>. Festlegen von <xref:System.IO.StreamWriter.AutoFlush%2A> zu `true` ist, werden Daten weggeschrieben aus dem Puffer in den Stream nach jedem Schreibvorgang, aber der Encoderzustand wird nicht geleert. Dadurch wird den Encoder auf seinen Zustand (partielle Zeichen) beibehalten, sodass den nächsten Block Zeichen richtig codiert werden können. Dieses Szenario betrifft, UTF8 und UTF7, in denen bestimmte Zeichen nur verschlüsselt werden können, nachdem der Encoder das bzw. der angrenzenden Zeichen empfangen.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der aktuelle Writer wird geschlossen.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler ist aufgetreten.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Die aktuelle Codierung unterstützt das Anzeigen einer Hälfte eines Unicode-Ersatzzeichenpaars nicht.</exception>
        <altmember cref="M:System.IO.Stream.Close" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="streamWriter.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle Puffer für diesen Stream asynchron und veranlasst die Ausgabe aller gepufferten Daten an das zugrunde liegende Gerät.</summary>
        <returns>Eine Aufgabe, die die asynchrone Leerung darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Der Stream wurde verworfen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.StreamWriter Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.StreamWriter Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.StreamWriter.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As StreamWriter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::StreamWriter ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.IO.StreamWriter" Usage="System.IO.StreamWriter.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt einen <see langword="StreamWriter" /> ohne Sicherungsspeicher bereit, in den zwar geschrieben, aus dem jedoch nicht gelesen werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden `Null` zum Umleiten der Ausgabe um ein `StreamWriter` belegt, die keine Ressourcen des Betriebssystems.  
  
 Wenn die `StreamWriter.Write` Methoden werden aufgerufen, auf `Null`, der Aufruf zurückgegeben und keine Daten tatsächlich in einen Sicherungsspeicher geschrieben.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung des der `Null` Feld.  
  
 [!code-cpp[System.IO.StreamWriter#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamWriter/CPP/logger.cpp#6)]
 [!code-csharp[System.IO.StreamWriter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamWriter/CS/logger.cs#6)]
 [!code-vb[System.IO.StreamWriter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamWriter/VB/logger.vb#6)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt Daten in den Stream.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(char value);" />
      <MemberSignature Language="F#" Value="override this.Write : char -&gt; unit" Usage="streamWriter.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Das in den Stream zu schreibende Zeichen.</param>
        <summary>Schreibt ein Zeichen in den Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.TextWriter.Write%2A?displayProperty=nameWithType>.  
  
 Das angegebene Zeichen wird in den zugrunde liegenden Stream geschrieben werden, es sei denn, das Ende des Streams vorzeitig erreicht ist. Wenn <xref:System.IO.StreamWriter.AutoFlush%2A> ist `true`, <xref:System.IO.StreamWriter.Flush%2A> wird automatisch aufgerufen.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="P:System.IO.StreamWriter.AutoFlush" /> ist true, oder der <see cref="T:System.IO.StreamWriter" />-Puffer ist voll, und der aktuelle Writer ist geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="P:System.IO.StreamWriter.AutoFlush" /> ist true, oder der <see cref="T:System.IO.StreamWriter" />-Puffer ist voll, und der Inhalt des Puffers kann nicht in den zugrunde liegenden Stream fester Größe geschrieben werden, da der <see cref="T:System.IO.StreamWriter" /> sich am Ende des Streams befindet.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (char[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(char[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.Write(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;char&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="override this.Write : char[] -&gt; unit" Usage="streamWriter.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Zeichenarray mit den zu schreibenden Daten. Wenn <c>buffer</c> den Wert <see langword="null" /> hat, wird nichts geschrieben.</param>
        <summary>Schreibt ein Zeichenarray in den Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.TextWriter.Write%2A?displayProperty=nameWithType>.  
  
 Die angegebenen Zeichen werden in den zugrunde liegenden Stream geschrieben, es sei denn, das Ende des Streams vorzeitig erreicht ist. Wenn <xref:System.IO.StreamWriter.AutoFlush%2A> ist `true`, <xref:System.IO.StreamWriter.Flush%2A> wird automatisch aufgerufen.  
  
 Diese Methode bietet möglicherweise schneller als die `Write` (`char[],``int,``int`) da es weniger Argumente überprüft hat.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="P:System.IO.StreamWriter.AutoFlush" /> ist true, oder der <see cref="T:System.IO.StreamWriter" />-Puffer ist voll, und der aktuelle Writer ist geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="P:System.IO.StreamWriter.AutoFlush" /> ist true, oder der <see cref="T:System.IO.StreamWriter" />-Puffer ist voll, und der Inhalt des Puffers kann nicht in den zugrunde liegenden Stream fester Größe geschrieben werden, da der <see cref="T:System.IO.StreamWriter" /> sich am Ende des Streams befindet.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.Write(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;char&gt; -&gt; unit" Usage="streamWriter.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Write : string -&gt; unit" Usage="streamWriter.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die in den Stream geschrieben werden soll. Wenn <c>value</c> den Wert NULL hat, wird nichts geschrieben.</param>
        <summary>Schreibt eine Zeichenfolge in den Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.TextWriter.Write%2A?displayProperty=nameWithType>.  
  
 Das angegebene <xref:System.String> wird in den zugrunde liegenden Stream geschrieben, es sei denn, das Ende des Streams vorzeitig erreicht ist.  
  
 <xref:System.IO.StreamWriter.Flush%2A> wird automatisch aufgerufen, wenn <xref:System.IO.StreamWriter.AutoFlush%2A> ist `true`. Wenn `value` ist `null`, keine Einträge geschrieben werden.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="P:System.IO.StreamWriter.AutoFlush" /> ist true, oder der <see cref="T:System.IO.StreamWriter" />-Puffer ist voll, und der aktuelle Writer ist geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="P:System.IO.StreamWriter.AutoFlush" /> ist true, oder der <see cref="T:System.IO.StreamWriter" />-Puffer ist voll, und der Inhalt des Puffers kann nicht in den zugrunde liegenden Stream fester Größe geschrieben werden, da der <see cref="T:System.IO.StreamWriter" /> sich am Ende des Streams befindet.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler tritt auf.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : char[] * int * int -&gt; unit" Usage="streamWriter.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Zeichenarray, das die zu schreibenden Daten enthält.</param>
        <param name="index">Die Zeichenposition im Puffer, an der mit dem Lesen von Daten begonnen werden soll.</param>
        <param name="count">Die maximale Anzahl der zu schreibenden Zeichen.</param>
        <summary>Schreibt ein Teilarray von Zeichen in den Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.TextWriter.Write%2A?displayProperty=nameWithType>.  
  
 Von werden die Zeichen gelesen `buffer` beginnend bei `index` und weiter über `index` + (`count` - 1). Alle Zeichen werden in den zugrunde liegenden Stream geschrieben werden, es sei denn, das Ende der zugrunde liegende Stream vorzeitig erreicht ist. <xref:System.IO.StreamWriter.Flush%2A> wird automatisch aufgerufen, wenn <xref:System.IO.StreamWriter.AutoFlush%2A> ist `true`.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 In diesem Beispiel schreibt acht Zeichen in ein Array mit 13 Elementen in eine Datei, und das dritte Element des Arrays ab.  
  
 [!code-cpp[Classic StreamWriter.Write2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic StreamWriter.Write2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic StreamWriter.Write2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic StreamWriter.Write2 Example/CS/source.cs#1)]
 [!code-vb[Classic StreamWriter.Write2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic StreamWriter.Write2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Länge des Puffers minus <paramref name="index" /> ist kleiner als <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="P:System.IO.StreamWriter.AutoFlush" /> ist true, oder der <see cref="T:System.IO.StreamWriter" />-Puffer ist voll, und der aktuelle Writer ist geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="P:System.IO.StreamWriter.AutoFlush" /> ist true, oder der <see cref="T:System.IO.StreamWriter" />-Puffer ist voll, und der Inhalt des Puffers kann nicht in den zugrunde liegenden Stream fester Größe geschrieben werden, da der <see cref="T:System.IO.StreamWriter" /> sich am Ende des Streams befindet.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt Daten asynchron in den Stream.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteAsync(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteAsync (value As Char) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(char value);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : char -&gt; System.Threading.Tasks.Task" Usage="streamWriter.WriteAsync value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Das in den Stream zu schreibende Zeichen.</param>
        <summary>Schreibt ein Zeichen asynchron in den Stream.</summary>
        <returns>Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie ein einzelnes Zeichen zu schreiben (den Buchstaben "a") in eine Textdatei mit dem <xref:System.IO.StreamWriter.WriteAsync%28System.Char%29> Methode.  
  
 [!code-csharp[System.IO.StreamWriter#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamWriter/CS/example20.cs#20)]
 [!code-vb[System.IO.StreamWriter#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamWriter/VB/example20.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der Streamwriter wird freigegeben.</exception>
        <exception cref="T:System.InvalidOperationException">Der Streamwriter wird derzeit von einem vorherigen Schreibvorgang verwendet.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteAsync (value As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : string -&gt; System.Threading.Tasks.Task" Usage="streamWriter.WriteAsync value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die in den Stream geschrieben werden soll. Wenn <c>value</c> den Wert <see langword="null" /> hat, wird nichts geschrieben.</param>
        <summary>Schreibt eine Zeichenfolge asynchron in den Stream.</summary>
        <returns>Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie eine Zeichenfolge in eine Textdatei zu schreiben, mit der <xref:System.IO.StreamWriter.WriteAsync%28System.String%29> Methode.  
  
 [!code-csharp[System.IO.StreamWriter#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamWriter/CS/example21.cs#21)]
 [!code-vb[System.IO.StreamWriter#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamWriter/VB/example21.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der Streamwriter wird freigegeben.</exception>
        <exception cref="T:System.InvalidOperationException">Der Streamwriter wird derzeit von einem vorherigen Schreibvorgang verwendet.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (ReadOnlyMemory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(valuetype System.ReadOnlyMemory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteAsync(System.ReadOnlyMemory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="streamWriter.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteAsync (buffer As Char(), index As Integer, count As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : char[] * int * int -&gt; System.Threading.Tasks.Task" Usage="streamWriter.WriteAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Zeichenarray, das die zu schreibenden Daten enthält.</param>
        <param name="index">Die Zeichenposition im Puffer, an der mit dem Lesen von Daten begonnen werden soll.</param>
        <param name="count">Die maximale Anzahl der zu schreibenden Zeichen.</param>
        <summary>Schreibt ein Teilarray von Zeichen asynchron in den Stream.</summary>
        <returns>Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mehrere Zeichen in eine Textdatei zu schreiben, mit der <xref:System.IO.StreamWriter.WriteAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Methode.  
  
 [!code-csharp[System.IO.StreamWriter#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamWriter/CS/example24.cs#24)]
 [!code-vb[System.IO.StreamWriter#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamWriter/VB/example24.vb#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="index" /> und <paramref name="count" /> ist größer als die Pufferlänge.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Der Streamwriter wird freigegeben.</exception>
        <exception cref="T:System.InvalidOperationException">Der Streamwriter wird derzeit von einem vorherigen Schreibvorgang verwendet.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public override void WriteLine (ReadOnlySpan&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteLine(valuetype System.ReadOnlySpan`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteLine(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteLine (buffer As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteLine(ReadOnlySpan&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.WriteLine : ReadOnlySpan&lt;char&gt; -&gt; unit" Usage="streamWriter.WriteLine buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public override void WriteLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteLine (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.WriteLine : string -&gt; unit" Usage="streamWriter.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLineAsync">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt Daten, gefolgt von einem Zeichen für den Zeilenabschluss, asynchron in den Stream.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteLineAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteLineAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteLineAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteLineAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteLineAsync();" />
      <MemberSignature Language="F#" Value="override this.WriteLineAsync : unit -&gt; System.Threading.Tasks.Task" Usage="streamWriter.WriteLineAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schreibt ein Zeichen für den Zeilenabschluss asynchron in den Stream.</summary>
        <returns>Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die für den Zeilenabschluss wird definiert, indem die <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der Streamwriter wird freigegeben.</exception>
        <exception cref="T:System.InvalidOperationException">Der Streamwriter wird derzeit von einem vorherigen Schreibvorgang verwendet.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteLineAsync (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteLineAsync(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteLineAsync(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteLineAsync (value As Char) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteLineAsync(char value);" />
      <MemberSignature Language="F#" Value="override this.WriteLineAsync : char -&gt; System.Threading.Tasks.Task" Usage="streamWriter.WriteLineAsync value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Das in den Stream zu schreibende Zeichen.</param>
        <summary>Schreibt ein Zeichen, gefolgt von einem Zeichen für den Zeilenabschluss asynchron in den Stream.</summary>
        <returns>Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die für den Zeilenabschluss wird definiert, indem die <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie ein einzelnes Zeichen zu schreiben (den Buchstaben "a") um eine Zeile in einer Textdatei, gefolgt von einer anderen Zeile, die ein einzelnes Zeichen (den Buchstaben "b"), mithilfe enthält der <xref:System.IO.StreamWriter.WriteLineAsync%28System.Char%29> Methode.  
  
 [!code-csharp[System.IO.StreamWriter#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamWriter/CS/example22.cs#22)]
 [!code-vb[System.IO.StreamWriter#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamWriter/VB/example22.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der Streamwriter wird freigegeben.</exception>
        <exception cref="T:System.InvalidOperationException">Der Streamwriter wird derzeit von einem vorherigen Schreibvorgang verwendet.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteLineAsync (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteLineAsync(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteLineAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteLineAsync (value As String) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteLineAsync(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.WriteLineAsync : string -&gt; System.Threading.Tasks.Task" Usage="streamWriter.WriteLineAsync value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Die zu schreibende Zeichenfolge. Wenn der Wert <see langword="null" /> ist, wird nur ein Zeichen für den Zeilenabschluss geschrieben.</param>
        <summary>Schreibt eine Zeichenfolge, gefolgt von einem Zeichen für den Zeilenabschluss, asynchron in den Stream.</summary>
        <returns>Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die für den Zeilenabschluss wird definiert, indem die <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie zwei Zeilen zu schreiben, die mithilfe von Zeichenfolgenwerten in einer Textdatei bestehen die <xref:System.IO.StreamWriter.WriteLineAsync%28System.String%29> Methode.  
  
 [!code-csharp[System.IO.StreamWriter#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamWriter/CS/example23.cs#23)]
 [!code-vb[System.IO.StreamWriter#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamWriter/VB/example23.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der Streamwriter wird freigegeben.</exception>
        <exception cref="T:System.InvalidOperationException">Der Streamwriter wird derzeit von einem vorherigen Schreibvorgang verwendet.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteLineAsync (ReadOnlyMemory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteLineAsync(valuetype System.ReadOnlyMemory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteLineAsync(System.ReadOnlyMemory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.WriteLineAsync : ReadOnlyMemory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="streamWriter.WriteLineAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Char&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteLineAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteLineAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamWriter.WriteLineAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function WriteLineAsync (buffer As Char(), index As Integer, count As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteLineAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.WriteLineAsync : char[] * int * int -&gt; System.Threading.Tasks.Task" Usage="streamWriter.WriteLineAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Das Zeichenarray, aus dem Daten geschrieben werden sollen.</param>
        <param name="index">Die Zeichenposition im Puffer, an der mit dem Lesen von Daten begonnen werden soll.</param>
        <param name="count">Die maximale Anzahl der zu schreibenden Zeichen.</param>
        <summary>Schreibt ein Teilarray von Zeichen, gefolgt von einem Zeichen für den Zeilenabschluss, asynchron in den Stream.</summary>
        <returns>Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die für den Zeilenabschluss wird definiert, indem die <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie zum Schreiben von Zeichen in zwei separate Zeilen in einer Textdatei mithilfe der <xref:System.IO.StreamWriter.WriteLineAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Methode. Die erste Zeile enthält die ersten 11 Zeichen aus der Zeichenfolge (den Buchstaben, von einem Leerzeichen gefolgt "Zuerst line"). Die zweite Zeile enthält die verbleibenden Zeichen aus der Zeichenfolge (den Buchstaben "und die zweite Zeile").  
  
 [!code-csharp[System.IO.StreamWriter#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamWriter/CS/example25.cs#25)]
 [!code-vb[System.IO.StreamWriter#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamWriter/VB/example25.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="index" /> und <paramref name="count" /> ist größer als die Pufferlänge.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> oder <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Der Streamwriter wird freigegeben.</exception>
        <exception cref="T:System.InvalidOperationException">Der Streamwriter wird derzeit von einem vorherigen Schreibvorgang verwendet.</exception>
      </Docs>
    </Member>
  </Members>
</Type>