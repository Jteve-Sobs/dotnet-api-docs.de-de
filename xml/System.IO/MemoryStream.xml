<Type Name="MemoryStream" FullName="System.IO.MemoryStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="341a56319a90adec6dc24bbd6edd5b18ef3a50ab" /><Meta Name="ms.sourcegitcommit" Value="367e1eae0725e6da7136cd073aaa856ded5d5c29" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/13/2019" /><Meta Name="ms.locfileid" Value="75030017" /></Metadata><TypeSignature Language="C#" Value="public class MemoryStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit MemoryStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.MemoryStream" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type MemoryStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="ff93e-101">Erstellt einen Stream, der den Arbeitsspeicher als Sicherungsspeicher verwendet.</span><span class="sxs-lookup"><span data-stu-id="ff93e-101">Creates a stream whose backing store is memory.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-102">Die aktuelle Position eines Streams ist die Position, an der der nächste Lese-oder Schreibvorgang stattfinden kann.</span><span class="sxs-lookup"><span data-stu-id="ff93e-102">The current position of a stream is the position at which the next read or write operation could take place.</span></span> <span data-ttu-id="ff93e-103">Die aktuelle Position kann durch die <xref:System.IO.MemoryStream.Seek%2A>-Methode abgerufen oder festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-103">The current position can be retrieved or set through the <xref:System.IO.MemoryStream.Seek%2A> method.</span></span> <span data-ttu-id="ff93e-104">Wenn eine neue Instanz von <xref:System.IO.MemoryStream> erstellt wird, wird die aktuelle Position auf 0 (null) festgelegt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-104">When a new instance of <xref:System.IO.MemoryStream> is created, the current position is set to zero.</span></span>  
  
[!INCLUDE[note_unnecessary_dispose](~/includes/note-unnecessary-dispose.md)]
  
 <span data-ttu-id="ff93e-105">Speicherdaten Ströme, die mit einem Bytearray ohne Vorzeichen erstellt werden, stellen einen Datenstrom der Daten dar, der nicht geändert werden konnte</span><span class="sxs-lookup"><span data-stu-id="ff93e-105">Memory streams created with an unsigned byte array provide a non-resizable stream of the data.</span></span> <span data-ttu-id="ff93e-106">Wenn Sie ein Bytearray verwenden, können Sie den Stream weder anfügen noch verkleinern, obwohl Sie möglicherweise in der Lage sind, den vorhandenen Inhalt abhängig von den Parametern zu ändern, die an den Konstruktor übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-106">When using a byte array, you can neither append to nor shrink the stream, although you might be able to modify the existing contents depending on the parameters passed into the constructor.</span></span> <span data-ttu-id="ff93e-107">Leere Speicherdaten Ströme können in die Größe geändert werden, und Sie können geschrieben und aus gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-107">Empty memory streams are resizable, and can be written to and read from.</span></span>  
  
 <span data-ttu-id="ff93e-108">Wenn einer RESX-Datei oder einer resources-Datei ein <xref:System.IO.MemoryStream> Objekt hinzugefügt wird, rufen Sie die <xref:System.Resources.ResourceManager.GetStream%2A>-Methode zur Laufzeit auf, um Sie abzurufen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-108">If a <xref:System.IO.MemoryStream> object is added to a ResX file or a .resources file, call the <xref:System.Resources.ResourceManager.GetStream%2A> method at runtime to retrieve it.</span></span>  
  
 <span data-ttu-id="ff93e-109">Wenn ein <xref:System.IO.MemoryStream> Objekt in eine Ressourcen Datei serialisiert wird, wird es tatsächlich als <xref:System.IO.UnmanagedMemoryStream>serialisiert.</span><span class="sxs-lookup"><span data-stu-id="ff93e-109">If a <xref:System.IO.MemoryStream> object is serialized to a resource file it will actually be serialized as an <xref:System.IO.UnmanagedMemoryStream>.</span></span> <span data-ttu-id="ff93e-110">Dieses Verhalten bietet eine bessere Leistung sowie die Möglichkeit, direkt einen Zeiger auf die Daten zu erhalten, ohne <xref:System.IO.Stream> Methoden durchlaufen zu müssen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-110">This behavior provides better performance, as well as the ability to get a pointer to the data directly, without having to go through <xref:System.IO.Stream> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ff93e-111">Im folgenden Codebeispiel wird veranschaulicht, wie Sie Daten mit dem Arbeitsspeicher als Sicherungs Speicher lesen und schreiben.</span><span class="sxs-lookup"><span data-stu-id="ff93e-111">The following code example shows how to read and write data using memory as a backing store.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#1)]
 [!code-csharp[System.IO.MemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#1)]
 [!code-vb[System.IO.MemoryStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-112">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-112">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-113">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-113">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-114">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-114">How to: Write Text to a File</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ff93e-115">Initialisiert eine neue Instanz der <see cref="T:System.IO.MemoryStream" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="ff93e-115">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ff93e-116">Initialisiert eine neue Instanz der <see cref="T:System.IO.MemoryStream" />-Klasse mit einer erweiterbaren Kapazität, die mit 0 (null) initialisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="ff93e-116">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class with an expandable capacity initialized to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-117">Die Eigenschaften <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>und <xref:System.IO.MemoryStream.CanWrite%2A> sind alle auf `true`festgelegt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-117">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`.</span></span>  
  
 <span data-ttu-id="ff93e-118">Die Kapazität des aktuellen Streams wird automatisch erhöht, wenn Sie die <xref:System.IO.MemoryStream.SetLength%2A>-Methode verwenden, um die Länge auf einen Wert festzulegen, der größer ist als die Kapazität des aktuellen Streams.</span><span class="sxs-lookup"><span data-stu-id="ff93e-118">The capacity of the current stream automatically increases when you use the <xref:System.IO.MemoryStream.SetLength%2A> method to set the length to a value larger than the capacity of the current stream.</span></span>  
  
 <span data-ttu-id="ff93e-119">Dieser Konstruktor macht den zugrunde liegenden Stream verfügbar, der <xref:System.IO.MemoryStream.GetBuffer%2A> zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-119">This constructor exposes the underlying stream, which <xref:System.IO.MemoryStream.GetBuffer%2A> returns.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-120">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-120">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-121">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-121">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-122">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-122">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : byte[] -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream buffer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ff93e-123">Das Array vorzeichenloser Bytes, aus dem der aktuelle Stream erstellt werden soll.</span><span class="sxs-lookup"><span data-stu-id="ff93e-123">The array of unsigned bytes from which to create the current stream.</span></span></param>
        <summary><span data-ttu-id="ff93e-124">Initialisiert anhand des angegebenen Bytearrays eine neue Instanz der <see cref="T:System.IO.MemoryStream" />-Klasse, deren Größe nicht geändert werden kann.</span><span class="sxs-lookup"><span data-stu-id="ff93e-124">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-125">Die Eigenschaften <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>und <xref:System.IO.MemoryStream.CanWrite%2A> sind alle auf `true`festgelegt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-125">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`.</span></span> <span data-ttu-id="ff93e-126"><xref:System.IO.MemoryStream.Capacity%2A> auf die Länge des angegebenen Bytearrays festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="ff93e-126"><xref:System.IO.MemoryStream.Capacity%2A> is set to the length of the specified byte array.</span></span> <span data-ttu-id="ff93e-127">Der neue Stream kann in geschrieben, aber nicht in der Größe geändert werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-127">The new stream can be written to, but is not resizable.</span></span>  
  
 <span data-ttu-id="ff93e-128">Die Länge des Datenstroms kann nicht auf einen Wert festgelegt werden, der größer als die ursprüngliche Länge des angegebenen Bytearrays ist. der Stream kann jedoch abgeschnitten werden (siehe <xref:System.IO.MemoryStream.SetLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="ff93e-128">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="ff93e-129">Dieser Konstruktor macht den zugrunde liegenden Stream nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="ff93e-129">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="ff93e-130"><xref:System.IO.MemoryStream.GetBuffer%2A> löst <xref:System.UnauthorizedAccessException>aus.</span><span class="sxs-lookup"><span data-stu-id="ff93e-130"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ff93e-131"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-131"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-132">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-132">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-133">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-133">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-134">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-134">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(int capacity);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : int -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity"><span data-ttu-id="ff93e-135">Die Anfangsgröße des internen Arrays in Bytes.</span><span class="sxs-lookup"><span data-stu-id="ff93e-135">The initial size of the internal array in bytes.</span></span></param>
        <summary><span data-ttu-id="ff93e-136">Initialisiert eine neue Instanz der <see cref="T:System.IO.MemoryStream" />-Klasse mit einer erweiterbaren Kapazität, die mit dem angegebenen Wert initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-136">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class with an expandable capacity initialized as specified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-137">Die Eigenschaften <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>und <xref:System.IO.MemoryStream.CanWrite%2A> sind alle auf `true`festgelegt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-137">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`.</span></span>  
  
 <span data-ttu-id="ff93e-138">Die Kapazität wird automatisch erhöht, wenn Sie die <xref:System.IO.MemoryStream.SetLength%2A>-Methode verwenden, um die Länge auf einen Wert festzulegen, der größer ist als die Kapazität des aktuellen Streams.</span><span class="sxs-lookup"><span data-stu-id="ff93e-138">The capacity automatically increases when you use the <xref:System.IO.MemoryStream.SetLength%2A> method to set the length to a value larger than the capacity of the current stream.</span></span> <span data-ttu-id="ff93e-139">Mit Ausnahme einer `MemoryStream`, die mit einem Byte []-Parameter erstellt wurde, erweitern Schreibvorgänge am Ende einer `MemoryStream` die `MemoryStream`.</span><span class="sxs-lookup"><span data-stu-id="ff93e-139">Except for a `MemoryStream` constructed with a byte[] parameter, write operations at the end of a `MemoryStream` expand the `MemoryStream`.</span></span>  
  
 <span data-ttu-id="ff93e-140">Dieser Konstruktor macht den zugrunde liegenden Stream verfügbar, den <xref:System.IO.MemoryStream.GetBuffer%2A> zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-140">This constructor exposes the underlying stream that <xref:System.IO.MemoryStream.GetBuffer%2A> returns.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ff93e-141">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.MemoryStream>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-141">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#2)]
 [!code-csharp[System.IO.MemoryStream#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#2)]
 [!code-vb[System.IO.MemoryStream#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ff93e-142"><paramref name="capacity" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="ff93e-142"><paramref name="capacity" /> is negative.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-143">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-143">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-144">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-144">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-145">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-145">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), writable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, bool writable);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : byte[] * bool -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream (buffer, writable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ff93e-146">Das Array vorzeichenloser Bytes, aus dem dieser Stream erstellt werden soll.</span><span class="sxs-lookup"><span data-stu-id="ff93e-146">The array of unsigned bytes from which to create this stream.</span></span></param>
        <param name="writable"><span data-ttu-id="ff93e-147">Die Einstellung der <see cref="P:System.IO.MemoryStream.CanWrite" />-Eigenschaft, mit der bestimmt wird, ob der Stream Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-147">The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing.</span></span></param>
        <summary><span data-ttu-id="ff93e-148">Initialisiert anhand des angegebenen Bytearrays eine neue Instanz der <see cref="T:System.IO.MemoryStream" />-Klasse, deren Größe nicht geändert werden kann, wobei die <see cref="P:System.IO.MemoryStream.CanWrite" />-Eigenschaft wie angegeben festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-148">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified byte array with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-149">Die Eigenschaften <xref:System.IO.MemoryStream.CanRead%2A> und <xref:System.IO.MemoryStream.CanSeek%2A> sind beide auf `true`festgelegt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-149">The <xref:System.IO.MemoryStream.CanRead%2A> and <xref:System.IO.MemoryStream.CanSeek%2A> properties are both set to `true`.</span></span> <span data-ttu-id="ff93e-150"><xref:System.IO.MemoryStream.Capacity%2A> auf die Länge des angegebenen Bytearrays festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="ff93e-150"><xref:System.IO.MemoryStream.Capacity%2A> is set to the length of the specified byte array.</span></span>  
  
 <span data-ttu-id="ff93e-151">Die Länge des Datenstroms kann nicht auf einen Wert festgelegt werden, der größer als die ursprüngliche Länge des angegebenen Bytearrays ist. der Stream kann jedoch abgeschnitten werden (siehe <xref:System.IO.MemoryStream.SetLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="ff93e-151">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="ff93e-152">Dieser Konstruktor macht den zugrunde liegenden Stream nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="ff93e-152">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="ff93e-153"><xref:System.IO.MemoryStream.GetBuffer%2A> löst <xref:System.UnauthorizedAccessException>aus.</span><span class="sxs-lookup"><span data-stu-id="ff93e-153"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ff93e-154"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-154"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-155">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-155">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-156">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-156">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-157">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-157">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : byte[] * int * int -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream (buffer, index, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ff93e-158">Das Array vorzeichenloser Bytes, aus dem dieser Stream erstellt werden soll.</span><span class="sxs-lookup"><span data-stu-id="ff93e-158">The array of unsigned bytes from which to create this stream.</span></span></param>
        <param name="index"><span data-ttu-id="ff93e-159">Der Index in <paramref name="buffer" />, an dem der Stream beginnt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-159">The index into <paramref name="buffer" /> at which the stream begins.</span></span></param>
        <param name="count"><span data-ttu-id="ff93e-160">Die Länge des Streams in Bytes.</span><span class="sxs-lookup"><span data-stu-id="ff93e-160">The length of the stream in bytes.</span></span></param>
        <summary><span data-ttu-id="ff93e-161">Initialisiert anhand des angegebenen Bereichs (Indexes) eines Bytearrays eine neue Instanz der <see cref="T:System.IO.MemoryStream" />-Klasse, deren Größe nicht geändert werden kann.</span><span class="sxs-lookup"><span data-stu-id="ff93e-161">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region (index) of a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-162">Die Eigenschaften <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>und <xref:System.IO.MemoryStream.CanWrite%2A> sind auf `true`festgelegt, die Kapazität kann jedoch nicht geändert werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-162">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`, but the capacity cannot be changed.</span></span> <span data-ttu-id="ff93e-163">Für <xref:System.IO.MemoryStream.Capacity%2A> ist `count` festgelegt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-163"><xref:System.IO.MemoryStream.Capacity%2A> is set to `count`.</span></span>  
  
 <span data-ttu-id="ff93e-164">Die Länge des Datenstroms kann nicht auf einen Wert festgelegt werden, der größer als die ursprüngliche Länge des angegebenen Bytearrays ist. der Stream kann jedoch abgeschnitten werden (siehe <xref:System.IO.MemoryStream.SetLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="ff93e-164">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="ff93e-165">Dieser Konstruktor macht den zugrunde liegenden Stream nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="ff93e-165">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="ff93e-166"><xref:System.IO.MemoryStream.GetBuffer%2A> löst <xref:System.UnauthorizedAccessException>aus.</span><span class="sxs-lookup"><span data-stu-id="ff93e-166"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span> <span data-ttu-id="ff93e-167">Sie können jedoch in den Stream schreiben.</span><span class="sxs-lookup"><span data-stu-id="ff93e-167">However, you can write to the stream.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ff93e-168"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-168"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ff93e-169"><paramref name="index" /> oder <paramref name="count" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="ff93e-169"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ff93e-170">Die Pufferlänge minus <paramref name="index" /> ist kleiner als <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-170">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-171">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-171">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-172">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-172">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-173">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-173">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer, writable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count, bool writable);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : byte[] * int * int * bool -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream (buffer, index, count, writable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ff93e-174">Das Array vorzeichenloser Bytes, aus dem dieser Stream erstellt werden soll.</span><span class="sxs-lookup"><span data-stu-id="ff93e-174">The array of unsigned bytes from which to create this stream.</span></span></param>
        <param name="index"><span data-ttu-id="ff93e-175">Der Index in <paramref name="buffer" />, bei dem der Stream beginnt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-175">The index in <paramref name="buffer" /> at which the stream begins.</span></span></param>
        <param name="count"><span data-ttu-id="ff93e-176">Die Länge des Streams in Bytes.</span><span class="sxs-lookup"><span data-stu-id="ff93e-176">The length of the stream in bytes.</span></span></param>
        <param name="writable"><span data-ttu-id="ff93e-177">Die Einstellung der <see cref="P:System.IO.MemoryStream.CanWrite" />-Eigenschaft, mit der bestimmt wird, ob der Stream Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-177">The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing.</span></span></param>
        <summary><span data-ttu-id="ff93e-178">Initialisiert anhand des angegebenen Bereichs eines Bytearrays eine neue Instanz der <see cref="T:System.IO.MemoryStream" />-Klasse, deren Größe nicht geändert werden kann, wobei die <see cref="P:System.IO.MemoryStream.CanWrite" />-Eigenschaft wie angegeben festgelegt wurde.</span><span class="sxs-lookup"><span data-stu-id="ff93e-178">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region of a byte array, with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-179">Die Eigenschaften <xref:System.IO.MemoryStream.CanRead%2A> und <xref:System.IO.MemoryStream.CanSeek%2A> sind beide auf `true`festgelegt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-179">The <xref:System.IO.MemoryStream.CanRead%2A> and <xref:System.IO.MemoryStream.CanSeek%2A> properties are both set to `true`.</span></span> <span data-ttu-id="ff93e-180">Für <xref:System.IO.MemoryStream.Capacity%2A> ist `count` festgelegt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-180"><xref:System.IO.MemoryStream.Capacity%2A> is set to `count`.</span></span>  
  
 <span data-ttu-id="ff93e-181">Die Länge des Datenstroms kann nicht auf einen Wert festgelegt werden, der größer als die ursprüngliche Länge des angegebenen Bytearrays ist. der Stream kann jedoch abgeschnitten werden (siehe <xref:System.IO.MemoryStream.SetLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="ff93e-181">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="ff93e-182">Dieser Konstruktor macht den zugrunde liegenden Stream nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="ff93e-182">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="ff93e-183"><xref:System.IO.MemoryStream.GetBuffer%2A> löst <xref:System.UnauthorizedAccessException>aus.</span><span class="sxs-lookup"><span data-stu-id="ff93e-183"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span> <span data-ttu-id="ff93e-184">Sie können jedoch in den Stream schreiben, wenn `writable` `true`ist.</span><span class="sxs-lookup"><span data-stu-id="ff93e-184">However, you can write to the stream if `writable` is `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ff93e-185"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-185"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ff93e-186"><paramref name="index" /> oder <paramref name="count" /> ist negativ.</span><span class="sxs-lookup"><span data-stu-id="ff93e-186"><paramref name="index" /> or <paramref name="count" /> are negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ff93e-187">Die Pufferlänge minus <paramref name="index" /> ist kleiner als <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-187">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-188">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-188">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-189">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-189">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-190">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-190">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count, bool writable, bool publiclyVisible);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count, bool writable, bool publiclyVisible) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer, writable As Boolean, publiclyVisible As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count, bool writable, bool publiclyVisible);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : byte[] * int * int * bool * bool -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream (buffer, index, count, writable, publiclyVisible)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="writable" Type="System.Boolean" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="publiclyVisible" Type="System.Boolean" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ff93e-191">Das Array vorzeichenloser Bytes, aus dem dieser Stream erstellt werden soll.</span><span class="sxs-lookup"><span data-stu-id="ff93e-191">The array of unsigned bytes from which to create this stream.</span></span></param>
        <param name="index"><span data-ttu-id="ff93e-192">Der Index in <paramref name="buffer" />, an dem der Stream beginnt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-192">The index into <paramref name="buffer" /> at which the stream begins.</span></span></param>
        <param name="count"><span data-ttu-id="ff93e-193">Die Länge des Streams in Bytes.</span><span class="sxs-lookup"><span data-stu-id="ff93e-193">The length of the stream in bytes.</span></span></param>
        <param name="writable"><span data-ttu-id="ff93e-194">Die Einstellung der <see cref="P:System.IO.MemoryStream.CanWrite" />-Eigenschaft, mit der bestimmt wird, ob der Stream Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-194">The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing.</span></span></param>
        <param name="publiclyVisible"><span data-ttu-id="ff93e-195"><see langword="true" />, um <see cref="M:System.IO.MemoryStream.GetBuffer" /> zu aktivieren, wodurch das Array vorzeichenloser Bytes zurückgegeben wird, aus dem der Stream erstellt wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-195"><see langword="true" /> to enable <see cref="M:System.IO.MemoryStream.GetBuffer" />, which returns the unsigned byte array from which the stream was created; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="ff93e-196">Initialisiert eine neue Instanz der <see cref="T:System.IO.MemoryStream" />-Klasse auf der Grundlage des angegebenen Bereichs eines Bytearrays, wobei die <see cref="P:System.IO.MemoryStream.CanWrite" />-Eigenschaft und die Möglichkeit zum Aufruf von <see cref="M:System.IO.MemoryStream.GetBuffer" /> wie angegeben festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-196">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region of a byte array, with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified, and the ability to call <see cref="M:System.IO.MemoryStream.GetBuffer" /> set as specified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-197">Die Eigenschaften <xref:System.IO.MemoryStream.CanRead%2A> und <xref:System.IO.MemoryStream.CanSeek%2A> sind beide auf `true`festgelegt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-197">The <xref:System.IO.MemoryStream.CanRead%2A> and <xref:System.IO.MemoryStream.CanSeek%2A> properties are both set to `true`.</span></span> <span data-ttu-id="ff93e-198">Für <xref:System.IO.MemoryStream.Capacity%2A> ist `count` festgelegt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-198"><xref:System.IO.MemoryStream.Capacity%2A> is set to `count`.</span></span>  
  
 <span data-ttu-id="ff93e-199">Die neue Datenstrom Instanz kann in geschrieben werden, aber die <xref:System.IO.MemoryStream.Capacity%2A> des zugrunde liegenden Bytearrays kann nicht geändert werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-199">The new stream instance can be written to, but the <xref:System.IO.MemoryStream.Capacity%2A> of the underlying byte array cannot be changed.</span></span> <span data-ttu-id="ff93e-200">Die Länge des Datenstroms kann nicht auf einen Wert festgelegt werden, der größer als die ursprüngliche Länge des angegebenen Bytearrays ist. der Stream kann jedoch abgeschnitten werden (siehe <xref:System.IO.MemoryStream.SetLength%2A>).</span><span class="sxs-lookup"><span data-stu-id="ff93e-200">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ff93e-201"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-201"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ff93e-202"><paramref name="index" /> oder <paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="ff93e-202"><paramref name="index" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ff93e-203">Die Pufferlänge minus <paramref name="index" /> ist kleiner als <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-203">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-204">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-204">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-205">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-205">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-206">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-206">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="memoryStream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ff93e-207">Der Puffer, in den die Daten gelesen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-207">The buffer to read the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="ff93e-208">Der Byteoffset im <paramref name="buffer" />, ab dem aus dem Speicherdatenstrom gelesene Daten geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-208">The byte offset in <paramref name="buffer" /> at which to begin writing data read from the memory stream.</span></span></param>
        <param name="count"><span data-ttu-id="ff93e-209">Die maximale Anzahl der zu lesenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="ff93e-209">The maximum number of bytes to read.</span></span></param>
        <param name="callback"><span data-ttu-id="ff93e-210">Ein optionaler asynchroner Rückruf, der nach Abschluss des Lesevorgangs aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="ff93e-210">An optional asynchronous callback, to be called when the read is complete.</span></span></param>
        <param name="state"><span data-ttu-id="ff93e-211">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Leseanforderung von anderen Anforderungen unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="ff93e-211">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span></span></param>
        <summary><span data-ttu-id="ff93e-212">Beginnt einen asynchronen Lesevorgang.</span><span class="sxs-lookup"><span data-stu-id="ff93e-212">Begins an asynchronous read operation.</span></span> <span data-ttu-id="ff93e-213">(Verwenden Sie stattdessen <see cref="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</span><span class="sxs-lookup"><span data-stu-id="ff93e-213">(Consider using <see cref="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="ff93e-214">Ein <see cref="T:System.IAsyncResult" />, das den asynchronen Lesevorgang darstellt, der möglicherweise noch aussteht.</span><span class="sxs-lookup"><span data-stu-id="ff93e-214">An <see cref="T:System.IAsyncResult" /> that represents the asynchronous read, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="ff93e-215">Weitere Informationen zur Verwendung dieser Methode finden Sie in der <xref:System.IO.Stream.BeginRead%2A>-Hinweise.</span><span class="sxs-lookup"><span data-stu-id="ff93e-215">Refer to the <xref:System.IO.Stream.BeginRead%2A> remarks for additional usage information for this method.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ff93e-216">Es wurde versucht, einen asynchronen Lesevorgang über das Ende des Speicherdatenstroms hinaus durchzuführen, oder es ist ein Datenträgerfehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ff93e-216">Attempted an asynchronous read past the end of the memory stream, or a disk error occurred.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ff93e-217">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ff93e-217">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ff93e-218">Es wurden Methoden aufgerufen, nachdem der Speicherdatenstrom geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="ff93e-218">Methods were called after the memory stream was closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ff93e-219">Die aktuelle Speicherdatenstromimplementierung unterstützt den Lesevorgang nicht.</span><span class="sxs-lookup"><span data-stu-id="ff93e-219">The current memory stream implementation does not support the read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="memoryStream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ff93e-220">Der Puffer, aus dem Daten geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-220">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="ff93e-221">Der Byteoffset im <paramref name="buffer" />, ab dem geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="ff93e-221">The byte offset in <paramref name="buffer" /> from which to begin writing.</span></span></param>
        <param name="count"><span data-ttu-id="ff93e-222">Die maximale Anzahl der zu schreibenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="ff93e-222">The maximum number of bytes to write.</span></span></param>
        <param name="callback"><span data-ttu-id="ff93e-223">Ein optionaler asynchroner Rückruf, der nach Abschluss des Schreibvorgangs aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-223">An optional asynchronous callback, to be called when the write is complete.</span></span></param>
        <param name="state"><span data-ttu-id="ff93e-224">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Schreibanforderung von anderen Anforderungen unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="ff93e-224">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span></span></param>
        <summary><span data-ttu-id="ff93e-225">Beginnt einen asynchronen Schreibvorgang.</span><span class="sxs-lookup"><span data-stu-id="ff93e-225">Begins an asynchronous write operation.</span></span> <span data-ttu-id="ff93e-226">(Verwenden Sie stattdessen <see cref="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</span><span class="sxs-lookup"><span data-stu-id="ff93e-226">(Consider using <see cref="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="ff93e-227">Ein <see langword="IAsyncResult" />, das den asynchronen Schreibvorgang darstellt, der möglicherweise noch aussteht.</span><span class="sxs-lookup"><span data-stu-id="ff93e-227">An <see langword="IAsyncResult" /> that represents the asynchronous write, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="ff93e-228">Weitere Informationen zur Verwendung dieser Methode finden Sie in der <xref:System.IO.Stream.BeginWrite%2A>-Hinweise.</span><span class="sxs-lookup"><span data-stu-id="ff93e-228">Refer to the <xref:System.IO.Stream.BeginWrite%2A> remarks for additional usage information for this method.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ff93e-229">Es wurde versucht, einen asynchronen Schreibvorgang über das Ende des Speicherdatenstroms hinaus durchzuführen, oder es ist ein Datenträgerfehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ff93e-229">Attempted an asynchronous write past the end of the memory stream, or a disk error occurred.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ff93e-230">Mindestens eines der Argumente ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ff93e-230">One or more of the arguments is invalid.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ff93e-231">Es wurden Methoden aufgerufen, nachdem der Speicherdatenstrom geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="ff93e-231">Methods were called after the memory stream was closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ff93e-232">Die aktuelle Speicherdatenstromimplementierung unterstützt den Schreibvorgang nicht.</span><span class="sxs-lookup"><span data-stu-id="ff93e-232">The current memory stream implementation does not support the write operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.MemoryStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ff93e-233">Ruft einen Wert ab, der angibt, ob der aktuelle Stream Lesevorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-233">Gets a value indicating whether the current stream supports reading.</span></span></summary>
        <value><span data-ttu-id="ff93e-234"><see langword="true" />, wenn der Stream geöffnet ist.</span><span class="sxs-lookup"><span data-stu-id="ff93e-234"><see langword="true" /> if the stream is open.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-235">Wenn eine von <xref:System.IO.Stream> abgeleitete Klasse Lesevorgänge nicht unterstützt, lösen Aufrufe der Methoden <xref:System.IO.MemoryStream.Read%2A> und <xref:System.IO.MemoryStream.ReadByte%2A> einen <xref:System.NotSupportedException>aus.</span><span class="sxs-lookup"><span data-stu-id="ff93e-235">If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.MemoryStream.Read%2A> and <xref:System.IO.MemoryStream.ReadByte%2A> methods throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="ff93e-236">Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="ff93e-236">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-237">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-237">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-238">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-238">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-239">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-239">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.MemoryStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ff93e-240">Ruft einen Wert ab, der angibt, ob der aktuelle Stream Suchvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-240">Gets a value indicating whether the current stream supports seeking.</span></span></summary>
        <value><span data-ttu-id="ff93e-241"><see langword="true" />, wenn der Stream geöffnet ist.</span><span class="sxs-lookup"><span data-stu-id="ff93e-241"><see langword="true" /> if the stream is open.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-242">Wenn eine von <xref:System.IO.Stream> abgeleitete Klasse keine Suchvorgänge unterstützt, werden Aufrufe von <xref:System.IO.MemoryStream.Length%2A>, <xref:System.IO.MemoryStream.SetLength%2A>, <xref:System.IO.MemoryStream.Position%2A>und <xref:System.IO.MemoryStream.Seek%2A> eine <xref:System.NotSupportedException>auslösen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-242">If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.MemoryStream.Length%2A>, <xref:System.IO.MemoryStream.SetLength%2A>, <xref:System.IO.MemoryStream.Position%2A>, and <xref:System.IO.MemoryStream.Seek%2A> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="ff93e-243">Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="ff93e-243">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-244">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-244">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-245">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-245">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-246">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-246">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.MemoryStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ff93e-247">Ruft einen Wert ab, der angibt, ob der aktuelle Stream Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-247">Gets a value indicating whether the current stream supports writing.</span></span></summary>
        <value><span data-ttu-id="ff93e-248"><see langword="true" />, wenn der Stream Schreibvorgänge unterstützt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-248"><see langword="true" /> if the stream supports writing; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-249">Wenn eine von <xref:System.IO.Stream> abgeleitete Klasse Schreibvorgänge nicht unterstützt, löst ein-<xref:System.IO.Stream.SetLength%2A>, <xref:System.IO.Stream.Write%2A>oder <xref:System.IO.Stream.WriteByte%2A> einen <xref:System.NotSupportedException>aus.</span><span class="sxs-lookup"><span data-stu-id="ff93e-249">If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.Stream.SetLength%2A>, <xref:System.IO.Stream.Write%2A>, or <xref:System.IO.Stream.WriteByte%2A> throws a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="ff93e-250">Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="ff93e-250">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-251">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-251">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-252">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-252">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-253">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-253">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.IO.MemoryStream.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ff93e-254">Ruft die Anzahl der für diesen Stream reservierten Bytes ab oder legt diese fest.</span><span class="sxs-lookup"><span data-stu-id="ff93e-254">Gets or sets the number of bytes allocated for this stream.</span></span></summary>
        <value><span data-ttu-id="ff93e-255">Die Länge des Bereichs, der für den Stream im Puffer verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="ff93e-255">The length of the usable portion of the buffer for the stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-256">`Capacity` ist die Pufferlänge für vom System bereitgestellte Byte Arrays.</span><span class="sxs-lookup"><span data-stu-id="ff93e-256">`Capacity` is the buffer length for system-provided byte arrays.</span></span> <span data-ttu-id="ff93e-257">`Capacity` kann nicht auf einen Wert festgelegt werden, der kleiner als die aktuelle Länge des Streams ist.</span><span class="sxs-lookup"><span data-stu-id="ff93e-257">`Capacity` cannot be set to a value less than the current length of the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ff93e-258">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.MemoryStream>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-258">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ff93e-259">Es wurde eine Kapazität festgelegt, die negativ oder kleiner als die derzeitige Länge des Streams ist.</span><span class="sxs-lookup"><span data-stu-id="ff93e-259">A capacity is set that is negative or less than the current length of the stream.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ff93e-260">Der aktuelle Stream wird geschlossen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-260">The current stream is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ff93e-261"><see langword="set" /> wird für einen Stream aufgerufen, dessen Kapazität nicht geändert werden kann.</span><span class="sxs-lookup"><span data-stu-id="ff93e-261"><see langword="set" /> is invoked on a stream whose capacity cannot be modified.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-262">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-262">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-263">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-263">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-264">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-264">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="memoryStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ff93e-265">Schließt den Stream für das Lesen und Schreiben.</span><span class="sxs-lookup"><span data-stu-id="ff93e-265">Closes the stream for reading and writing.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="ff93e-266">Diese Methode überschreibt <xref:System.IO.Stream.Close?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ff93e-266">This method overrides <xref:System.IO.Stream.Close?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="ff93e-267">Der Puffer ist weiterhin auf einem <xref:System.IO.MemoryStream> verfügbar, sobald der Stream geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="ff93e-267">The buffer is still available on a <xref:System.IO.MemoryStream> once the stream has been closed.</span></span>

<span data-ttu-id="ff93e-268">Das Leeren des Streams leert den zugrunde liegenden Encoder nicht, es sei denn, Sie haben explizit <xref:System.IO.MemoryStream.Flush> oder `Close`aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-268">Flushing the stream will not flush its underlying encoder unless you explicitly call <xref:System.IO.MemoryStream.Flush> or `Close`.</span></span> <span data-ttu-id="ff93e-269">Wenn <xref:System.IO.StreamWriter.AutoFlush> auf "true" festgelegt wird, werden Daten aus dem Puffer in den Stream geleert, aber der Codierungs Status wird nicht geleert.</span><span class="sxs-lookup"><span data-stu-id="ff93e-269">Setting <xref:System.IO.StreamWriter.AutoFlush> to true means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</span></span> <span data-ttu-id="ff93e-270">Dies ermöglicht es dem Encoder, seinen Zustand (partielle Zeichen) beizubehalten, damit der nächste Zeichenblock ordnungsgemäß codiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="ff93e-270">This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</span></span> <span data-ttu-id="ff93e-271">Dieses Szenario wirkt sich auf UTF8 und UTF7 aus, bei denen bestimmte Zeichen nur codiert werden können, nachdem der Encoder die angrenzenden Zeichen oder Zeichen empfangen hat.</span><span class="sxs-lookup"><span data-stu-id="ff93e-271">This scenario affects UTF8 and UTF7 where certain characters can only be encoded after the encoder receives the adjacent character or characters.</span></span>

<span data-ttu-id="ff93e-272">Wenn Sie versuchen, einen Datenstrom zu manipulieren, nachdem er geschlossen wurde, kann ein <xref:System.ObjectDisposedException>ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-272">Attempting to manipulate a stream after it has been closed might throw an <xref:System.ObjectDisposedException>.</span></span>

## Examples  
<span data-ttu-id="ff93e-273">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.MemoryStream>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-273">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>

```vb
Finally
    memStream.Close()
End Try
```

]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-274">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-274">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-275">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-275">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-276">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-276">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public override void CopyTo (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub CopyTo (destination As Stream, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void CopyTo(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.IO.Stream * int -&gt; unit" Usage="memoryStream.CopyTo (destination, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="ff93e-277">Der Datenstrom, in den der Inhalt des aktuellen Speicherdatenstroms kopiert wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-277">The stream to which the contents of the current memory stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="ff93e-278">Die Größe des Puffers.</span><span class="sxs-lookup"><span data-stu-id="ff93e-278">The size of the buffer.</span></span> <span data-ttu-id="ff93e-279">Dieser Wert muss größer als 0 sein.</span><span class="sxs-lookup"><span data-stu-id="ff93e-279">This value must be greater than zero.</span></span> <span data-ttu-id="ff93e-280">Die Standardgröße ist 81920.</span><span class="sxs-lookup"><span data-stu-id="ff93e-280">The default size is 81920.</span></span></param>
        <summary><span data-ttu-id="ff93e-281">Liest alles Bytes aus dem aktuellen Speicherdatenstrom und schreibt sie unter Verwendung einer angegebenen Puffergröße in einen anderen Datenstrom.</span><span class="sxs-lookup"><span data-stu-id="ff93e-281">Reads the bytes from the current memory stream and writes them to another stream, using a specified buffer size.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ff93e-282"><paramref name="destination" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-282"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ff93e-283"><paramref name="bufferSize" /> ist keine positive Zahl.</span><span class="sxs-lookup"><span data-stu-id="ff93e-283"><paramref name="bufferSize" /> is not a positive number.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ff93e-284">Entweder der zugrunde liegende Speicherdatenstrom oder der <paramref name="destination" />-Datenstrom ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-284">Either the underlying memory stream or the <paramref name="destination" /> stream is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ff93e-285">Der zugrunde liegende Speicherdatenstrom ist nicht lesbar.</span><span class="sxs-lookup"><span data-stu-id="ff93e-285">The underlying memory stream is unreadable.</span></span>

<span data-ttu-id="ff93e-286">- oder - </span><span class="sxs-lookup"><span data-stu-id="ff93e-286">-or-</span></span>

<span data-ttu-id="ff93e-287">Der <paramref name="destination" />-Datenstrom ist nicht schreibbar.</span><span class="sxs-lookup"><span data-stu-id="ff93e-287">The <paramref name="destination" /> stream is unwritable.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="memoryStream.CopyToAsync (destination, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="ff93e-288">Der Stream, in den der Inhalt des aktuellen Stream kopiert wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-288">The stream to which the contents of the current stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="ff93e-289">Die Größe des Cookies in Bytes.</span><span class="sxs-lookup"><span data-stu-id="ff93e-289">The size, in bytes, of the buffer.</span></span> <span data-ttu-id="ff93e-290">Dieser Wert muss größer als 0 sein.</span><span class="sxs-lookup"><span data-stu-id="ff93e-290">This value must be greater than zero.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="ff93e-291">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-291">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="ff93e-292">Liest alle Bytes asynchron aus dem aktuellen Stream und schreibt sie unter Verwendung einer angegebenen Puffergröße und eines Abbruchtokens in einen anderen Stream.</span><span class="sxs-lookup"><span data-stu-id="ff93e-292">Asynchronously reads all the bytes from the current stream and writes them to another stream, using a specified buffer size and cancellation token.</span></span></summary>
        <returns><span data-ttu-id="ff93e-293">Eine Aufgabe, die den asynchronen Kopiervorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-293">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ff93e-294"><paramref name="destination" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-294"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ff93e-295"><paramref name="buffersize" /> ist negativ oder 0 (null).</span><span class="sxs-lookup"><span data-stu-id="ff93e-295"><paramref name="buffersize" /> is negative or zero.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ff93e-296">Entweder der aktuelle Stream oder der Zielstream wird freigegeben.</span><span class="sxs-lookup"><span data-stu-id="ff93e-296">Either the current stream or the destination stream is disposed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ff93e-297">Der aktuelle Stream unterstützt kein Lesen oder Zielstream unterstützt keine Schreibvorgänge.</span><span class="sxs-lookup"><span data-stu-id="ff93e-297">The current stream does not support reading, or the destination stream does not support writing.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="memoryStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="ff93e-298"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="ff93e-298"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="ff93e-299">Gibt die von der <see cref="T:System.IO.MemoryStream" />-Klasse verwendeten nicht verwalteten Ressourcen frei und gibt (optional) auch die verwalteten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="ff93e-299">Releases the unmanaged resources used by the <see cref="T:System.IO.MemoryStream" /> class and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-300">Diese Methode wird von der öffentlichen <xref:System.ComponentModel.Component.Dispose%2A>-Methode und der <xref:System.Object.Finalize%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-300">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="ff93e-301"><xref:System.ComponentModel.Component.Dispose%2A> Ruft die geschützte <xref:System.IO.MemoryStream.Dispose%2A> Methode auf, wobei der `disposing`-Parameter auf `true`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="ff93e-301"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.MemoryStream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="ff93e-302"><xref:System.Object.Finalize%2A> ruft <xref:System.IO.MemoryStream.Dispose%2A> auf, bei dem `disposing` auf `false`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="ff93e-302"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.MemoryStream.Dispose%2A> with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="ff93e-303">Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.IO.MemoryStream> verweist.</span><span class="sxs-lookup"><span data-stu-id="ff93e-303">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.MemoryStream> references.</span></span> <span data-ttu-id="ff93e-304">Diese Methode ruft die <xref:System.ComponentModel.Component.Dispose%2A>-Methode aller Objekte auf, auf die verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-304">This method invokes the <xref:System.ComponentModel.Component.Dispose%2A> method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="ff93e-305">
            <see cref="M:System.ComponentModel.Component.Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-305">
            <see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="ff93e-306">Beim Überschreiben <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /> Sie darauf achten, nicht auf Objekte zu verweisen, die zuvor in einem früheren <see cref="M:System.ComponentModel.Component.Dispose" />von freigegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-306">When overriding <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /> be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />.</span></span> <span data-ttu-id="ff93e-307">Weitere Informationen zum Implementieren von <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" />finden Sie unter [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.</span><span class="sxs-lookup"><span data-stu-id="ff93e-307">For more information about how to implement <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="ff93e-308">Weitere Informationen zu <see cref="M:System.ComponentModel.Component.Dispose" /> und <see cref="M:System.Object.Finalize" />finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="ff93e-308">For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="memoryStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="ff93e-309">Der Verweis auf die ausstehende asynchrone Anforderung, die beendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="ff93e-309">The reference to the pending asynchronous request to finish.</span></span></param>
        <summary><span data-ttu-id="ff93e-310">Wartet, bis der ausstehende asynchrone Lesevorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="ff93e-310">Waits for the pending asynchronous read to complete.</span></span> <span data-ttu-id="ff93e-311">(Verwenden Sie stattdessen <see cref="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</span><span class="sxs-lookup"><span data-stu-id="ff93e-311">(Consider using <see cref="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="ff93e-312">Die Anzahl der aus dem Speicherdatenstrom gelesenen Bytes. Diese Anzahl kann zwischen 0 (null) und der Anzahl der angeforderten Bytes liegen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-312">The number of bytes read from the memory stream, between zero (0) and the number of bytes you requested.</span></span> <span data-ttu-id="ff93e-313">Gibt am Ende des Speicherdatenstroms 0 zurück, andernfalls soll blockiert werden, bis mindestens 1 Byte verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="ff93e-313">Returns zero (0) only at the end of the memory stream, otherwise, it should block until at least one byte is available.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="ff93e-314">Weitere Informationen zur Verwendung dieser Methode finden Sie in der <xref:System.IO.Stream.EndRead%2A>-Hinweise.</span><span class="sxs-lookup"><span data-stu-id="ff93e-314">Refer to the <xref:System.IO.Stream.EndRead%2A> remarks for additional usage information for this method.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ff93e-315"><paramref name="asyncResult" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-315"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ff93e-316">Ein Handle für den ausstehenden Lesevorgang ist nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="ff93e-316">A handle to the pending read operation is not available.</span></span>

<span data-ttu-id="ff93e-317">- oder - </span><span class="sxs-lookup"><span data-stu-id="ff93e-317">-or-</span></span>

<span data-ttu-id="ff93e-318">Die anstehende Operation unterstützt keine Lesevorgänge.</span><span class="sxs-lookup"><span data-stu-id="ff93e-318">The pending operation does not support reading.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ff93e-319"><paramref name="asyncResult" /> basiert nicht auf einer <see cref="M:System.IO.MemoryStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />-Methode im aktuellen Speicherdatenstrom.</span><span class="sxs-lookup"><span data-stu-id="ff93e-319"><paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.MemoryStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current memory stream.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ff93e-320">Der Stream ist geschlossen, oder ein interner Fehler ist aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ff93e-320">The stream is closed or an internal error has occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="memoryStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="ff93e-321">Ein Verweis auf die ausstehende asynchrone E/A-Anforderung.</span><span class="sxs-lookup"><span data-stu-id="ff93e-321">A reference to the outstanding asynchronous I/O request.</span></span></param>
        <summary><span data-ttu-id="ff93e-322">Beendet einen asynchronen Schreibvorgang.</span><span class="sxs-lookup"><span data-stu-id="ff93e-322">Ends an asynchronous write operation.</span></span> <span data-ttu-id="ff93e-323">(Verwenden Sie stattdessen <see cref="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</span><span class="sxs-lookup"><span data-stu-id="ff93e-323">(Consider using <see cref="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="ff93e-324">Weitere Informationen zur Verwendung dieser Methode finden Sie in der <xref:System.IO.Stream.EndWrite%2A>-Hinweise.</span><span class="sxs-lookup"><span data-stu-id="ff93e-324">Refer to the <xref:System.IO.Stream.EndWrite%2A> remarks for additional usage information for this method.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ff93e-325"><paramref name="asyncResult" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-325"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ff93e-326">Ein Handle für den ausstehenden Schreibvorgang ist nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="ff93e-326">A handle to the pending write operation is not available.</span></span>

<span data-ttu-id="ff93e-327">- oder - </span><span class="sxs-lookup"><span data-stu-id="ff93e-327">-or-</span></span>

<span data-ttu-id="ff93e-328">Die anstehende Operation unterstützt keine Schreibvorgänge.</span><span class="sxs-lookup"><span data-stu-id="ff93e-328">The pending operation does not support writing.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ff93e-329"><paramref name="asyncResult" /> basiert nicht auf einer <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />-Methode im aktuellen Stream.</span><span class="sxs-lookup"><span data-stu-id="ff93e-329"><paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ff93e-330">Der Stream ist geschlossen, oder ein interner Fehler ist aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="ff93e-330">The stream is closed or an internal error has occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="memoryStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ff93e-331">Überschreibt die <see cref="M:System.IO.Stream.Flush" />-Methode, sodass keine Aktion durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-331">Overrides the <see cref="M:System.IO.Stream.Flush" /> method so that no action is performed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-332">Diese Methode überschreibt die <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>-Methode.</span><span class="sxs-lookup"><span data-stu-id="ff93e-332">This method overrides the <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ff93e-333">Da alle Daten, die in ein <xref:System.IO.MemoryStream> Objekt geschrieben werden, in den RAM geschrieben werden, ist diese Methode redundant.</span><span class="sxs-lookup"><span data-stu-id="ff93e-333">Because any data written to a <xref:System.IO.MemoryStream> object is written into RAM, this method is redundant.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-334">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-334">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-335">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-335">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-336">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-336">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="memoryStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="ff93e-337">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-337">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="ff93e-338">Löscht sämtliche Puffer für diesen Stream asynchron und überwacht Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-338">Asynchronously clears all buffers for this stream, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="ff93e-339">Eine Aufgabe, die die asynchrone Leerung darstellt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-339">A task that represents the asynchronous flush operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-340">Da alle Daten, die in ein <xref:System.IO.MemoryStream> Objekt geschrieben werden, in den RAM geschrieben werden, ist diese Methode redundant.</span><span class="sxs-lookup"><span data-stu-id="ff93e-340">Because any data written to a <xref:System.IO.MemoryStream> object is written into RAM, this method is redundant.</span></span>  
  
 <span data-ttu-id="ff93e-341">Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die zurückgegebene Aufgabe den <xref:System.Threading.Tasks.TaskStatus.Canceled> Wert für die <xref:System.Threading.Tasks.Task.Status%2A>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="ff93e-341">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="ff93e-342">Sie können ein Abbruch Token erstellen, indem Sie eine Instanz der <xref:System.Threading.CancellationTokenSource>-Klasse erstellen und die <xref:System.Threading.CancellationTokenSource.Token%2A>-Eigenschaft als `cancellationToken`-Parameter übergeben.</span><span class="sxs-lookup"><span data-stu-id="ff93e-342">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ff93e-343">Der Stream wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-343">The stream has been disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md"><span data-ttu-id="ff93e-344">Abbruch</span><span class="sxs-lookup"><span data-stu-id="ff93e-344">Cancellation</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetBuffer">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.GetBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBuffer () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBuffer();" />
      <MemberSignature Language="F#" Value="abstract member GetBuffer : unit -&gt; byte[]&#xA;override this.GetBuffer : unit -&gt; byte[]" Usage="memoryStream.GetBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ff93e-345">Gibt das Array vorzeichenloser Bytes zurück, aus dem dieser Stream erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="ff93e-345">Returns the array of unsigned bytes from which this stream was created.</span></span></summary>
        <returns><span data-ttu-id="ff93e-346">Das Bytearray, aus dem der Stream erstellt wurde, oder das zugrunde liegende Array, wenn für den <see cref="T:System.IO.MemoryStream" />-Konstruktor beim Erstellen der aktuellen Instanz kein Bytearray bereitgestellt wurde.</span><span class="sxs-lookup"><span data-stu-id="ff93e-346">The byte array from which this stream was created, or the underlying array if a byte array was not provided to the <see cref="T:System.IO.MemoryStream" /> constructor during construction of the current instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-347">Beachten Sie, dass der Puffer zugeordnete Bytes enthält, die möglicherweise nicht verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-347">Note that the buffer contains allocated bytes which might be unused.</span></span> <span data-ttu-id="ff93e-348">Wenn z. b. die Zeichenfolge "Test" in das <xref:System.IO.MemoryStream> Objekt geschrieben wird, ist die Länge des von <xref:System.IO.MemoryStream.GetBuffer%2A> zurückgegebenen Puffers 256, nicht 4, wobei 252 Bytes nicht verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-348">For example, if the string "test" is written into the <xref:System.IO.MemoryStream> object, the length of the buffer returned from <xref:System.IO.MemoryStream.GetBuffer%2A> is 256, not 4, with 252 bytes unused.</span></span> <span data-ttu-id="ff93e-349">Wenn Sie nur die Daten im Puffer abrufen möchten, verwenden Sie die <xref:System.IO.MemoryStream.ToArray%2A>-Methode. <xref:System.IO.MemoryStream.ToArray%2A> erstellt jedoch eine Kopie der Daten im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="ff93e-349">To obtain only the data in the buffer, use the <xref:System.IO.MemoryStream.ToArray%2A> method; however, <xref:System.IO.MemoryStream.ToArray%2A> creates a copy of the data in memory.</span></span>  
  
 <span data-ttu-id="ff93e-350">Der Puffer kann auch `null`werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-350">The buffer can also be `null`.</span></span>  
  
 <span data-ttu-id="ff93e-351">Verwenden Sie <xref:System.IO.MemoryStream.%23ctor%2A>, <xref:System.IO.MemoryStream.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Boolean%29>oder <xref:System.IO.MemoryStream.%23ctor%28System.Int32%29>, um eine `MemoryStream` Instanz mit einem öffentlich sichtbaren Puffer zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-351">To create a `MemoryStream` instance with a publicly visible buffer, use <xref:System.IO.MemoryStream.%23ctor%2A>, <xref:System.IO.MemoryStream.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Boolean%29>, or <xref:System.IO.MemoryStream.%23ctor%28System.Int32%29>.</span></span> <span data-ttu-id="ff93e-352">Wenn der aktuelle Stream in der Größe geändert werden kann, geben zwei Aufrufe dieser Methode nicht dasselbe Array zurück, wenn die Größe des zugrunde liegenden Bytearrays zwischen den Aufrufen geändert wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-352">If the current stream is resizable, two calls to this method do not return the same array if the underlying byte array is resized between calls.</span></span> <span data-ttu-id="ff93e-353">Weitere Informationen finden Sie unter <xref:System.IO.MemoryStream.Capacity%2A>.</span><span class="sxs-lookup"><span data-stu-id="ff93e-353">For additional information, see <xref:System.IO.MemoryStream.Capacity%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ff93e-354">Diese Methode funktioniert, wenn der Arbeitsspeicherstream geschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-354">This method works when the memory stream is closed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="ff93e-355">Die <see langword="MemoryStream" />-Instanz wurde nicht mit einem öffentlich sichtbaren Puffer erstellt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-355">The <see langword="MemoryStream" /> instance was not created with a publicly visible buffer.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-356">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-356">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-357">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-357">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-358">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-358">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.MemoryStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ff93e-359">Ruft die Länge des Streams in Bytes ab.</span><span class="sxs-lookup"><span data-stu-id="ff93e-359">Gets the length of the stream in bytes.</span></span></summary>
        <value><span data-ttu-id="ff93e-360">Die Länge des Streams in Bytes.</span><span class="sxs-lookup"><span data-stu-id="ff93e-360">The length of the stream in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ff93e-361">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.MemoryStream>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-361">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ff93e-362">Der Stream ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-362">The stream is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-363">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-363">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-364">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-364">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-365">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-365">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ObjectInvariant">
      <MemberSignature Language="C#" Value="protected override void ObjectInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ObjectInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ObjectInvariant" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ObjectInvariant ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ObjectInvariant();" />
      <MemberSignature Language="F#" Value="override this.ObjectInvariant : unit -&gt; unit" Usage="memoryStream.ObjectInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ff93e-366">Bietet Unterstützung für einen <see cref="T:System.Diagnostics.Contracts.Contract" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-366">Provides support for a <see cref="T:System.Diagnostics.Contracts.Contract" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.MemoryStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ff93e-367">Ruft die aktuelle Position im Stream ab oder legt diese fest.</span><span class="sxs-lookup"><span data-stu-id="ff93e-367">Gets or sets the current position within the stream.</span></span></summary>
        <value><span data-ttu-id="ff93e-368">Die aktuelle Position innerhalb des Streams.</span><span class="sxs-lookup"><span data-stu-id="ff93e-368">The current position within the stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ff93e-369">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.MemoryStream>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-369">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ff93e-370">Die Position ist auf einen negativen Wert oder einen größeren Wert als <see cref="F:System.Int32.MaxValue" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-370">The position is set to a negative value or a value greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ff93e-371">Der Stream ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-371">The stream is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-372">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-372">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-373">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-373">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-374">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-374">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; destination);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="memoryStream.Read destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="ff93e-375">Ein Bereich im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="ff93e-375">A region of memory.</span></span> <span data-ttu-id="ff93e-376">Nach Ausführung dieser Methode wurden die Inhalte dieser Spanne durch die aus der aktuellen Speicherdatenstrom-Quelle gelesenen Bytes ersetzt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-376">When this method returns, the contents of this span are replaced by the bytes read from the current memory stream source.</span></span></param>
        <summary><span data-ttu-id="ff93e-377">Liest eine Bytesequenz aus dem aktuellen Speicherdatenstrom und setzt die Position in diesem Speicherdatenstrom um die Anzahl der gelesenen Bytes nach vorn.</span><span class="sxs-lookup"><span data-stu-id="ff93e-377">Reads a sequence of bytes from the current memory stream and advances the position within the memory stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="ff93e-378">Die Gesamtanzahl der in den Puffer gelesenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="ff93e-378">The total number of bytes read into the buffer.</span></span> <span data-ttu-id="ff93e-379">Dies kann weniger als die Anzahl der im Puffer zugeordneten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder 0 (null), wenn das Ende des Speicherdatenstroms erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="ff93e-379">This can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or zero (0) if the end of the memory stream has been reached.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="memoryStream.Read (buffer, offset, count)" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ff93e-380">Enthält nach dem Beenden dieser Methode das angegebene Bytearray mit den Werten zwischen <paramref name="offset" /> und (<paramref name="offset" /> + <paramref name="count" /> - 1), die durch aus dem aktuellen Stream gelesene Zeichen ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-380">When this method returns, contains the specified byte array with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1) replaced by the characters read from the current stream.</span></span></param>
        <param name="offset"><span data-ttu-id="ff93e-381">Der nullbasierte Byteoffset im <paramref name="buffer" />, ab dem die Daten aus dem aktuellen Stream gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-381">The zero-based byte offset in <paramref name="buffer" /> at which to begin storing data from the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="ff93e-382">Die maximale Anzahl der zu lesenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="ff93e-382">The maximum number of bytes to read.</span></span></param>
        <summary><span data-ttu-id="ff93e-383">Liest einen Byteblock aus dem aktuellen Stream und schreibt die Daten in einen Puffer.</span><span class="sxs-lookup"><span data-stu-id="ff93e-383">Reads a block of bytes from the current stream and writes the data to a buffer.</span></span></summary>
        <returns><span data-ttu-id="ff93e-384">Die Gesamtanzahl der in den Puffer geschriebenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="ff93e-384">The total number of bytes written into the buffer.</span></span> <span data-ttu-id="ff93e-385">Dies kann weniger als die Anzahl der angeforderten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder null, wenn das Ende des Streams erreicht ist, bevor mindestens ein Byte gelesen wurde.</span><span class="sxs-lookup"><span data-stu-id="ff93e-385">This can be less than the number of bytes requested if that number of bytes are not currently available, or zero if the end of the stream is reached before any bytes are read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-386">Diese Methode überschreibt <xref:System.IO.Stream.Read%2A>.</span><span class="sxs-lookup"><span data-stu-id="ff93e-386">This method overrides <xref:System.IO.Stream.Read%2A>.</span></span>  
  
 <span data-ttu-id="ff93e-387">Der `offset`-Parameter gibt den Offset des ersten Bytes in `buffer` an, in den die Daten aus dem aktuellen Stream geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-387">The `offset` parameter gives the offset of the first byte in `buffer` to which data from the current stream is written.</span></span> <span data-ttu-id="ff93e-388">Der `count`-Parameter gibt die maximale Anzahl von Bytes an, die aus dem aktuellen Stream gelesen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-388">The `count` parameter gives the maximum number of bytes to read from the current stream.</span></span> <span data-ttu-id="ff93e-389">Der zurückgegebene Wert ist die tatsächliche Anzahl von gelesenen Bytes, oder 0 (null), wenn das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="ff93e-389">The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</span></span>  
  
 <span data-ttu-id="ff93e-390">Wenn der Lesevorgang erfolgreich ist, wird die aktuelle Position im Stream um die Anzahl der gelesenen Bytes fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-390">If the read operation is successful, the current position within the stream advances by the number of bytes read.</span></span> <span data-ttu-id="ff93e-391">Wenn eine Ausnahme auftritt, bleibt die aktuelle Position im Stream unverändert.</span><span class="sxs-lookup"><span data-stu-id="ff93e-391">If an exception occurs, the current position within the stream remains unchanged.</span></span>  
  
 <span data-ttu-id="ff93e-392">Die `Read`-Methode gibt nur dann NULL zurück, wenn das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="ff93e-392">The `Read` method will return zero only if the end of the stream is reached.</span></span> <span data-ttu-id="ff93e-393">In allen anderen Fällen liest `Read` vor der Rückgabe immer mindestens ein Byte aus dem Datenstrom.</span><span class="sxs-lookup"><span data-stu-id="ff93e-393">In all other cases, `Read` always reads at least one byte from the stream before returning.</span></span> <span data-ttu-id="ff93e-394">Definitionsgemäß gibt die `Read` Methode 0 (null) zurück (das Ende des Streams wird automatisch erreicht), wenn keine Daten aus dem Stream bei einem `Read`verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="ff93e-394">By definition, if no data is available from the stream upon a call to `Read`, the `Read` method returns zero (the end of the stream is reached automatically).</span></span> <span data-ttu-id="ff93e-395">Eine-Implementierung kann weniger Bytes zurückgeben als angefordert werden, auch wenn das Ende des Streams nicht erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="ff93e-395">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="ff93e-396">Verwenden Sie <xref:System.IO.BinaryReader> zum Lesen primitiver Datentypen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-396">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ff93e-397">Wenn das im `buffer`-Parameter angegebene Bytearray der zugrunde liegende Puffer ist, der von der <xref:System.IO.MemoryStream.GetBuffer%2A>-Methode zurückgegeben wird, wird der Array Inhalt überschrieben, und es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="ff93e-397">If the byte array specified in the `buffer` parameter is the underlying buffer returned by the <xref:System.IO.MemoryStream.GetBuffer%2A> method, the array contents are overwritten, and no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ff93e-398">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.MemoryStream>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-398">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#7)]
 [!code-csharp[System.IO.MemoryStream#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#7)]
 [!code-vb[System.IO.MemoryStream#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ff93e-399"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-399"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ff93e-400"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="ff93e-400"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ff93e-401"><paramref name="offset" /> subtrahiert von der Pufferlänge ist kleiner als <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-401"><paramref name="offset" /> subtracted from the buffer length is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ff93e-402">Der aktuelle Instanz des Streams ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-402">The current stream instance is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-403">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-403">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-404">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-404">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-405">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-405">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; destination, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; destination, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="memoryStream.ReadAsync (destination, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="ff93e-406">Der Bereich im Arbeitsspeicher, in den die Daten geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-406">The region of memory to write the data into.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="ff93e-407">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-407">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="ff93e-408">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />sein.</span><span class="sxs-lookup"><span data-stu-id="ff93e-408">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="ff93e-409">Liest eine Folge von Bytes asynchron aus dem aktuellen Speicherdatenstrom, schreibt diese in <paramref name="destination" />, erhöht die Position im Speicherdatenstrom um die Anzahl der gelesenen Bytes und überwacht Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-409">Asynchronously reads a sequence of bytes from the current memory stream, writes the sequence into <paramref name="destination" />, advances the position within the memory stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="ff93e-410">Eine Aufgabe, die den asynchronen Lesevorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-410">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="ff93e-411">Der Wert seiner <see cref="P:System.Threading.Tasks.ValueTask`1.Result" />-Eigenschaft enthält die Gesamtzahl der Bytes, die in <paramref name="destination" /> gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-411">The value of its <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> property contains the total number of bytes read into the <paramref name="destination" />.</span></span> <span data-ttu-id="ff93e-412">Der Ergebniswert kann weniger als die Anzahl der in <paramref name="destination" /> zugeordneten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder er kann 0 (null) sein, wenn das Ende des Speicherdatenstroms erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="ff93e-412">The result value can be less than the number of bytes allocated in <paramref name="destination" /> if that many bytes are not currently available, or it can be 0 (zero) if the end of the memory stream has been reached.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="memoryStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ff93e-413">Der Puffer, in den die Daten geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-413">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="ff93e-414">Der Byteoffset im <paramref name="buffer" />, ab dem Daten aus dem Stream geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-414">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="ff93e-415">Die maximale Anzahl der zu lesenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="ff93e-415">The maximum number of bytes to read.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="ff93e-416">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-416">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="ff93e-417">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />sein.</span><span class="sxs-lookup"><span data-stu-id="ff93e-417">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="ff93e-418">Liest eine Folge von Bytes asynchron aus aktuellen Stream, erhöht die Position im Stream um die Anzahl der gelesenen Bytes und überwacht Abbruchanfragen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-418">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="ff93e-419">Eine Aufgabe, die den asynchronen Lesevorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-419">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="ff93e-420">Der Wert des <paramref name="TResult" />-Parameters enthält die Gesamtzahl der Bytes, die in den Puffer gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-420">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="ff93e-421">Der Ergebniswert kann niedriger als die Anzahl der angeforderten Bytes sein, wenn die Anzahl an derzeit verfügbaren Bytes kleiner ist als die angeforderte Anzahl, oder sie kann 0 (null) sein, wenn das Datenstromende erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="ff93e-421">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-422">Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die zurückgegebene Aufgabe den <xref:System.Threading.Tasks.TaskStatus.Canceled> Wert für die <xref:System.Threading.Tasks.Task.Status%2A>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="ff93e-422">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="ff93e-423">Sie können ein Abbruch Token erstellen, indem Sie eine Instanz der <xref:System.Threading.CancellationTokenSource>-Klasse erstellen und die <xref:System.Threading.CancellationTokenSource.Token%2A>-Eigenschaft als `cancellationToken`-Parameter übergeben.</span><span class="sxs-lookup"><span data-stu-id="ff93e-423">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ff93e-424"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-424"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ff93e-425"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="ff93e-425"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ff93e-426">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Pufferlänge.</span><span class="sxs-lookup"><span data-stu-id="ff93e-426">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ff93e-427">Lesevorgänge werden vom Stream nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-427">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ff93e-428">Der Stream wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-428">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ff93e-429">Der Stream wird zurzeit von einem vorherigen Lesevorgang verwendet.</span><span class="sxs-lookup"><span data-stu-id="ff93e-429">The stream is currently in use by a previous read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="memoryStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ff93e-430">Liest ein Byte aus dem aktuellen Stream.</span><span class="sxs-lookup"><span data-stu-id="ff93e-430">Reads a byte from the current stream.</span></span></summary>
        <returns><span data-ttu-id="ff93e-431">Das Byte, das in <see cref="T:System.Int32" /> umgewandelt wurde, oder -1, wenn das Ende des Streams erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="ff93e-431">The byte cast to a <see cref="T:System.Int32" />, or -1 if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-432">Diese Methode überschreibt <xref:System.IO.Stream.ReadByte%2A>.</span><span class="sxs-lookup"><span data-stu-id="ff93e-432">This method overrides <xref:System.IO.Stream.ReadByte%2A>.</span></span>  
  
 <span data-ttu-id="ff93e-433">Wenn der Lesevorgang erfolgreich ist, wird die aktuelle Position im Stream um ein Byte erweitert.</span><span class="sxs-lookup"><span data-stu-id="ff93e-433">If the read operation is successful, the current position within the stream is advanced by one byte.</span></span> <span data-ttu-id="ff93e-434">Wenn eine Ausnahme auftritt, wird die aktuelle Position im Stream unverändert.</span><span class="sxs-lookup"><span data-stu-id="ff93e-434">If an exception occurs, the current position within the stream is unchanged.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ff93e-435">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.MemoryStream>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-435">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#8)]
 [!code-csharp[System.IO.MemoryStream#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#8)]
 [!code-vb[System.IO.MemoryStream#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ff93e-436">Der aktuelle Instanz des Streams ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-436">The current stream instance is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-437">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-437">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-438">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-438">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-439">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-439">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin loc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, loc As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin loc);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="memoryStream.Seek (offset, loc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="loc" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="ff93e-440">Die neue Position innerhalb des Streams.</span><span class="sxs-lookup"><span data-stu-id="ff93e-440">The new position within the stream.</span></span> <span data-ttu-id="ff93e-441">Diese ist relativ zum <paramref name="loc" />-Parameter und kann positiv oder negativ sein.</span><span class="sxs-lookup"><span data-stu-id="ff93e-441">This is relative to the <paramref name="loc" /> parameter, and can be positive or negative.</span></span></param>
        <param name="loc"><span data-ttu-id="ff93e-442">Ein Wert vom Typ <see cref="T:System.IO.SeekOrigin" />, der den Bezugspunkt für die Suche darstellt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-442">A value of type <see cref="T:System.IO.SeekOrigin" />, which acts as the seek reference point.</span></span></param>
        <summary><span data-ttu-id="ff93e-443">Legt die Position im aktuellen Stream auf den angegebenen Wert fest.</span><span class="sxs-lookup"><span data-stu-id="ff93e-443">Sets the position within the current stream to the specified value.</span></span></summary>
        <returns><span data-ttu-id="ff93e-444">Die neue Position im Stream, die durch Kombinieren des anfänglichen Verweispunktes und des Offsets berechnet wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-444">The new position within the stream, calculated by combining the initial reference point and the offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-445">Diese Methode überschreibt <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ff93e-445">This method overrides <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ff93e-446">Das Suchen nach einem beliebigen Speicherort über die Länge des Streams wird unterstützt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-446">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 <span data-ttu-id="ff93e-447">Verwenden Sie die <xref:System.IO.MemoryStream.Seek%2A>-Methode nicht, um die neue Position im Stream zu ermitteln, wenn die <xref:System.IO.MemoryStream> mit einem Offset ungleich 0 (null) initialisiert wurde.</span><span class="sxs-lookup"><span data-stu-id="ff93e-447">Do not use the <xref:System.IO.MemoryStream.Seek%2A> method to determine the new position in the stream if the <xref:System.IO.MemoryStream> was initialized with a non-zero offset.</span></span> <span data-ttu-id="ff93e-448">Wenn Sie dies tun, wird <xref:System.IO.MemoryStream.Seek%2A> einen ungenauen Wert zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="ff93e-448">If you do, <xref:System.IO.MemoryStream.Seek%2A> will return an inaccurate value.</span></span> <span data-ttu-id="ff93e-449">Verwenden Sie stattdessen die <xref:System.IO.MemoryStream.Position%2A>-Eigenschaft, um die neue Position des Streams zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="ff93e-449">Instead, use the <xref:System.IO.MemoryStream.Position%2A> property to get the new position of the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ff93e-450">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.MemoryStream>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-450">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#6)]
 [!code-csharp[System.IO.MemoryStream#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#6)]
 [!code-vb[System.IO.MemoryStream#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ff93e-451">Es wird versucht, vor Beginn des Streams eine Suche auszuführen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-451">Seeking is attempted before the beginning of the stream.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ff93e-452"><paramref name="offset" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-452"><paramref name="offset" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ff93e-453">Ein <see cref="T:System.IO.SeekOrigin" /> ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="ff93e-453">There is an invalid <see cref="T:System.IO.SeekOrigin" />.</span></span>  
  
<span data-ttu-id="ff93e-454">- oder - </span><span class="sxs-lookup"><span data-stu-id="ff93e-454">-or-</span></span> 
 <span data-ttu-id="ff93e-455"><paramref name="offset" /> hat einen arithmetischen Überlauf verursacht.</span><span class="sxs-lookup"><span data-stu-id="ff93e-455"><paramref name="offset" /> caused an arithmetic overflow.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ff93e-456">Der aktuelle Instanz des Streams ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-456">The current stream instance is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-457">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-457">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-458">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-458">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-459">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-459">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="memoryStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ff93e-460">Der Wert, auf den die Länge festgelegt werden soll.</span><span class="sxs-lookup"><span data-stu-id="ff93e-460">The value at which to set the length.</span></span></param>
        <summary><span data-ttu-id="ff93e-461">Legt die Länge des aktuellen Streams auf den angegebenen Wert fest.</span><span class="sxs-lookup"><span data-stu-id="ff93e-461">Sets the length of the current stream to the specified value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-462">Diese Methode überschreibt <xref:System.IO.Stream.SetLength%2A>.</span><span class="sxs-lookup"><span data-stu-id="ff93e-462">This method overrides <xref:System.IO.Stream.SetLength%2A>.</span></span>  
  
 <span data-ttu-id="ff93e-463">Wenn der angegebene Wert kleiner als die aktuelle Länge des Streams ist, wird der Stream abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="ff93e-463">If the specified value is less than the current length of the stream, the stream is truncated.</span></span> <span data-ttu-id="ff93e-464">Wenn die aktuelle Position im Stream nach dem Abschneiden hinter dem Ende des Streams liegt, gibt die <xref:System.IO.MemoryStream.ReadByte%2A>-Methode-1 zurück, die <xref:System.IO.MemoryStream.Read%2A>-Methode NULL Bytes in das angegebene Bytearray, und <xref:System.IO.MemoryStream.Write%2A>-und <xref:System.IO.MemoryStream.WriteByte%2A>-Methoden fügen angegebene Bytes am Ende des Streams an und erhöhen so die Länge.</span><span class="sxs-lookup"><span data-stu-id="ff93e-464">If after the truncation the current position within the stream is past the end of the stream, the <xref:System.IO.MemoryStream.ReadByte%2A> method returns -1, the <xref:System.IO.MemoryStream.Read%2A> method reads zero bytes into the provided byte array, and <xref:System.IO.MemoryStream.Write%2A> and <xref:System.IO.MemoryStream.WriteByte%2A> methods append specified bytes at the end of the stream, increasing its length.</span></span> <span data-ttu-id="ff93e-465">Wenn der angegebene Wert größer ist als die aktuelle Kapazität und die Größe des Streams geändert werden kann, wird die Kapazität vergrößert, und die aktuelle Position innerhalb des Streams bleibt unverändert.</span><span class="sxs-lookup"><span data-stu-id="ff93e-465">If the specified value is larger than the current capacity and the stream is resizable, the capacity is increased, and the current position within the stream is unchanged.</span></span> <span data-ttu-id="ff93e-466">Wenn die Länge zunimmt, werden die Inhalte des Streams zwischen der alten und der neuen Länge mit Nullen initialisiert.</span><span class="sxs-lookup"><span data-stu-id="ff93e-466">If the length is increased, the contents of the stream between the old and the new length are initialized to zeros.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ff93e-467">Eine <xref:System.IO.MemoryStream> Instanz muss das Schreiben unterstützen, damit diese Methode funktioniert.</span><span class="sxs-lookup"><span data-stu-id="ff93e-467">A <xref:System.IO.MemoryStream> instance must support writing for this method to work.</span></span> <span data-ttu-id="ff93e-468">Verwenden Sie die Eigenschaft <xref:System.IO.MemoryStream.CanWrite%2A>, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-468">Use the <xref:System.IO.MemoryStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="ff93e-469">Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="ff93e-469">For additional information, see <xref:System.IO.Stream.CanWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ff93e-470">Die Größe des aktuellen Streams kann nicht geändert werden, und <paramref name="value" /> übersteigt die aktuelle Kapazität.</span><span class="sxs-lookup"><span data-stu-id="ff93e-470">The current stream is not resizable and <paramref name="value" /> is larger than the current capacity.</span></span>  
  
<span data-ttu-id="ff93e-471">- oder - </span><span class="sxs-lookup"><span data-stu-id="ff93e-471">-or-</span></span> 
<span data-ttu-id="ff93e-472">Der aktuelle Stream unterstützt keine Schreibvorgänge.</span><span class="sxs-lookup"><span data-stu-id="ff93e-472">The current stream does not support writing.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ff93e-473"><paramref name="value" /> ist negativ oder größer als die maximale Länge von <see cref="T:System.IO.MemoryStream" />, wobei die maximale Länge (<see cref="F:System.Int32.MaxValue" /> - Ursprung) ist, und der Ursprung der Index des zugrunde liegenden Puffers ist, an dem der Stream beginnt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-473"><paramref name="value" /> is negative or is greater than the maximum length of the <see cref="T:System.IO.MemoryStream" />, where the maximum length is(<see cref="F:System.Int32.MaxValue" /> - origin), and origin is the index into the underlying buffer at which the stream starts.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-474">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-474">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-475">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-475">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-476">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-476">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual byte[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="abstract member ToArray : unit -&gt; byte[]&#xA;override this.ToArray : unit -&gt; byte[]" Usage="memoryStream.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ff93e-477">Schreibt den Inhalt des Streams in ein Bytearray, unabhängig von der <see cref="P:System.IO.MemoryStream.Position" />-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="ff93e-477">Writes the stream contents to a byte array, regardless of the <see cref="P:System.IO.MemoryStream.Position" /> property.</span></span></summary>
        <returns><span data-ttu-id="ff93e-478">Ein neues Bytearray.</span><span class="sxs-lookup"><span data-stu-id="ff93e-478">A new byte array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-479">Diese Methode lässt nicht verwendete Bytes in <xref:System.IO.MemoryStream> aus dem Array aus.</span><span class="sxs-lookup"><span data-stu-id="ff93e-479">This method omits unused bytes in <xref:System.IO.MemoryStream> from the array.</span></span> <span data-ttu-id="ff93e-480">Um den gesamten Puffer zu erhalten, verwenden Sie die <xref:System.IO.MemoryStream.GetBuffer%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="ff93e-480">To get the entire buffer, use the <xref:System.IO.MemoryStream.GetBuffer%2A> method.</span></span>  
  
 <span data-ttu-id="ff93e-481">Diese Methode gibt eine Kopie des Inhalts der <xref:System.IO.MemoryStream> als Bytearray zurück.</span><span class="sxs-lookup"><span data-stu-id="ff93e-481">This method returns a copy of the contents of the <xref:System.IO.MemoryStream> as a byte array.</span></span> <span data-ttu-id="ff93e-482">Wenn die aktuelle Instanz für ein bereitgestelltes Bytearray erstellt wurde, wird eine Kopie des Abschnitts des Arrays zurückgegeben, auf das diese Instanz Zugriff hat.</span><span class="sxs-lookup"><span data-stu-id="ff93e-482">If the current instance was constructed on a provided byte array, a copy of the section of the array to which this instance has access is returned.</span></span> <span data-ttu-id="ff93e-483">Weitere Informationen finden Sie im <xref:System.IO.MemoryStream.%23ctor%2A>-Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="ff93e-483">See the <xref:System.IO.MemoryStream.%23ctor%2A> constructor for details.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ff93e-484">Diese Methode funktioniert, wenn die <xref:System.IO.MemoryStream> geschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-484">This method works when the <xref:System.IO.MemoryStream> is closed.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-485">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-485">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-486">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-486">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-487">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-487">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryGetBuffer">
      <MemberSignature Language="C#" Value="public virtual bool TryGetBuffer (out ArraySegment&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetBuffer([out] valuetype System.ArraySegment`1&lt;unsigned int8&gt;&amp; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetBuffer (ByRef buffer As ArraySegment(Of Byte)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetBuffer([Runtime::InteropServices::Out] ArraySegment&lt;System::Byte&gt; % buffer);" />
      <MemberSignature Language="F#" Value="abstract member TryGetBuffer : ArraySegment -&gt; bool&#xA;override this.TryGetBuffer : ArraySegment -&gt; bool" Usage="memoryStream.TryGetBuffer buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ArraySegment&lt;System.Byte&gt;" RefType="out" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ff93e-488">Wenn diese Methode <see langword="true" /> zurückgibt, wird Bytearray ausgegeben, aus dem dieser Stream erstellt wurde. Wenn die Methode <see langword="false" /> zurückgibt, wird dieser Parameter auf <see langword="default" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-488">When this method returns <see langword="true" />, the byte array segment from which this stream was created; when this method returns <see langword="false" />, this parameter is set to <see langword="default" />.</span></span></param>
        <summary><span data-ttu-id="ff93e-489">Gibt das Array vorzeichenloser Bytes zurück, aus dem dieser Stream erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="ff93e-489">Returns the array of unsigned bytes from which this stream was created.</span></span> <span data-ttu-id="ff93e-490">Der Rückgabewert gibt an, ob die Konvertierung erfolgreich abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="ff93e-490">The return value indicates whether the conversion succeeded.</span></span></summary>
        <returns><span data-ttu-id="ff93e-491"><see langword="true" />, wenn der Puffer für die Darstellung sichtbar ist, andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="ff93e-491"><see langword="true" /> if the buffer is exposable; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="ff93e-492">Diese Methode gibt `true` zurück, wenn der zugrunde liegende Puffer als exposable markiert ist. Dies geschieht, wenn die aktuelle `MemoryStream` Instanz mit erstellt wird:</span><span class="sxs-lookup"><span data-stu-id="ff93e-492">This method returns `true` when the the underlying buffer is marked as exposable, which happens when the current `MemoryStream` instance is created with:</span></span>

- <span data-ttu-id="ff93e-493"><xref:System.IO.MemoryStream.%23ctor>.</span><span class="sxs-lookup"><span data-stu-id="ff93e-493"><xref:System.IO.MemoryStream.%23ctor>.</span></span>
- <span data-ttu-id="ff93e-494"><xref:System.IO.MemoryStream.%23ctor(System.Int32)>.</span><span class="sxs-lookup"><span data-stu-id="ff93e-494"><xref:System.IO.MemoryStream.%23ctor(System.Int32)>.</span></span>
- <span data-ttu-id="ff93e-495"><xref:System.IO.MemoryStream.%23ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)>, bei dem der-Parameter `publiclyVisible` auf `true`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="ff93e-495"><xref:System.IO.MemoryStream.%23ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)> with the parameter `publiclyVisible` set to `true`.</span></span>

<span data-ttu-id="ff93e-496">Der zugrunde liegende Puffer wird nicht verfügbar gemacht, wenn die aktuelle `MemoryStream` Instanz mit erstellt wird:</span><span class="sxs-lookup"><span data-stu-id="ff93e-496">The underlying buffer will not be exposed if the current `MemoryStream` instance is created with:</span></span>

- <xref:System.IO.MemoryStream.%23ctor(System.Byte[],System.Boolean)>
- <span data-ttu-id="ff93e-497"><xref:System.IO.MemoryStream.%23ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)>, bei dem der-Parameter `publiclyVisible` auf `false`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="ff93e-497"><xref:System.IO.MemoryStream.%23ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)> with the parameter `publiclyVisible` set to `false`.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (source As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="memoryStream.Write source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="ff93e-498">Ein Bereich im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="ff93e-498">A region of memory.</span></span> <span data-ttu-id="ff93e-499">Diese Methode kopiert den Inhalt dieses Bereichs in den aktuellen Speicherdatenstrom.</span><span class="sxs-lookup"><span data-stu-id="ff93e-499">This method copies the contents of this region to the current memory stream.</span></span></param>
        <summary><span data-ttu-id="ff93e-500">Schreibt die Bytesequenz, die in <paramref name="source" /> enthalten ist, in den aktuellen Speicherdatenstrom und setzt die aktuelle Position in diesem Speicherdatenstrom um die Anzahl der geschriebenen Bytes nach vorn.</span><span class="sxs-lookup"><span data-stu-id="ff93e-500">Writes the sequence of bytes contained in <paramref name="source" /> into the current memory stream and advances the current position within this memory stream by the number of bytes written.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="memoryStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ff93e-501">Der Puffer, aus dem Daten geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-501">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="ff93e-502">Der nullbasierte Byteoffset im <paramref name="buffer" />, ab dem Bytes in den aktuellen Stream kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-502">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="ff93e-503">Die maximale Anzahl der zu schreibenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="ff93e-503">The maximum number of bytes to write.</span></span></param>
        <summary><span data-ttu-id="ff93e-504">Schreibt einen Byteblock mit den aus einem Puffer gelesenen Daten in den aktuellen Stream.</span><span class="sxs-lookup"><span data-stu-id="ff93e-504">Writes a block of bytes to the current stream using data read from a buffer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-505">Diese Methode überschreibt <xref:System.IO.Stream.Write%2A>.</span><span class="sxs-lookup"><span data-stu-id="ff93e-505">This method overrides <xref:System.IO.Stream.Write%2A>.</span></span>  
  
 <span data-ttu-id="ff93e-506">Der `offset`-Parameter gibt den Offset des ersten Bytes in `buffer` an, aus dem geschrieben werden soll, und der `count`-Parameter gibt die Anzahl der zu schreibenden Bytes an.</span><span class="sxs-lookup"><span data-stu-id="ff93e-506">The `offset` parameter gives the offset of the first byte in `buffer` to write from, and the `count` parameter gives the number of bytes to write.</span></span> <span data-ttu-id="ff93e-507">Wenn der Schreibvorgang erfolgreich ist, wird die aktuelle Position im Stream um die Anzahl der geschriebenen Bytes erweitert.</span><span class="sxs-lookup"><span data-stu-id="ff93e-507">If the write operation is successful, the current position within the stream is advanced by the number of bytes written.</span></span> <span data-ttu-id="ff93e-508">Wenn eine Ausnahme auftritt, wird die aktuelle Position im Stream unverändert.</span><span class="sxs-lookup"><span data-stu-id="ff93e-508">If an exception occurs, the current position within the stream is unchanged.</span></span>  
  
 <span data-ttu-id="ff93e-509">Mit Ausnahme einer `MemoryStream`, die mit einem Byte []-Parameter erstellt wurde, erweitern Schreibvorgänge am Ende einer `MemoryStream` die `MemoryStream`.</span><span class="sxs-lookup"><span data-stu-id="ff93e-509">Except for a `MemoryStream` constructed with a byte[] parameter, write operations at the end of a `MemoryStream` expand the `MemoryStream`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ff93e-510">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.MemoryStream>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-510">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#3)]
 [!code-csharp[System.IO.MemoryStream#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#3)]
 [!code-vb[System.IO.MemoryStream#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ff93e-511"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-511"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ff93e-512">Der Stream unterstützt das Schreiben nicht.</span><span class="sxs-lookup"><span data-stu-id="ff93e-512">The stream does not support writing.</span></span> <span data-ttu-id="ff93e-513">Weitere Informationen finden Sie unter <see cref="P:System.IO.Stream.CanWrite" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-513">For additional information see <see cref="P:System.IO.Stream.CanWrite" />.</span></span>  
  
<span data-ttu-id="ff93e-514">- oder - </span><span class="sxs-lookup"><span data-stu-id="ff93e-514">-or-</span></span> 
<span data-ttu-id="ff93e-515">Der Abstand der aktuellen Position zum Ende des Streams beträgt weniger als <paramref name="count" /> Bytes, und die Kapazität kann nicht geändert werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-515">The current position is closer than <paramref name="count" /> bytes to the end of the stream, and the capacity cannot be modified.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ff93e-516"><paramref name="offset" /> subtrahiert von der Pufferlänge ist kleiner als <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-516"><paramref name="offset" /> subtracted from the buffer length is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ff93e-517"><paramref name="offset" /> oder <paramref name="count" /> ist negativ.</span><span class="sxs-lookup"><span data-stu-id="ff93e-517"><paramref name="offset" /> or <paramref name="count" /> are negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ff93e-518">Ein E/A-Fehler tritt auf.</span><span class="sxs-lookup"><span data-stu-id="ff93e-518">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ff93e-519">Der aktuelle Instanz des Streams ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-519">The current stream instance is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-520">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-520">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-521">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-521">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-522">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-522">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; source, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="memoryStream.WriteAsync (source, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="ff93e-523">Die Region im Arbeitsspeicher, aus der die Daten für das Schreiben gelesen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-523">The region of memory to write data from.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="ff93e-524">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-524">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="ff93e-525">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />sein.</span><span class="sxs-lookup"><span data-stu-id="ff93e-525">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="ff93e-526">Schreibt die Bytesequenz, die in <paramref name="source" /> enthalten ist, in den aktuellen Speicherdatenstrom, erhöht die aktuelle Position im Speicherdatenstrom um die Anzahl geschriebener Bytes und überwacht Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-526">Asynchronously writes the sequence of bytes contained in <paramref name="source" /> into the current memory stream, advances the current position within this memory stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="ff93e-527">Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-527">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="memoryStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="ff93e-528">Der Puffer, aus dem Daten geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-528">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="ff93e-529">Der nullbasierte Byteoffset im <paramref name="buffer" />, ab dem Bytes in den Stream kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-529">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="ff93e-530">Die maximale Anzahl der zu schreibenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="ff93e-530">The maximum number of bytes to write.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="ff93e-531">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-531">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="ff93e-532">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />sein.</span><span class="sxs-lookup"><span data-stu-id="ff93e-532">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="ff93e-533">Schreibt beim Überschreiben in einer abgeleiteten Klasse eine Folge von Bytes asynchron in den aktuellen Stream und erhöht die aktuelle Position im Stream um die Anzahl der geschriebenen Bytes und überwacht Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-533">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="ff93e-534">Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="ff93e-534">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-535">Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die zurückgegebene Aufgabe den <xref:System.Threading.Tasks.TaskStatus.Canceled> Wert für die <xref:System.Threading.Tasks.Task.Status%2A>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="ff93e-535">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="ff93e-536">Sie können ein Abbruch Token erstellen, indem Sie eine Instanz der <xref:System.Threading.CancellationTokenSource>-Klasse erstellen und die <xref:System.Threading.CancellationTokenSource.Token%2A>-Eigenschaft als `cancellationToken`-Parameter übergeben.</span><span class="sxs-lookup"><span data-stu-id="ff93e-536">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ff93e-537"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-537"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ff93e-538"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="ff93e-538"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ff93e-539">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Pufferlänge.</span><span class="sxs-lookup"><span data-stu-id="ff93e-539">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ff93e-540">Der Stream unterstützt das Schreiben nicht.</span><span class="sxs-lookup"><span data-stu-id="ff93e-540">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ff93e-541">Der Stream wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-541">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ff93e-542">Der Stream wird zurzeit von einem vorherigen Schreibvorgang verwendet.</span><span class="sxs-lookup"><span data-stu-id="ff93e-542">The stream is currently in use by a previous write operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="memoryStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="ff93e-543">Das zu schreibende Byte.</span><span class="sxs-lookup"><span data-stu-id="ff93e-543">The byte to write.</span></span></param>
        <summary><span data-ttu-id="ff93e-544">Schreibt ein Byte an die aktuelle Position im aktuellen Stream.</span><span class="sxs-lookup"><span data-stu-id="ff93e-544">Writes a byte to the current stream at the current position.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-545">Diese Methode überschreibt <xref:System.IO.Stream.WriteByte%2A>.</span><span class="sxs-lookup"><span data-stu-id="ff93e-545">This method overrides <xref:System.IO.Stream.WriteByte%2A>.</span></span>  
  
 <span data-ttu-id="ff93e-546">Mit Ausnahme einer `MemoryStream`, die mit einem Byte []-Parameter erstellt wurde, erweitern Schreibvorgänge am Ende einer `MemoryStream` die `MemoryStream`.</span><span class="sxs-lookup"><span data-stu-id="ff93e-546">Except for a `MemoryStream` constructed with a byte[] parameter, write operations at the end of a `MemoryStream` expand the `MemoryStream`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ff93e-547">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.MemoryStream>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="ff93e-547">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#4)]
 [!code-csharp[System.IO.MemoryStream#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#4)]
 [!code-vb[System.IO.MemoryStream#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ff93e-548">Der Stream unterstützt das Schreiben nicht.</span><span class="sxs-lookup"><span data-stu-id="ff93e-548">The stream does not support writing.</span></span> <span data-ttu-id="ff93e-549">Weitere Informationen finden Sie unter <see cref="P:System.IO.Stream.CanWrite" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-549">For additional information see <see cref="P:System.IO.Stream.CanWrite" />.</span></span>  
  
<span data-ttu-id="ff93e-550">- oder - </span><span class="sxs-lookup"><span data-stu-id="ff93e-550">-or-</span></span> 
<span data-ttu-id="ff93e-551">Die aktuelle Position befindet sich am Ende des Streams, und die Kapazität kann nicht geändert werden.</span><span class="sxs-lookup"><span data-stu-id="ff93e-551">The current position is at the end of the stream, and the capacity cannot be modified.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ff93e-552">Der aktuelle Stream wird geschlossen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-552">The current stream is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-553">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-553">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-554">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-554">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-555">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-555">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public virtual void WriteTo (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteTo(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteTo(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="abstract member WriteTo : System.IO.Stream -&gt; unit&#xA;override this.WriteTo : System.IO.Stream -&gt; unit" Usage="memoryStream.WriteTo stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="ff93e-556">Der Stream, in den dieser Arbeitsspeicherstream geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="ff93e-556">The stream to write this memory stream to.</span></span></param>
        <summary><span data-ttu-id="ff93e-557">Schreibt den gesamten Inhalt dieses Arbeitsspeicherstreams in einen anderen Stream.</span><span class="sxs-lookup"><span data-stu-id="ff93e-557">Writes the entire contents of this memory stream to another stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ff93e-558">Wenn der aktuelle Stream geöffnet ist, entspricht diese Methode dem Aufrufen von <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> im zugrunde liegenden Puffer dieses Streams.</span><span class="sxs-lookup"><span data-stu-id="ff93e-558">When the current stream is open, this method is equivalent to calling <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> on the underlying buffer of this stream.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ff93e-559"><paramref name="stream" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ff93e-559"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ff93e-560">Der aktuelle Stream oder der Zielstream ist geschlossen.</span><span class="sxs-lookup"><span data-stu-id="ff93e-560">The current or target stream is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="ff93e-561">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="ff93e-561">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="ff93e-562">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="ff93e-562">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="ff93e-563">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="ff93e-563">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
