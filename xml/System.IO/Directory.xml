<Type Name="Directory" FullName="System.IO.Directory">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3bbea36b17f443851517ccfbeca4383a06386061" /><Meta Name="ms.sourcegitcommit" Value="47aee60cbc5001a16d5b9cdd0500df890fb1cdec" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/26/2019" /><Meta Name="ms.locfileid" Value="74529837" /></Metadata><TypeSignature Language="C#" Value="public static class Directory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Directory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Directory" />
  <TypeSignature Language="VB.NET" Value="Public Class Directory" />
  <TypeSignature Language="C++ CLI" Value="public ref class Directory abstract sealed" />
  <TypeSignature Language="F#" Value="type Directory = class" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Macht statische Methoden zum Erstellen, Verschieben und Auflisten in Verzeichnissen und Unterverzeichnissen verfügbar. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.IO.Directory>-Klasse für typische Vorgänge wie das Kopieren, verschieben, umbenennen, erstellen und Löschen von Verzeichnissen.  
  
-   Verwenden Sie zum Erstellen eines Verzeichnisses eine der <xref:System.IO.Directory.CreateDirectory%2A> Methoden.  
  
-   Verwenden Sie zum Löschen eines Verzeichnisses eine der <xref:System.IO.Directory.Delete%2A> Methoden.  
  
-   Um das aktuelle Verzeichnis für eine APP zu erhalten oder festzulegen, verwenden Sie die Methode <xref:System.IO.Directory.GetCurrentDirectory%2A> oder <xref:System.IO.Directory.SetCurrentDirectory%2A>.  
  
-   Verwenden Sie Methoden wie <xref:System.IO.Directory.SetLastAccessTime%2A> und <xref:System.IO.Directory.SetCreationTime%2A>, um <xref:System.DateTime> Informationen im Zusammenhang mit dem Erstellen, zugreifen und Schreiben eines Verzeichnisses zu bearbeiten.  
  
 Die statischen Methoden der <xref:System.IO.Directory>-Klasse führen Sicherheitsüberprüfungen für alle Methoden aus. Wenn Sie ein Objekt mehrmals wieder verwenden möchten, sollten Sie stattdessen die entsprechende Instanzmethode von <xref:System.IO.DirectoryInfo> verwenden, da die Sicherheitsüberprüfung nicht immer erforderlich ist.  
  
 Wenn Sie nur eine Verzeichnis bezogene Aktion ausführen, ist es möglicherweise effizienter, eine statische <xref:System.IO.Directory> Methode anstelle einer entsprechenden <xref:System.IO.DirectoryInfo> Instanzmethode zu verwenden. Die meisten <xref:System.IO.Directory> Methoden benötigen den Pfad zu dem Verzeichnis, das Sie bearbeiten.  
  
> [!NOTE]
>  In Membern, die eine Zeichenfolge `path` Parameter akzeptieren, muss dieser Pfad wohl geformt sein, oder es wird eine Ausnahme ausgelöst. Wenn ein Pfad z. b. voll qualifiziert ist, aber mit einem Leerzeichen ("c:\temp") beginnt, wird die Pfad Zeichenfolge nicht gekürzt, sodass der Pfad als falsch formatiert angesehen wird und eine Ausnahme ausgelöst wird. Außerdem kann ein Pfad oder eine Kombination von Pfaden nicht zweimal voll qualifiziert werden. Beispielsweise löst "c:\temp c:\Windows" auch eine Ausnahme aus. Stellen Sie sicher, dass die Pfade wohl geformt sind, wenn Sie Methoden verwenden, die eine Pfad Zeichenfolge akzeptieren. Weitere Informationen finden Sie unter <xref:System.IO.Path>.  
  
 In Membern, die einen Pfad akzeptieren, kann der Pfad auf eine Datei oder ein Verzeichnis verweisen. Sie können einen vollständigen Pfad, einen relativen Pfad oder einen Universal Naming Convention Pfad (UNC-Pfad) für einen Server-und einen Freigabe Namen verwenden. Die folgenden Pfade sind beispielsweise zulässig:  
  
-   "c:\\\meinedir" C#in, oder "c:\meinedir" in Visual Basic.  
  
-   "Mydir\\\meinsubdir" in C#, oder "mydir\meinsubdir" in Visual Basic.  
  
-   "\\\\\\\meinserver\meineserver\\C#\meinefreigabe" in, oder "\\\meinserver\meinefreigabe" in Visual Basic.  
  
 Standardmäßig wird allen Benutzern der vollständige Lese-/Schreibzugriff auf neue Verzeichnisse gewährt. Allerdings muss die APP über die richtige Sicherheit für den Zugriff auf vorhandene Verzeichnisse verfügen.  
  
 Um Berechtigungen für ein Verzeichnis und alle zugehörigen Unterverzeichnisse zu fordern, beenden Sie die Pfad Zeichenfolge mit dem Verzeichnis Trennzeichen. ("C:\temp\\" gewährt z. b. Zugriff auf "c:\temp\" und alle zugehörigen Unterverzeichnisse.) Um nur Berechtigungen für ein bestimmtes Verzeichnis zu fordern, beenden Sie die Pfad Zeichenfolge mit einem bestimmten Zeitraum. (Z. b. "c:\temp\\". gewährt nur Zugriff auf c:\temp-\\, nicht auf seine Unterverzeichnisse.)  
  
 In Membern, die einen `searchPattern` Parameter akzeptieren, kann die Such Zeichenfolge eine beliebige Kombination aus Literalzeichen und zwei Platzhalter Zeichen sein. \* und?. Dieser Parameter erkennt keine regulären Ausdrücke. Weitere Informationen finden Sie unter der <xref:System.IO.Directory.EnumerateDirectories%28System.String%2CSystem.String%29>-Methode oder einer anderen Methode, die den `searchPattern`-Parameter verwendet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
 <xref:System.IO.Directory> und <xref:System.IO.DirectoryInfo> werden für die Verwendung in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]-apps nicht unterstützt. Informationen zum Zugreifen auf Dateien und Ordner in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]-apps finden Sie unter [zugreifen auf Daten und Dateien (Windows Store-Apps)](https://msdn.microsoft.com/library/windows/apps/hh758319.aspx).  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie alle Textdateien aus einem Verzeichnis abrufen und in ein neues Verzeichnis verschieben. Nachdem die Dateien verschoben wurden, sind Sie nicht mehr im ursprünglichen Verzeichnis vorhanden.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.IO.Directory.EnumerateFiles%2A>-Methode verwendet wird, um eine Auflistung von Textdateien aus einem Verzeichnis abzurufen. Anschließend wird diese Auflistung in einer Abfrage verwendet, um alle Zeilen zu suchen, die "example" enthalten.  
  
 [!code-csharp[System.IO.Directory#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class3.cs#11)]
 [!code-vb[System.IO.Directory#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class3.vb#11)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie ein Verzeichnis und alle zugehörigen Dateien in ein neues Verzeichnis verschoben werden. Das ursprüngliche Verzeichnis ist nicht mehr vorhanden, nachdem es verschoben wurde.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.DriveInfo" />
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.DirectoryInfo" />
    <altmember cref="T:System.IO.FileInfo" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Gewusst wie: Lesen und Schreiben einer neu erstellten Datendatei</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateDirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt alle Verzeichnisse in einem angegebenen Pfad.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.CreateDirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Das zu erstellende Verzeichnis.</param>
        <summary>Erstellt alle Verzeichnisse und Unterverzeichnisse im angegebenen Pfad, es sei denn, sie sind bereits vorhanden.</summary>
        <returns>Ein Objekt, das das Verzeichnis im angegebenen Pfad darstellt. Dieses Objekt wird unabhängig davon zurückgegeben, ob ein Verzeichnis unter dem angegebenen Pfad bereits vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle in `path` angegebenen Verzeichnisse werden erstellt, es sei denn, Sie sind bereits vorhanden, oder ein Teil der `path` ist ungültig. Wenn das Verzeichnis bereits vorhanden ist, erstellt diese Methode kein neues Verzeichnis, sondern gibt ein <xref:System.IO.DirectoryInfo> Objekt für das vorhandene Verzeichnis zurück.  
  
 Der `path`-Parameter gibt einen Verzeichnispfad und keinen Dateipfad an.  
  
 Nachfolgende Leerzeichen werden am Ende des `path`-Parameters vor dem Erstellen des Verzeichnisses entfernt.  
  
 Sie können ein Verzeichnis auf einem Remote Computer auf einer Freigabe erstellen, für die Sie über Schreibzugriff verfügen. UNC-Pfade werden unterstützt. Beispielsweise können Sie Folgendes für `path`angeben: `\\2009\Archives\December` in Visual Basic und `\\\\2009\\Archives\\December` in C#.  
  
 Erstellen eines Verzeichnisses, das nur das Doppelpunkt Zeichen (:) wird nicht unterstützt und bewirkt, dass eine `NotSupportedException` ausgelöst wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das angegebene Verzeichnis erstellt und gelöscht.  
  
 [!code-cpp[Dir_CreateDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_CreateDir/CPP/dir_createdir.cpp#1)]
 [!code-csharp[Dir_CreateDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_CreateDir/CS/dir_createdir.cs#1)]
 [!code-vb[Dir_CreateDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_CreateDir/VB/dir_createdir.vb#1)]  
  
 Um das Verzeichnis c:\Users\User1\Public\Html zu erstellen, wenn das aktuelle Verzeichnis c:\Users\User1 ist, verwenden Sie einen der folgenden Aufrufe, um sicherzustellen, dass der umgekehrte Schrägstrich ordnungsgemäß interpretiert wird.  
  
 In Visual Basic  
  
```  
Directory.CreateDirectory("Public\Html")   
    Directory.CreateDirectory("\Users\User1\Public\Html")   
    Directory.CreateDirectory("c:\Users\User1\Public\Html")  
```  
  
 In C#:  
  
```  
Directory.CreateDirectory("Public\\Html");  
    Directory.CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory.CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 In C++:  
  
```  
Directory::CreateDirectory("Public\\Html");  
    Directory::CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory::CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Das durch <paramref name="path" /> angegebene Verzeichnis ist eine Datei.  
  
- oder - 
Der Netzwerkname ist nicht bekannt.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
- oder - 
 <paramref name="path" /> ist ein Doppelpunkt (:) vorangestellt bzw. enthält nur einen Doppelpunkt.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> enthält einen Doppelpunkt (:), der nicht Teil einer Laufwerksbezeichnung ist („C:\\“).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen und Schreiben von Dateien oder Verzeichnissen. Zugehörige Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /><see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string * System.Security.AccessControl.DirectorySecurity -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.CreateDirectory (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Das zu erstellende Verzeichnis.</param>
        <param name="directorySecurity">Die Zugriffssteuerung, die auf das Verzeichnis angewendet werden soll.</param>
        <summary>Erstellt alle Verzeichnisse im angegebenen Pfad, sofern diese nicht bereits vorhanden sind. Dabei wird die angegebene Windows-Sicherheit angewendet.</summary>
        <returns>Ein Objekt, das das Verzeichnis im angegebenen Pfad darstellt. Dieses Objekt wird unabhängig davon zurückgegeben, ob ein Verzeichnis unter dem angegebenen Pfad bereits vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methoden Überladung, um ein Verzeichnis mit Zugriffs Steuerung zu erstellen. Daher besteht keine Chance, dass auf das Verzeichnis zugegriffen werden kann, bevor die Sicherheit angewendet wird.  
  
 Alle Verzeichnisse, die im `path`-Parameter angegeben sind, werden erstellt, es sei denn, Sie sind bereits vorhanden, oder es sei denn, ein Teil `path` ist ungültig. Der `path`-Parameter gibt einen Verzeichnispfad und keinen Dateipfad an. Wenn das Verzeichnis bereits vorhanden ist, erstellt diese Methode kein neues Verzeichnis, sondern gibt ein <xref:System.IO.DirectoryInfo> Objekt für das vorhandene Verzeichnis zurück.  
  
 Nachfolgende Leerzeichen werden am Ende des `path`-Parameters vor dem Erstellen des Verzeichnisses entfernt.  
  
 Sie können ein Verzeichnis auf einem Remote Computer auf einer Freigabe erstellen, für die Sie über Schreibzugriff verfügen. UNC-Pfade werden unterstützt. Beispielsweise können Sie Folgendes für `path`angeben: `\\2009\Archives\December` in Visual Basic und `\\\\2009\\Archives\\December` in C#.  
  
 Erstellen eines Verzeichnisses, das nur das Doppelpunkt Zeichen (:) wird nicht unterstützt und bewirkt, dass eine `NotSupportedException` ausgelöst wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein neues Verzeichnis mit Zugriffsregeln für zwei Benutzerkonten erstellt.  
  
 [!code-csharp[System.IO.Directory#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class7.cs#15)]
 [!code-vb[System.IO.Directory#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class7.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Das durch <paramref name="path" /> angegebene Verzeichnis ist eine Datei.  
  
- oder - 
Der Netzwerkname ist nicht bekannt.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
- oder - 
 <paramref name="path" /> ist ein Doppelpunkt (:) vorangestellt bzw. enthält nur einen Doppelpunkt.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> enthält einen Doppelpunkt (:), der nicht Teil einer Laufwerksbezeichnung ist („C:\\“).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen und Schreiben von Dateien und Verzeichnissen und für den Zugriff auf das Zielverzeichnis. Zugehörige Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /><see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht ein angegebenes Verzeichnis und optional alle Unterverzeichnisse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Directory.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Name des zu entfernenden leeren Verzeichnisses. Dieses Verzeichnis muss schreibbar und leer sein.</param>
        <summary>Löscht ein leeres Verzeichnis aus einem angegebenen Pfad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verhält sich identisch mit <xref:System.IO.Directory.Delete%28System.String%2CSystem.Boolean%29>, wobei `false` für den zweiten Parameter angegeben wird.  
  
 Der `path`-Parameter kann relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Nachfolgende Leerzeichen werden am Ende des `path`-Parameters entfernt, bevor das Verzeichnis gelöscht wird.  
  
 Diese Methode löst eine <xref:System.IO.IOException> aus, wenn das im `path`-Parameter angegebene Verzeichnis Dateien oder Unterverzeichnisse enthält.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
 Wenn das angegebene Verzeichnis im Datei-Explorer geöffnet ist, kann es in einigen Fällen von der <xref:System.IO.Directory.Delete%2A>-Methode nicht gelöscht werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie ein neues Verzeichnis und ein neues Unterverzeichnis erstellen und dann nur das Unterverzeichnis löschen.  
  
 [!code-csharp[System.IO.Directory.Delete#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class1.cs#1)]
 [!code-vb[System.IO.Directory.Delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Es gibt eine Datei, die denselben Namen und Speicherort hat wie in <paramref name="path" /> angegeben.  
  
- oder - 
Das Verzeichnis ist das aktuelle Arbeitsverzeichnis der Anwendung.  
  
- oder - 
Das durch <paramref name="path" /> angegebene Verzeichnis ist nicht leer.  
  
- oder - 
Das Verzeichnis ist schreibgeschützt oder enthält eine schreibgeschützte Datei.  
  
- oder - 
Das Verzeichnis wird von einem anderen Prozess verwendet.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> ist nicht vorhanden oder wurde nicht gefunden.  
  
- oder - 
Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in das angegebene Verzeichnis. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path, bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path, bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String, recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path, bool recursive);" />
      <MemberSignature Language="F#" Value="static member Delete : string * bool -&gt; unit" Usage="System.IO.Directory.Delete (path, recursive)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der Name des zu entfernenden Verzeichnisses.</param>
        <param name="recursive"><see langword="true" /> zum Entfernen von Verzeichnissen, Unterverzeichnissen und Dateien in <paramref name="path" />, andernfalls <see langword="false" />.</param>
        <summary>Löscht das angegebene Verzeichnis und, sofern angegeben, alle Unterverzeichnisse und Dateien im Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `path`-Parameter kann relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Nachfolgende Leerzeichen werden am Ende des `path`-Parameters entfernt, bevor das Verzeichnis gelöscht wird.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
 Wenn der `recursive`-Parameter `true`ist, muss der Benutzer über die Schreib Berechtigung für das aktuelle Verzeichnis sowie für alle Unterverzeichnisse verfügen.  
  
 Das Verhalten dieser Methode unterscheidet sich geringfügig, wenn ein Verzeichnis gelöscht wird, das einen Analyse Punkt enthält, z. b. eine symbolische Verknüpfung oder einen Einfügepunkt. Wenn der Analyse Punkt ein Verzeichnis ist, z. b. ein Einstellungspunkt, wird die Bereitstellung aufgehoben und der Einstellungspunkt gelöscht. Diese Methode wird nicht durch den Analyse Punkt rekursiert. Wenn der Analyse Punkt ein symbolischer Link zu einer Datei ist, wird der Analyse Punkt und nicht das Ziel der symbolischen Verknüpfung gelöscht.  
  
 Wenn das angegebene Verzeichnis im Datei-Explorer geöffnet ist, kann es in einigen Fällen von der <xref:System.IO.Directory.Delete%2A>-Methode nicht gelöscht werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein neues Verzeichnis, ein Unterverzeichnis und eine Datei im Unterverzeichnis erstellt und anschließend alle neuen Elemente rekursiv gelöscht werden.  
  
 [!code-csharp[System.IO.Directory.Delete#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class2.cs#2)]
 [!code-vb[System.IO.Directory.Delete#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Es gibt eine Datei, die denselben Namen und Speicherort hat wie in <paramref name="path" /> angegeben.  
  
- oder - 
Das von <paramref name="path" /> angegebene Verzeichnis ist schreibgeschützt, oder <paramref name="recursive" /> ist <see langword="false" />, und <paramref name="path" /> ist kein leeres Verzeichnis.  
  
- oder - 
Das Verzeichnis ist das aktuelle Arbeitsverzeichnis der Anwendung.  
  
- oder - 
Das Verzeichnis enthält eine schreibgeschützte Datei.  
  
- oder - 
Das Verzeichnis wird von einem anderen Prozess verwendet.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> ist nicht vorhanden oder wurde nicht gefunden.  
  
- oder - 
Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in das angegebene Verzeichnis. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine aufzählbare Sammlung von vollständigen Verzeichnisnamen zurück, die bestimmte Kriterien erfüllen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Gibt eine aufzählbare Sammlung von vollständigen Verzeichnisnamen in einem angegebenen Pfad zurück.</summary>
        <returns>Eine aufzählbare Auflistung der vollständigen Namen (einschließlich Pfade) für die Verzeichnisse im Verzeichnis, das von <paramref name="path" /> angegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können relative oder absolute Pfadinformationen im `path`-Parameter angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert, das Sie mithilfe der <xref:System.IO.Directory.GetCurrentDirectory%2A>-Methode ermitteln können. Die zurückgegebenen Verzeichnisnamen haben den Wert, den Sie im `path`-Parameter angegeben haben, als Präfix. Wenn Sie z. b. einen relativen Pfad im `path`-Parameter angeben, enthalten die zurückgegebenen Verzeichnisnamen einen relativen Pfad.  
  
 Die Methoden <xref:System.IO.Directory.EnumerateDirectories%2A> und <xref:System.IO.Directory.GetDirectories%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateDirectories%2A>verwenden, können Sie damit beginnen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetDirectories%2A>verwenden, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateDirectories%2A> effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> in der Auflistung startet eine neue-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Verzeichnisse der obersten Ebene in einem angegebenen Pfad aufgelistet.  
  
 [!code-csharp[System.IO.EnumDirs1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs1/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs1/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Verzeichnissen in <paramref name="path" /> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <summary>Gibt eine aufzählbare Sammlung von vollständigen Verzeichnisnamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen.</summary>
        <returns>Eine aufzählbare Auflistung der vollständigen Namen (einschließlich Pfade) für die Verzeichnisse im Verzeichnis, das von <paramref name="path" /> angegebenen wird und der angegebene Suchmuster entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Namen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 `searchPattern` darf nicht mit zwei Punkten ("..") enden oder zwei Punkte ("..") enthalten, auf die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>folgt und keine ungültigen Zeichen enthalten kann. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Sie können relative oder absolute Pfadinformationen im `path`-Parameter angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert, das Sie mithilfe der <xref:System.IO.Directory.GetCurrentDirectory%2A>-Methode ermitteln können. Die zurückgegebenen Verzeichnisnamen haben den Wert, den Sie im `path`-Parameter angegeben haben, als Präfix. Wenn Sie z. b. einen relativen Pfad im `path`-Parameter angeben, enthalten die zurückgegebenen Verzeichnisnamen einen relativen Pfad.  
  
 Die Methoden <xref:System.IO.Directory.EnumerateDirectories%2A> und <xref:System.IO.Directory.GetDirectories%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateDirectories%2A>verwenden, können Sie damit beginnen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetDirectories%2A>verwenden, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateDirectories%2A> effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> in der Auflistung startet eine neue-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Verzeichnisse der obersten Ebene in einem angegebenen Pfad aufgelistet, die einem angegebenen Suchmuster entsprechen.  
  
 [!code-csharp[System.IO.EnumDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs2/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs2/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
- oder - 
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Verzeichnissen in <paramref name="path" /> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="enumerationOptions">Ein Objekt, das die zu verwendende Such- und Enumerationskonfiguration beschreibt.</param>
        <summary>Gibt eine aufzählbare Sammlung der vollständigen Verzeichnisnamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen. Optional werden Unterverzeichnisse durchsucht.</summary>
        <returns>Eine aufzählbare Auflistung der vollständigen Namen (einschließlich Pfade) für die Verzeichnisse im Verzeichnis, die von <paramref name="path" /> angegebenen werden und dem angegebenen Suchmuster und den angegebenen Enumerationsoptionen entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.

|Platzhalter Bezeichner|Übereinstimmungen|
|------------------------|-------------|
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|
|? (Fragezeichen)|Genau ein Zeichen an dieser Position.|

 Andere Zeichen als der Platzhalter sind Literalzeichen. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Namen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".

 `searchPattern` darf nicht mit zwei Punkten ("..") enden oder zwei Punkte ("..") enthalten, auf die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>folgt und keine ungültigen Zeichen enthalten kann. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.

 Sie können relative oder absolute Pfadinformationen im `path`-Parameter angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert, das Sie mithilfe der <xref:System.IO.Directory.GetCurrentDirectory%2A>-Methode ermitteln können. Die zurückgegebenen Verzeichnisnamen haben den Wert, den Sie im `path`-Parameter angegeben haben, als Präfix. Wenn Sie z. b. einen relativen Pfad im `path`-Parameter angeben, enthalten die zurückgegebenen Verzeichnisnamen einen relativen Pfad.

 Die Methoden <xref:System.IO.Directory.EnumerateDirectories%2A> und <xref:System.IO.Directory.GetDirectories%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateDirectories%2A>verwenden, können Sie damit beginnen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetDirectories%2A>verwenden, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateDirectories%2A> effizienter sein.

 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> in der Auflistung startet eine neue-Enumeration.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
- oder - 
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> oder <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Verzeichnissen in <paramref name="path" /> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen. Der Standardwert ist <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />sein.</param>
        <summary>Gibt eine aufzählbare Sammlung von vollständigen Verzeichnisnamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen. Optional werden Unterverzeichnisse durchsucht.</summary>
        <returns>Eine aufzählbare Auflistung der vollständigen Namen (einschließlich Pfade) für die Verzeichnisse im Verzeichnis, die von <paramref name="path" /> angegebenen werden und dem angegebenen Suchmuster und der angegebenen Suchoptionen entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|Genau ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Namen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 `searchPattern` darf nicht mit zwei Punkten ("..") enden oder zwei Punkte ("..") enthalten, auf die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>folgt und keine ungültigen Zeichen enthalten kann. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Sie können relative oder absolute Pfadinformationen im `path`-Parameter angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert, das Sie mithilfe der <xref:System.IO.Directory.GetCurrentDirectory%2A>-Methode ermitteln können. Die zurückgegebenen Verzeichnisnamen haben den Wert, den Sie im `path`-Parameter angegeben haben, als Präfix. Wenn Sie z. b. einen relativen Pfad im `path`-Parameter angeben, enthalten die zurückgegebenen Verzeichnisnamen einen relativen Pfad.  
  
 Die Methoden <xref:System.IO.Directory.EnumerateDirectories%2A> und <xref:System.IO.Directory.GetDirectories%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateDirectories%2A>verwenden, können Sie damit beginnen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetDirectories%2A>verwenden, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateDirectories%2A> effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> in der Auflistung startet eine neue-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel werden Verzeichnisse in einem angegebenen Pfad aufgelistet, die einem angegebenen Suchmuster entsprechen. Er verwendet den `searchOption`-Parameter, um anzugeben, dass alle Unterverzeichnisse in die Suche eingeschlossen werden sollen.  
  
 [!code-csharp[System.IO.EnumDirs3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs3/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs3/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
- oder - 
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine aufzählbare Sammlung von vollständigen Dateinamen zurück, die bestimmte Kriterien erfüllen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Gibt eine aufzählbare Sammlung von vollständigen Dateinamen in einem angegebenen Pfad zurück.</summary>
        <returns>Eine aufzählbare Auflistung der vollständigen Namen (einschließlich Pfade) für die Verzeichnisse im Verzeichnis, das von <paramref name="path" /> angegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können relative Pfadinformationen mit dem `path`-Parameter angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert, das Sie mithilfe der <xref:System.IO.Directory.GetCurrentDirectory%2A>-Methode ermitteln können.  
  
 Die Methoden <xref:System.IO.Directory.EnumerateFiles%2A> und <xref:System.IO.Directory.GetFiles%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateFiles%2A>verwenden, können Sie damit beginnen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateFiles%2A> effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> in der Auflistung startet eine neue-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie alle Dateien in einem Verzeichnis abgerufen und in ein neues Verzeichnis verschoben werden. Nachdem die Dateien verschoben wurden, sind Sie nicht mehr im ursprünglichen Verzeichnis vorhanden.  
  
 [!code-csharp[System.IO.Directory#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class4.cs#12)]
 [!code-vb[System.IO.Directory#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class4.vb#12)]  
  
 Im folgenden Beispiel werden die Dateien im angegebenen Verzeichnis aufgelistet, jede Zeile der Datei gelesen und die Zeile angezeigt, wenn Sie die Zeichenfolge "Europe" enthält.  
  
 [!code-csharp[System.IO.Directory.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien in <paramref name="path" /> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <summary>Gibt eine aufzählbare Sammlung von vollständigen Dateinamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen.</summary>
        <returns>Eine aufzählbare Auflistung der vollständigen Namen (einschließlich Pfade) für die Dateien im Verzeichnis, das von <paramref name="path" /> angegebenen wird und dem angegebenen Suchmuster entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Namen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
> [!NOTE]
>  Wenn Sie das Platzhalter Zeichen Sternchen in einem `searchPattern` wie z. b. "\*. txt" verwenden, wirkt sich die Anzahl der Zeichen in der angegebenen Erweiterung wie folgt auf die Suche aus:  
>   
> -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, gibt die Methode Dateien mit Erweiterungen zurück, die mit der angegebenen Erweiterung beginnen. Beispielsweise gibt "\*. xls" sowohl "Book. xls" als auch "Book. xlsx" zurück.  
> -   In allen anderen Fällen gibt die-Methode Dateien zurück, die exakt mit der angegebenen Erweiterung übereinstimmen. "\*. ai" gibt z. b. "file.ai", jedoch nicht "file. AIF" zurück.  
>   
>  Wenn Sie das Fragezeichen-Platzhalter Zeichen verwenden, gibt diese Methode nur die Dateien zurück, die der angegebenen Dateierweiterung entsprechen. Angenommen, die beiden Dateien "file1. txt" und "file1. txtother" in einem Verzeichnis haben das Suchmuster "file?". txt "gibt nur die erste Datei zurück, während das Suchmuster" File\*. txt "beide Dateien zurückgibt.  
  
 `searchPattern` darf nicht mit zwei Punkten ("..") enden oder zwei Punkte ("..") enthalten, auf die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>folgt und keine ungültigen Zeichen enthalten kann. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Sie können relative Pfadinformationen mit dem `path`-Parameter angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert, das Sie mithilfe der <xref:System.IO.Directory.GetCurrentDirectory%2A>-Methode ermitteln können.  
  
 Die Methoden <xref:System.IO.Directory.EnumerateFiles%2A> und <xref:System.IO.Directory.GetFiles%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateFiles%2A>verwenden, können Sie damit beginnen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateFiles%2A> effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> in der Auflistung startet eine neue-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie alle Textdateien in einem Verzeichnis abgerufen und in ein neues Verzeichnis verschoben werden. Nachdem die Dateien verschoben wurden, sind Sie nicht mehr im ursprünglichen Verzeichnis vorhanden.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 Im folgenden Beispiel werden die Dateien im angegebenen Verzeichnis aufgelistet, die über die Erweiterung ". txt" verfügen. jede Zeile der Datei wird gelesen, und die Zeile wird angezeigt, wenn Sie die Zeichenfolge "Europe" enthält.  
  
 [!code-csharp[System.IO.Directory.EnumFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles2/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles2/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
- oder - 
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien in <paramref name="path" /> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="enumerationOptions">Ein Objekt, das die zu verwendende Such- und Enumerationskonfiguration beschreibt.</param>
        <summary>Gibt eine aufzählbare Sammlung von vollständigen Dateinamen zurück, die einem Suchmuster und Enumerationsoptionen in einem angegebenen Pfad entsprechen. Optional werden Unterverzeichnisse durchsucht.</summary>
        <returns>Eine aufzählbare Auflistung der vollständigen Namen (einschließlich Pfade) für die Dateien im Verzeichnis, die von <paramref name="path" /> angegebenen werden und dem angegebenen Suchmuster und den angegebenen Enumerationsoptionen entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.

|Platzhalter Bezeichner|Übereinstimmungen|
|------------------------|-------------|
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|

 Andere Zeichen als der Platzhalter sind Literalzeichen. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Namen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".

> [!NOTE]
>  Wenn Sie das Platzhalter Zeichen Sternchen in einem `searchPattern` wie z. b. "\*. txt" verwenden, wirkt sich die Anzahl der Zeichen in der angegebenen Erweiterung wie folgt auf die Suche aus:
> 
> -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, gibt die Methode Dateien mit Erweiterungen zurück, die mit der angegebenen Erweiterung beginnen. Beispielsweise gibt "\*. xls" sowohl "Book. xls" als auch "Book. xlsx" zurück.
> -   In allen anderen Fällen gibt die-Methode Dateien zurück, die exakt mit der angegebenen Erweiterung übereinstimmen. "\*. ai" gibt z. b. "file.ai", jedoch nicht "file. AIF" zurück.
> 
>  Wenn Sie das Fragezeichen-Platzhalter Zeichen verwenden, gibt diese Methode nur die Dateien zurück, die der angegebenen Dateierweiterung entsprechen. Angenommen, die beiden Dateien "file1. txt" und "file1. txtother" in einem Verzeichnis haben das Suchmuster "file?". txt "gibt nur die erste Datei zurück, während das Suchmuster" File\*. txt "beide Dateien zurückgibt.

 `searchPattern` darf nicht mit zwei Punkten ("..") enden oder zwei Punkte ("..") enthalten, auf die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>folgt und keine ungültigen Zeichen enthalten kann. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.

 Sie können relative Pfadinformationen mit dem `path`-Parameter angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert, das Sie mithilfe der <xref:System.IO.Directory.GetCurrentDirectory%2A>-Methode ermitteln können.

 Die Methoden <xref:System.IO.Directory.EnumerateFiles%2A> und <xref:System.IO.Directory.GetFiles%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateFiles%2A>verwenden, können Sie damit beginnen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateFiles%2A> effizienter sein.

 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> in der Auflistung startet eine neue-Enumeration.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
- oder - 
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien in <paramref name="path" /> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen. Der Standardwert ist <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />sein.</param>
        <summary>Gibt eine aufzählbare Sammlung von vollständigen Dateinamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen. Optional werden Unterverzeichnisse durchsucht.</summary>
        <returns>Eine aufzählbare Auflistung der vollständigen Namen (einschließlich Pfade) für die Dateien im Verzeichnis, die von <paramref name="path" /> angegebenen werden und dem angegebenen Suchmuster und der angegebenen Suchoption entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Namen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
> [!NOTE]
>  Wenn Sie das Platzhalter Zeichen Sternchen in einem `searchPattern` wie z. b. "\*. txt" verwenden, wirkt sich die Anzahl der Zeichen in der angegebenen Erweiterung wie folgt auf die Suche aus:  
>   
> -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, gibt die Methode Dateien mit Erweiterungen zurück, die mit der angegebenen Erweiterung beginnen. Beispielsweise gibt "\*. xls" sowohl "Book. xls" als auch "Book. xlsx" zurück.  
> -   In allen anderen Fällen gibt die-Methode Dateien zurück, die exakt mit der angegebenen Erweiterung übereinstimmen. "\*. ai" gibt z. b. "file.ai", jedoch nicht "file. AIF" zurück.  
>   
>  Wenn Sie das Fragezeichen-Platzhalter Zeichen verwenden, gibt diese Methode nur die Dateien zurück, die der angegebenen Dateierweiterung entsprechen. Angenommen, die beiden Dateien "file1. txt" und "file1. txtother" in einem Verzeichnis haben das Suchmuster "file?". txt "gibt nur die erste Datei zurück, während das Suchmuster" File\*. txt "beide Dateien zurückgibt.  
  
 `searchPattern` darf nicht mit zwei Punkten ("..") enden oder zwei Punkte ("..") enthalten, auf die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>folgt und keine ungültigen Zeichen enthalten kann. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Sie können relative Pfadinformationen mit dem `path`-Parameter angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert, das Sie mithilfe der <xref:System.IO.Directory.GetCurrentDirectory%2A>-Methode ermitteln können.  
  
 Die Methoden <xref:System.IO.Directory.EnumerateFiles%2A> und <xref:System.IO.Directory.GetFiles%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateFiles%2A>verwenden, können Sie damit beginnen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateFiles%2A> effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> in der Auflistung startet eine neue-Enumeration.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie alle Textdateien in einem Verzeichnis und seinen Unterverzeichnissen abgerufen und in ein neues Verzeichnis verschoben werden. Nachdem die Dateien verschoben wurden, sind Sie nicht mehr in den ursprünglichen Verzeichnissen vorhanden.  
  
 [!code-csharp[System.IO.Directory#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class5.cs#13)]
 [!code-vb[System.IO.Directory#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class5.vb#13)]  
  
 Im folgenden Beispiel werden rekursiv alle Dateien mit der Erweiterung. txt aufgelistet, jede Zeile der Datei gelesen und die Zeile angezeigt, wenn Sie die Zeichenfolge "Microsoft" enthält.  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
- oder - 
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine aufzählbare Auflistung von Dateisystemeinträgen zurück, die bestimmte Kriterien erfüllen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Gibt eine aufzählbare Auflistung von Dateinamen und Verzeichnisnamen in einem angegebenen Pfad zurück.</summary>
        <returns>Eine aufzählbare Auflistung von Dateisystemeinträgen im von <paramref name="path" /> angegebenen Verzeichnis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können relative Pfadinformationen mit dem `path`-Parameter angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert, das Sie mithilfe der <xref:System.IO.Directory.GetCurrentDirectory%2A>-Methode ermitteln können.

 Die Methoden <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> und <xref:System.IO.Directory.GetFileSystemEntries%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>verwenden, können Sie mit dem Auflisten der Auflistung von Einträgen beginnen, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetFileSystemEntries%2A>verwenden, müssen Sie warten, bis das gesamte Array von Einträgen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateFiles%2A> effizienter sein.

 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> in der Auflistung startet eine neue-Enumeration.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateisystemeinträgen in <paramref name="path" /> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <summary>Gibt eine aufzählbare Auflistung von Dateinamen und Verzeichnisnamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen.</summary>
        <returns>Eine aufzählbare Auflistung von Dateisystemeinträgen, die sich in dem von <paramref name="path" /> angegebenen Verzeichnis befinden und dem angegebenen Suchmuster entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig. 
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Namen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
> [!NOTE]
>  Wenn Sie das Platzhalter Zeichen Sternchen in einem `searchPattern` wie z. b. "\*. txt" verwenden, wirkt sich die Anzahl der Zeichen in der angegebenen Erweiterung wie folgt auf die Suche aus:  
>   
> -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, gibt die Methode Dateien mit Erweiterungen zurück, die mit der angegebenen Erweiterung beginnen. Beispielsweise gibt "\*. xls" sowohl "Book. xls" als auch "Book. xlsx" zurück.  
> -   In allen anderen Fällen gibt die-Methode Dateien zurück, die exakt mit der angegebenen Erweiterung übereinstimmen. "\*. ai" gibt z. b. "file.ai", jedoch nicht "file. AIF" zurück.  
>   
>  Wenn Sie das Fragezeichen-Platzhalter Zeichen verwenden, gibt diese Methode nur die Dateien zurück, die der angegebenen Dateierweiterung entsprechen. Angenommen, die beiden Dateien "file1. txt" und "file1. txtother" in einem Verzeichnis haben das Suchmuster "file?". txt "gibt nur die erste Datei zurück, während das Suchmuster" File\*. txt "beide Dateien zurückgibt.  
  
 `searchPattern` darf nicht mit zwei Punkten ("..") enden oder zwei Punkte ("..") enthalten, auf die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>folgt und keine ungültigen Zeichen enthalten kann. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Sie können relative Pfadinformationen mit dem `path`-Parameter angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert, das Sie mithilfe der <xref:System.IO.Directory.GetCurrentDirectory%2A>-Methode ermitteln können.  
  
 Die Methoden <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> und <xref:System.IO.Directory.GetFileSystemEntries%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>verwenden, können Sie mit dem Auflisten der Auflistung von Einträgen beginnen, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetFileSystemEntries%2A>verwenden, müssen Sie warten, bis das gesamte Array von Einträgen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateFiles%2A> effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> in der Auflistung startet eine neue-Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
- oder - 
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Unterverzeichnissen in <paramref name="path" /> auf Übereinstimmungen. Dieser Parameter kann eine Kombination aus gültigen Literal- und Platzhalterzeichen enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="enumerationOptions">Ein Objekt, das die zu verwendende Such- und Enumerationskonfiguration beschreibt.</param>
        <summary>Gibt eine aufzählbare Auflistung von Dateinamen und Verzeichnisnamen zurück, die einem Suchmuster und Enumerationsoptionen in einem angegebenen Pfad entsprechen.</summary>
        <returns>Eine aufzählbare Auflistung von Dateisystemeinträgen, die sich in dem von <paramref name="path" /> angegebenen Verzeichnis befinden und dem angegebenen Suchmuster und den angegebenen Enumerationsoptionen entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.

|Platzhalter Bezeichner|Übereinstimmungen|
|------------------------|-------------|
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|

 Andere Zeichen als der Platzhalter sind Literalzeichen. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Namen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".

> [!NOTE]
>  Wenn Sie das Platzhalter Zeichen Sternchen in einem `searchPattern` wie z. b. "\*. txt" verwenden, wirkt sich die Anzahl der Zeichen in der angegebenen Erweiterung wie folgt auf die Suche aus:
> 
> -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, gibt die Methode Dateien mit Erweiterungen zurück, die mit der angegebenen Erweiterung beginnen. Beispielsweise gibt "\*. xls" sowohl "Book. xls" als auch "Book. xlsx" zurück.
> -   In allen anderen Fällen gibt die-Methode Dateien zurück, die exakt mit der angegebenen Erweiterung übereinstimmen. "\*. ai" gibt z. b. "file.ai", jedoch nicht "file. AIF" zurück.
> 
>  Wenn Sie das Fragezeichen-Platzhalter Zeichen verwenden, gibt diese Methode nur die Dateien zurück, die der angegebenen Dateierweiterung entsprechen. Angenommen, die beiden Dateien "file1. txt" und "file1. txtother" in einem Verzeichnis haben das Suchmuster "file?". txt "gibt nur die erste Datei zurück, während das Suchmuster" File\*. txt "beide Dateien zurückgibt.

 `searchPattern` darf nicht mit zwei Punkten ("..") enden oder zwei Punkte ("..") enthalten, auf die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>folgt und keine ungültigen Zeichen enthalten kann. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.

 Sie können relative Pfadinformationen mit dem `path`-Parameter angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert, das Sie mithilfe der <xref:System.IO.Directory.GetCurrentDirectory%2A>-Methode ermitteln können.

 Die Methoden <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> und <xref:System.IO.Directory.GetFileSystemEntries%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>verwenden, können Sie mit dem Auflisten der Auflistung von Einträgen beginnen, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetFileSystemEntries%2A>verwenden, müssen Sie warten, bis das gesamte Array von Einträgen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateFiles%2A> effizienter sein.

 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> in der Auflistung startet eine neue-Enumeration.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
- oder - 
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung von Dateisystemeinträgen in <paramref name="path" /> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen. Der Standardwert ist <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Gibt eine aufzählbare Auflistung von Dateinamen und Verzeichnisnamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen. Optional werden Unterverzeichnisse durchsucht.</summary>
        <returns>Eine aufzählbare Auflistung von Dateisystemeinträgen, die sich in dem von <paramref name="path" /> angegebenen Verzeichnis befinden und dem angegebenen Suchmuster und der Option entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Namen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
> [!NOTE]
>  Wenn Sie das Platzhalter Zeichen Sternchen in einem `searchPattern` wie z. b. "\*. txt" verwenden, wirkt sich die Anzahl der Zeichen in der angegebenen Erweiterung wie folgt auf die Suche aus:  
>   
> -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, gibt die Methode Dateien mit Erweiterungen zurück, die mit der angegebenen Erweiterung beginnen. Beispielsweise gibt "\*. xls" sowohl "Book. xls" als auch "Book. xlsx" zurück.  
> -   In allen anderen Fällen gibt die-Methode Dateien zurück, die exakt mit der angegebenen Erweiterung übereinstimmen. "\*. ai" gibt z. b. "file.ai", jedoch nicht "file. AIF" zurück.  
>   
>  Wenn Sie das Fragezeichen-Platzhalter Zeichen verwenden, gibt diese Methode nur die Dateien zurück, die der angegebenen Dateierweiterung entsprechen. Angenommen, die beiden Dateien "file1. txt" und "file1. txtother" in einem Verzeichnis haben das Suchmuster "file?". txt "gibt nur die erste Datei zurück, während das Suchmuster" File\*. txt "beide Dateien zurückgibt.  
  
 `searchPattern` darf nicht mit zwei Punkten ("..") enden oder zwei Punkte ("..") enthalten, auf die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>folgt und keine ungültigen Zeichen enthalten kann. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Sie können relative Pfadinformationen mit dem `path`-Parameter angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert, das Sie mithilfe der <xref:System.IO.Directory.GetCurrentDirectory%2A>-Methode ermitteln können.  
  
 Die Methoden <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> und <xref:System.IO.Directory.GetFileSystemEntries%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>verwenden, können Sie mit dem Auflisten der Auflistung von Einträgen beginnen, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetFileSystemEntries%2A>verwenden, müssen Sie warten, bis das gesamte Array von Einträgen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateFiles%2A> effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. jeder aufzurufende <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> in der Auflistung startet eine neue-Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
- oder - 
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.IO.Directory.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der zu testende Pfad.</param>
        <summary>Bestimmt, ob der angegebene Pfad auf ein vorhandenes Verzeichnis auf einem Datenträger verweist.</summary>
        <returns><see langword="true" />, wenn sich <paramref name="path" /> auf ein vorhandenes Verzeichnis bezieht; <see langword="false" />, wenn ein Verzeichnis nicht vorhanden ist, oder wenn beim Versuch festzustellen, ob ein angegebenes Verzeichnis vorhanden ist, ein Fehler auftritt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `path`-Parameter darf relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert.  
  
 Nachfolgende Leerzeichen werden am Ende des `path`-Parameters entfernt, bevor überprüft wird, ob das Verzeichnis vorhanden ist.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
 Wenn Sie nicht über eine Leseberechtigung für das Verzeichnis verfügen, gibt die <xref:System.IO.Directory.Exists%2A> Methode `false`zurück.  
  
 Die <xref:System.IO.Directory.Exists%2A>-Methode gibt `false` zurück, wenn bei dem Versuch, festzustellen, ob die angegebene Datei vorhanden ist, ein Fehler auftritt. Dies kann in Situationen auftreten, in denen Ausnahmen ausgelöst werden, z. b. das Übergeben eines Datei namens mit ungültigen Zeichen oder zu vielen Zeichen, einem fehlerhaften oder fehlenden Datenträger oder, wenn der Aufrufer nicht über die Berechtigung zum Lesen der Datei verfügt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array von Datei-oder Verzeichnisnamen in der Befehlszeile erstellt, die Art des Namens bestimmt und entsprechend verarbeitet.  
  
 [!code-cpp[Recursive file finder#2](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#2)]
 [!code-csharp[Recursive file finder#2](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#2)]
 [!code-vb[Recursive file finder#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen von Dateien. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die Windows-Zugriffssteuerungsliste für ein Verzeichnis zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string -&gt; System.Security.AccessControl.DirectorySecurity" Usage="System.IO.Directory.GetAccessControl path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad zu einem Verzeichnis, das ein <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt enthält, das die Informationen zu einer Zugriffssteuerungsliste der Datei beschreibt.</param>
        <summary>Ruft ein <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt ab, das die ACL-Einträge für ein angegebenes Verzeichnis kapselt.</summary>
        <returns>Ein Objekt, das die Zugriffssteuerungsregeln für die vom <paramref name="path" />-Parameter beschriebene Datei kapselt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.IO.Directory.GetAccessControl%2A>-Methode, um die Einträge in der Zugriffs Steuerungs Liste (ACL) für ein Verzeichnis abzurufen.  
  
 Eine ACL beschreibt Personen und/oder Gruppen, die über Rechte für bestimmte Aktionen in der angegebenen Datei oder dem angegebenen Verzeichnis verfügen oder diese nicht besitzen. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 In NTFS-Umgebungen werden dem Benutzer <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> gewährt, wenn der Benutzer über <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> Rechte für den übergeordneten Ordner verfügt. Um <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>abzulehnen, verweigern Sie <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> für das übergeordnete Verzeichnis.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.IO.Directory.GetAccessControl%2A> und die <xref:System.IO.Directory.SetAccessControl%2A> Methoden verwendet, um einen Eintrag in einer Zugriffs Steuerungs Liste (ACL) hinzuzufügen und anschließend einen ACL-Eintrag aus einem Verzeichnis zu entfernen.  Sie müssen ein gültiges Benutzer- oder Gruppenkonto angeben, um dieses Beispiel auszuführen.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler beim Öffnen des Verzeichnisses.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows 2000 oder höher.</exception>
        <exception cref="T:System.SystemException">Ein Fehler auf Systemebene ist aufgetreten, z. B. konnte das Verzeichnis nicht gefunden werden. Bei der spezifischen Ausnahme handelt es sich möglicherweise um eine Unterklasse von <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der <paramref name="path" />-Parameter hat ein schreibgeschütztes Verzeichnis angegeben.  
  
- oder - 
Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  
  
- oder - 
Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">, um die Zugriffs Steuerungs Liste (ACL) für ein Verzeichnis aufzuzählen. Zugehörige Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Sicherheitsaktion: Bedarf.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String, includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.DirectorySecurity" Usage="System.IO.Directory.GetAccessControl (path, includeSections)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad zu einem Verzeichnis, das ein <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt enthält, das die Informationen zu einer Zugriffssteuerungsliste der Datei beschreibt.</param>
        <param name="includeSections">Einer der <see cref="T:System.Security.AccessControl.AccessControlSections" />-Werte, der den Typ der zu empfangenden ACL-Informationen angibt.</param>
        <summary>Ruft ein <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt ab, das die angegebenen Typen von Einträgen in einer Zugriffssteuerungsliste für ein angegebenes Verzeichnis kapselt.</summary>
        <returns>Ein Objekt, das die Zugriffssteuerungsregeln für die vom <paramref name="path" />-Parameter beschriebene Datei kapselt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.IO.Directory.GetAccessControl%2A>-Methode, um die Einträge in der Zugriffs Steuerungs Liste (ACL) für ein Verzeichnis abzurufen.  
  
 Eine ACL beschreibt Personen und/oder Gruppen, die über Rechte für bestimmte Aktionen in der angegebenen Datei oder dem angegebenen Verzeichnis verfügen oder diese nicht besitzen. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 In NTFS-Umgebungen werden dem Benutzer <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> gewährt, wenn der Benutzer über <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> Rechte für den übergeordneten Ordner verfügt. Um <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>abzulehnen, verweigern Sie <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> für das übergeordnete Verzeichnis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler beim Öffnen des Verzeichnisses.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows 2000 oder höher.</exception>
        <exception cref="T:System.SystemException">Ein Fehler auf Systemebene ist aufgetreten, z. B. konnte das Verzeichnis nicht gefunden werden. Bei der spezifischen Ausnahme handelt es sich möglicherweise um eine Unterklasse von <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der <paramref name="path" />-Parameter hat ein schreibgeschütztes Verzeichnis angegeben.  
  
- oder - 
Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  
  
- oder - 
Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">, um die Zugriffs Steuerungs Liste (ACL) für ein Verzeichnis aufzuzählen. Zugehörige Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Sicherheitsaktion: Bedarf.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTime : string -&gt; DateTime" Usage="System.IO.Directory.GetCreationTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad des Verzeichnisses.</param>
        <summary>Ruft Datum und Zeit der Erstellung eines Verzeichnisses ab.</summary>
        <returns>Eine Struktur, die auf das Erstellungsdatum und den Erstellungszeitpunkt für das angegebene Verzeichnis festgelegt wird. Dieser Wert wird in Ortszeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode gibt möglicherweise einen ungenauen Wert zurück, da Sie Native Funktionen verwendet, deren Werte nicht fortlaufend vom Betriebssystem aktualisiert werden.  
  
 Diese Methode entspricht <xref:System.IO.File.GetCreationTime%2A?displayProperty=nameWithType>.  
  
 Wenn das im `path`-Parameter beschriebene Verzeichnis nicht vorhanden ist, gibt diese Methode 12:00 Mitternacht, 1. Januar 1601 n. Chr. zurück. unserer Zeitrechnung Koordinierte Weltzeit (UTC), angepasst an Ortszeit.  
  
 Der `path`-Parameter darf relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Erstellungszeit des angegebenen Verzeichnisses abgerufen.  
  
 [!code-cpp[Dir_GetCreation#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCreation/CPP/dir_getcreation.cpp#1)]
 [!code-csharp[Dir_GetCreation#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCreation/CS/dir_getcreation.cs#1)]
 [!code-vb[Dir_GetCreation#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCreation/VB/dir_getcreation.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen der angegebenen Datei bzw. des angegebenen Verzeichnisses. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetCreationTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad des Verzeichnisses.</param>
        <summary>Ruft das Erstellungsdatum und den Erstellungszeitpunkt im UTC-Format (Coordinated Universal Time, koordinierte Weltzeit) eines Verzeichnisses ab.</summary>
        <returns>Eine Struktur, die auf das Erstellungsdatum und den Erstellungszeitpunkt für das angegebene Verzeichnis festgelegt wird. Der Wert wird in UTC-Zeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode gibt möglicherweise einen ungenauen Wert zurück, da Sie Native Funktionen verwendet, deren Werte nicht fortlaufend vom Betriebssystem aktualisiert werden.  
  
 Wenn das im `path`-Parameter beschriebene Verzeichnis nicht vorhanden ist, gibt diese Methode 12:00 Mitternacht, 1. Januar 1601 n. Chr. zurück. unserer Zeitrechnung Koordinierte Weltzeit (UTC).  
  
 Verwenden Sie diese Methode, um die Erstellungszeit für ein Verzeichnis basierend auf der koordinierten Weltzeit (UTC) zu erhalten.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Unterschiede in der Ausgabe veranschaulicht, wenn eine koordinierte Weltzeit (UTC)-Ausgabe verwendet wird.  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen der angegebenen Datei bzw. des angegebenen Verzeichnisses. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static string GetCurrentDirectory ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCurrentDirectory() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentDirectory () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCurrentDirectory();" />
      <MemberSignature Language="F#" Value="static member GetCurrentDirectory : unit -&gt; string" Usage="System.IO.Directory.GetCurrentDirectory " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft das aktuelle Arbeitsverzeichnis der Anwendung ab.</summary>
        <returns>Eine Zeichenfolge, die den absoluten Pfad des aktuellen Arbeitsverzeichnisses enthält und nicht mit einem umgekehrten Schrägstrich (\\) endet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das aktuelle Verzeichnis unterscheidet sich vom ursprünglichen Verzeichnis, in dem der Prozess gestartet wurde.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `GetCurrentDirectory`-Methode veranschaulicht.  
  
 [!code-cpp[Dir_GetCurDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCurDir/CPP/dir_getcurdir.cpp#1)]
 [!code-csharp[Dir_GetCurDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCurDir/CS/dir_getcurdir.cs#1)]
 [!code-vb[Dir_GetCurDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCurDir/VB/dir_getcurdir.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist Windows CE, das keine Funktionalität für das aktuelle Verzeichnis enthält.  
  
 Diese Methode ist in .NET Compact Framework verfügbar, wird aber derzeit nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Pfadinformationen für das aktuelle Verzeichnis. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die Namen der Unterverzeichnisse zurück, die die angegebenen Kriterien erfüllen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string -&gt; string[]" Usage="System.IO.Directory.GetDirectories path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Gibt die Namen der Unterverzeichnisse (einschließlich der Pfade) im angegebenen Verzeichnis zurück.</summary>
        <returns>Ein Array der vollständigen Namen (einschließlich der Pfade) der Unterverzeichnisse im angegebenen Pfad, oder ein leeres Array, wenn keine Verzeichnisse gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist identisch mit <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%29>, wobei das Sternchen (\*) als Suchmuster angegeben ist, sodass alle Unterverzeichnisse zurückgegeben werden. Wenn Sie Unterverzeichnisse durchsuchen müssen, verwenden Sie die <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29>-Methode, die es Ihnen ermöglicht, eine Suche nach Unterverzeichnissen mit dem Parameter `searchOption` anzugeben.  
  
 Die Methoden <xref:System.IO.Directory.EnumerateDirectories%2A> und <xref:System.IO.Directory.GetDirectories%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateDirectories%2A>verwenden, können Sie damit beginnen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetDirectories%2A>verwenden, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateDirectories%2A> effizienter sein.  
  
 Der `path`-Parameter kann relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die von dieser Methode zurückgegebenen Namen verfügen über die Verzeichnisinformationen, die in `path`bereitgestellt werden.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array von Datei-oder Verzeichnisnamen in der Befehlszeile erstellt, die Art des Namens bestimmt und entsprechend verarbeitet.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Pfadinformationen für das aktuelle Verzeichnis. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Unterverzeichnissen in <paramref name="path" /> auf Übereinstimmungen. Dieser Parameter kann eine Kombination aus gültigen Literal- und Platzhalterzeichen enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <summary>Gibt die Namen von Unterverzeichnissen (einschließlich der zugehörigen Pfade) zurück, die dem angegebenen Suchmuster im angegebenen Verzeichnis entsprechen.</summary>
        <returns>Ein Array der vollständigen Namen (einschließlich der Pfade) der Unterverzeichnisse, die dem Suchmuster im angegebenen Verzeichnis entsprechen, oder ein leeres Array, wenn keine Verzeichnisse gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt alle Unterverzeichnisse direkt unter dem angegebenen Verzeichnis zurück, die dem angegebenen Suchmuster entsprechen. Wenn das angegebene Verzeichnis keine Unterverzeichnisse aufweist oder keine Unterverzeichnisse mit dem `searchPattern`-Parameter identisch sind, gibt diese Methode ein leeres Array zurück. Nur das oberste Verzeichnis wird durchsucht. Wenn Sie auch die Unterverzeichnisse durchsuchen möchten, verwenden Sie die <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29>-Methode, und geben Sie <xref:System.IO.SearchOption.AllDirectories> im `searchOption`-Parameter an.  
  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Namen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 `searchPattern` darf nicht mit zwei Punkten ("..") enden oder zwei Punkte ("..") enthalten, auf die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>folgt und keine ungültigen Zeichen enthalten kann. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Der `path`-Parameter kann relative oder absolute Pfadinformationen angeben und unterscheidet nicht zwischen Groß-und Kleinschreibung.  Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die Methoden <xref:System.IO.Directory.EnumerateDirectories%2A> und <xref:System.IO.Directory.GetDirectories%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateDirectories%2A>verwenden, können Sie damit beginnen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetDirectories%2A>verwenden, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateDirectories%2A> effizienter sein.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Anzahl der Verzeichnisse in einem Pfad gezählt, der mit dem angegebenen Buchstaben beginnt.  
  
 [!code-cpp[Dir_GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetDirs2/CPP/dir_getdirs2.cpp#1)]
 [!code-csharp[Dir_GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs2.cs#1)]
 [!code-vb[Dir_GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Mit <see cref="M:System.IO.Path.GetInvalidPathChars" /> können Sie Abfragen für ungültige Zeichen ausführen.  
  
- oder - 
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> oder <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Pfadinformationen für das aktuelle Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Unterverzeichnissen in <paramref name="path" /> auf Übereinstimmungen. Dieser Parameter kann eine Kombination aus gültigen Literal- und Platzhalterzeichen enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="enumerationOptions">Ein Objekt, das die zu verwendende Such- und Enumerationskonfiguration beschreibt.</param>
        <summary>Gibt die Namen von Unterverzeichnissen (einschließlich der zugehörigen Pfade) zurück, die dem angegebenen Suchmuster und den angegebenen Enumerationsoptionen im angegebenen Verzeichnis entsprechen.</summary>
        <returns>Ein Array der vollständigen Namen (einschließlich der Pfade) der Unterverzeichnisse, die dem Suchmuster und den Enumerationsoperationen im angegebenen Verzeichnis entsprechen, oder ein leeres Array, wenn keine Verzeichnisse gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt alle Unterverzeichnisse direkt unter dem angegebenen Verzeichnis zurück, die dem angegebenen Suchmuster entsprechen. Wenn das angegebene Verzeichnis keine Unterverzeichnisse aufweist oder keine Unterverzeichnisse mit dem `searchPattern`-Parameter identisch sind, gibt diese Methode ein leeres Array zurück. Nur das oberste Verzeichnis wird durchsucht. Wenn Sie auch die Unterverzeichnisse durchsuchen möchten, verwenden Sie die <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29>-Methode, und geben Sie <xref:System.IO.SearchOption.AllDirectories> im `searchOption`-Parameter an.

 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.

|Platzhalter Bezeichner|Übereinstimmungen|
|------------------------|-------------|
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|

 Andere Zeichen als der Platzhalter sind Literalzeichen. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Namen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".

 `searchPattern` darf nicht mit zwei Punkten ("..") enden oder zwei Punkte ("..") enthalten, auf die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>folgt und keine ungültigen Zeichen enthalten kann. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.

 Der `path`-Parameter kann relative oder absolute Pfadinformationen angeben und unterscheidet nicht zwischen Groß-und Kleinschreibung.  Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.

 Die Methoden <xref:System.IO.Directory.EnumerateDirectories%2A> und <xref:System.IO.Directory.GetDirectories%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateDirectories%2A>verwenden, können Sie damit beginnen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetDirectories%2A>verwenden, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateDirectories%2A> effizienter sein.

 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Mit <see cref="M:System.IO.Path.GetInvalidPathChars" /> können Sie Abfragen für ungültige Zeichen ausführen.  
  
- oder - 
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> oder <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Unterverzeichnissen in <paramref name="path" /> auf Übereinstimmungen. Dieser Parameter kann eine Kombination aus gültigen Literal- und Platzhalterzeichen enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen.</param>
        <summary>Gibt die Namen der Unterverzeichnisse (einschließlich der Pfade) zurück, die dem angegebenen Suchmuster im aktuellen Verzeichnis entsprechen. Optional werden Unterverzeichnisse durchsucht.</summary>
        <returns>Ein Array der vollständigen Namen (einschließlich der Pfade) der Unterverzeichnisse, die den angegebenen Kriterien entsprechen, oder ein leeres Array, wenn keine Verzeichnisse gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `path`-Parameter kann relative oder absolute Pfadinformationen angeben und unterscheidet nicht zwischen Groß-und Kleinschreibung. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Namen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 `searchPattern` darf nicht mit zwei Punkten ("..") enden oder zwei Punkte ("..") enthalten, auf die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>folgt und keine ungültigen Zeichen enthalten kann. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Die Methoden <xref:System.IO.Directory.EnumerateDirectories%2A> und <xref:System.IO.Directory.GetDirectories%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateDirectories%2A>verwenden, können Sie damit beginnen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetDirectories%2A>verwenden, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateDirectories%2A> effizienter sein.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Anzahl von Verzeichnissen, die mit dem angegebenen Buchstaben beginnen, in einem Pfad gezählt. Nur das Verzeichnis der obersten Ebene wird durchsucht.  
  
 [!code-csharp[Dir_GetDirs2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs3.cs#2)]
 [!code-vb[Dir_GetDirs2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
- oder - 
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> oder <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Pfadinformationen für das aktuelle Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryRoot">
      <MemberSignature Language="C#" Value="public static string GetDirectoryRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectoryRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryRoot : string -&gt; string" Usage="System.IO.Directory.GetDirectoryRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad einer Datei oder eines Verzeichnisses.</param>
        <summary>Gibt für den angegebenen Pfad die Informationen über Volume, Stammverzeichnis oder beides zurück.</summary>
        <returns>Eine Zeichenfolge, die für den angegebenen Pfad die Informationen über Volume, Stammverzeichnis oder beides enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft den voll qualifizierten Pfadnamen `path`ab, wie von <xref:System.IO.Path.GetFullPath%2A>zurückgegeben, und gibt Stammverzeichnis Informationen zurück. Der angegebene Pfad muss nicht vorhanden sein.  
  
 Der `path`-Parameter darf relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das aktuelle Verzeichnis festgelegt und der Verzeichnis Stamm angezeigt wird.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Mit <see cref="M:System.IO.Path.GetInvalidPathChars" /> können Sie Abfragen für ungültige Zeichen ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Pfadinformationen für das aktuelle Verzeichnis. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die Namen der Dateien zurück, die die angegebenen Kriterien erfüllen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string -&gt; string[]" Usage="System.IO.Directory.GetFiles path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Gibt die Namen aller Dateien (einschließlich des Pfads) im angegebenen Verzeichnis zurück.</summary>
        <returns>Ein Array der vollständigen Namen (einschließlich der Pfade) für die Dateien im angegebenen Verzeichnis, oder ein leeres Array, wenn keine Dateien gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden <xref:System.IO.Directory.EnumerateFiles%2A> und <xref:System.IO.Directory.GetFiles%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateFiles%2A>verwenden, können Sie damit beginnen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateFiles%2A> effizienter sein.  
  
 Die zurückgegebenen Dateinamen werden an den angegebenen `path` Parameter angefügt.  
  
 Diese Methode ist identisch mit <xref:System.IO.Directory.GetFiles%28System.String%2CSystem.String%29>, wobei das Sternchen (\*) als Suchmuster angegeben wird.  
  
 Der `path`-Parameter kann relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die Reihenfolge der zurückgegebenen Dateinamen ist nicht garantiert. Verwenden Sie die <xref:System.Array.Sort%2A>-Methode, wenn eine bestimmte Sortierreihenfolge erforderlich ist.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.IO.Directory.GetFiles%2A>-Methode verwendet wird, um Dateinamen von einem benutzerdefinierten Speicherort zurückzugeben. Das Beispiel ist so konfiguriert, dass alle Fehler abgefangen werden, die von dieser Methode gemeinsam sind.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.  
  
- oder - 
Netzwerkfehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad wurde nicht gefunden oder ist ungültig (er befindet sich z. B.auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Pfadinformationen für das aktuelle Verzeichnis. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien in <paramref name="path" /> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <summary>Gibt die Namen der Dateien (einschließlich der zugehörigen Pfade) zurück, die dem angegebenen Suchmuster im angegebenen Verzeichnis entsprechen.</summary>
        <returns>Ein Array der vollständigen Namen der Dateien im angegebenen Verzeichnis (einschließlich der zugehörigen Pfade), die dem angegebenen Suchmuster entsprechen, oder ein leeres Array, wenn keine Dateien gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebenen Dateinamen werden an den angegebenen `path` Parameter angehängt, und die Reihenfolge der zurückgegebenen Dateinamen ist nicht garantiert. Verwenden Sie die <xref:System.Array.Sort%2A>-Methode, wenn eine bestimmte Sortierreihenfolge erforderlich ist.  
  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Namen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 `searchPattern` darf nicht mit zwei Punkten ("..") enden oder zwei Punkte ("..") enthalten, auf die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>folgt und keine ungültigen Zeichen enthalten kann. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
> [!NOTE]
>  Wenn Sie das Platzhalter Zeichen Sternchen in einem `searchPattern` wie z. b. "\*. txt" verwenden, wirkt sich die Anzahl der Zeichen in der angegebenen Erweiterung wie folgt auf die Suche aus:  
>   
> -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, gibt die Methode Dateien mit Erweiterungen zurück, die mit der angegebenen Erweiterung beginnen. Beispielsweise gibt "\*. xls" sowohl "Book. xls" als auch "Book. xlsx" zurück.  
> -   In allen anderen Fällen gibt die-Methode Dateien zurück, die exakt mit der angegebenen Erweiterung übereinstimmen. "\*. ai" gibt z. b. "file.ai", jedoch nicht "file. AIF" zurück.  
>   
>  Wenn Sie das Fragezeichen-Platzhalter Zeichen verwenden, gibt diese Methode nur die Dateien zurück, die der angegebenen Dateierweiterung entsprechen. Angenommen, die beiden Dateien "file1. txt" und "file1. txtother" in einem Verzeichnis haben das Suchmuster "file?". txt "gibt nur die erste Datei zurück, während das Suchmuster" File\*. txt "beide Dateien zurückgibt.  
  
> [!NOTE]
>  Da diese Methode Dateinamen sowohl mit dem Dateinamen Format 8,3 als auch mit dem langen Dateinamen Format prüft, gibt ein Suchmuster, das "\*1\*. txt" ähnelt, möglicherweise unerwartete Dateinamen zurück. Wenn Sie z. b. ein Suchmuster von "\*1\*. txt" verwenden, wird "longfilename. txt" zurückgegeben, da das entsprechende Format für den 8,3-Dateinamen "LONGFI ~ 1. txt" lautet.  
  
 Die Methoden <xref:System.IO.Directory.EnumerateFiles%2A> und <xref:System.IO.Directory.GetFiles%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateFiles%2A>verwenden, können Sie damit beginnen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateFiles%2A> effizienter sein.  
  
 Der `path`-Parameter kann relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Anzahl der Dateien, die mit dem angegebenen Buchstaben beginnen, gezählt.  
  
 [!code-cpp[Dir_GetFiles2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetFiles2/CPP/dir_getfiles2.cpp#1)]
 [!code-csharp[Dir_GetFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetFiles2/CS/dir_getfiles2.cs#1)]
 [!code-vb[Dir_GetFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetFiles2/VB/dir_getfiles2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.  
  
- oder - 
Netzwerkfehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Mit <see cref="M:System.IO.Path.GetInvalidPathChars" /> können Sie Abfragen für ungültige Zeichen ausführen.  
  
- oder - 
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> oder <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad wurde nicht gefunden oder ist ungültig (er befindet sich z. B.auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Pfadinformationen für das aktuelle Verzeichnis. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Unterverzeichnissen in <paramref name="path" /> auf Übereinstimmungen. Dieser Parameter kann eine Kombination aus gültigen Literal- und Platzhalterzeichen enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="enumerationOptions">Ein Objekt, das die zu verwendende Such- und Enumerationskonfiguration beschreibt.</param>
        <summary>Gibt die Namen der Dateien (einschließlich der zugehörigen Pfade) zurück, die dem angegebenen Suchmuster und den angegebenen Enumerationsoptionen im angegebenen Verzeichnis entsprechen.</summary>
        <returns>Ein Array der vollständigen Namen der Dateien im angegebenen Verzeichnis (einschließlich der Pfade), die dem angegebenen Suchmuster und den angegebenen Enumerationsoptionen entsprechen, oder ein leeres Array, wenn keine Dateien gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebenen Dateinamen werden an den angegebenen `path` Parameter angehängt, und die Reihenfolge der zurückgegebenen Dateinamen ist nicht garantiert. Verwenden Sie die <xref:System.Array.Sort%2A>-Methode, wenn eine bestimmte Sortierreihenfolge erforderlich ist.

 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.

|Platzhalter Bezeichner|Übereinstimmungen|
|------------------------|-------------|
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|

 Andere Zeichen als der Platzhalter sind Literalzeichen. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Namen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".

 `searchPattern` darf nicht mit zwei Punkten ("..") enden oder zwei Punkte ("..") enthalten, auf die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>folgt und keine ungültigen Zeichen enthalten kann. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.

> [!NOTE]
>  Wenn Sie das Platzhalter Zeichen Sternchen in einem `searchPattern` wie z. b. "\*. txt" verwenden, wirkt sich die Anzahl der Zeichen in der angegebenen Erweiterung wie folgt auf die Suche aus:
> 
> -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, gibt die Methode Dateien mit Erweiterungen zurück, die mit der angegebenen Erweiterung beginnen. Beispielsweise gibt "\*. xls" sowohl "Book. xls" als auch "Book. xlsx" zurück.
> -   In allen anderen Fällen gibt die-Methode Dateien zurück, die exakt mit der angegebenen Erweiterung übereinstimmen. "\*. ai" gibt z. b. "file.ai", jedoch nicht "file. AIF" zurück.
> 
>  Wenn Sie das Fragezeichen-Platzhalter Zeichen verwenden, gibt diese Methode nur die Dateien zurück, die der angegebenen Dateierweiterung entsprechen. Angenommen, die beiden Dateien "file1. txt" und "file1. txtother" in einem Verzeichnis haben das Suchmuster "file?". txt "gibt nur die erste Datei zurück, während das Suchmuster" File\*. txt "beide Dateien zurückgibt.

> [!NOTE]
>  Da diese Methode Dateinamen sowohl mit dem Dateinamen Format 8,3 als auch mit dem langen Dateinamen Format prüft, gibt ein Suchmuster, das "\*1\*. txt" ähnelt, möglicherweise unerwartete Dateinamen zurück. Wenn Sie z. b. ein Suchmuster von "\*1\*. txt" verwenden, wird "longfilename. txt" zurückgegeben, da das entsprechende Format für den 8,3-Dateinamen "LONGFI ~ 1. txt" lautet.

 Die Methoden <xref:System.IO.Directory.EnumerateFiles%2A> und <xref:System.IO.Directory.GetFiles%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateFiles%2A>verwenden, können Sie damit beginnen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateFiles%2A> effizienter sein.

 Der `path`-Parameter kann relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.

 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.

 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.  
  
- oder - 
Netzwerkfehler.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Mit <see cref="M:System.IO.Path.GetInvalidPathChars" /> können Sie Abfragen für ungültige Zeichen ausführen.  
  
- oder - 
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> oder <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad wurde nicht gefunden oder ist ungültig (er befindet sich z. B.auf einem nicht zugeordneten Laufwerk).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien in <paramref name="path" /> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen.</param>
        <summary>Gibt die Namen der Dateien (einschließlich der zugehörigen Pfade) zurück, die dem angegebenen Suchmuster im angegebenen Verzeichnis entsprechen. Anhand eines Werts wird bestimmt, ob Unterverzeichnisse durchsucht werden sollen.</summary>
        <returns>Ein Array der vollständigen Namen der Dateien im angegebenen Verzeichnis (einschließlich der Pfade), die dem angegebenen Suchmuster und der Option entsprechen, oder ein leeres Array, wenn keine Dateien gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebenen Dateinamen werden an den angegebenen Parameter angehängt `path` und die Reihenfolge der zurückgegebenen Dateinamen ist nicht garantiert. Verwenden Sie die <xref:System.Array.Sort%2A>-Methode, wenn eine bestimmte Sortierreihenfolge erforderlich ist.  
  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Namen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 `searchPattern` darf nicht mit zwei Punkten ("..") enden oder zwei Punkte ("..") enthalten, auf die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>folgt und keine ungültigen Zeichen enthalten kann. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
> [!NOTE]
>  Wenn Sie das Platzhalter Zeichen Sternchen in einem `searchPattern` wie z. b. "\*. txt" verwenden, wirkt sich die Anzahl der Zeichen in der angegebenen Erweiterung wie folgt auf die Suche aus:  
>   
> -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, gibt die Methode Dateien mit Erweiterungen zurück, die mit der angegebenen Erweiterung beginnen. Beispielsweise gibt "\*. xls" sowohl "Book. xls" als auch "Book. xlsx" zurück.  
> -   In allen anderen Fällen gibt die-Methode Dateien zurück, die exakt mit der angegebenen Erweiterung übereinstimmen. "\*. ai" gibt z. b. "file.ai", jedoch nicht "file. AIF" zurück.  
>   
>  Wenn Sie das Fragezeichen-Platzhalter Zeichen verwenden, gibt diese Methode nur die Dateien zurück, die der angegebenen Dateierweiterung entsprechen. Angenommen, die beiden Dateien "file1. txt" und "file1. txtother" in einem Verzeichnis haben das Suchmuster "file?". txt "gibt nur die erste Datei zurück, während ein Suchmuster von" file*. txt "beide Dateien zurückgibt.  
  
> [!NOTE]
>  Da diese Methode Dateinamen sowohl mit dem Dateinamen Format 8,3 als auch mit dem langen Dateinamen Format prüft, gibt ein Suchmuster, das "\*1\*. txt" ähnelt, möglicherweise unerwartete Dateinamen zurück. Wenn Sie z. b. ein Suchmuster von "\*1\*. txt" verwenden, wird "longfilename. txt" zurückgegeben, da das entsprechende Format für den 8,3-Dateinamen "LONGFI ~ 1. txt" lautet.  
  
 Die Methoden <xref:System.IO.Directory.EnumerateFiles%2A> und <xref:System.IO.Directory.GetFiles%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateFiles%2A>verwenden, können Sie damit beginnen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetFiles%2A>verwenden, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateFiles%2A> effizienter sein.  
  
 Die Dateinamen enthalten den vollständigen Pfad.  
  
 Der `path`-Parameter kann relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
- oder - 
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> oder <paramref name="searchpattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad wurde nicht gefunden oder ist ungültig (er befindet sich z. B.auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.  
  
- oder - 
Netzwerkfehler.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Pfadinformationen für das aktuelle Verzeichnis. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die Namen aller Dateien und Unterverzeichnisse zurück, die bestimmte Kriterien erfüllen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Gibt die Namen aller Dateien und Unterverzeichnisse in einem angegebenen Pfad zurück.</summary>
        <returns>Ein Array mit den Namen der Dateien und Unterverzeichnisse im angegebenen Verzeichnis, oder ein leeres Array, wenn keine Dateien oder Unterverzeichnisse gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der zurückgegebenen Datei-und Verzeichnisnamen ist nicht garantiert. Verwenden Sie die <xref:System.Array.Sort%2A>-Methode, wenn eine bestimmte Sortierreihenfolge erforderlich ist.  
  
 Die Methoden <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> und <xref:System.IO.Directory.GetFileSystemEntries%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>verwenden, können Sie mit dem Auflisten der Auflistung von Einträgen beginnen, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetFileSystemEntries%2A>verwenden, müssen Sie warten, bis das gesamte Array von Einträgen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateFiles%2A> effizienter sein.  
  
 Diese Methode ist identisch mit <xref:System.IO.Directory.GetFileSystemEntries%2A>, wobei das Sternchen (\*) als Suchmuster angegeben wird.  
  
 Der `path`-Parameter darf relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.Directory.GetFileSystemEntries%2A>-Methode verwendet, um ein Array von Zeichen folgen mit den Namen aller Dateien und Unterverzeichnisse an einem benutzerdefinierten Speicherort auszufüllen und jede Zeichenfolge im Array auf der Konsole zu drucken. Das Beispiel ist so konfiguriert, dass alle Fehler abgefangen werden, die von dieser Methode gemeinsam sind.  
  
 [!code-cpp[System.IO.Directory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#1)]
 [!code-csharp[System.IO.Directory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#1)]
 [!code-vb[System.IO.Directory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Mit <see cref="M:System.IO.Path.GetInvalidPathChars" /> können Sie Abfragen für ungültige Zeichen ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Pfadinformationen für das aktuelle Verzeichnis. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="T:System.IO.FileSystemInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien und Verzeichnissen in <paramref name="path" /> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <summary>Gibt ein Array von Dateinamen und Verzeichnisnamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen.</summary>
        <returns>Ein Array von Dateinamen und Verzeichnisnamen, die den angegebenen Suchkriterien entsprechen, oder ein leeres Array, wenn keine Dateien oder Verzeichnisse gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der zurückgegebenen Datei-und Verzeichnisnamen ist nicht garantiert. Verwenden Sie die <xref:System.Array.Sort%2A>-Methode, wenn eine bestimmte Sortierreihenfolge erforderlich ist.  
  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Namen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 `searchPattern` darf nicht mit zwei Punkten ("..") enden oder zwei Punkte ("..") enthalten, auf die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>folgt und keine ungültigen Zeichen enthalten kann. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
> [!NOTE]
>  Wenn Sie das Platzhalter Zeichen Sternchen in einem `searchPattern` wie z. b. "\*. txt" verwenden, wirkt sich die Anzahl der Zeichen in der angegebenen Erweiterung wie folgt auf die Suche aus:  
>   
> -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, gibt die Methode Dateien mit Erweiterungen zurück, die mit der angegebenen Erweiterung beginnen. Beispielsweise gibt "\*. xls" sowohl "Book. xls" als auch "Book. xlsx" zurück.  
> -   In allen anderen Fällen gibt die-Methode Dateien zurück, die exakt mit der angegebenen Erweiterung übereinstimmen. "\*. ai" gibt z. b. "file.ai", jedoch nicht "file. AIF" zurück.  
>   
>  Wenn Sie das Fragezeichen-Platzhalter Zeichen verwenden, gibt diese Methode nur die Dateien zurück, die der angegebenen Dateierweiterung entsprechen. Angenommen, die beiden Dateien "file1. txt" und "file1. txtother" in einem Verzeichnis haben das Suchmuster "file?". txt "gibt nur die erste Datei zurück, während das Suchmuster" File\*. txt "beide Dateien zurückgibt.  
  
 Der `path`-Parameter darf relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.Directory.GetFileSystemEntries%2A>-Methode verwendet, um ein Array von Zeichen folgen mit den Namen aller Dateien auszufüllen, die mit einem benutzerdefinierten Filter an einem bestimmten Speicherort übereinstimmen, und jede Zeichenfolge im Array wird auf der Konsole gedruckt. Das Beispiel ist so konfiguriert, dass alle Fehler abgefangen werden, die von dieser Methode gemeinsam sind.  
  
 [!code-cpp[System.IO.Directory#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#2)]
 [!code-csharp[System.IO.Directory#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#2)]
 [!code-vb[System.IO.Directory#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
- oder - 
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> oder <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Pfadinformationen für das aktuelle Verzeichnis. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Unterverzeichnissen in <paramref name="path" /> auf Übereinstimmungen. Dieser Parameter kann eine Kombination aus gültigen Literal- und Platzhalterzeichen enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="enumerationOptions">Ein Objekt, das die zu verwendende Such- und Enumerationskonfiguration beschreibt.</param>
        <summary>Gibt ein Array von Dateinamen und Verzeichnisnamen zurück, die einem Suchmuster und Enumerationsoptionen in einem angegebenen Pfad entsprechen.</summary>
        <returns>Ein Array von Dateinamen und Verzeichnisnamen, die den angegebenen Suchmustern und Enumerationsoptionen entsprechen, oder ein leeres Array, wenn keine Dateien oder Verzeichnisse gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der zurückgegebenen Datei-und Verzeichnisnamen ist nicht garantiert. Verwenden Sie die <xref:System.Array.Sort%2A>-Methode, wenn eine bestimmte Sortierreihenfolge erforderlich ist.

 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.

|Platzhalter Bezeichner|Übereinstimmungen|
|------------------------|-------------|
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|

 Andere Zeichen als der Platzhalter sind Literalzeichen. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Namen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".

 `searchPattern` darf nicht mit zwei Punkten ("..") enden oder zwei Punkte ("..") enthalten, auf die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>folgt und keine ungültigen Zeichen enthalten kann. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.

> [!NOTE]
>  Wenn Sie das Platzhalter Zeichen Sternchen in einem `searchPattern` wie z. b. "\*. txt" verwenden, wirkt sich die Anzahl der Zeichen in der angegebenen Erweiterung wie folgt auf die Suche aus:
> 
> -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, gibt die Methode Dateien mit Erweiterungen zurück, die mit der angegebenen Erweiterung beginnen. Beispielsweise gibt "\*. xls" sowohl "Book. xls" als auch "Book. xlsx" zurück.
> -   In allen anderen Fällen gibt die-Methode Dateien zurück, die exakt mit der angegebenen Erweiterung übereinstimmen. "\*. ai" gibt z. b. "file.ai", jedoch nicht "file. AIF" zurück.
> 
>  Wenn Sie das Fragezeichen-Platzhalter Zeichen verwenden, gibt diese Methode nur die Dateien zurück, die der angegebenen Dateierweiterung entsprechen. Angenommen, die beiden Dateien "file1. txt" und "file1. txtother" in einem Verzeichnis haben das Suchmuster "file?". txt "gibt nur die erste Datei zurück, während das Suchmuster" File\*. txt "beide Dateien zurückgibt.

 Der `path`-Parameter darf relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.

 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.

 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.

          ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.

- oder -

          <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> oder <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchPattern" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien und Verzeichnissen in <paramref name="path" /> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen. Der Standardwert ist <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Gibt ein Array aller Dateinamen und Verzeichnisnamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen. Optional werden Unterverzeichnisse durchsucht.</summary>
        <returns>Ein Array von Dateinamen und Verzeichnisnamen, die den angegebenen Suchkriterien entsprechen, oder ein leeres Array, wenn keine Dateien oder Verzeichnisse gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der zurückgegebenen Datei-und Verzeichnisnamen ist nicht garantiert. Verwenden Sie die <xref:System.Array.Sort%2A>-Methode, wenn eine bestimmte Sortierreihenfolge erforderlich ist.  
  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Platzhalter spezifiatoren sind in `searchPattern`zulässig.  
  
|Platzhalter Bezeichner|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|NULL oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als der Platzhalter sind Literalzeichen. Beispielsweise sucht die `searchPattern` Zeichenfolge "\*t" nach allen Namen in `path`, die mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` beginnend mit dem Buchstaben "s".  
  
 `searchPattern` darf nicht mit zwei Punkten ("..") enden oder zwei Punkte ("..") enthalten, auf die <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>folgt und keine ungültigen Zeichen enthalten kann. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
> [!NOTE]
>  Wenn Sie das Platzhalter Zeichen Sternchen in einem `searchPattern` wie z. b. "\*. txt" verwenden, wirkt sich die Anzahl der Zeichen in der angegebenen Erweiterung wie folgt auf die Suche aus:  
>   
> -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, gibt die Methode Dateien mit Erweiterungen zurück, die mit der angegebenen Erweiterung beginnen. Beispielsweise gibt "\*. xls" sowohl "Book. xls" als auch "Book. xlsx" zurück.  
> -   In allen anderen Fällen gibt die-Methode Dateien zurück, die exakt mit der angegebenen Erweiterung übereinstimmen. "\*. ai" gibt z. b. "file.ai", jedoch nicht "file. AIF" zurück.  
>   
>  Wenn Sie das Fragezeichen-Platzhalter Zeichen verwenden, gibt diese Methode nur die Dateien zurück, die der angegebenen Dateierweiterung entsprechen. Angenommen, die beiden Dateien "file1. txt" und "file1. txtother" in einem Verzeichnis haben das Suchmuster "file?". txt "gibt nur die erste Datei zurück, während das Suchmuster" File\*. txt "beide Dateien zurückgibt.  
  
 Die Methoden <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> und <xref:System.IO.Directory.GetFileSystemEntries%2A> unterscheiden sich wie folgt: Wenn Sie <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>verwenden, können Sie mit dem Auflisten der Auflistung von Einträgen beginnen, bevor die gesamte Auflistung zurückgegeben wird. Wenn Sie <xref:System.IO.Directory.GetFileSystemEntries%2A>verwenden, müssen Sie warten, bis das gesamte Array von Einträgen zurückgegeben wird, bevor Sie auf das Array zugreifen können. Wenn Sie also mit vielen Dateien und Verzeichnissen arbeiten, können <xref:System.IO.Directory.EnumerateFiles%2A> effizienter sein.  
  
 Sie können relative Pfadinformationen mit dem `path`-Parameter angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert, das Sie mithilfe der <xref:System.IO.Directory.GetCurrentDirectory%2A>-Methode ermitteln können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  
  
- oder - 
 <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTime : string -&gt; DateTime" Usage="System.IO.Directory.GetLastAccessTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. das die Informationen über Zugriffsdatum und -zeitpunkt abgerufen werden sollen.</param>
        <summary>Gibt das Datum und die Uhrzeit des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis zurück.</summary>
        <returns>Eine Struktur, die auf das Datum und die Uhrzeit des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis festgelegt wird. Dieser Wert wird in Ortszeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode gibt möglicherweise einen ungenauen Wert zurück, da Sie Native Funktionen verwendet, deren Werte nicht fortlaufend vom Betriebssystem aktualisiert werden.  
  
 Diese Methode ist identisch mit <xref:System.IO.File.GetLastAccessTime%2A?displayProperty=nameWithType>.  
  
 Wenn das im `path`-Parameter beschriebene Verzeichnis nicht vorhanden ist, gibt diese Methode 12:00 Mitternacht, 1. Januar 1601 n. Chr. zurück. unserer Zeitrechnung Koordinierte Weltzeit (UTC), angepasst an Ortszeit.  
  
 Der `path`-Parameter darf relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung von `GetLastAccessTime`veranschaulicht.  
  
 [!code-cpp[Dir_GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastAccess/CPP/dir_getlastaccess.cpp#1)]
 [!code-csharp[Dir_GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastAccess/CS/dir_getlastaccess.cs#1)]
 [!code-vb[Dir_GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastAccess/VB/dir_getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Der <paramref name="path" />-Parameter hat ein ungültiges Format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen der angegebenen Datei bzw. des angegebenen Verzeichnisses. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetLastAccessTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. das die Informationen über Zugriffsdatum und -zeitpunkt abgerufen werden sollen.</param>
        <summary>Gibt das Datum und den Zeitpunkt im UTC-Format (Coordinated Universal Time, koordinierte Weltzeit) des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis zurück.</summary>
        <returns>Eine Struktur, die auf das Datum und die Uhrzeit des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis festgelegt wird. Der Wert wird in UTC-Zeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode gibt möglicherweise einen ungenauen Wert zurück, da Sie Native Funktionen verwendet, deren Werte nicht fortlaufend vom Betriebssystem aktualisiert werden.  
  
 Wenn das im `path`-Parameter beschriebene Verzeichnis nicht vorhanden ist, gibt diese Methode 12:00 Mitternacht, 1. Januar 1601 n. Chr. zurück. unserer Zeitrechnung Koordinierte Weltzeit (UTC).  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Unterschiede in der Ausgabe veranschaulicht, wenn eine koordinierte Weltzeit (UTC)-Ausgabe verwendet wird.  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Der <paramref name="path" />-Parameter hat ein ungültiges Format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen der angegebenen Datei bzw. des angegebenen Verzeichnisses. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTime : string -&gt; DateTime" Usage="System.IO.Directory.GetLastWriteTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. für das die Informationen über Datum und Uhrzeit der letzten Änderung abgerufen werden sollen.</param>
        <summary>Gibt das Datum und die Uhrzeit des letzten Schreibvorgangs in die angegebene Datei bzw. das angegebene Verzeichnis zurück.</summary>
        <returns>Eine Struktur, die auf das Datum und die Uhrzeit des letzten Schreibvorgangs in die angegebene Datei bzw. das angegebene Verzeichnis festgelegt wird. Dieser Wert wird in Ortszeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode gibt möglicherweise einen ungenauen Wert zurück, da Sie Native Funktionen verwendet, deren Werte nicht fortlaufend vom Betriebssystem aktualisiert werden.  
  
 Wenn das im `path`-Parameter beschriebene Verzeichnis nicht vorhanden ist, gibt diese Methode 12:00 Mitternacht, 1. Januar 1601 n. Chr. zurück. unserer Zeitrechnung Koordinierte Weltzeit (UTC), angepasst an Ortszeit.  
  
 Der `path`-Parameter darf relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung von `GetLastWriteTime`veranschaulicht.  
  
 [!code-cpp[Dir_GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastWrite/CPP/dir_getlastwrite.cpp#1)]
 [!code-csharp[Dir_GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastWrite/CS/dir_getlastwrite.cs#1)]
 [!code-vb[Dir_GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastWrite/VB/dir_getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen der angegebenen Datei bzw. des angegebenen Verzeichnisses. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetLastWriteTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. für das die Informationen über Datum und Uhrzeit der letzten Änderung abgerufen werden sollen.</param>
        <summary>Gibt das Datum und den Zeitpunkt des letzten Schreibzugriffs im UTC-Format (Coordinated Universal Time, koordinierte Weltzeit) auf die angegebenen Datei bzw. das angegebene Verzeichnis zurück.</summary>
        <returns>Eine Struktur, die auf das Datum und die Uhrzeit des letzten Schreibvorgangs in die angegebene Datei bzw. das angegebene Verzeichnis festgelegt wird. Der Wert wird in UTC-Zeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode gibt möglicherweise einen ungenauen Wert zurück, da Sie Native Funktionen verwendet, deren Werte nicht fortlaufend vom Betriebssystem aktualisiert werden.  
  
 Wenn das im `path`-Parameter beschriebene Verzeichnis nicht vorhanden ist, gibt diese Methode 12:00 Mitternacht, 1. Januar 1601 n. Chr. zurück. unserer Zeitrechnung Koordinierte Weltzeit (UTC).  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Unterschiede in der Ausgabe veranschaulicht, wenn eine koordinierte Weltzeit (UTC)-Ausgabe verwendet wird.  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen der angegebenen Datei bzw. des angegebenen Verzeichnisses. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.IO.Directory.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Namen der logischen Laufwerke auf diesem Computer im Format „&lt;Laufwerkbuchstabe&gt;:\\“ ab.</summary>
        <returns>Die logischen Laufwerke auf diesem Computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GetLogicalDrives gibt alle zugänglichen Laufwerke auf einem bestimmten Computer zurück, einschließlich des Disketten Laufwerks und aller optischen Laufwerke.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.Directory.GetLogicalDrives%2A>-Methode verwendet, um den Namen jedes Laufwerks auf dem aufrufenden Computer einem Array von Zeichen folgen zuzuweisen. Jeder Member dieses Zeichen folgen Arrays wird dann in der Konsole gedruckt. Das Beispiel ist so konfiguriert, dass alle Fehler abgefangen werden, die von dieser Methode gemeinsam sind.  
  
 [!code-cpp[System.IO.Directory#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#3)]
 [!code-csharp[System.IO.Directory#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#3)]
 [!code-vb[System.IO.Directory#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten (z. B. ein Datenträgerfehler).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwaltetem Code, z. b. Aufrufen von nativem Code mit PInvoke oder COM-Interop. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="GetParent">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetParent (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo GetParent(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetParent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParent (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetParent(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetParent : string -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.GetParent path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad, dessen übergeordnetes Verzeichnis abgerufen werden soll.</param>
        <summary>Ruft das übergeordnete Verzeichnis des angegebenen Pfads ab, sowohl für absolute als auch für relative Pfade.</summary>
        <returns>Das übergeordnete Verzeichnis oder <see langword="null" />, wenn <paramref name="path" /> das Stammverzeichnis ist, einschließlich des Stammverzeichnisses eines UNC-Server- oder Freigabenamens.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `path`-Parameter kann relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Nachfolgende Leerzeichen werden am Ende des `path`-Parameters vor dem Verzeichnis entfernt.  
  
 Die von dieser Methode zurückgegebene Zeichenfolge besteht aus allen Zeichen im Pfad bis zum, jedoch nicht einschließlich, dem letzten <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>. Wenn Sie z. b. den Pfad "c:\direct\subdirector \ Test.txt" an <xref:System.IO.Directory.GetParent%2A> übergeben, wird "c:\direct\unterverzeichnis" zurückgegeben. Durch das Übergeben von "c:\direct\subdirectory" wird "c:\directory" zurückgegeben. Wenn Sie jedoch "c:\direct\subdirectory\\" übergeben, wird "c:\direct\subdirectory" zurückgegeben, da sich das Ende Verzeichnis Trennzeichen hinter "Unterverzeichnis" befindet.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.IO.Directory.GetParent%2A>-Methode verwendet wird, um das übergeordnete Verzeichnis eines vom Benutzer angegebenen Speicher Orts "Path" abzurufen. Der von der <xref:System.IO.Directory.GetParent%2A>-Methode zurückgegebene Wert wird dann in der Konsole gedruckt. Das Beispiel ist so konfiguriert, dass alle Fehler abgefangen werden, die von dieser Methode gemeinsam sind.  
  
 [!code-cpp[System.IO.Directory#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#4)]
 [!code-csharp[System.IO.Directory#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#4)]
 [!code-vb[System.IO.Directory#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Das durch <paramref name="path" /> angegebene Verzeichnis ist schreibgeschützt.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Weitere Informationen finden Sie im Thema <see cref="T:System.IO.PathTooLongException" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.NotSupportedException">Das Format von <paramref name="path" /> ist ungültig.</exception>
        <exception cref="T:System.Security.SecurityException">Nur .NET Framework: Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen aus Dateien oder Verzeichnissen. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceDirName, string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceDirName, string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Move(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceDirName As String, destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceDirName, System::String ^ destDirName);" />
      <MemberSignature Language="F#" Value="static member Move : string * string -&gt; unit" Usage="System.IO.Directory.Move (sourceDirName, destDirName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirName" Type="System.String" />
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirName">Der Pfad der Datei oder des Verzeichnisses, das verschoben werden soll.</param>
        <param name="destDirName">Der Pfad zum neuen Speicherort für <paramref name="sourceDirName" />. Wenn <paramref name="sourceDirName" /> eine Datei ist, muss <paramref name="destDirName" /> auch ein Dateiname sein.</param>
        <summary>Verschiebt eine Datei oder ein Verzeichnis und dessen Inhalt an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt ein neues Verzeichnis mit dem Namen, der von `destDirName` angegeben wird, und verschiebt den Inhalt `sourceDirName` in das neu erstellte Zielverzeichnis. Wenn Sie versuchen, ein Verzeichnis in ein Verzeichnis zu verschieben, das bereits vorhanden ist, wird ein <xref:System.IO.IOException> auftreten. Beispielsweise wird eine Ausnahme ausgelöst, wenn Sie versuchen, c:\meinedir nach c:\Public zu verschieben, und c:\Public bereits vorhanden ist. Alternativ können Sie "c:\\\Public\\\MyDir" als `destDirName` Parameter angeben, vorausgesetzt, dass "MyDir" nicht unter "c:\\\Public" vorhanden ist, oder Sie geben einen neuen Verzeichnisnamen an, z. b. "c:\\\newdir".  
  
 Die Argumente "`sourceDirName`" und "`destDirName`" dürfen relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Nachfolgende Leerzeichen werden am Ende der Pfad Parameter vor dem Verschieben des Verzeichnisses entfernt.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  


> [!NOTE]
>  Ab .net Core 3,0 löst die `Move`-Methode eine <xref:System.IO.IOException> auf allen Plattformen aus, wenn die `destDirName` bereits vorhanden ist. In .net Core 2,2 und früheren Versionen wurde die Ausnahme nur unter Windows ausgelöst, und andere Plattformen konnten die `destDirName`fehlschlagen oder überschreiben. Siehe [ C++ umbenennen](https://linux.die.net/man/2/rename).
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Verzeichnis und alle zugehörigen Dateien in ein neues Verzeichnis verschoben werden. Das ursprüngliche Verzeichnis ist nicht mehr vorhanden, nachdem es verschoben wurde.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Es wurde versucht, ein Verzeichnis auf ein anderes Volume zu verschieben.
  
- oder - 
 <paramref name="destDirName" /> ist bereits vorhanden. Weitere Informationen finden Sie im Abschnitt „Hinweise“.
  
- oder - 
Der <paramref name="sourceDirName" />-Parameter und <paramref name="destDirName" />-Parameter verweisen auf dieselbe Datei oder dasselbe Verzeichnis.  
  
- oder - 
Das Verzeichnis oder eine darin enthaltene Datei wird von einem anderen Prozess verwendet.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceDirName" /> oder <paramref name="destDirName" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirName" /> oder <paramref name="destDirName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der von <paramref name="sourceDirName" /> angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen von <paramref name="sourceDirName" /> und Schreiben in <paramref name="sourceDirName" /> und <paramref name="destDirName" />. Zugehörige Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /><see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetAccessControl(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAccessControl(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="static member SetAccessControl : string * System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="System.IO.Directory.SetAccessControl (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ein Verzeichnis, dem Einträge von Zugriffssteuerungslisten hinzugefügt oder aus diesem entfernt werden sollen.</param>
        <param name="directorySecurity">Ein <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt, das einen Eintrag in einer Zugriffssteuerungsliste beschreibt, der auf das vom <paramref name="path" />-Parameter beschriebene Verzeichnis angewendet werden soll.</param>
        <summary>Wendet von einem <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt beschriebene Einträge von Zugriffssteuerungslisten auf das angegebene Verzeichnis an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Directory.SetAccessControl%2A>-Methode wendet Einträge in der Zugriffs Steuerungs Liste (ACL) auf eine Datei an, die die nicht geerbte ACL-Liste darstellt.  
  
> [!CAUTION]
>  Die für den `directorySecurity`-Parameter angegebene ACL ersetzt die vorhandene ACL für das Verzeichnis. Um Berechtigungen für einen neuen Benutzer hinzuzufügen, verwenden Sie die <xref:System.IO.Directory.GetAccessControl%2A>-Methode, um die vorhandene ACL abzurufen und zu ändern.  
  
 Eine ACL beschreibt Personen und/oder Gruppen, die über Rechte für bestimmte Aktionen in der angegebenen Datei oder dem angegebenen Verzeichnis verfügen oder diese nicht besitzen. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Die <xref:System.IO.Directory.SetAccessControl%2A>-Methode speichert nur <xref:System.Security.AccessControl.DirectorySecurity> Objekte, die nach der Objekt Erstellung geändert wurden.  Wenn ein <xref:System.Security.AccessControl.DirectorySecurity> Objekt nicht geändert wurde, wird es nicht in einer Datei persistent gespeichert.  Aus diesem Grund ist es nicht möglich, ein <xref:System.Security.AccessControl.DirectorySecurity> Objekt aus einer Datei abzurufen und das gleiche Objekt erneut auf eine andere Datei anzuwenden.  
  
 So kopieren Sie ACL-Informationen aus einer Datei in eine andere:  
  
1.  Verwenden Sie die <xref:System.IO.Directory.GetAccessControl%2A>-Methode, um das <xref:System.Security.AccessControl.DirectorySecurity> Objekt aus der Quelldatei abzurufen.  
  
2.  Erstellen Sie ein neues <xref:System.Security.AccessControl.DirectorySecurity>-Objekt für die Zieldatei.  
  
3.  Verwenden Sie die <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A>-oder <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>-Methode des Quell <xref:System.Security.AccessControl.DirectorySecurity> Objekts, um die ACL-Informationen abzurufen.  
  
4.  Verwenden Sie die Methode <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> oder <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>, um die in Schritt 3 abgerufenen Informationen in das Ziel <xref:System.Security.AccessControl.DirectorySecurity> Objekt zu kopieren.  
  
5.  Legen Sie das Ziel <xref:System.Security.AccessControl.DirectorySecurity> Objekt mithilfe der <xref:System.IO.Directory.SetAccessControl%2A>-Methode auf die Zieldatei fest.  
  
 In NTFS-Umgebungen werden dem Benutzer <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> gewährt, wenn der Benutzer über <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> Rechte für den übergeordneten Ordner verfügt. Um <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>abzulehnen, verweigern Sie <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> für das übergeordnete Verzeichnis.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.IO.Directory.GetAccessControl%2A> und die <xref:System.IO.Directory.SetAccessControl%2A> Methoden verwendet, um einen Eintrag in einer Zugriffs Steuerungs Liste (ACL) hinzuzufügen und anschließend einen ACL-Eintrag aus einem Verzeichnis zu entfernen.  Sie müssen ein gültiges Benutzer- oder Gruppenkonto angeben, um dieses Beispiel auszuführen.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directorySecurity" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Verzeichnis wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="path" /> war ungültig.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der aktuelle Prozess hat keinen Zugriff auf das durch <paramref name="path" /> angegebene Verzeichnis.  
  
- oder - 
Der aktuelle Prozess verfügt nicht über ausreichende Berechtigungen zum Festlegen des ACL-Eintrags.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows 2000 oder höher.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">, um die Zugriffs Steuerungs Liste (ACL) für ein Verzeichnis aufzuzählen. Zugehörige Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> <see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
Sicherheitsaktion: Bedarf.</permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTime (path As String, creationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTime(System::String ^ path, DateTime creationTime);" />
      <MemberSignature Language="F#" Value="static member SetCreationTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetCreationTime (path, creationTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für das die Informationen über Erstellungsdatum und -zeitpunkt festgelegt werden sollen.</param>
        <param name="creationTime">Datum und Zeitpunkt des letzten Schreibvorgangs in einer Datei oder einem Verzeichnis. Dieser Wert wird in Ortszeit angegeben.</param>
        <summary>Legt das Erstellungsdatum und den Erstellungszeitpunkt für die angegebene Datei bzw. das angegebene Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `path`-Parameter darf relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Unterschiede in der Ausgabe veranschaulicht, wenn eine koordinierte Weltzeit (UTC)-Ausgabe verwendet wird.  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationTime" /> gibt einen Wert außerhalb des Datums- oder Uhrzeitbereichs an, der für diesen Vorgang zulässig ist.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei bzw. das angegebene Verzeichnis. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTimeUtc (path As String, creationTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTimeUtc(System::String ^ path, DateTime creationTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetCreationTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetCreationTimeUtc (path, creationTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für das die Informationen über Erstellungsdatum und -zeitpunkt festgelegt werden sollen.</param>
        <param name="creationTimeUtc">Datum und Uhrzeit der Erstellung des Verzeichnisses oder der Datei. Dieser Wert wird in Ortszeit angegeben.</param>
        <summary>Legt das Erstellungsdatum und den Erstellungszeitpunkt im UTC-Format (Coordinated Universal Time, koordinierte Weltzeit) für die angegebene Datei oder das angegebene Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `path`-Parameter darf relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationTime" /> gibt einen Wert außerhalb des Datums- oder Uhrzeitbereichs an, der für diesen Vorgang zulässig ist.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei bzw. das angegebene Verzeichnis. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="SetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static void SetCurrentDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCurrentDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCurrentDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCurrentDirectory (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCurrentDirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member SetCurrentDirectory : string -&gt; unit" Usage="System.IO.Directory.SetCurrentDirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad, auf den das aktuelle Arbeitsverzeichnis festgelegt ist.</param>
        <summary>Legt das aktuelle Arbeitsverzeichnis der Anwendung auf das angegebene Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Anwendung beendet wird, wird das Arbeitsverzeichnis am ursprünglichen Speicherort wieder hergestellt (das Verzeichnis, in dem der Prozess gestartet wurde).  
  
 Der `path`-Parameter darf relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Nachfolgende Leerzeichen werden am Ende des `path`-Parameters entfernt, bevor das Verzeichnis festgelegt wird.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
 Wenn Sie das Verzeichnis auf ein Laufwerk mit Wechselmedien (z. b. "E:" für einen USB-Speicherstick) festlegen, können Sie mithilfe der <xref:System.IO.DriveInfo.IsReady%2A>-Eigenschaft feststellen, ob das Laufwerk bereit ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie das aktuelle Verzeichnis festgelegt und der Verzeichnis Stamm angezeigt wird.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung zum Zugreifen auf nicht verwalteten Code.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das angegebene Verzeichnis wurde nicht gefunden.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in Dateien oder Verzeichnisse. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwaltetem Code. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTime (path As String, lastAccessTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTime(System::String ^ path, DateTime lastAccessTime);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastAccessTime (path, lastAccessTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. für das die Informationen über Zugriffsdatum und -zeitpunkt festgelegt werden sollen.</param>
        <param name="lastAccessTime">Eine Objekt, das den festzulegenden Wert für Zugriffsdatum und -zeitpunkt von <paramref name="path" /> enthält. Dieser Wert wird in Ortszeit angegeben.</param>
        <summary>Legt das Datum und die Uhrzeit des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `path`-Parameter darf relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung von `SetLastAccessTime`veranschaulicht.  
  
 [!code-cpp[Dir_SetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastAccess/CPP/dir_setlastaccess.cpp#1)]
 [!code-csharp[Dir_SetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastAccess/CS/dir_setlastaccess.cs#1)]
 [!code-vb[Dir_SetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastAccess/VB/dir_setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastAccessTime" /> gibt einen Wert außerhalb des Datums- oder Zeitbereichs an, der für diesen Vorgang zulässig ist.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei bzw. das angegebene Verzeichnis. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTimeUtc (path As String, lastAccessTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTimeUtc(System::String ^ path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastAccessTimeUtc (path, lastAccessTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. für das die Informationen über Zugriffsdatum und -zeitpunkt festgelegt werden sollen.</param>
        <param name="lastAccessTimeUtc">Eine Objekt, das den festzulegenden Wert für Zugriffsdatum und -zeitpunkt von <paramref name="path" /> enthält. Der Wert wird in UTC-Zeit angegeben.</param>
        <summary>Legt das Datum und den Zeitpunkt im UTC-Format (Coordinated Universal Time, koordinierte Weltzeit) des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `path`-Parameter darf relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Unterschiede in der Ausgabe veranschaulicht, wenn eine koordinierte Weltzeit (UTC)-Ausgabe verwendet wird.  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastAccessTimeUtc" /> gibt einen Wert außerhalb des Datums- oder Zeitbereichs an, der für diesen Vorgang zulässig ist.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei bzw. das angegebene Verzeichnis. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTime (path As String, lastWriteTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTime(System::String ^ path, DateTime lastWriteTime);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastWriteTime (path, lastWriteTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad des Verzeichnisses.</param>
        <param name="lastWriteTime">Datum und Zeitpunkt des letzten Schreibvorgangs in einem Verzeichnis. Dieser Wert wird in Ortszeit angegeben.</param>
        <summary>Legt Datum und Zeit des letzten Schreibvorgangs in einem Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `path`-Parameter darf relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung von `SetLastWriteTime`veranschaulicht.  
  
 [!code-cpp[Dir_SetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastWrite/CPP/dir_setlastwrite.cpp#1)]
 [!code-csharp[Dir_SetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastWrite/CS/dir_setlastwrite.cs#1)]
 [!code-vb[Dir_SetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastWrite/VB/dir_setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="path" /> wurde nicht gefunden (z. B. ist das Verzeichnis nicht vorhanden oder befindet sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> wurde nicht gefunden (z. B. ist das Verzeichnis nicht vorhanden oder befindet sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastWriteTime" /> gibt einen Wert außerhalb des Datums- oder Zeitbereichs an, der für diesen Vorgang zulässig ist.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei bzw. das angegebene Verzeichnis. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTimeUtc (path As String, lastWriteTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTimeUtc(System::String ^ path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastWriteTimeUtc (path, lastWriteTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad des Verzeichnisses.</param>
        <param name="lastWriteTimeUtc">Datum und Zeitpunkt des letzten Schreibvorgangs in einem Verzeichnis. Der Wert wird in UTC-Zeit angegeben.</param>
        <summary>Legt das Datum und den Zeitpunkt im UTC-Format (Coordinated Universal Time, koordinierte Weltzeit) des letzten Schreibzugriffs auf ein Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `path`-Parameter darf relative oder absolute Pfadinformationen angeben. Relative Pfadinformationen werden als relativ zum aktuellen Arbeitsverzeichnis interpretiert. Informationen zum Abrufen des aktuellen Arbeitsverzeichnisses finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Beim `path`-Parameter wird die Groß-/Kleinschreibung nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben finden Sie unter [Allgemeine e/](~/docs/standard/io/common-i-o-tasks.md)a-Aufgaben.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Unterschiede in der Ausgabe veranschaulicht, wenn eine koordinierte Weltzeit (UTC)-Ausgabe verwendet wird.  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="path" /> wurde nicht gefunden (z. B. ist das Verzeichnis nicht vorhanden oder befindet sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="path" /> wurde nicht gefunden (z. B. ist das Verzeichnis nicht vorhanden oder befindet sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lastWriteTimeUtc" /> gibt einen Wert außerhalb des Datums- oder Zeitbereichs an, der für diesen Vorgang zulässig ist.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei bzw. das angegebene Verzeichnis. Zugehörige Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
  </Members>
</Type>
