<Type Name="Directory" FullName="System.IO.Directory">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a0c1039692e52af1fa4e012fbe5e539bb1f23eab" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39732848" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Directory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Directory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Directory" />
  <TypeSignature Language="VB.NET" Value="Public Class Directory" />
  <TypeSignature Language="C++ CLI" Value="public ref class Directory abstract sealed" />
  <TypeSignature Language="F#" Value="type Directory = class" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Macht statische Methoden zum Erstellen, Verschieben und Auflisten in Verzeichnissen und Unterverzeichnissen verfügbar. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.IO.Directory> Klasse für normale Vorgänge wie kopieren, verschieben, umbenennen, erstellen und Löschen von Verzeichnissen.  
  
-   Um ein Verzeichnis zu erstellen, gehen die <xref:System.IO.Directory.CreateDirectory%2A> Methoden.  
  
-   Um ein Verzeichnis zu löschen, gehen die <xref:System.IO.Directory.Delete%2A> Methoden.  
  
-   Verwenden Sie zum Abrufen, oder legen das aktuelle Verzeichnis für eine app, die <xref:System.IO.Directory.GetCurrentDirectory%2A> oder <xref:System.IO.Directory.SetCurrentDirectory%2A> Methode.  
  
-   Zum Bearbeiten von <xref:System.DateTime> Informationen in Bezug auf die Erstellung, Zugriff und das Schreiben eines Verzeichnisses, verwenden Methoden wie <xref:System.IO.Directory.SetLastAccessTime%2A> und <xref:System.IO.Directory.SetCreationTime%2A>.  
  
 Die statischen Methoden der <xref:System.IO.Directory> Klasse sicherheitsüberprüfungen für alle Methoden ausgeführt werden. Wenn Sie ein Objekt mehrmals wiederverwenden möchten, erwägen Sie die entsprechende Instanzmethode der <xref:System.IO.DirectoryInfo> stattdessen, da die sicherheitsüberprüfung wird nicht immer erforderlich sein.  
  
 Wenn Sie nur eine Verbindung mit dem Directory-Aktion ausführen, ist es möglicherweise effizienter, verwenden einen statischen <xref:System.IO.Directory> -Methode anstelle einer entsprechenden <xref:System.IO.DirectoryInfo> Instanzmethode. Die meisten <xref:System.IO.Directory> Methoden erfordern, den Pfad zu dem Verzeichnis, das Sie bearbeiten.  
  
> [!NOTE]
>  Bei Membern, die eine Zeichenfolge akzeptieren `path` -Parameter, dass der Pfad muss wohlgeformt sein oder eine Ausnahme ausgelöst. Z. B., wenn ein Pfad voll qualifiziert, aber mit einem Leerzeichen ("c:\temp") beginnt, ist nicht die Path-Zeichenfolge abgeschnitten, damit der Pfad als fehlerhaft betrachtet wird und eine Ausnahme ausgelöst. Darüber hinaus kann keinen Pfad oder eine Kombination von Pfaden zweimal vollqualifiziert werden. "C:\temp c:\windows" wird z. B. auch eine Ausnahme auslöst. Stellen Sie sicher, dass die Pfade wohlgeformt sind, bei Verwendung von Methoden, die eine Pfadzeichenfolge akzeptieren. Weitere Informationen finden Sie unter <xref:System.IO.Path>.  
  
 Bei Membern, die einen Pfad zu akzeptieren, kann der Pfad zu einer Datei oder ein Verzeichnis verweisen. Sie können einen vollständigen Pfad, einen relativen Pfad oder ein Universal Naming Convention (UNC)-Pfad für den Namen eines Servers und der freigabeeinstellungen verwenden. Beispielsweise sind alle folgenden Pfade zulässig:  
  
-   "c:\\\MyDir" in C#- oder "c:\MyDir" in Visual Basic.  
  
-   "" MyDir "\\\MySubdir" in C#- oder "MyDir\MySubDir" in Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" in c# oder "\\\MyServer\MyShare" in Visual Basic.  
  
 Standardmäßig erhält die vollständige Lese-/Schreibzugriff neuen Verzeichnisse für alle Benutzer. Allerdings müssen die app die richtigen Sicherheit den Zugriff auf vorhandene Verzeichnisse verfügen.  
  
 Bei Bedarf die Berechtigungen für ein Verzeichnis und allen seinen Unterverzeichnisse, Ende der Path-Zeichenfolge mit dem Verzeichnistrennzeichen. (Z.B. "C:\Temp\\" C:\Temp\ und allen seinen Unterverzeichnisse den Zugriff gewährt.) Bei Bedarf die Berechtigungen nur für ein bestimmtes Verzeichnis End die Pfadzeichenfolge mit einem Punkt. (Z.B. "C:\Temp\\." gewährt Zugriff nur auf C:\Temp\\und nicht auf seinen Unterverzeichnissen.)  
  
 Bei Membern, akzeptieren ein `searchPattern` Parameter, die zu suchende Zeichenfolge kann eine beliebige Kombination von literalen Zeichen und Platzhalterzeichen; sein \* und?. Dieser Parameter kann nicht mit reguläre Ausdrücken erkennen. Weitere Informationen finden Sie unter den <xref:System.IO.Directory.EnumerateDirectories%28System.String%2CSystem.String%29> -Methode oder eine andere Methode, die verwendet die `searchPattern` Parameter.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 <xref:System.IO.Directory> und <xref:System.IO.DirectoryInfo> werden nicht unterstützt, für die Verwendung in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps. Informationen zum Zugriff auf Dateien und Ordner in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] -apps finden Sie unter [den Zugriff auf Daten und Dateien (Windows Store-apps)](http://msdn.microsoft.com/library/windows/apps/hh758319.aspx).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie alle Textdateien aus einem Verzeichnis abzurufen und in ein neues Verzeichnis verschieben. Nachdem die Dateien verschoben werden, sind sie nicht mehr in das ursprüngliche Verzeichnis vorhanden.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.IO.Directory.EnumerateFiles%2A> Methode, um eine Auflistung von Textdateien aus einem Verzeichnis abzurufen, und klicken Sie dann diese Sammlung in einer Abfrage verwenden, um alle Zeilen zu suchen, "Example" enthalten.  
  
 [!code-csharp[System.IO.Directory#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class3.cs#11)]
 [!code-vb[System.IO.Directory#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class3.vb#11)]  
  
 Im folgende Beispiel wird veranschaulicht, wie Sie ein Verzeichnis und alle Dateien in ein neues Verzeichnis verschieben. Das ursprüngliche Verzeichnis ist nicht mehr vorhanden, nachdem es verschoben wurde.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.DriveInfo" />
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.DirectoryInfo" />
    <altmember cref="T:System.IO.FileInfo" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateDirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt alle Verzeichnisse in einem angegebenen Pfad.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.CreateDirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Das zu erstellende Verzeichnis.</param>
        <summary>Erstellt alle Verzeichnisse und Unterverzeichnisse im angegebenen Pfad, es sei denn, sie sind bereits vorhanden.</summary>
        <returns>Ein Objekt, das das Verzeichnis im angegebenen Pfad darstellt. Dieses Objekt wird unabhängig davon zurückgegeben, ob ein Verzeichnis unter dem angegebenen Pfad bereits vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Verzeichnisse im angegebenen `path` werden erstellt, es sei denn, sie sind bereits vorhanden oder eines Teils des `path` ist ungültig. Wenn das Verzeichnis bereits vorhanden ist, diese Methode ein neues Verzeichnis keine erstellt, aber es gibt eine <xref:System.IO.DirectoryInfo> -Objekt für das vorhandene Verzeichnis.  
  
 Die `path` Parameter gibt einen Verzeichnispfad, kein Dateipfad an.  
  
 Nachgestellte Leerzeichen entfernt werden, am Ende der `path` -Parameter vor dem Erstellen des Verzeichnisses.  
  
 Sie können ein Verzeichnis auf einem Remotecomputer, auf eine Freigabe erstellen, denen Sie über Schreibzugriff zu verfügen. UNC-Pfade werden unterstützt. Sie können beispielsweise angeben, die folgenden `path`: `\\2009\Archives\December` in Visual Basic und `\\\\2009\\Archives\\December` in C# geschrieben.  
  
 Erstellen ein Verzeichnis mit nur den Doppelpunkt (:) wird nicht unterstützt und führt dazu, dass eine `NotSupportedException` ausgelöst wird.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt und löscht das angegebene Verzeichnis.  
  
 [!code-cpp[Dir_CreateDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_CreateDir/CPP/dir_createdir.cpp#1)]
 [!code-csharp[Dir_CreateDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_CreateDir/CS/dir_createdir.cs#1)]
 [!code-vb[Dir_CreateDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_CreateDir/VB/dir_createdir.vb#1)]  
  
 Um das Verzeichnis C:\Users\User1\Public\Html zu erstellen, wenn das aktuelle Verzeichnis C:\Users\User1 ist, verwenden Sie eine der folgenden Aufrufe, stellen Sie sicher, dass der umgekehrte Schrägstrich ordnungsgemäß interpretiert wird.  
  
 In Visual Basic:  
  
```  
Directory.CreateDirectory("Public\Html")   
    Directory.CreateDirectory("\Users\User1\Public\Html")   
    Directory.CreateDirectory("c:\Users\User1\Public\Html")  
```  
  
 In C#:  
  
```  
Directory.CreateDirectory("Public\\Html");  
    Directory.CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory.CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 In C++:  
  
```  
Directory::CreateDirectory("Public\\Html");  
    Directory::CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory::CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Das durch <paramref name="path" /> angegebene Verzeichnis ist eine Datei.  Oder:  Der Netzwerkname ist nicht bekannt.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  Oder:  <paramref name="path" /> ist ein Doppelpunkt (:) vorangestellt bzw. enthält nur einen Doppelpunkt.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> enthält einen Doppelpunkt (:), der nicht Teil einer Laufwerksbezeichnung ist („C:\\“).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen und Schreiben von Dateien oder Verzeichnisse. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ CreateDirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="static member CreateDirectory : string * System.Security.AccessControl.DirectorySecurity -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.CreateDirectory (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="path">Das zu erstellende Verzeichnis.</param>
        <param name="directorySecurity">Die Zugriffssteuerung, die auf das Verzeichnis angewendet werden soll.</param>
        <summary>Erstellt alle Verzeichnisse im angegebenen Pfad, sofern diese nicht bereits vorhanden sind, und übernimmt die angegebene Windows-Sicherheit.</summary>
        <returns>Ein Objekt, das das Verzeichnis im angegebenen Pfad darstellt. Dieses Objekt wird unabhängig davon zurückgegeben, ob ein Verzeichnis unter dem angegebenen Pfad bereits vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese methodenüberladung, ein Verzeichnis mit der Zugriffssteuerung zu erstellen, daher ist es nicht möglich, die das Verzeichnis zugegriffen werden kann, bevor die Sicherheit angewendet wird.  
  
 Alle Verzeichnisse im angegebenen die `path` Parameter werden erstellt, es sei denn, sie sind bereits vorhanden oder eines Teils des `path` ist ungültig. Die `path` Parameter gibt einen Verzeichnispfad, kein Dateipfad an. Wenn das Verzeichnis bereits vorhanden ist, diese Methode ein neues Verzeichnis keine erstellt, aber es gibt eine <xref:System.IO.DirectoryInfo> -Objekt für das vorhandene Verzeichnis.  
  
 Nachgestellte Leerzeichen entfernt werden, am Ende der `path` -Parameter vor dem Erstellen des Verzeichnisses.  
  
 Sie können ein Verzeichnis auf einem Remotecomputer, auf eine Freigabe erstellen, denen Sie über Schreibzugriff zu verfügen. UNC-Pfade werden unterstützt. Sie können beispielsweise angeben, die folgenden `path`: `\\2009\Archives\December` in Visual Basic und `\\\\2009\\Archives\\December` in C# geschrieben.  
  
 Erstellen ein Verzeichnis mit nur den Doppelpunkt (:) wird nicht unterstützt und bewirkt, dass eine `NotSupportedException` ausgelöst wird.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues Verzeichnis mit den Regeln für den Zugriff für zwei Benutzerkonten.  
  
 [!code-csharp[System.IO.Directory#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class7.cs#15)]
 [!code-vb[System.IO.Directory#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class7.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Das durch <paramref name="path" /> angegebene Verzeichnis ist eine Datei.  Oder:  Der Netzwerkname ist nicht bekannt.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  Oder:  <paramref name="path" /> ist ein Doppelpunkt (:) vorangestellt bzw. enthält nur einen Doppelpunkt.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> enthält einen Doppelpunkt (:), der nicht Teil einer Laufwerksbezeichnung ist („C:\\“).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Lesen und Schreiben von Dateien und Verzeichnisse und für den Zugriff auf das Zielverzeichnis. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht ein angegebenes Verzeichnis und optional alle Unterverzeichnisse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.IO.Directory.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Name des zu entfernenden leeren Verzeichnisses. Dieses Verzeichnis muss schreibbar und leer sein.</param>
        <summary>Löscht ein leeres Verzeichnis aus einem angegebenen Pfad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verhält sich genauso wie <xref:System.IO.Directory.Delete%28System.String%2CSystem.Boolean%29> mit `false` für den zweiten Parameter angegeben.  
  
 Die `path` Parameter kann ein relativer oder absoluter Pfadinformationen angeben. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Nachgestellte Leerzeichen entfernt werden, am Ende der `path` -Parameter vor dem Löschen des Verzeichnisses.  
  
 Diese Methode löst eine <xref:System.IO.IOException> , wenn das Verzeichnis im angegebenen die `path` Parameter enthält, Dateien oder Unterverzeichnisse.  
  
 Die `path` Parameter wird nicht beachtet.  
  
 In einigen Fällen, wenn Sie das angegebene Verzeichnis im Datei-Explorer geöffnet haben die <xref:System.IO.Directory.Delete%2A> Methode kann nicht in der Lage, um ihn zu löschen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie ein neues Verzeichnis und Unterverzeichnissen zu erstellen und löschen Sie nur das Unterverzeichnis.  
  
 [!code-csharp[System.IO.Directory.Delete#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class1.cs#1)]
 [!code-vb[System.IO.Directory.Delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Es gibt eine Datei, die denselben Namen und Speicherort hat wie in <paramref name="path" /> angegeben.  Oder:  Das Verzeichnis ist das aktuelle Arbeitsverzeichnis der Anwendung.  Oder:  Das von <paramref name="path" /> angegebene Verzeichnis ist nicht leer.  Oder:  Das Verzeichnis ist schreibgeschützt oder enthält eine schreibgeschützte Datei.  Oder:  Das Verzeichnis wird von einem anderen Prozess verwendet.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist nicht vorhanden oder wurde nicht gefunden.  Oder:  Der angegebene Pfad ist ungültig (er befindet sich z.B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in das angegebene Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path, bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path, bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String, recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path, bool recursive);" />
      <MemberSignature Language="F#" Value="static member Delete : string * bool -&gt; unit" Usage="System.IO.Directory.Delete (path, recursive)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Der Name des zu entfernenden Verzeichnisses.</param>
        <param name="recursive">
          <see langword="true" />, um Verzeichnisse, Unterverzeichnisse und Dateien in <c>path</c> zu entfernen; andernfalls <see langword="false" />.</param>
        <summary>Löscht das angegebene Verzeichnis und, sofern angegeben, alle Unterverzeichnisse und Dateien im Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter kann ein relativer oder absoluter Pfadinformationen angeben. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Nachgestellte Leerzeichen entfernt werden, am Ende der `path` -Parameter vor dem Löschen des Verzeichnisses.  
  
 Die `path` Parameter wird nicht beachtet.  
  
 Wenn die `recursive` Parameter `true`, der Benutzer muss über Schreibberechtigungen für das aktuelle Verzeichnis als auch für alle Unterverzeichnisse verfügen.  
  
 Das Verhalten dieser Methode unterscheidet sich geringfügig, wenn Sie ein Verzeichnis zu löschen, die einen Analysepunkt, z. B. eine symbolische Verknüpfung oder einen Bereitstellungspunkt enthält. Wenn Sie der Analysepunkt auf ein Verzeichnis ist, wird z. B. einen Bereitstellungspunkt wird aufgehoben, und der Bereitstellungspunkt wird gelöscht. Diese Methode wird über den Analysepunkt nicht rekursiv. Der Analysepunkt wird gelöscht, ist der Analysepunkt eine symbolische Verknüpfung zu einer Datei, und nicht das Ziel der symbolischen Verknüpfung.  
  
 In einigen Fällen, wenn Sie das angegebene Verzeichnis im Datei-Explorer geöffnet haben die <xref:System.IO.Directory.Delete%2A> Methode kann nicht in der Lage, um ihn zu löschen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie ein neues Verzeichnis, die Unterverzeichnis und die Datei im Unterverzeichnis erstellen, und klicken Sie dann rekursiv für alle neuen Elemente löschen.  
  
 [!code-csharp[System.IO.Directory.Delete#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class2.cs#2)]
 [!code-vb[System.IO.Directory.Delete#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Es gibt eine Datei, die denselben Namen und Speicherort hat wie in <paramref name="path" /> angegeben.  Oder:  Das von <paramref name="path" /> angegebene Verzeichnis ist schreibgeschützt, oder <paramref name="recursive" /> ist <see langword="false" />, und <paramref name="path" /> ist kein leeres Verzeichnis.  Oder:  Das Verzeichnis ist das aktuelle Arbeitsverzeichnis der Anwendung.  Oder:  Das Verzeichnis enthält eine schreibgeschützte Datei.  Oder:  Das Verzeichnis wird von einem anderen Prozess verwendet.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist nicht vorhanden oder wurde nicht gefunden.  Oder:  Der angegebene Pfad ist ungültig (er befindet sich z.B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in das angegebene Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine aufzählbare Auflistung von Verzeichnisnamen zurück, die bestimmte Kriterien erfüllen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Gibt eine aufzählbare Auflistung von Verzeichnisnamen in einem angegebenen Pfad zurück.</summary>
        <returns>Eine aufzählbare Auflistung der vollständigen Namen (einschließlich Pfade) für die Verzeichnisse im Verzeichnis, das von <paramref name="path" /> angegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können angeben, relative oder absolute Pfad der Informationen in den `path` Parameter. Informationen über relative Pfade relativ zum aktuellen Arbeitsverzeichnis, die Sie ermitteln können, indem Sie mithilfe von interpretiert die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode. Die Namen der zurückgegebenen Verzeichnisse mit dem Wert in angegebenen Präfix der `path` Parameter. Angenommen, Sie geben Sie einen relativen Pfad in der `path` Parameter zurückgegebenen Verzeichnisnamen enthält einen relativen Pfad.  
  
 Die <xref:System.IO.Directory.EnumerateDirectories%2A> und <xref:System.IO.Directory.GetDirectories%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateDirectories%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird; bei Verwendung von <xref:System.IO.Directory.GetDirectories%2A>, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund werden, wenn Sie arbeiten mit vielen Dateien und Verzeichnissen, <xref:System.IO.Directory.EnumerateDirectories%2A> kann effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. Jeder Aufruf der <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> startet in der Auflistung eine neue Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel listet die Verzeichnisse der obersten Ebene in einem angegebenen Pfad.  
  
 [!code-csharp[System.IO.EnumDirs1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs1/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs1/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateDirectories (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Verzeichnissen in <c>path</c> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <summary>Gibt eine aufzählbare Auflistung von Verzeichnisnamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen.</summary>
        <returns>Eine aufzählbare Auflistung der vollständigen Namen (einschließlich Pfade) für die Verzeichnisse im Verzeichnis, das von <paramref name="path" /> angegebenen wird und der angegebene Suchmuster entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Bezeichner für die Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|Kein oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als Platzhalter lauten wie folgt. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
 `searchPattern` darf nicht mit zwei Punkten enden ("..") oder zwei Punkte enthalten ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, und er darf keine ungültigen Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Sie können angeben, relative oder absolute Pfad der Informationen in den `path` Parameter. Informationen über relative Pfade relativ zum aktuellen Arbeitsverzeichnis, die Sie ermitteln können, indem Sie mithilfe von interpretiert die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode. Die Namen der zurückgegebenen Verzeichnisse mit dem Wert in angegebenen Präfix der `path` Parameter. Angenommen, Sie geben Sie einen relativen Pfad in der `path` Parameter zurückgegebenen Verzeichnisnamen enthält einen relativen Pfad.  
  
 Die <xref:System.IO.Directory.EnumerateDirectories%2A> und <xref:System.IO.Directory.GetDirectories%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateDirectories%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird; bei Verwendung von <xref:System.IO.Directory.GetDirectories%2A>, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund werden, wenn Sie arbeiten mit vielen Dateien und Verzeichnissen, <xref:System.IO.Directory.EnumerateDirectories%2A> kann effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. Jeder Aufruf der <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> startet in der Auflistung eine neue Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel listet die Verzeichnisse der obersten Ebene in einem angegebenen Pfad, die einem angegebenen Suchmuster entsprechen.  
  
 [!code-csharp[System.IO.EnumDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs2/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs2/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  Oder:  <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.  Oder:  <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateDirectories : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateDirectories (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Verzeichnissen in <c>path</c> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen.  Der Standardwert ist <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Gibt eine aufzählbare Auflistung von Verzeichnisnamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen. Optional werden Unterverzeichnisse durchsucht.</summary>
        <returns>Eine aufzählbare Auflistung der vollständigen Namen (einschließlich Pfade) für die Verzeichnisse im Verzeichnis, die von <paramref name="path" /> angegebenen werden und dem angegebenen Suchmuster und der angegebenen Option entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Bezeichner für die Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|Genau ein Zeichen an dieser Position.|  
  
 Andere Zeichen als Platzhalter lauten wie folgt. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
 `searchPattern` darf nicht mit zwei Punkten enden ("..") oder zwei Punkte enthalten ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, und er darf keine ungültigen Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Sie können angeben, relative oder absolute Pfad der Informationen in den `path` Parameter. Informationen über relative Pfade relativ zum aktuellen Arbeitsverzeichnis, die Sie ermitteln können, indem Sie mithilfe von interpretiert die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode. Die Namen der zurückgegebenen Verzeichnisse mit dem Wert in angegebenen Präfix der `path` Parameter. Angenommen, Sie geben Sie einen relativen Pfad in der `path` Parameter zurückgegebenen Verzeichnisnamen enthält einen relativen Pfad.  
  
 Die <xref:System.IO.Directory.EnumerateDirectories%2A> und <xref:System.IO.Directory.GetDirectories%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateDirectories%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird; bei Verwendung von <xref:System.IO.Directory.GetDirectories%2A>, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund werden, wenn Sie arbeiten mit vielen Dateien und Verzeichnissen, <xref:System.IO.Directory.EnumerateDirectories%2A> kann effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. Jeder Aufruf der <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> startet in der Auflistung eine neue Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel listet die Verzeichnisse in einem angegebenen Pfad, die einem angegebenen Suchmuster entsprechen. Er verwendet den `searchOption` Parameter, um anzugeben, dass alle Unterverzeichnisse in die Suche einbezogen werden sollen.  
  
 [!code-csharp[System.IO.EnumDirs3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs3/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs3/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  Oder:  <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.  Oder:  <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine aufzählbare Auflistung von Dateinamen zurück, die bestimmte Kriterien erfüllen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Gibt eine aufzählbare Auflistung von Dateinamen in einem angegebenen Pfad zurück.</summary>
        <returns>Eine aufzählbare Auflistung der vollständigen Namen (einschließlich Pfade) für die Verzeichnisse im Verzeichnis, das von <paramref name="path" /> angegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können mit relativen Pfadinformationen angeben der `path` Parameter. Informationen über relative Pfade relativ zum aktuellen Arbeitsverzeichnis, die Sie ermitteln können, indem Sie mithilfe von interpretiert die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode.  
  
 Die <xref:System.IO.Directory.EnumerateFiles%2A> und <xref:System.IO.Directory.GetFiles%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFiles%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird; bei Verwendung von <xref:System.IO.Directory.GetFiles%2A>, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund werden, wenn Sie arbeiten mit vielen Dateien und Verzeichnissen, <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. Jeder Aufruf der <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> startet in der Auflistung eine neue Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie alle Dateien in einem Verzeichnis abzurufen und in ein neues Verzeichnis verschieben. Nachdem die Dateien verschoben werden, sind sie nicht mehr in das ursprüngliche Verzeichnis vorhanden.  
  
 [!code-csharp[System.IO.Directory#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class4.cs#12)]
 [!code-vb[System.IO.Directory#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class4.vb#12)]  
  
 Das folgende Beispiel listet die Dateien in das angegebene Verzeichnis liest jede Zeile der Datei und zeigt die Codezeile aus, wenn sie die Zeichenfolge "Europe" enthält.  
  
 [!code-csharp[System.IO.Directory.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFiles (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien in <c>path</c> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <summary>Gibt eine aufzählbare Auflistung von Dateinamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen.</summary>
        <returns>Eine aufzählbare Auflistung der vollständigen Namen (einschließlich Pfade) für die Dateien im Verzeichnis, das von <paramref name="path" /> angegebenen wird und dem angegebenen Suchmuster entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Bezeichner für die Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|Kein oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als Platzhalter lauten wie folgt. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
> [!NOTE]
>  Bei Verwendung des Platzhalterzeichens Sternchen in einem `searchPattern` wie z. B. "\*.txt", die Anzahl der Zeichen in der angegebenen Erweiterung wirkt sich folgendermaßen auf die Suche:  
>   
>  -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, erfolgt die Methodenrückgabe Dateien mit Erweiterungen, die beginnen mit der angegebenen Erweiterung aus. Z. B. "\*xls" sowohl "book.xls" und "book.xlsx" zurückgegeben.  
> -   In allen anderen Fällen gibt die Methode die Dateien, die die angegebene Erweiterung genau entsprechen. Z. B. "\*AI" gibt "file.ai" aber nicht "file.aif" zurück.  
>   
>  Wenn Sie das Fragezeichen-Platzhalterzeichen verwenden, gibt diese Methode nur die Dateien, die die angegebene Dateierweiterung entsprechen. Angenommen, zwei Dateien: "file1.txt" und "file1.txtother", in einem Verzeichnis, die einem Suchmuster von "Datei?. TXT"gibt nur die erste Datei zurück, während ein Suchmuster von" Datei\*.txt "beide Dateien zurückgegeben.  
  
 `searchPattern` darf nicht mit zwei Punkten enden ("..") oder zwei Punkte enthalten ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, und er darf keine ungültigen Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Sie können mit relativen Pfadinformationen angeben der `path` Parameter. Informationen über relative Pfade relativ zum aktuellen Arbeitsverzeichnis, die Sie ermitteln können, indem Sie mithilfe von interpretiert die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode.  
  
 Die <xref:System.IO.Directory.EnumerateFiles%2A> und <xref:System.IO.Directory.GetFiles%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFiles%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird; bei Verwendung von <xref:System.IO.Directory.GetFiles%2A>, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund werden, wenn Sie arbeiten mit vielen Dateien und Verzeichnissen, <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. Jeder Aufruf der <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> startet in der Auflistung eine neue Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie alle Textdateien in einem Verzeichnis abzurufen und in ein neues Verzeichnis verschieben. Nachdem die Dateien verschoben werden, sind sie nicht mehr in das ursprüngliche Verzeichnis vorhanden.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 Im folgenden Beispiel wird die Dateien im angegebenen Verzeichnis aufgeführt werden, die Erweiterung TXT, liest jeder Zeile der Datei und zeigt die Codezeile aus, wenn sie die Zeichenfolge "Europe" enthält.  
  
 [!code-csharp[System.IO.Directory.EnumFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles2/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles2/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  Oder:  <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.  Oder:  <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateFiles : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFiles (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien in <c>path</c> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen.  Der Standardwert ist <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Gibt eine aufzählbare Auflistung von Dateinamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen. Optional werden Unterverzeichnisse durchsucht.</summary>
        <returns>Eine aufzählbare Auflistung der vollständigen Namen (einschließlich Pfade) für die Dateien im Verzeichnis, die von <paramref name="path" /> angegebenen werden und dem angegebenen Suchmuster und der angegebenen Option entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Bezeichner für die Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|Kein oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als Platzhalter lauten wie folgt. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
> [!NOTE]
>  Bei Verwendung des Platzhalterzeichens Sternchen in einem `searchPattern` wie z. B. "\*.txt", die Anzahl der Zeichen in der angegebenen Erweiterung wirkt sich folgendermaßen auf die Suche:  
>   
>  -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, erfolgt die Methodenrückgabe Dateien mit Erweiterungen, die beginnen mit der angegebenen Erweiterung aus. Z. B. "\*xls" sowohl "book.xls" und "book.xlsx" zurückgegeben.  
> -   In allen anderen Fällen gibt die Methode die Dateien, die die angegebene Erweiterung genau entsprechen. Z. B. "\*AI" gibt "file.ai" aber nicht "file.aif" zurück.  
>   
>  Wenn Sie das Fragezeichen-Platzhalterzeichen verwenden, gibt diese Methode nur die Dateien, die die angegebene Dateierweiterung entsprechen. Angenommen, zwei Dateien: "file1.txt" und "file1.txtother", in einem Verzeichnis, die einem Suchmuster von "Datei?. TXT"gibt nur die erste Datei zurück, während ein Suchmuster von" Datei\*.txt "beide Dateien zurückgegeben.  
  
 `searchPattern` darf nicht mit zwei Punkten enden ("..") oder zwei Punkte enthalten ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, und er darf keine ungültigen Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Sie können mit relativen Pfadinformationen angeben der `path` Parameter. Informationen über relative Pfade relativ zum aktuellen Arbeitsverzeichnis, die Sie ermitteln können, indem Sie mithilfe von interpretiert die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode.  
  
 Die <xref:System.IO.Directory.EnumerateFiles%2A> und <xref:System.IO.Directory.GetFiles%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFiles%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird; bei Verwendung von <xref:System.IO.Directory.GetFiles%2A>, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund werden, wenn Sie arbeiten mit vielen Dateien und Verzeichnissen, <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. Jeder Aufruf der <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> startet in der Auflistung eine neue Enumeration.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie alle Textdateien in einem Verzeichnis und seinen Unterverzeichnissen abgerufen und in ein neues Verzeichnis verschieben. Nachdem die Dateien verschoben werden, ist sie nicht mehr in den ursprünglichen Verzeichnissen vorhanden.  
  
 [!code-csharp[System.IO.Directory#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class5.cs#13)]
 [!code-vb[System.IO.Directory#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class5.vb#13)]  
  
 Das folgende Beispiel rekursiv alle Dateien aufgeführt werden, die Erweiterung TXT, liest jeder Zeile der Datei und zeigt die Codezeile aus, wenn sie die Zeichenfolge "Microsoft" enthält.  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  Oder:  <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.  Oder:  <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine aufzählbare Auflistung von Dateisystemeinträgen zurück, die bestimmte Kriterien erfüllen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Gibt eine aufzählbare Auflistung von Dateinamen und Verzeichnisnamen in einem angegebenen Pfad zurück.</summary>
        <returns>Eine aufzählbare Auflistung von Dateisystemeinträgen im von <paramref name="path" /> angegebenen Verzeichnis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können mit relativen Pfadinformationen angeben der `path` Parameter. Informationen über relative Pfade relativ zum aktuellen Arbeitsverzeichnis, die Sie ermitteln können, indem Sie mithilfe von interpretiert die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode.  
  
 Die <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> und <xref:System.IO.Directory.GetFileSystemEntries%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, können Sie anfangen, die Auflistung von Einträgen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird; bei Verwendung von <xref:System.IO.Directory.GetFileSystemEntries%2A>, müssen Sie warten, bis das gesamte Array von Einträgen, die zurückgegeben Sie werden, bevor Sie das Array zugreifen können. Aus diesem Grund werden, wenn Sie arbeiten mit vielen Dateien und Verzeichnissen, <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. Jeder Aufruf der <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> startet in der Auflistung eine neue Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnumerateFileSystemEntries (path As String, searchPattern As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateisystemeinträgen in <c>path</c> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <summary>Gibt eine aufzählbare Auflistung von Dateinamen und Verzeichnisnamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen.</summary>
        <returns>Eine aufzählbare Auflistung von Dateisystemeinträgen, die sich in dem von <paramref name="path" /> angegebenen Verzeichnis befinden und dem angegebenen Suchmuster entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Bezeichner für die Platzhalter sind zulässig, `searchPattern`...  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|Kein oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als Platzhalter lauten wie folgt. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
> [!NOTE]
>  Bei Verwendung des Platzhalterzeichens Sternchen in einem `searchPattern` wie z. B. "\*.txt", die Anzahl der Zeichen in der angegebenen Erweiterung wirkt sich folgendermaßen auf die Suche:  
>   
>  -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, erfolgt die Methodenrückgabe Dateien mit Erweiterungen, die beginnen mit der angegebenen Erweiterung aus. Z. B. "\*xls" sowohl "book.xls" und "book.xlsx" zurückgegeben.  
> -   In allen anderen Fällen gibt die Methode die Dateien, die die angegebene Erweiterung genau entsprechen. Z. B. "\*AI" gibt "file.ai" aber nicht "file.aif" zurück.  
>   
>  Wenn Sie das Fragezeichen-Platzhalterzeichen verwenden, gibt diese Methode nur die Dateien, die die angegebene Dateierweiterung entsprechen. Angenommen, zwei Dateien: "file1.txt" und "file1.txtother", in einem Verzeichnis, die einem Suchmuster von "Datei?. TXT"gibt nur die erste Datei zurück, während ein Suchmuster von" Datei\*.txt "beide Dateien zurückgegeben.  
  
 `searchPattern` darf nicht mit zwei Punkten enden ("..") oder zwei Punkte enthalten ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, und er darf keine ungültigen Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Sie können mit relativen Pfadinformationen angeben der `path` Parameter. Informationen über relative Pfade relativ zum aktuellen Arbeitsverzeichnis, die Sie ermitteln können, indem Sie mithilfe von interpretiert die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode.  
  
 Die <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> und <xref:System.IO.Directory.GetFileSystemEntries%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, können Sie anfangen, die Auflistung von Einträgen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird; bei Verwendung von <xref:System.IO.Directory.GetFileSystemEntries%2A>, müssen Sie warten, bis das gesamte Array von Einträgen, die zurückgegeben Sie werden, bevor Sie das Array zugreifen können. Aus diesem Grund werden, wenn Sie arbeiten mit vielen Dateien und Verzeichnissen, <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. Jeder Aufruf der <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> startet in der Auflistung eine neue Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  Oder:  <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.  Oder:  <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string * System.IO.EnumerationOptions -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ EnumerateFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member EnumerateFileSystemEntries : string * string * System.IO.SearchOption -&gt; seq&lt;string&gt;" Usage="System.IO.Directory.EnumerateFileSystemEntries (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung von Dateisystemeinträgen in <c>path</c> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen.  Der Standardwert ist <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Gibt eine aufzählbare Auflistung von Dateinamen und Verzeichnisnamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen. Optional werden Unterverzeichnisse durchsucht.</summary>
        <returns>Eine aufzählbare Auflistung von Dateisystemeinträgen, die sich in dem von <paramref name="path" /> angegebenen Verzeichnis befinden und dem angegebenen Suchmuster und der angegebenen Option entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Bezeichner für die Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|Kein oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als Platzhalter lauten wie folgt. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
> [!NOTE]
>  Bei Verwendung des Platzhalterzeichens Sternchen in einem `searchPattern` wie z. B. "\*.txt", die Anzahl der Zeichen in der angegebenen Erweiterung wirkt sich folgendermaßen auf die Suche:  
>   
>  -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, erfolgt die Methodenrückgabe Dateien mit Erweiterungen, die beginnen mit der angegebenen Erweiterung aus. Z. B. "\*xls" sowohl "book.xls" und "book.xlsx" zurückgegeben.  
> -   In allen anderen Fällen gibt die Methode die Dateien, die die angegebene Erweiterung genau entsprechen. Z. B. "\*AI" gibt "file.ai" aber nicht "file.aif" zurück.  
>   
>  Wenn Sie das Fragezeichen-Platzhalterzeichen verwenden, gibt diese Methode nur die Dateien, die die angegebene Dateierweiterung entsprechen. Angenommen, zwei Dateien: "file1.txt" und "file1.txtother", in einem Verzeichnis, die einem Suchmuster von "Datei?. TXT"gibt nur die erste Datei zurück, während ein Suchmuster von" Datei\*.txt "beide Dateien zurückgegeben.  
  
 `searchPattern` darf nicht mit zwei Punkten enden ("..") oder zwei Punkte enthalten ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, und er darf keine ungültigen Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Sie können mit relativen Pfadinformationen angeben der `path` Parameter. Informationen über relative Pfade relativ zum aktuellen Arbeitsverzeichnis, die Sie ermitteln können, indem Sie mithilfe von interpretiert die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode.  
  
 Die <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> und <xref:System.IO.Directory.GetFileSystemEntries%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, können Sie anfangen, die Auflistung von Einträgen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird; bei Verwendung von <xref:System.IO.Directory.GetFileSystemEntries%2A>, müssen Sie warten, bis das gesamte Array von Einträgen, die zurückgegeben Sie werden, bevor Sie das Array zugreifen können. Aus diesem Grund werden, wenn Sie arbeiten mit vielen Dateien und Verzeichnissen, <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Die zurückgegebene Auflistung wird nicht zwischengespeichert. Jeder Aufruf der <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> startet in der Auflistung eine neue Enumeration.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  Oder:  <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.  Oder:  <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.IO.Directory.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der zu testende Pfad.</param>
        <summary>Bestimmt, ob der angegebene Pfad auf ein vorhandenes Verzeichnis auf einem Datenträger verweist.</summary>
        <returns>
          <see langword="true" />, wenn sich <paramref name="path" /> auf ein vorhandenes Verzeichnis bezieht; <see langword="false" />, wenn ein Verzeichnis nicht vorhanden ist, oder wenn beim Versuch festzustellen, ob ein angegebenes Verzeichnis vorhanden ist, ein Fehler auftritt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter dürfen relativer oder absoluter Pfad angegeben werden. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert.  
  
 Nachgestellte Leerzeichen entfernt werden, am Ende der `path` -Parameter vor dem Überprüfen, ob das Verzeichnis vorhanden ist.  
  
 Die `path` Parameter wird nicht beachtet.  
  
 Wenn Sie nicht mindestens über eine nur-Lese Berechtigung in das Verzeichnis, verfügen die <xref:System.IO.Directory.Exists%2A> Methode zurück `false`.  
  
 Die <xref:System.IO.Directory.Exists%2A> Methodenrückgabe `false` Wenn ein Fehler auftritt, bei dem Versuch, um festzustellen, ob die angegebene Datei vorhanden ist. Dies kann auftreten, in Situationen, in denen Auslösen von Ausnahmen, z. B. ein Dateiname ungültige Zeichen oder zu viele Zeichen, eine fehlerhafte oder fehlende Datenträger übergeben oder wenn der Aufrufer keine Berechtigung zum Lesen der Datei.  
  
   
  
## Examples  
 Im folgende Beispiel wird ein Array von Datei- bzw. Verzeichnisnamen in der Befehlszeile, bestimmt, welche Art von Namen dabei handelt es sich, verarbeitet sie entsprechend.  
  
 [!code-cpp[Recursive file finder#2](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#2)]
 [!code-csharp[Recursive file finder#2](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#2)]
 [!code-vb[Recursive file finder#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen von Dateien. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die Windows-Zugriffssteuerungsliste für ein Verzeichnis zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string -&gt; System.Security.AccessControl.DirectorySecurity" Usage="System.IO.Directory.GetAccessControl path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad zu einem Verzeichnis, das ein <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt enthält, das die Informationen zu einer Zugriffssteuerungsliste der Datei beschreibt.</param>
        <summary>Ruft ein <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt ab, das die ACL-Einträge für ein angegebenes Verzeichnis kapselt.</summary>
        <returns>Ein Objekt, das die Zugriffssteuerungsregeln für die vom <paramref name="path" />-Parameter beschriebene Datei kapselt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.IO.Directory.GetAccessControl%2A> Methode, um die Einträge in der Zugriffssteuerungsliste (ACL) für ein Verzeichnis abzurufen.  
  
 Eine ACL beschreibt Personen bzw. Gruppen besitzen oder verfügen nicht über, Rechte für bestimmte Aktionen für die angegebene Datei oder das Verzeichnis an. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 In Umgebungen mit NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> werden dem Benutzer erteilt, wenn der Benutzer hat <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> Rechte für den übergeordneten Ordner. Verweigern <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Verweigern <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> für das übergeordnete Verzeichnis.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.Directory.GetAccessControl%2A> und <xref:System.IO.Directory.SetAccessControl%2A> Methoden zum Hinzufügen eines Eintrags der Zugriffssteuerungsliste (ACL) zu steuern und entfernen Sie dann einen ACL-Eintrag aus einem Verzeichnis.  Sie müssen ein gültiges Benutzer- oder Gruppenkonto angeben, um dieses Beispiel auszuführen.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler beim Öffnen des Verzeichnisses.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows 2000 oder höher.</exception>
        <exception cref="T:System.SystemException">Ein Fehler auf Systemebene ist aufgetreten, z. B. konnte das Verzeichnis nicht gefunden werden. Die spezifische Ausnahme ist möglicherweise eine Unterklasse von <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der <paramref name="path" />-Parameter hat ein schreibgeschütztes Verzeichnis angegeben.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Berechtigung zum Auflisten der Zugriffssteuerungsliste (ACL) für ein Verzeichnis. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" /> Sicherheitsaktion: bei Bedarf.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String, includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::String ^ path, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="static member GetAccessControl : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.DirectorySecurity" Usage="System.IO.Directory.GetAccessControl (path, includeSections)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad zu einem Verzeichnis, das ein <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt enthält, das die Informationen zu einer Zugriffssteuerungsliste der Datei beschreibt.</param>
        <param name="includeSections">Einer der <see cref="T:System.Security.AccessControl.AccessControlSections" />-Werte, der den Typ der zu empfangenden ACL-Informationen angibt.</param>
        <summary>Ruft ein <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt ab, das die angegebenen Typen von Einträgen in einer Zugriffssteuerungsliste für ein angegebenes Verzeichnis kapselt.</summary>
        <returns>Ein Objekt, das die Zugriffssteuerungsregeln für die vom <paramref name="path" />-Parameter beschriebene Datei kapselt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.IO.Directory.GetAccessControl%2A> Methode, um die Einträge in der Zugriffssteuerungsliste (ACL) für ein Verzeichnis abzurufen.  
  
 Eine ACL beschreibt Personen bzw. Gruppen besitzen oder verfügen nicht über, Rechte für bestimmte Aktionen für die angegebene Datei oder das Verzeichnis an. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 In Umgebungen mit NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> werden dem Benutzer erteilt, wenn der Benutzer hat <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> Rechte für den übergeordneten Ordner. Verweigern <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Verweigern <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> für das übergeordnete Verzeichnis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="path" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler beim Öffnen des Verzeichnisses.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows 2000 oder höher.</exception>
        <exception cref="T:System.SystemException">Ein Fehler auf Systemebene ist aufgetreten, z. B. konnte das Verzeichnis nicht gefunden werden. Die spezifische Ausnahme ist möglicherweise eine Unterklasse von <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der <paramref name="path" />-Parameter hat ein schreibgeschütztes Verzeichnis angegeben.  Oder:  Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  Oder:  Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Berechtigung zum Auflisten der Zugriffssteuerungsliste (ACL) für ein Verzeichnis. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" /> Sicherheitsaktion: bei Bedarf.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTime : string -&gt; DateTime" Usage="System.IO.Directory.GetCreationTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad des Verzeichnisses.</param>
        <summary>Ruft Datum und Zeit der Erstellung eines Verzeichnisses ab.</summary>
        <returns>Eine Struktur, die auf das Erstellungsdatum und den Erstellungszeitpunkt für das angegebene Verzeichnis festgelegt wird. Dieser Wert wird in Ortszeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode kann einen fehlerhaften Wert, zurück, da sie systemeigene Funktionen verwendet, deren Werte nicht kontinuierlich durch das Betriebssystem aktualisiert werden können.  
  
 Diese Methode entspricht dem <xref:System.IO.File.GetCreationTime%2A?displayProperty=nameWithType>.  
  
 Wenn das Verzeichnis in beschrieben die `path` Parameter ist nicht vorhanden, diese Methode gibt zurück, 0:00 Uhr, 1. Januar 1601 n. Chr. (C.E.) Coordinated Universal Time (UTC), in die lokale Zeit angepasst.  
  
 Die `path` Parameter dürfen relativer oder absoluter Pfad angegeben werden. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter wird nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgende Beispiel ruft die Erstellungszeit des angegebenen Verzeichnisses ab.  
  
 [!code-cpp[Dir_GetCreation#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCreation/CPP/dir_getcreation.cpp#1)]
 [!code-csharp[Dir_GetCreation#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCreation/CS/dir_getcreation.cs#1)]
 [!code-vb[Dir_GetCreation#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCreation/VB/dir_getcreation.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen der Datei oder das Verzeichnis an. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetCreationTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetCreationTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad des Verzeichnisses.</param>
        <summary>Ruft das Erstellungsdatum und den Erstellungszeitpunkt im UTC-Format (Coordinated Universal Time, koordinierte Weltzeit) eines Verzeichnisses ab.</summary>
        <returns>Eine Struktur, die auf das Erstellungsdatum und den Erstellungszeitpunkt für das angegebene Verzeichnis festgelegt wird. Der Wert wird in UTC-Zeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode kann einen fehlerhaften Wert, zurück, da sie systemeigene Funktionen verwendet, deren Werte nicht kontinuierlich durch das Betriebssystem aktualisiert werden können.  
  
 Wenn das Verzeichnis in beschrieben die `path` Parameter ist nicht vorhanden, diese Methode gibt zurück, 0:00 Uhr, 1. Januar 1601 n. Chr. (C.E.) Koordinierte Weltzeit (UTC).  
  
 Verwenden Sie diese Methode, um den Zeitpunkt der Erstellung für ein Verzeichnis, das basierend auf der koordinierten Weltzeit (UTC) zu erhalten.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Unterschiede in der Ausgabe bei Verwendung der koordinierten Weltzeit (Coordinated Universal Time, UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen der Datei oder das Verzeichnis an. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static string GetCurrentDirectory ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCurrentDirectory() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentDirectory () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCurrentDirectory();" />
      <MemberSignature Language="F#" Value="static member GetCurrentDirectory : unit -&gt; string" Usage="System.IO.Directory.GetCurrentDirectory " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft das aktuelle Arbeitsverzeichnis der Anwendung ab.</summary>
        <returns>Eine Zeichenfolge, die den Pfad des aktuellen Arbeitsverzeichnisses enthält und nicht mit einem umgekehrten Schrägstrich (\\) endet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das aktuelle Verzeichnis unterscheidet sich von dem ursprünglichen Verzeichnis, das Sie aus dem der Prozess gestartet wurde.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `GetCurrentDirectory`-Methode veranschaulicht.  
  
 [!code-cpp[Dir_GetCurDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCurDir/CPP/dir_getcurdir.cpp#1)]
 [!code-csharp[Dir_GetCurDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCurDir/CS/dir_getcurdir.cs#1)]
 [!code-vb[Dir_GetCurDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCurDir/VB/dir_getcurdir.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist Windows CE, das keine Funktionalität für das aktuelle Verzeichnis enthält.  Diese Methode ist in .NET Compact Framework verfügbar, wird aber derzeit nicht unterstützt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Informationen über Pfade für das aktuelle Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die Namen der Unterverzeichnisse zurück, die die angegebenen Kriterien erfüllen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string -&gt; string[]" Usage="System.IO.Directory.GetDirectories path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Gibt die Namen der Unterverzeichnisse (einschließlich der Pfade) im angegebenen Verzeichnis zurück.</summary>
        <returns>Ein Array der vollständigen Namen (einschließlich der Pfade) der Unterverzeichnisse im angegebenen Pfad, oder ein leeres Array, wenn keine Verzeichnisse gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist identisch mit <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%29> durch ein Sternchen (\*) als das Suchmuster angegeben, daher wird allen Unterverzeichnissen. Verwenden Sie bei Bedarf in Unterverzeichnissen gesucht, die <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> -Methode, die Ihnen ermöglicht, geben Sie eine Suche in Unterverzeichnissen mit dem `searchOption` Parameter.  
  
 Die <xref:System.IO.Directory.EnumerateDirectories%2A> und <xref:System.IO.Directory.GetDirectories%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateDirectories%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird; bei Verwendung von <xref:System.IO.Directory.GetDirectories%2A>, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund werden, wenn Sie arbeiten mit vielen Dateien und Verzeichnissen, <xref:System.IO.Directory.EnumerateDirectories%2A> kann effizienter sein.  
  
 Die `path` Parameter relativer oder absoluter Pfad-Informationen angeben kann. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die Namen, die von dieser Methode zurückgegebene sind mit den im angegebenen Verzeichnis mit dem Präfix `path`.  
  
 Die `path` Parameter wird nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgende Beispiel wird ein Array von Datei- bzw. Verzeichnisnamen in der Befehlszeile, bestimmt, welche Art von Namen dabei handelt es sich, verarbeitet sie entsprechend.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Informationen über Pfade für das aktuelle Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectories (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Unterverzeichnissen in <c>path</c> auf Übereinstimmungen. Dieser Parameter kann eine Kombination aus gültigen Literal- und Platzhalterzeichen enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <summary>Gibt die Namen von Unterverzeichnissen (einschließlich der zugehörigen Pfade) zurück, die dem angegebenen Suchmuster im angegebenen Verzeichnis entsprechen.</summary>
        <returns>Ein Array der vollständigen Namen (einschließlich der Pfade) der Unterverzeichnisse, die dem Suchmuster im angegebenen Verzeichnis entsprechen, oder ein leeres Array, wenn keine Verzeichnisse gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt alle Unterverzeichnisse direkt unter dem angegebenen Verzeichnis, die das angegebenen Suchmuster entsprechen. Keine Unterverzeichnisse entsprechen, wenn das angegebene Verzeichnis ist keine Unterverzeichnisse der `searchPattern` Parameter dieser Methode ein leeres Array zurück. Es wird nur das oberste Verzeichnis durchsucht. Wenn Sie auch die Unterverzeichnisse durchsuchen möchten, verwenden Sie die <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> Methode, und geben Sie <xref:System.IO.SearchOption.AllDirectories> in die `searchOption` Parameter.  
  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Bezeichner für die Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|Kein oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als Platzhalter lauten wie folgt. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
 `searchPattern` darf nicht mit zwei Punkten enden ("..") oder zwei Punkte enthalten ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, und er darf keine ungültigen Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Die `path` Parameter relativer oder absoluter Pfadinformationen angeben können, und wird nicht beachtet.  Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die <xref:System.IO.Directory.EnumerateDirectories%2A> und <xref:System.IO.Directory.GetDirectories%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateDirectories%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird; bei Verwendung von <xref:System.IO.Directory.GetDirectories%2A>, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund werden, wenn Sie arbeiten mit vielen Dateien und Verzeichnissen, <xref:System.IO.Directory.EnumerateDirectories%2A> kann effizienter sein.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Anzahl der Verzeichnisse in einem Pfad, die mit dem angegebenen Buchstaben zu beginnen.  
  
 [!code-cpp[Dir_GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetDirs2/CPP/dir_getdirs2.cpp#1)]
 [!code-csharp[Dir_GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs2.cs#1)]
 [!code-vb[Dir_GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mit <see cref="M:System.IO.Path.GetInvalidPathChars" /> durchführen.  Oder:  <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> oder <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Informationen über Pfade für das aktuelle Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetDirectories(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetDirectories : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetDirectories (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Unterverzeichnissen in <c>path</c> auf Übereinstimmungen. Dieser Parameter kann eine Kombination aus gültigen Literal- und Platzhalterzeichen enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen.</param>
        <summary>Gibt die Namen der Unterverzeichnisse (einschließlich der Pfade) zurück, die dem angegebenen Suchmuster im aktuellen Verzeichnis entsprechen. Optional werden Unterverzeichnisse durchsucht.</summary>
        <returns>Ein Array der vollständigen Namen (einschließlich der Pfade) der Unterverzeichnisse, die den angegebenen Kriterien entsprechen, oder ein leeres Array, wenn keine Verzeichnisse gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfadinformationen angeben können, und wird nicht beachtet. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Bezeichner für die Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|Kein oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als Platzhalter lauten wie folgt. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
 `searchPattern` darf nicht mit zwei Punkten enden ("..") oder zwei Punkte enthalten ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, und er darf keine ungültigen Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
 Die <xref:System.IO.Directory.EnumerateDirectories%2A> und <xref:System.IO.Directory.GetDirectories%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateDirectories%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird; bei Verwendung von <xref:System.IO.Directory.GetDirectories%2A>, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund werden, wenn Sie arbeiten mit vielen Dateien und Verzeichnissen, <xref:System.IO.Directory.EnumerateDirectories%2A> kann effizienter sein.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Anzahl der Verzeichnisse, die mit dem angegebenen Buchstaben in einem Pfad zu beginnen. Es wird nur das Verzeichnis der obersten Ebene durchsucht.  
  
 [!code-csharp[Dir_GetDirs2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs3.cs#2)]
 [!code-vb[Dir_GetDirs2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  Oder:  <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> oder <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Informationen über Pfade für das aktuelle Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.IO.Directory.GetCurrentDirectory" />
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryRoot">
      <MemberSignature Language="C#" Value="public static string GetDirectoryRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectoryRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryRoot : string -&gt; string" Usage="System.IO.Directory.GetDirectoryRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad einer Datei oder eines Verzeichnisses.</param>
        <summary>Gibt für den angegebenen Pfad die Informationen über Volume, Stammverzeichnis oder beides zurück.</summary>
        <returns>Eine Zeichenfolge, die für den angegebenen Pfad die Informationen über Volume, Stammverzeichnis oder beides enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft den vollqualifizierten Pfadnamen der `path`, wie vom <xref:System.IO.Path.GetFullPath%2A>, und gibt Informationen zum Stammverzeichnis. Der angegebene Pfad ist nicht erforderlich, vorhanden sein.  
  
 Die `path` Parameter dürfen relativer oder absoluter Pfad angegeben werden. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter wird nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die legen das aktuelle Verzeichnis und den Verzeichnisstamm anzuzeigen.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mit <see cref="M:System.IO.Path.GetInvalidPathChars" /> durchführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Informationen über Pfade für das aktuelle Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die Namen der Dateien zurück, die die angegebenen Kriterien erfüllen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string -&gt; string[]" Usage="System.IO.Directory.GetFiles path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Gibt die Namen aller Dateien (einschließlich des Pfads) im angegebenen Verzeichnis zurück.</summary>
        <returns>Ein Array der vollständigen Namen (einschließlich der Pfade) für die Dateien im angegebenen Verzeichnis, oder ein leeres Array, wenn keine Dateien gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Directory.EnumerateFiles%2A> und <xref:System.IO.Directory.GetFiles%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFiles%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird; bei Verwendung von <xref:System.IO.Directory.GetFiles%2A>, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund werden, wenn Sie arbeiten mit vielen Dateien und Verzeichnissen, <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Die zurückgegebenen Dateinamen angefügt werden mit dem angegebenen `path` Parameter.  
  
 Diese Methode ist identisch mit <xref:System.IO.Directory.GetFiles%28System.String%2CSystem.String%29> durch ein Sternchen (\*) als das Suchmuster angegeben.  
  
 Die `path` Parameter relativer oder absoluter Pfad-Informationen angeben kann. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die Reihenfolge der zurückgegebenen Dateinamen ist nicht garantiert werden; Verwenden Sie die <xref:System.Array.Sort%2A> Methode, wenn keine bestimmte Sortierreihenfolge erforderlich ist.  
  
 Die `path` Parameter wird nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.IO.Directory.GetFiles%2A> Methode, um die Namen von einem Benutzer angegebenen Speicherort zurückzugeben. Im Beispiel ist zum Abfangen aller Fehler für diese Methode konfiguriert.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.  Oder:  Es ist ein Netzwerkfehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad wurde nicht gefunden oder ist ungültig (er befindet sich z. B.auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Informationen über Pfade für das aktuelle Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFiles (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien in <c>path</c> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <summary>Gibt die Namen der Dateien (einschließlich der zugehörigen Pfade) zurück, die dem angegebenen Suchmuster im angegebenen Verzeichnis entsprechen.</summary>
        <returns>Ein Array der vollständigen Namen der Dateien im angegebenen Verzeichnis (einschließlich der zugehörigen Pfade), die dem angegebenen Suchmuster entsprechen, oder ein leeres Array, wenn keine Dateien gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zurückgegebenen Dateinamen angefügt werden mit dem angegebenen `path` Parameter und die Reihenfolge der zurückgegebenen Dateinamen ist nicht garantiert; verwenden Sie die <xref:System.Array.Sort%2A> Methode, wenn keine bestimmte Sortierreihenfolge erforderlich ist.  
  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Bezeichner für die Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|Kein oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als Platzhalter lauten wie folgt. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
 `searchPattern` darf nicht mit zwei Punkten enden ("..") oder zwei Punkte enthalten ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, und er darf keine ungültigen Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
> [!NOTE]
>  Bei Verwendung des Platzhalterzeichens Sternchen in einem `searchPattern` wie z. B. "\*.txt", die Anzahl der Zeichen in der angegebenen Erweiterung wirkt sich folgendermaßen auf die Suche:  
>   
>  -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, erfolgt die Methodenrückgabe Dateien mit Erweiterungen, die beginnen mit der angegebenen Erweiterung aus. Z. B. "\*xls" sowohl "book.xls" und "book.xlsx" zurückgegeben.  
> -   In allen anderen Fällen gibt die Methode die Dateien, die die angegebene Erweiterung genau entsprechen. Z. B. "\*AI" gibt "file.ai" aber nicht "file.aif" zurück.  
>   
>  Wenn Sie das Fragezeichen-Platzhalterzeichen verwenden, gibt diese Methode nur die Dateien, die die angegebene Dateierweiterung entsprechen. Angenommen, zwei Dateien: "file1.txt" und "file1.txtother", in einem Verzeichnis, die einem Suchmuster von "Datei?. TXT"gibt nur die erste Datei zurück, während ein Suchmuster von" Datei\*.txt "beide Dateien zurückgegeben.  
  
> [!NOTE]
>  Da diese Methode für den Dateinamen mit der der 8.3-Namensformat und Format des lange Datei eincheckt, ein Suchmuster "\*1\*.txt" möglicherweise unerwartete Dateinamen zurück. Verwenden Sie beispielsweise ein Suchmuster von "\*1\*.txt" "longfilename.txt" zurückgegeben, da das Äquivalent der 8.3-Namensformat "LONGFI ~ 1.txt" lautet.  
  
 Die <xref:System.IO.Directory.EnumerateFiles%2A> und <xref:System.IO.Directory.GetFiles%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFiles%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird; bei Verwendung von <xref:System.IO.Directory.GetFiles%2A>, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund werden, wenn Sie arbeiten mit vielen Dateien und Verzeichnissen, <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Die `path` Parameter relativer oder absoluter Pfad-Informationen angeben kann. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter wird nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Anzahl der Dateien, die mit dem angegebenen Buchstaben zu beginnen.  
  
 [!code-cpp[Dir_GetFiles2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetFiles2/CPP/dir_getfiles2.cpp#1)]
 [!code-csharp[Dir_GetFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetFiles2/CS/dir_getfiles2.cs#1)]
 [!code-vb[Dir_GetFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetFiles2/VB/dir_getfiles2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.  Oder:  Es ist ein Netzwerkfehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mit <see cref="M:System.IO.Path.GetInvalidPathChars" /> durchführen.  Oder:  <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> oder <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad wurde nicht gefunden oder ist ungültig (er befindet sich z. B.auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Informationen über Pfade für das aktuelle Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFiles(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetFiles : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetFiles (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien in <c>path</c> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen.</param>
        <summary>Gibt die Namen der Dateien (einschließlich der zugehörigen Pfade) zurück, die dem angegebenen Suchmuster im angegebenen Verzeichnis entsprechen. Anhand eines Werts wird bestimmt, ob Unterverzeichnisse durchsucht werden sollen.</summary>
        <returns>Ein Array der vollständigen Namen der Dateien im angegebenen Verzeichnis (einschließlich der Pfade), die dem angegebenen Suchmuster und der Option entsprechen, oder ein leeres Array, wenn keine Dateien gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der angegebene Parameter werden die zurückgegebenen Dateinamen angehängt `path` und die Reihenfolge der zurückgegebenen Dateinamen ist nicht garantiert., verwenden Sie die <xref:System.Array.Sort%2A> Methode, wenn keine bestimmte Sortierreihenfolge erforderlich ist.  
  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Bezeichner für die Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|Kein oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als Platzhalter lauten wie folgt. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
 `searchPattern` darf nicht mit zwei Punkten enden ("..") oder zwei Punkte enthalten ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, und er darf keine ungültigen Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
> [!NOTE]
>  Bei Verwendung des Platzhalterzeichens Sternchen in einem `searchPattern` wie z. B. "\*.txt", die Anzahl der Zeichen in der angegebenen Erweiterung wirkt sich folgendermaßen auf die Suche:  
>   
>  -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, erfolgt die Methodenrückgabe Dateien mit Erweiterungen, die beginnen mit der angegebenen Erweiterung aus. Z. B. "\*xls" sowohl "book.xls" und "book.xlsx" zurückgegeben.  
> -   In allen anderen Fällen gibt die Methode die Dateien, die die angegebene Erweiterung genau entsprechen. Z. B. "\*AI" gibt "file.ai" aber nicht "file.aif" zurück.  
>   
>  Wenn Sie das Fragezeichen-Platzhalterzeichen verwenden, gibt diese Methode nur die Dateien, die die angegebene Dateierweiterung entsprechen. Angenommen, zwei Dateien: "file1.txt" und "file1.txtother", in einem Verzeichnis, die einem Suchmuster von "Datei?. TXT"gibt nur die erste Datei hingegen Suchmuster"Suchmuster"beide Dateien zurück.  
  
> [!NOTE]
>  Da diese Methode für den Dateinamen mit der der 8.3-Namensformat und Format des lange Datei eincheckt, ein Suchmuster "\*1\*.txt" möglicherweise unerwartete Dateinamen zurück. Verwenden Sie beispielsweise ein Suchmuster von "\*1\*.txt" "longfilename.txt" zurückgegeben, da das Äquivalent der 8.3-Namensformat "LONGFI ~ 1.txt" lautet.  
  
 Die <xref:System.IO.Directory.EnumerateFiles%2A> und <xref:System.IO.Directory.GetFiles%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFiles%2A>, können Sie anfangen, die Auflistung von Namen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird; bei Verwendung von <xref:System.IO.Directory.GetFiles%2A>, müssen Sie warten, bis das gesamte Array von Namen zurückgegeben, bevor Sie das Array zugreifen können. Aus diesem Grund werden, wenn Sie arbeiten mit vielen Dateien und Verzeichnissen, <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Die Dateinamen enthalten den vollständigen Pfad.  
  
 Die `path` Parameter relativer oder absoluter Pfad-Informationen angeben kann. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter wird nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mit der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode durchführen.  Oder:  <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> oder <paramref name="searchpattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad wurde nicht gefunden oder ist ungültig (er befindet sich z. B.auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.  Oder:  Es ist ein Netzwerkfehler aufgetreten.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Informationen über Pfade für das aktuelle Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemEntries">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die Namen aller Dateien und Unterverzeichnisse zurück, die bestimmte Kriterien erfüllen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <summary>Gibt die Namen aller Dateien und Unterverzeichnisse in einem angegebenen Pfad zurück.</summary>
        <returns>Ein Array mit den Namen der Dateien und Unterverzeichnisse im angegebenen Verzeichnis, oder ein leeres Array, wenn keine Dateien oder Unterverzeichnisse gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der zurückgegebenen Datei- und Verzeichnisnamen ist nicht garantiert werden; Verwenden Sie die <xref:System.Array.Sort%2A> Methode, wenn keine bestimmte Sortierreihenfolge erforderlich ist.  
  
 Die <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> und <xref:System.IO.Directory.GetFileSystemEntries%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, können Sie anfangen, die Auflistung von Einträgen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird; bei Verwendung von <xref:System.IO.Directory.GetFileSystemEntries%2A>, müssen Sie warten, bis das gesamte Array von Einträgen, die zurückgegeben Sie werden, bevor Sie das Array zugreifen können. Aus diesem Grund werden, wenn Sie arbeiten mit vielen Dateien und Verzeichnissen, <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Diese Methode ist identisch mit <xref:System.IO.Directory.GetFileSystemEntries%2A> durch ein Sternchen (\*) als das Suchmuster angegeben.  
  
 Die `path` Parameter dürfen relativer oder absoluter Pfad angegeben werden. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter wird nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.Directory.GetFileSystemEntries%2A> Methode, um mit den Namen aller Dateien und Unterverzeichnisse in einem vom Benutzer angegebenen Speicherort und gibt ein Array von Zeichenfolgen zu füllen. jeder Zeichenfolgenwert im Array an die Konsole. Im Beispiel ist zum Abfangen aller Fehler für diese Methode konfiguriert.  
  
 [!code-cpp[System.IO.Directory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#1)]
 [!code-csharp[System.IO.Directory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#1)]
 [!code-vb[System.IO.Directory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mit <see cref="M:System.IO.Path.GetInvalidPathChars" /> durchführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Informationen über Pfade für das aktuelle Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="T:System.IO.FileSystemInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileSystemEntries (path As String, searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien und Verzeichnissen in <c>path</c> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <summary>Gibt ein Array von Dateinamen und Verzeichnisnamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen.</summary>
        <returns>Ein Array von Dateinamen und Verzeichnisnamen, die den angegebenen Suchkriterien entsprechen, oder ein leeres Array, wenn keine Dateien oder Verzeichnisse gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der zurückgegebenen Datei- und Verzeichnisnamen ist nicht garantiert werden; Verwenden Sie die <xref:System.Array.Sort%2A> Methode, wenn keine bestimmte Sortierreihenfolge erforderlich ist.  
  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Bezeichner für die Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|Kein oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als Platzhalter lauten wie folgt. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
 `searchPattern` darf nicht mit zwei Punkten enden ("..") oder zwei Punkte enthalten ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, und er darf keine ungültigen Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
> [!NOTE]
>  Bei Verwendung des Platzhalterzeichens Sternchen in einem `searchPattern` wie z. B. "\*.txt", die Anzahl der Zeichen in der angegebenen Erweiterung wirkt sich folgendermaßen auf die Suche:  
>   
>  -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, erfolgt die Methodenrückgabe Dateien mit Erweiterungen, die beginnen mit der angegebenen Erweiterung aus. Z. B. "\*xls" sowohl "book.xls" und "book.xlsx" zurückgegeben.  
> -   In allen anderen Fällen gibt die Methode die Dateien, die die angegebene Erweiterung genau entsprechen. Z. B. "\*AI" gibt "file.ai" aber nicht "file.aif" zurück.  
>   
>  Wenn Sie das Fragezeichen-Platzhalterzeichen verwenden, gibt diese Methode nur die Dateien, die die angegebene Dateierweiterung entsprechen. Angenommen, zwei Dateien: "file1.txt" und "file1.txtother", in einem Verzeichnis, die einem Suchmuster von "Datei?. TXT"gibt nur die erste Datei zurück, während ein Suchmuster von" Datei\*.txt "beide Dateien zurückgegeben.  
  
 Die `path` Parameter dürfen relativer oder absoluter Pfad angegeben werden. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter wird nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.Directory.GetFileSystemEntries%2A> Methode zu füllen ein Array von Zeichenfolgen mit den Namen aller Dateien von einem Benutzer angegebenen Filter in einem bestimmten Speicherort und die einzelnen Zeichenfolgen im Array, an der Konsole ausgegeben. Im Beispiel ist zum Abfangen aller Fehler für diese Methode konfiguriert.  
  
 [!code-cpp[System.IO.Directory#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#2)]
 [!code-csharp[System.IO.Directory#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#2)]
 [!code-vb[System.IO.Directory#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mit der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode durchführen.  Oder:  <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> oder <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf Informationen über Pfade für das aktuelle Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string * System.IO.EnumerationOptions -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetFileSystemEntries(System::String ^ path, System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="static member GetFileSystemEntries : string * string * System.IO.SearchOption -&gt; string[]" Usage="System.IO.Directory.GetFileSystemEntries (path, searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">Der relative oder absolute Pfad zum Verzeichnis, das durchsucht werden soll. Bei dieser Zeichenfolge wird die Groß-/Kleinschreibung nicht berücksichtigt.</param>
        <param name="searchPattern">Die Suchzeichenfolge für die Überprüfung der Namen von Dateien und Verzeichnissen in <c>path</c> auf Übereinstimmungen.  Dieser Parameter kann eine Kombination aus gültigen Literalpfad- und Platzhalterzeichen (* und ?) enthalten, unterstützt jedoch keine regulären Ausdrücke.</param>
        <param name="searchOption">Einer der Enumerationswerte, der angibt, ob nur das aktuelle Verzeichnis oder auch alle Unterverzeichnisse durchsucht werden sollen.  Der Standardwert ist <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Gibt ein Array aller Dateinamen und Verzeichnisnamen zurück, die einem Suchmuster in einem angegebenen Pfad entsprechen. Optional werden Unterverzeichnisse durchsucht.</summary>
        <returns>Ein Array von Dateinamen und Verzeichnisnamen, die den angegebenen Suchkriterien entsprechen, oder ein leeres Array, wenn keine Dateien oder Verzeichnisse gefunden werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der zurückgegebenen Datei- und Verzeichnisnamen ist nicht garantiert werden; Verwenden Sie die <xref:System.Array.Sort%2A> Methode, wenn keine bestimmte Sortierreihenfolge erforderlich ist.  
  
 `searchPattern` kann eine Kombination von Literal-und Platzhalterzeichen, jedoch werden reguläre Ausdrücke nicht unterstützt. Die folgenden Bezeichner für die Platzhalter sind zulässig, `searchPattern`.  
  
|Platzhalter-Spezifizierer|Übereinstimmungen|  
|------------------------|-------------|  
|\* (Sternchen)|NULL oder mehr Zeichen an dieser Position.|  
|? (Fragezeichen)|Kein oder ein Zeichen an dieser Position.|  
  
 Andere Zeichen als Platzhalter lauten wie folgt. Z. B. die `searchPattern` Zeichenfolge "\*t" sucht nach allen Namen in `path` mit dem Buchstaben "t" enden. Die `searchPattern` Zeichenfolge "s\*" sucht nach allen Namen in `path` mit dem Buchstaben "s" beginnen.  
  
 `searchPattern` darf nicht mit zwei Punkten enden ("..") oder zwei Punkte enthalten ("..") gefolgt von <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>, und er darf keine ungültigen Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <xref:System.IO.Path.GetInvalidPathChars%2A>-Methode ausführen.  
  
> [!NOTE]
>  Bei Verwendung des Platzhalterzeichens Sternchen in einem `searchPattern` wie z. B. "\*.txt", die Anzahl der Zeichen in der angegebenen Erweiterung wirkt sich folgendermaßen auf die Suche:  
>   
>  -   Wenn die angegebene Erweiterung genau drei Zeichen lang ist, erfolgt die Methodenrückgabe Dateien mit Erweiterungen, die beginnen mit der angegebenen Erweiterung aus. Z. B. "\*xls" sowohl "book.xls" und "book.xlsx" zurückgegeben.  
> -   In allen anderen Fällen gibt die Methode die Dateien, die die angegebene Erweiterung genau entsprechen. Z. B. "\*AI" gibt "file.ai" aber nicht "file.aif" zurück.  
>   
>  Wenn Sie das Fragezeichen-Platzhalterzeichen verwenden, gibt diese Methode nur die Dateien, die die angegebene Dateierweiterung entsprechen. Angenommen, zwei Dateien: "file1.txt" und "file1.txtother", in einem Verzeichnis, die einem Suchmuster von "Datei?. TXT"gibt nur die erste Datei zurück, während ein Suchmuster von" Datei\*.txt "beide Dateien zurückgegeben.  
  
 Die <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> und <xref:System.IO.Directory.GetFileSystemEntries%2A> Methoden unterscheiden sich wie folgt: bei Verwendung von <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, können Sie anfangen, die Auflistung von Einträgen aufzulisten, bevor die gesamte Auflistung zurückgegeben wird; bei Verwendung von <xref:System.IO.Directory.GetFileSystemEntries%2A>, müssen Sie warten, bis das gesamte Array von Einträgen, die zurückgegeben Sie werden, bevor Sie das Array zugreifen können. Aus diesem Grund werden, wenn Sie arbeiten mit vielen Dateien und Verzeichnissen, <xref:System.IO.Directory.EnumerateFiles%2A> kann effizienter sein.  
  
 Sie können mit relativen Pfadinformationen angeben der `path` Parameter. Informationen über relative Pfade relativ zum aktuellen Arbeitsverzeichnis, die Sie ermitteln können, indem Sie mithilfe von interpretiert die <xref:System.IO.Directory.GetCurrentDirectory%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine Zeichenfolge der Länge 0 (null), die nur Leerraum oder ungültige Zeichen enthält. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.  Oder:  <paramref name="searchPattern" /> enthält kein gültiges Muster.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.  Oder:  <paramref name="searchPattern" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> ist kein gültiger <see cref="T:System.IO.SearchOption" />-Wert.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> ist ungültig (verweist z. B. auf ein nicht zugeordnetes Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> ist ein Dateiname.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTime : string -&gt; DateTime" Usage="System.IO.Directory.GetLastAccessTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. das die Informationen über Zugriffsdatum und -zeitpunkt abgerufen werden sollen.</param>
        <summary>Gibt das Datum und die Uhrzeit des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis zurück.</summary>
        <returns>Eine Struktur, die auf das Datum und die Uhrzeit des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis festgelegt wird. Dieser Wert wird in Ortszeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode kann einen fehlerhaften Wert, zurück, da sie systemeigene Funktionen verwendet, deren Werte nicht kontinuierlich durch das Betriebssystem aktualisiert werden können.  
  
 Diese Methode ist identisch mit <xref:System.IO.File.GetLastAccessTime%2A?displayProperty=nameWithType>.  
  
 Wenn das Verzeichnis in beschrieben die `path` Parameter ist nicht vorhanden, diese Methode gibt zurück, 0:00 Uhr, 1. Januar 1601 n. Chr. (C.E.) Coordinated Universal Time (UTC), in die lokale Zeit angepasst.  
  
 Die `path` Parameter dürfen relativer oder absoluter Pfad angegeben werden. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter wird nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie `GetLastAccessTime`.  
  
 [!code-cpp[Dir_GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastAccess/CPP/dir_getlastaccess.cpp#1)]
 [!code-csharp[Dir_GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastAccess/CS/dir_getlastaccess.cs#1)]
 [!code-vb[Dir_GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastAccess/VB/dir_getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mit der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode durchführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Der <paramref name="path" />-Parameter hat ein ungültiges Format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen der Datei oder das Verzeichnis an. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastAccessTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetLastAccessTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. das die Informationen über Zugriffsdatum und -zeitpunkt abgerufen werden sollen.</param>
        <summary>Gibt das Datum und den Zeitpunkt im UTC-Format (Coordinated Universal Time, koordinierte Weltzeit) des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis zurück.</summary>
        <returns>Eine Struktur, die auf das Datum und die Uhrzeit des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis festgelegt wird. Der Wert wird in UTC-Zeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode kann einen fehlerhaften Wert, zurück, da sie systemeigene Funktionen verwendet, deren Werte nicht kontinuierlich durch das Betriebssystem aktualisiert werden können.  
  
 Wenn das Verzeichnis in beschrieben die `path` Parameter ist nicht vorhanden, diese Methode gibt zurück, 0:00 Uhr, 1. Januar 1601 n. Chr. (C.E.) Koordinierte Weltzeit (UTC).  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Unterschiede in der Ausgabe bei Verwendung der koordinierten Weltzeit (Coordinated Universal Time, UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Der <paramref name="path" />-Parameter hat ein ungültiges Format.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen der Datei oder das Verzeichnis an. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTime : string -&gt; DateTime" Usage="System.IO.Directory.GetLastWriteTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. für das die Informationen über Datum und Uhrzeit der letzten Änderung abgerufen werden sollen.</param>
        <summary>Gibt das Datum und die Uhrzeit des letzten Schreibvorgangs in die angegebene Datei bzw. das angegebene Verzeichnis zurück.</summary>
        <returns>Eine Struktur, die auf das Datum und die Uhrzeit des letzten Schreibvorgangs in die angegebene Datei bzw. das angegebene Verzeichnis festgelegt wird. Dieser Wert wird in Ortszeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode kann einen fehlerhaften Wert, zurück, da sie systemeigene Funktionen verwendet, deren Werte nicht kontinuierlich durch das Betriebssystem aktualisiert werden können.  
  
 Wenn das Verzeichnis in beschrieben die `path` Parameter ist nicht vorhanden, diese Methode gibt zurück, 0:00 Uhr, 1. Januar 1601 n. Chr. (C.E.) Coordinated Universal Time (UTC), in die lokale Zeit angepasst.  
  
 Die `path` Parameter dürfen relativer oder absoluter Pfad angegeben werden. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter wird nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie `GetLastWriteTime`.  
  
 [!code-cpp[Dir_GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastWrite/CPP/dir_getlastwrite.cpp#1)]
 [!code-csharp[Dir_GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastWrite/CS/dir_getlastwrite.cs#1)]
 [!code-vb[Dir_GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastWrite/VB/dir_getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen der Datei oder das Verzeichnis an. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTimeUtc(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetLastWriteTimeUtc : string -&gt; DateTime" Usage="System.IO.Directory.GetLastWriteTimeUtc path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. für das die Informationen über Datum und Uhrzeit der letzten Änderung abgerufen werden sollen.</param>
        <summary>Gibt das Datum und den Zeitpunkt des letzten Schreibzugriffs im UTC-Format (Coordinated Universal Time, koordinierte Weltzeit) auf die angegebenen Datei bzw. das angegebene Verzeichnis zurück.</summary>
        <returns>Eine Struktur, die auf das Datum und die Uhrzeit des letzten Schreibvorgangs in die angegebene Datei bzw. das angegebene Verzeichnis festgelegt wird. Der Wert wird in UTC-Zeit angegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode kann einen fehlerhaften Wert, zurück, da sie systemeigene Funktionen verwendet, deren Werte nicht kontinuierlich durch das Betriebssystem aktualisiert werden können.  
  
 Wenn das Verzeichnis in beschrieben die `path` Parameter ist nicht vorhanden, diese Methode gibt zurück, 0:00 Uhr, 1. Januar 1601 n. Chr. (C.E.) Koordinierte Weltzeit (UTC).  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Unterschiede in der Ausgabe bei Verwendung der koordinierten Weltzeit (Coordinated Universal Time, UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen der Datei oder das Verzeichnis an. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.IO.Directory.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Namen der logischen Laufwerke auf diesem Computer im Format „&lt;Laufwerkbuchstabe&gt;:\\“ ab.</summary>
        <returns>Die logischen Laufwerke auf diesem Computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GetLogicalDrives gibt alle Laufwerke, auf die zugegriffen werden kann auf einem bestimmten Computer, einschließlich des Diskettenlaufwerks und optische Laufwerke zurück.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.Directory.GetLogicalDrives%2A> Methode, um ein Array von Zeichenfolgen die Namen der einzelnen Laufwerke auf dem aufrufenden Computer zuweisen. Jedes Mitglied dieser Zeichenfolgen-Array wird anschließend an die Konsole ausgegeben. Im Beispiel ist zum Abfangen aller Fehler für diese Methode konfiguriert.  
  
 [!code-cpp[System.IO.Directory#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#3)]
 [!code-csharp[System.IO.Directory#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#3)]
 [!code-vb[System.IO.Directory#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler (z. B. ein Datenträgerfehler) aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwaltetem Code, wie das Aufrufen von systemeigenem Code mit PInvoke oder COM-Interop. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetParent">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetParent (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo GetParent(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetParent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetParent (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::DirectoryInfo ^ GetParent(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetParent : string -&gt; System.IO.DirectoryInfo" Usage="System.IO.Directory.GetParent path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad, dessen übergeordnetes Verzeichnis abgerufen werden soll.</param>
        <summary>Ruft das übergeordnete Verzeichnis des angegebenen Pfads ab, sowohl für absolute als auch für relative Pfade.</summary>
        <returns>	Das übergeordnete Verzeichnis oder <see langword="null" />, wenn <paramref name="path" />das Stammverzeichnis ist, einschließlich des Stammverzeichnisses eines UNC-Server- oder Freigabenamens.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter relativer oder absoluter Pfad-Informationen angeben kann. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Nachgestellte Leerzeichen entfernt werden, am Ende der `path` -Parameter vor dem Abrufen des Verzeichnisses.  
  
 Die von dieser Methode zurückgegebene Zeichenfolge enthält alle Zeichen in den Pfad bis zum, jedoch nicht einschließlich, die letzte <xref:System.IO.Path.DirectorySeparatorChar> oder <xref:System.IO.Path.AltDirectorySeparatorChar>. Beispielsweise der Pfad "C:\Directory\SubDirectory\test.txt" übergeben, um <xref:System.IO.Directory.GetParent%2A> "C:\Directory\SubDirectory" zurückgegeben. Übergeben "C:\Directory\SubDirectory" gibt "C:\Directory" zurück. Übergeben Sie jedoch "C:\Directory\SubDirectory\\" gibt "C:\Directory\SubDirectory" zurück, da das letzte Verzeichnistrennzeichen nach "Unterverzeichnis" ist.  
  
 Die `path` Parameter wird nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.IO.Directory.GetParent%2A> Methode, um das übergeordnete Verzeichnis von einem Benutzer angegebenen Ort abrufen "Path". Der Rückgabewert von der <xref:System.IO.Directory.GetParent%2A> Methode ist, klicken Sie dann in der Konsole ausgegeben. Im Beispiel ist zum Abfangen aller Fehler für diese Methode konfiguriert.  
  
 [!code-cpp[System.IO.Directory#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#4)]
 [!code-csharp[System.IO.Directory#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#4)]
 [!code-vb[System.IO.Directory#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Das durch <paramref name="path" /> angegebene Verzeichnis ist schreibgeschützt.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge. Weitere Informationen finden Sie im Thema <see cref="T:System.IO.PathTooLongException" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.Security.SecurityException">Nur .NET Framework: Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen von Dateien oder Verzeichnisse. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceDirName, string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceDirName, string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Move(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceDirName As String, destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceDirName, System::String ^ destDirName);" />
      <MemberSignature Language="F#" Value="static member Move : string * string -&gt; unit" Usage="System.IO.Directory.Move (sourceDirName, destDirName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirName" Type="System.String" />
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirName">Der Pfad der Datei oder des Verzeichnisses, das verschoben werden soll.</param>
        <param name="destDirName">Der Pfad zum neuen Speicherort für <c>sourceDirName</c>. Wenn es sich bei <c>sourceDirName</c> um eine Datei handelt, muss auch <c>destDirName</c> ein Dateiname sein.</param>
        <summary>Verschiebt eine Datei oder ein Verzeichnis und dessen Inhalt an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt ein neues Verzeichnis mit den Namen trägt `destDirName` und verschiebt den Inhalt des `sourceDirName` in das neu erstellte Zielverzeichnis. Wenn Sie versuchen, ein Verzeichnis in ein Verzeichnis zu verschieben, die bereits vorhanden ist, eine <xref:System.IO.IOException> erfolgt. Beispielsweise wird eine Ausnahme ausgelöst, wenn Sie versuchen, c:\mydir nach c:\public zu verschieben und c:\public bereits vorhanden ist. Alternativ können Sie angeben "" c: "\\\public\\\mydir" als die `destDirName` -Parameter angegeben, dass "Mydir" nicht vorhanden ist, klicken Sie unter "" c: "\\\public", oder geben Sie einen neuen Verzeichnisnamen z. B. "c:\\\newdir".  
  
 Die `sourceDirName` und `destDirName` Argumente sind berechtigt, auf die Informationen der relativen oder absoluten Pfad angeben. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Nachfolgende Leerzeichen werden am Ende der Path-Parameter vor dem Verschieben des Verzeichnis entfernt.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie Sie ein Verzeichnis und alle Dateien in ein neues Verzeichnis verschieben. Das ursprüngliche Verzeichnis ist nicht mehr vorhanden, nachdem es verschoben wurde.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Es wurde versucht, ein Verzeichnis auf ein anderes Volume zu verschieben.  Oder:  <paramref name="destDirName" /> ist bereits vorhanden.  Oder:  Die Parameter <paramref name="sourceDirName" /> und <paramref name="destDirName" /> verweisen auf dieselbe Datei oder dasselbe Verzeichnis.  Oder:  Das enthaltene Verzeichnis oder die enthaltene Datei wird von einem anderen Prozess verwendet.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceDirName" /> oder <paramref name="destDirName" /> ist eine Zeichenfolge der Länge 0 (null), besteht nur aus Leerraum oder enthält ein oder mehrere ungültige Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirName" /> oder <paramref name="destDirName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der durch <paramref name="sourceDirName" /> angegebene Pfad ist ungültig (z. B. befindet er sich auf einem nicht zugeordneten Laufwerk).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen von <paramref name="sourceDirName" /> der und Schreiben in <paramref name="sourceDirName" /> und <paramref name="destDirName" />. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetAccessControl(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAccessControl(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="static member SetAccessControl : string * System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="System.IO.Directory.SetAccessControl (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="path">Ein Verzeichnis, dem Einträge von Zugriffssteuerungslisten hinzugefügt oder aus diesem entfernt werden sollen.</param>
        <param name="directorySecurity">Ein <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt, das einen Eintrag in einer Zugriffssteuerungsliste beschreibt, der auf das vom <c>path</c>-Parameter beschriebene Verzeichnis angewendet werden soll.</param>
        <summary>Wendet von einem <see cref="T:System.Security.AccessControl.DirectorySecurity" />-Objekt beschriebene Einträge von Zugriffssteuerungslisten auf das angegebene Verzeichnis an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Directory.SetAccessControl%2A> Methode gilt Einträge Access Control List (ACL) für eine Datei, die nicht geerbte Zugriffssteuerungsliste darstellt.  
  
> [!CAUTION]
>  Die ACL angegeben wird, für die `directorySecurity` Parameter ersetzt die vorhandene Zugriffssteuerungsliste für das Verzeichnis. Um Berechtigungen für einen neuen Benutzer hinzuzufügen, verwenden Sie die <xref:System.IO.Directory.GetAccessControl%2A> Methode zum Abrufen der vorhandenen ACL, und ändern Sie sie.  
  
 Eine ACL beschreibt Personen bzw. Gruppen besitzen oder verfügen nicht über, Rechte für bestimmte Aktionen für die angegebene Datei oder das Verzeichnis an. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Die <xref:System.IO.Directory.SetAccessControl%2A> -Methode behält nur <xref:System.Security.AccessControl.DirectorySecurity> Objekte, die nach der Erstellung geändert wurden.  Wenn eine <xref:System.Security.AccessControl.DirectorySecurity> Objekt wurde nicht geändert wurde, wird nicht in einer Datei beibehalten werden.  Aus diesem Grund ist es nicht möglich, zum Abrufen einer <xref:System.Security.AccessControl.DirectorySecurity> Objekt aus einer Datei, und wenden Sie das gleiche Objekt in eine andere Datei erneut an.  
  
 ACL-Informationen aus einer Datei in ein anderes kopiert werden soll:  
  
1.  Verwenden der <xref:System.IO.Directory.GetAccessControl%2A> Methode zum Abrufen der <xref:System.Security.AccessControl.DirectorySecurity> Objekt aus der Quelldatei.  
  
2.  Erstellen Sie ein neues <xref:System.Security.AccessControl.DirectorySecurity> Objekt für die Zieldatei.  
  
3.  Verwenden der <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> oder <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> Methode der Quelle <xref:System.Security.AccessControl.DirectorySecurity> Objekt, das die ACL-Informationen abzurufen.  
  
4.  Verwenden der <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> oder <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> Methode, um die Informationen zu kopieren, die in Schritt 3 in das Ziel abgerufenen <xref:System.Security.AccessControl.DirectorySecurity> Objekt.  
  
5.  Legen Sie das Ziel <xref:System.Security.AccessControl.DirectorySecurity> Objekt, das die Ziel-Datei mithilfe der <xref:System.IO.Directory.SetAccessControl%2A> Methode.  
  
 In Umgebungen mit NTFS <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> werden dem Benutzer erteilt, wenn der Benutzer hat <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> Rechte für den übergeordneten Ordner. Verweigern <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> und <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, Verweigern <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> für das übergeordnete Verzeichnis.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.Directory.GetAccessControl%2A> und <xref:System.IO.Directory.SetAccessControl%2A> Methoden zum Hinzufügen eines Eintrags der Zugriffssteuerungsliste (ACL) zu steuern und entfernen Sie dann einen ACL-Eintrag aus einem Verzeichnis.  Sie müssen ein gültiges Benutzer- oder Gruppenkonto angeben, um dieses Beispiel auszuführen.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directorySecurity" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Verzeichnis wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="path" /> war ungültig.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der aktuelle Prozess hat keinen Zugriff zum Öffnen des specified durch <paramref name="path" /> angegebenen Verzeichnisses.  Oder:  Der aktuelle Prozess verfügt nicht über die nötigen Berechtigungen zum Festlegen des ACL-Eintrags.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows 2000 oder höher.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Berechtigung zum Auflisten der Zugriffssteuerungsliste (ACL) für ein Verzeichnis. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> , <see cref="F:System.Security.AccessControl.AccessControlActions.View" /> Sicherheitsaktion: bei Bedarf.</permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTime (path As String, creationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTime(System::String ^ path, DateTime creationTime);" />
      <MemberSignature Language="F#" Value="static member SetCreationTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetCreationTime (path, creationTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für das die Informationen über Erstellungsdatum und -zeitpunkt festgelegt werden sollen.</param>
        <param name="creationTime">Datum und Zeitpunkt des letzten Schreibvorgangs in einer Datei oder einem Verzeichnis. Dieser Wert wird in Ortszeit angegeben.</param>
        <summary>Legt das Erstellungsdatum und den Erstellungszeitpunkt für die angegebene Datei bzw. das angegebene Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter dürfen relativer oder absoluter Pfad angegeben werden. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter wird nicht beachtet.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Unterschiede in der Ausgabe bei Verwendung der koordinierten Weltzeit (Coordinated Universal Time, UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> gibt einen Wert an, der außerhalb des für diesen Vorgang zulässigen Bereichs für Datum oder Zeit liegt.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei oder das Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTimeUtc (path As String, creationTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTimeUtc(System::String ^ path, DateTime creationTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetCreationTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetCreationTimeUtc (path, creationTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für das die Informationen über Erstellungsdatum und -zeitpunkt festgelegt werden sollen.</param>
        <param name="creationTimeUtc">Datum und Uhrzeit der Erstellung des Verzeichnisses oder der Datei. Dieser Wert wird in Ortszeit angegeben.</param>
        <summary>Legt das Erstellungsdatum und den Erstellungszeitpunkt im UTC-Format (Coordinated Universal Time, koordinierte Weltzeit) für die angegebene Datei oder das angegebene Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter dürfen relativer oder absoluter Pfad angegeben werden. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter wird nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> gibt einen Wert an, der außerhalb des für diesen Vorgang zulässigen Bereichs für Datum oder Zeit liegt.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei oder das Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static void SetCurrentDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCurrentDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCurrentDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCurrentDirectory (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCurrentDirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member SetCurrentDirectory : string -&gt; unit" Usage="System.IO.Directory.SetCurrentDirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad, auf den das aktuelle Arbeitsverzeichnis festgelegt ist.</param>
        <summary>Legt das aktuelle Arbeitsverzeichnis der Anwendung auf das angegebene Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Anwendung beendet wird, wird das Arbeitsverzeichnis wiederhergestellt, an ihrem ursprünglichen Speicherort (das Verzeichnis, in dem der Prozess gestartet wurde).  
  
 Die `path` Parameter dürfen relativer oder absoluter Pfad angegeben werden. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Nachgestellte Leerzeichen entfernt werden, am Ende der `path` -Parameter vor dem Festlegen des Verzeichnisses.  
  
 Die `path` Parameter wird nicht beachtet.  
  
 Wenn Sie das Verzeichnis auf ein Laufwerk mit Wechselmedien, z. B. zu (für ein Laufwerk "A:") oder "E" für ein CD-ROM-Laufwerk festlegen, können Sie bestimmen, ob das Laufwerk bereit ist, mit der <xref:System.IO.DriveInfo.IsReady%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die legen das aktuelle Verzeichnis und den Verzeichnisstamm anzuzeigen.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung zum Zugreifen auf nicht verwalteten Code.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das angegebene Verzeichnis wurde nicht gefunden.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in Dateien oder Verzeichnisse. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Aufrufen von nicht verwaltetem Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTime (path As String, lastAccessTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTime(System::String ^ path, DateTime lastAccessTime);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastAccessTime (path, lastAccessTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. für das die Informationen über Zugriffsdatum und -zeitpunkt festgelegt werden sollen.</param>
        <param name="lastAccessTime">Eine Objekt, das den festzulegenden Wert für Zugriffsdatum und -zeitpunkt von <c>path</c> enthält. Dieser Wert wird in Ortszeit angegeben.</param>
        <summary>Legt das Datum und die Uhrzeit des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter dürfen relativer oder absoluter Pfad angegeben werden. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter wird nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie `SetLastAccessTime`.  
  
 [!code-cpp[Dir_SetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastAccess/CPP/dir_setlastaccess.cpp#1)]
 [!code-csharp[Dir_SetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastAccess/CS/dir_setlastaccess.cs#1)]
 [!code-vb[Dir_SetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastAccess/VB/dir_setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTime" /> gibt einen Wert an, der außerhalb des für diesen Vorgang zulässigen Bereichs für Datum oder Zeit liegt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei oder das Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTimeUtc (path As String, lastAccessTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTimeUtc(System::String ^ path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastAccessTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastAccessTimeUtc (path, lastAccessTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Die Datei oder das Verzeichnis, für die bzw. für das die Informationen über Zugriffsdatum und -zeitpunkt festgelegt werden sollen.</param>
        <param name="lastAccessTimeUtc">Eine Objekt, das den festzulegenden Wert für Zugriffsdatum und -zeitpunkt von <c>path</c> enthält. Der Wert wird in UTC-Zeit angegeben.</param>
        <summary>Legt das Datum und den Zeitpunkt im UTC-Format (Coordinated Universal Time, koordinierte Weltzeit) des letzten Zugriffs auf die angegebene Datei bzw. das angegebene Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter dürfen relativer oder absoluter Pfad angegeben werden. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter wird nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Unterschiede in der Ausgabe bei Verwendung der koordinierten Weltzeit (Coordinated Universal Time, UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Der angegebene Pfad wurde nicht gefunden.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTimeUtc" /> gibt einen Wert an, der außerhalb des für diesen Vorgang zulässigen Bereichs für Datum oder Zeit liegt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei oder das Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTime (path As String, lastWriteTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTime(System::String ^ path, DateTime lastWriteTime);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTime : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastWriteTime (path, lastWriteTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad des Verzeichnisses.</param>
        <param name="lastWriteTime">Datum und Zeitpunkt des letzten Schreibvorgangs in einem Verzeichnis. Dieser Wert wird in Ortszeit angegeben.</param>
        <summary>Legt Datum und Zeit des letzten Schreibvorgangs in einem Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter dürfen relativer oder absoluter Pfad angegeben werden. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter wird nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie `SetLastWriteTime`.  
  
 [!code-cpp[Dir_SetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastWrite/CPP/dir_setlastwrite.cpp#1)]
 [!code-csharp[Dir_SetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastWrite/CS/dir_setlastwrite.cs#1)]
 [!code-vb[Dir_SetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastWrite/VB/dir_setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> wurde nicht gefunden (z.B. ist das Verzeichnis nicht vorhanden oder befindet sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> wurde nicht gefunden (z.B. ist das Verzeichnis nicht vorhanden oder befindet sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTime" /> gibt einen Wert an, der außerhalb des für diesen Vorgang zulässigen Bereichs für Datum oder Zeit liegt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei oder das Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTimeUtc (path As String, lastWriteTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTimeUtc(System::String ^ path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="F#" Value="static member SetLastWriteTimeUtc : string * DateTime -&gt; unit" Usage="System.IO.Directory.SetLastWriteTimeUtc (path, lastWriteTimeUtc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad des Verzeichnisses.</param>
        <param name="lastWriteTimeUtc">Datum und Zeitpunkt des letzten Schreibvorgangs in einem Verzeichnis. Der Wert wird in UTC-Zeit angegeben.</param>
        <summary>Legt das Datum und den Zeitpunkt im UTC-Format (Coordinated Universal Time, koordinierte Weltzeit) des letzten Schreibzugriffs auf ein Verzeichnis fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `path` Parameter dürfen relativer oder absoluter Pfad angegeben werden. Relativer Pfad wird relativ zum aktuellen Arbeitsverzeichnis interpretiert. Um das aktuelle Arbeitsverzeichnis zu erhalten, finden Sie unter <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Die `path` Parameter wird nicht beachtet.  
  
 Eine Liste der allgemeinen e/a-Aufgaben, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Unterschiede in der Ausgabe bei Verwendung der koordinierten Weltzeit (Coordinated Universal Time, UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> wurde nicht gefunden (z.B. ist das Verzeichnis nicht vorhanden oder befindet sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> wurde nicht gefunden (z.B. ist das Verzeichnis nicht vorhanden oder befindet sich auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen. Sie können Abfragen für ungültige Zeichen mithilfe der <see cref="M:System.IO.Path.GetInvalidPathChars" />-Methode ausführen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTimeUtc" /> gibt einen Wert an, der außerhalb des für diesen Vorgang zulässigen Bereichs für Datum oder Zeit liegt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Schreiben in die angegebene Datei oder das Verzeichnis. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
  </Members>
</Type>