<Type Name="BufferedStream" FullName="System.IO.BufferedStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="33e39b2d72d234b37aed77898201a88e64ccdbb6" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75132503" /></Metadata><TypeSignature Language="C#" Value="public sealed class BufferedStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BufferedStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.BufferedStream" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BufferedStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class BufferedStream sealed : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type BufferedStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="39056-101">Fügt eine Pufferebene zu Lese- und Schreibvorgängen auf einem anderen Stream hinzu.</span><span class="sxs-lookup"><span data-stu-id="39056-101">Adds a buffering layer to read and write operations on another stream.</span></span> <span data-ttu-id="39056-102">Diese Klasse kann nicht vererbt werden.</span><span class="sxs-lookup"><span data-stu-id="39056-102">This class cannot be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39056-103">Ein Puffer ist ein Block von Bytes im Arbeitsspeicher, der zum Zwischenspeichern von Daten verwendet wird. Dadurch wird die Anzahl der Aufrufe des Betriebssystems reduziert.</span><span class="sxs-lookup"><span data-stu-id="39056-103">A buffer is a block of bytes in memory used to cache data, thereby reducing the number of calls to the operating system.</span></span> <span data-ttu-id="39056-104">Puffer verbessern die Lese-und Schreibleistung.</span><span class="sxs-lookup"><span data-stu-id="39056-104">Buffers improve read and write performance.</span></span> <span data-ttu-id="39056-105">Ein Puffer kann entweder für Lese-oder Schreibvorgänge verwendet werden, aber nicht beide gleichzeitig.</span><span class="sxs-lookup"><span data-stu-id="39056-105">A buffer can be used for either reading or writing, but never both simultaneously.</span></span> <span data-ttu-id="39056-106">Die <xref:System.IO.BufferedStream.Read%2A>-und <xref:System.IO.BufferedStream.Write%2A> Methoden von `BufferedStream` den Puffer automatisch beibehalten.</span><span class="sxs-lookup"><span data-stu-id="39056-106">The <xref:System.IO.BufferedStream.Read%2A> and <xref:System.IO.BufferedStream.Write%2A> methods of `BufferedStream` automatically maintain the buffer.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="39056-107">Dieser Typ implementiert die <xref:System.IDisposable>-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="39056-107">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="39056-108">Nach Abschluss der Verwendung sollten Sie den Typ entweder direkt oder indirekt löschen.</span><span class="sxs-lookup"><span data-stu-id="39056-108">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="39056-109">Zum direkten Löschen des Typs rufen Sie seine <xref:System.IDisposable.Dispose%2A>-Methode in einem `try`/`catch`-Block auf.</span><span class="sxs-lookup"><span data-stu-id="39056-109">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="39056-110">Zum indirekten Löschen verwenden Sie ein Sprachkonstrukt wie `using` (in C#) oder `Using` (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="39056-110">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="39056-111">Weitere Informationen finden Sie im Abschnitt „Verwenden eines Objekts, das IDisposable implementiert“ des Themas „Die <xref:System.IDisposable>-Schnittstelle“.</span><span class="sxs-lookup"><span data-stu-id="39056-111">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="39056-112">`BufferedStream` kann für bestimmte Arten von Streams zusammengesetzt werden.</span><span class="sxs-lookup"><span data-stu-id="39056-112">`BufferedStream` can be composed around certain types of streams.</span></span> <span data-ttu-id="39056-113">Es stellt Implementierungen zum Lesen und Schreiben von Bytes in einer zugrunde liegenden Datenquelle oder einem zugrunde liegenden Repository bereit.</span><span class="sxs-lookup"><span data-stu-id="39056-113">It provides implementations for reading and writing bytes to an underlying data source or repository.</span></span> <span data-ttu-id="39056-114">Verwenden Sie <xref:System.IO.BinaryReader> und <xref:System.IO.BinaryWriter>, um andere Datentypen zu lesen und zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="39056-114">Use <xref:System.IO.BinaryReader> and <xref:System.IO.BinaryWriter> for reading and writing other data types.</span></span> <span data-ttu-id="39056-115">`BufferedStream` soll verhindern, dass der Puffer die Eingabe und Ausgabe verlangsamt, wenn der Puffer nicht benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="39056-115">`BufferedStream` is designed to prevent the buffer from slowing down input and output when the buffer is not needed.</span></span> <span data-ttu-id="39056-116">Wenn Sie für Größen, die größer sind als die interne Puffergröße, immer lesen und schreiben, wird `BufferedStream` möglicherweise nicht einmal den internen Puffer zuordnen.</span><span class="sxs-lookup"><span data-stu-id="39056-116">If you always read and write for sizes greater than the internal buffer size, then `BufferedStream` might not even allocate the internal buffer.</span></span> <span data-ttu-id="39056-117">`BufferedStream` puffert auch Lese-und Schreibvorgänge in einem freigegebenen Puffer.</span><span class="sxs-lookup"><span data-stu-id="39056-117">`BufferedStream` also buffers reads and writes in a shared buffer.</span></span> <span data-ttu-id="39056-118">Es wird davon ausgegangen, dass Sie fast immer eine Reihe von Lese-oder Schreibvorgängen durchgehen, aber nur selten zwischen den beiden wechseln.</span><span class="sxs-lookup"><span data-stu-id="39056-118">It is assumed that you will almost always be doing a series of reads or writes, but rarely alternate between the two of them.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39056-119">In den folgenden Codebeispielen wird gezeigt, wie Sie die `BufferedStream`-Klasse für die `NetworkStream`-Klasse verwenden, um die Leistung bestimmter e/a-Vorgänge zu erhöhen.</span><span class="sxs-lookup"><span data-stu-id="39056-119">The following code examples show how to use the `BufferedStream` class over the `NetworkStream` class to increase the performance of certain I/O operations.</span></span> <span data-ttu-id="39056-120">Starten Sie den Server auf einem Remote Computer, bevor Sie den Client starten.</span><span class="sxs-lookup"><span data-stu-id="39056-120">Start the server on a remote computer before starting the client.</span></span> <span data-ttu-id="39056-121">Geben Sie den Remote Computernamen als Befehlszeilenargument an, wenn Sie den Client starten.</span><span class="sxs-lookup"><span data-stu-id="39056-121">Specify the remote computer name as a command-line argument when starting the client.</span></span> <span data-ttu-id="39056-122">Variieren Sie die `dataArraySize`-und `streamBufferSize` Konstanten, um ihre Auswirkungen auf die Leistung anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="39056-122">Vary the `dataArraySize` and `streamBufferSize` constants to view their effect on performance.</span></span>  
  
 <span data-ttu-id="39056-123">Das erste Beispiel zeigt den Code, der auf dem Client ausgeführt wird, und das zweite Beispiel zeigt den Code, der auf dem Server ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="39056-123">The first example shows the code that runs on the client, and the second example shows the code that runs on the server.</span></span>  
  
 <span data-ttu-id="39056-124">**Beispiel 1: Code, der auf dem Client ausgeführt wird**</span><span class="sxs-lookup"><span data-stu-id="39056-124">**Example 1: Code that runs on the client**</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#1)]
 [!code-csharp[System.IO.BufferedStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#1)]
 [!code-vb[System.IO.BufferedStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#1)]  
  
 <span data-ttu-id="39056-125">**Beispiel 2: Code, der auf dem Server ausgeführt wird**</span><span class="sxs-lookup"><span data-stu-id="39056-125">**Example 2: Code that runs on the server**</span></span>  
  
 [!code-cpp[System.IO.BufferedStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream2/CPP/server.cpp#1)]
 [!code-csharp[System.IO.BufferedStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream2/CS/server.cs#1)]
 [!code-vb[System.IO.BufferedStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream2/VB/server.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.FileStream" />
    <altmember cref="T:System.IO.MemoryStream" />
    <altmember cref="T:System.IO.Stream" />
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="39056-126">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="39056-126">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="39056-127">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="39056-127">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="39056-128">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="39056-128">How to: Write Text to a File</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="39056-129">Initialisiert eine neue Instanz der <see cref="T:System.IO.BufferedStream" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="39056-129">Initializes a new instance of the <see cref="T:System.IO.BufferedStream" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BufferedStream (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BufferedStream(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.IO.BufferedStream : System.IO.Stream -&gt; System.IO.BufferedStream" Usage="new System.IO.BufferedStream stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="39056-130">Der aktuelle Stream.</span><span class="sxs-lookup"><span data-stu-id="39056-130">The current stream.</span></span></param>
        <summary><span data-ttu-id="39056-131">Initialisiert eine neue Instanz der <see cref="T:System.IO.BufferedStream" />-Klasse mit einer Standardpuffergröße von 4096 Bytes.</span><span class="sxs-lookup"><span data-stu-id="39056-131">Initializes a new instance of the <see cref="T:System.IO.BufferedStream" /> class with a default buffer size of 4096 bytes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39056-132">Ein frei gegebener Lese-/Schreibpuffer wird zugewiesen, wenn ein `BufferedStream` Objekt mit diesem Konstruktor erstmalig initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="39056-132">A shared read/write buffer is allocated the first time a `BufferedStream` object is initialized with this constructor.</span></span> <span data-ttu-id="39056-133">Der freigegebene Puffer wird nicht verwendet, wenn alle Lese-und Schreibvorgänge größer oder gleich `bufferSize`sind.</span><span class="sxs-lookup"><span data-stu-id="39056-133">The shared buffer is not used if all reads and writes are greater than or equal to `bufferSize`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39056-134"><paramref name="stream" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39056-134"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="39056-135">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="39056-135">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="39056-136">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="39056-136">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="39056-137">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="39056-137">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BufferedStream (System.IO.Stream stream, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BufferedStream(System::IO::Stream ^ stream, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.BufferedStream : System.IO.Stream * int -&gt; System.IO.BufferedStream" Usage="new System.IO.BufferedStream (stream, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="39056-138">Der aktuelle Stream.</span><span class="sxs-lookup"><span data-stu-id="39056-138">The current stream.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="39056-139">Die Puffergröße in Byte.</span><span class="sxs-lookup"><span data-stu-id="39056-139">The buffer size in bytes.</span></span></param>
        <summary><span data-ttu-id="39056-140">Initialisiert eine neue Instanz der <see cref="T:System.IO.BufferedStream" />-Klasse mit der angegebenen Puffergröße.</span><span class="sxs-lookup"><span data-stu-id="39056-140">Initializes a new instance of the <see cref="T:System.IO.BufferedStream" /> class with the specified buffer size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39056-141">Ein frei gegebener Lese-/Schreibpuffer wird zugewiesen, wenn ein `BufferedStream` Objekt mit diesem Konstruktor erstmalig initialisiert wird.</span><span class="sxs-lookup"><span data-stu-id="39056-141">A shared read/write buffer is allocated the first time a `BufferedStream` object is initialized with this constructor.</span></span> <span data-ttu-id="39056-142">Der freigegebene Puffer wird nicht verwendet, wenn alle Lese-und Schreibvorgänge größer oder gleich `bufferSize`sind.</span><span class="sxs-lookup"><span data-stu-id="39056-142">The shared buffer is not used if all reads and writes are greater than or equal to `bufferSize`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39056-143">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.BufferedStream>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="39056-143">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#2)]
 [!code-csharp[System.IO.BufferedStream1#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#2)]
 [!code-vb[System.IO.BufferedStream1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39056-144"><paramref name="stream" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39056-144"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="39056-145"><paramref name="bufferSize" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="39056-145"><paramref name="bufferSize" /> is negative.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="39056-146">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="39056-146">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="39056-147">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="39056-147">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="39056-148">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="39056-148">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="bufferedStream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="39056-149">Der Puffer, in den die Daten eingelesen werden.</span><span class="sxs-lookup"><span data-stu-id="39056-149">The buffer to read the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="39056-150">Der Byteoffset im <paramref name="buffer" />, ab dem aus dem Stream gelesene Daten geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="39056-150">The byte offset in <paramref name="buffer" /> at which to begin writing data read from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="39056-151">Die maximale Anzahl der zu lesenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="39056-151">The maximum number of bytes to read.</span></span></param>
        <param name="callback"><span data-ttu-id="39056-152">Ein optionaler asynchroner Rückruf, der ausgeführt wird, wenn der Lesevorgang abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="39056-152">An optional asynchronous callback, to be called when the read is complete.</span></span></param>
        <param name="state"><span data-ttu-id="39056-153">Ein vom Benutzer bereitgestelltes Objekt, das zwischen dieser bestimmten asynchronen Leseanforderung und anderen Anforderungen unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="39056-153">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span></span></param>
        <summary><span data-ttu-id="39056-154">Startet einen asynchronen Lesevorgang.</span><span class="sxs-lookup"><span data-stu-id="39056-154">Begins an asynchronous read operation.</span></span> <span data-ttu-id="39056-155">(Verwenden Sie stattdessen <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</span><span class="sxs-lookup"><span data-stu-id="39056-155">(Consider using <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="39056-156">Ein Objekt, das den asynchronen Lesevorgang darstellt, der möglicherweise noch aussteht.</span><span class="sxs-lookup"><span data-stu-id="39056-156">An object that represents the asynchronous read, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39056-157">In der .NET Framework 4 und früheren Versionen erforderlich, wie z. B. <xref:System.IO.Stream.BeginRead%2A> und <xref:System.IO.Stream.EndRead%2A> , asynchrone Datei-Vorgänge zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="39056-157">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="39056-158">Diese Methoden sind weiterhin verfügbar, in der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zur Unterstützung von legacy-Code, jedoch die neuen Async-Methoden, wie z. B. <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, und <xref:System.IO.BufferedStream.FlushAsync%2A>, Hilfe, die Sie asynchrone Dateivorgänge leichter implementieren.</span><span class="sxs-lookup"><span data-stu-id="39056-158">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="39056-159"><xref:System.IO.BufferedStream.EndWrite%2A> muss genau einmal aufgerufen werden, für jeden Aufruf von <xref:System.IO.BufferedStream.BeginRead%2A>.</span><span class="sxs-lookup"><span data-stu-id="39056-159"><xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once for every call to <xref:System.IO.BufferedStream.BeginRead%2A>.</span></span> <span data-ttu-id="39056-160">Wenn ein Lesevorgang nicht beendet wird, bevor ein anderer Lesevorgang gestartet wird, kann dies unerwünschte Verhalten wie Deadlocks verursachen.</span><span class="sxs-lookup"><span data-stu-id="39056-160">Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="39056-161">Verwenden Sie die <xref:System.IO.BufferedStream.CanRead%2A>-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt</span><span class="sxs-lookup"><span data-stu-id="39056-161">Use the <xref:System.IO.BufferedStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="39056-162"><xref:System.IO.BufferedStream.EndRead%2A> müssen mit diesem <xref:System.IAsyncResult> aufgerufen werden, um herauszufinden, wie viele Bytes gelesen wurden.</span><span class="sxs-lookup"><span data-stu-id="39056-162"><xref:System.IO.BufferedStream.EndRead%2A> must be called with this <xref:System.IAsyncResult> to find out how many bytes were read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39056-163"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39056-163"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="39056-164"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="39056-164"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="39056-165">Es wurde ein asynchroner Lesevorgang über das Streamende hinaus versucht.</span><span class="sxs-lookup"><span data-stu-id="39056-165">Attempted an asynchronous read past the end of the stream.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="39056-166">Die Pufferlänge minus <paramref name="offset" /> ist kleiner als <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="39056-166">The buffer length minus <paramref name="offset" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="39056-167">Der aktuelle Stream unterstützt den Lesevorgang nicht.</span><span class="sxs-lookup"><span data-stu-id="39056-167">The current stream does not support the read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="bufferedStream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="39056-168">Der Puffer mit den Daten, die in den aktuellen Stream geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="39056-168">The buffer containing data to write to the current stream.</span></span></param>
        <param name="offset"><span data-ttu-id="39056-169">Der nullbasierte Byteoffset im <paramref name="buffer" />, ab dem Bytes in den aktuellen Stream kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="39056-169">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="39056-170">Die maximal zu schreibende Anzahl von Byte.</span><span class="sxs-lookup"><span data-stu-id="39056-170">The maximum number of bytes to write.</span></span></param>
        <param name="callback"><span data-ttu-id="39056-171">Die Methode, die aufgerufen werden soll, wenn der asynchrone Schreibvorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="39056-171">The method to be called when the asynchronous write operation is completed.</span></span></param>
        <param name="state"><span data-ttu-id="39056-172">Ein vom Benutzer bereitgestelltes Objekt, das zwischen dieser bestimmten asynchronen Schreibanforderung und anderen Anforderungen unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="39056-172">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span></span></param>
        <summary><span data-ttu-id="39056-173">Startet einen asynchronen Schreibvorgang.</span><span class="sxs-lookup"><span data-stu-id="39056-173">Begins an asynchronous write operation.</span></span> <span data-ttu-id="39056-174">(Verwenden Sie stattdessen <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</span><span class="sxs-lookup"><span data-stu-id="39056-174">(Consider using <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="39056-175">Ein Objekt, das auf den asynchronen Schreibvorgang verweist, der möglicherweise noch aussteht.</span><span class="sxs-lookup"><span data-stu-id="39056-175">An object that references the asynchronous write which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39056-176">In der .NET Framework 4 und früheren Versionen erforderlich, wie z. B. <xref:System.IO.Stream.BeginWrite%2A> und <xref:System.IO.Stream.EndWrite%2A> , asynchrone Datei-Vorgänge zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="39056-176">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="39056-177">Diese Methoden sind weiterhin verfügbar, in der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zur Unterstützung von legacy-Code, jedoch die neuen Async-Methoden, wie z. B. <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, und <xref:System.IO.BufferedStream.FlushAsync%2A>, Hilfe, die Sie asynchrone Dateivorgänge leichter implementieren.</span><span class="sxs-lookup"><span data-stu-id="39056-177">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="39056-178"><xref:System.IO.BufferedStream.EndWrite%2A> müssen für jede <xref:System.IAsyncResult> von <xref:System.IO.BufferedStream.BeginWrite%2A>genau einmal aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="39056-178"><xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once on every <xref:System.IAsyncResult> from <xref:System.IO.BufferedStream.BeginWrite%2A>.</span></span> <span data-ttu-id="39056-179"><xref:System.IO.BufferedStream.EndWrite%2A> wird blockiert, bis der e/a-Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="39056-179"><xref:System.IO.BufferedStream.EndWrite%2A> will block until the I/O operation has completed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="39056-180">Die Länge von <paramref name="buffer" /> minus <paramref name="offset" /> ist kleiner als <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="39056-180"><paramref name="buffer" /> length minus <paramref name="offset" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39056-181"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39056-181"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="39056-182"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="39056-182"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="39056-183">Der Stream unterstützt das Schreiben nicht.</span><span class="sxs-lookup"><span data-stu-id="39056-183">The stream does not support writing.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BufferSize">
      <MemberSignature Language="C#" Value="public int BufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.BufferSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BufferSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BufferSize : int" Usage="System.IO.BufferedStream.BufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="39056-184">Ruft die Puffergröße in Bytes für diesen gepufferten Stream ab.</span><span class="sxs-lookup"><span data-stu-id="39056-184">Gets the buffer size in bytes for this buffered stream.</span></span></summary>
        <value><span data-ttu-id="39056-185">Eine ganze Zahl, die die Puffergröße in Bytes darstellt.</span><span class="sxs-lookup"><span data-stu-id="39056-185">An integer representing the buffer size in bytes.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.BufferedStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="39056-186">Ruft einen Wert ab, der angibt, ob der aktuelle Stream Lesevorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="39056-186">Gets a value indicating whether the current stream supports reading.</span></span></summary>
        <value><span data-ttu-id="39056-187"><see langword="true" />, wenn der Stream Lesevorgänge unterstützt, <see langword="false" />, wenn der Stream geschlossen ist oder ausschließlich mit Schreibzugriff geöffnet wurde.</span><span class="sxs-lookup"><span data-stu-id="39056-187"><see langword="true" /> if the stream supports reading; <see langword="false" /> if the stream is closed or was opened with write-only access.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39056-188">Wenn eine von <xref:System.IO.Stream> abgeleitete Klasse Lesevorgänge nicht unterstützt, werden Aufrufe der <xref:System.IO.BufferedStream.Read%2A>, <xref:System.IO.BufferedStream.ReadByte%2A>, <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.EndRead%2A>und `Peek` Methoden <xref:System.IO.StreamReader>, <xref:System.IO.StringReader>und <xref:System.IO.TextReader> eine <xref:System.NotSupportedException>auslösen.</span><span class="sxs-lookup"><span data-stu-id="39056-188">If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.BufferedStream.Read%2A>, <xref:System.IO.BufferedStream.ReadByte%2A>, <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.EndRead%2A>, and the `Peek` methods of <xref:System.IO.StreamReader>, <xref:System.IO.StringReader>, and <xref:System.IO.TextReader> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="39056-189">Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="39056-189">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39056-190">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.BufferedStream>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="39056-190">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#5)]
 [!code-csharp[System.IO.BufferedStream1#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#5)]
 [!code-vb[System.IO.BufferedStream1#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="39056-191">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="39056-191">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="39056-192">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="39056-192">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="39056-193">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="39056-193">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.BufferedStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="39056-194">Ruft einen Wert ab, der angibt, ob der aktuelle Stream Suchvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="39056-194">Gets a value indicating whether the current stream supports seeking.</span></span></summary>
        <value><span data-ttu-id="39056-195"><see langword="true" />, wenn der Stream Suchvorgänge unterstützt, <see langword="false" />, wenn der Stream geschlossen ist oder von einem Betriebssystemhandle, z. B. einer Pipe oder einer Ausgabe an die Konsole, erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="39056-195"><see langword="true" /> if the stream supports seeking; <see langword="false" /> if the stream is closed or if the stream was constructed from an operating system handle such as a pipe or output to the console.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39056-196">Wenn eine von <xref:System.IO.Stream> abgeleitete Klasse keine Suchvorgänge unterstützt, werden Aufrufe von <xref:System.IO.BufferedStream.Length%2A>, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>und <xref:System.IO.BufferedStream.Seek%2A> eine <xref:System.NotSupportedException>auslösen.</span><span class="sxs-lookup"><span data-stu-id="39056-196">If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.BufferedStream.Length%2A>, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>, and <xref:System.IO.BufferedStream.Seek%2A> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="39056-197">Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="39056-197">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39056-198">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.BufferedStream>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="39056-198">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#3)]
 [!code-csharp[System.IO.BufferedStream1#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#3)]
 [!code-vb[System.IO.BufferedStream1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.SetLength(System.Int64)" />
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="39056-199">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="39056-199">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="39056-200">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="39056-200">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="39056-201">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="39056-201">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.BufferedStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="39056-202">Ruft einen Wert ab, der angibt, ob der aktuelle Stream Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="39056-202">Gets a value indicating whether the current stream supports writing.</span></span></summary>
        <value><span data-ttu-id="39056-203"><see langword="true" />, wenn der Stream Schreibvorgänge unterstützt, <see langword="false" />, wenn der Stream geschlossen ist oder mit schreibgeschütztem Zugriff geöffnet wurde.</span><span class="sxs-lookup"><span data-stu-id="39056-203"><see langword="true" /> if the stream supports writing; <see langword="false" /> if the stream is closed or was opened with read-only access.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39056-204">Wenn eine von <xref:System.IO.Stream> abgeleitete Klasse Schreibvorgänge nicht unterstützt, löst ein-<xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Write%2A>oder <xref:System.IO.BufferedStream.WriteByte%2A> einen <xref:System.NotSupportedException>aus.</span><span class="sxs-lookup"><span data-stu-id="39056-204">If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Write%2A>, or <xref:System.IO.BufferedStream.WriteByte%2A> throws a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="39056-205">Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`zurück.</span><span class="sxs-lookup"><span data-stu-id="39056-205">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39056-206">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.BufferedStream>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="39056-206">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#4)]
 [!code-csharp[System.IO.BufferedStream1#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#4)]
 [!code-vb[System.IO.BufferedStream1#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="39056-207">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="39056-207">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="39056-208">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="39056-208">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="39056-209">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="39056-209">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="bufferedStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="39056-210">Schließt den Stream und gibt alle Ressourcen frei (insbesondere Systemressourcen wie Sockets und Dateihandles), die dem aktuellen Pufferstream zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="39056-210">Closes the stream and releases any resources (especially system resources such as sockets and file handles) associated with the current buffered stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="39056-211">Alle Daten, die zuvor in den Puffer geschrieben wurden, werden in die zugrunde liegende Datenquelle oder das Repository kopiert, bevor der gepufferte Datenstrom geschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="39056-211">Any data previously written to the buffer is copied to the underlying data source or repository before the buffered stream is closed.</span></span> <span data-ttu-id="39056-212">Daher ist es nicht erforderlich, <xref:System.IO.BufferedStream.Flush> vor dem Aufrufen von "Close" aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="39056-212">Therefore, it is not necessary to call <xref:System.IO.BufferedStream.Flush> before invoking Close.</span></span> <span data-ttu-id="39056-213">Nach einem Aufrufen von Close können alle Vorgänge im gepufferten Stream Ausnahmen hervorrufen.</span><span class="sxs-lookup"><span data-stu-id="39056-213">Following a call to Close, any operations on the buffered stream might raise exceptions.</span></span>

<span data-ttu-id="39056-214">Das Leeren des Streams leert den zugrunde liegenden Encoder nicht, es sei denn, Sie haben explizit <xref:System.IO.BufferedStream.Flush> oder Close aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="39056-214">Flushing the stream will not flush its underlying encoder unless you explicitly call <xref:System.IO.BufferedStream.Flush> or Close.</span></span> <span data-ttu-id="39056-215">Wenn <xref:System.IO.StreamWriter.AutoFlush> auf "true" festgelegt wird, werden Daten aus dem Puffer in den Stream geleert, aber der Codierungs Status wird nicht geleert.</span><span class="sxs-lookup"><span data-stu-id="39056-215">Setting <xref:System.IO.StreamWriter.AutoFlush> to true means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</span></span> <span data-ttu-id="39056-216">Dies ermöglicht es dem Encoder, seinen Zustand (partielle Zeichen) beizubehalten, damit der nächste Zeichenblock ordnungsgemäß codiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="39056-216">This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</span></span> <span data-ttu-id="39056-217">Dieses Szenario wirkt sich auf UTF8 und UTF7 aus, bei denen bestimmte Zeichen nur codiert werden können, nachdem der Encoder die angrenzenden Zeichen oder Zeichen empfangen hat.</span><span class="sxs-lookup"><span data-stu-id="39056-217">This scenario affects UTF8 and UTF7 where certain characters can only be encoded after the encoder receives the adjacent character or characters.</span></span>

<span data-ttu-id="39056-218">Wenn Sie versuchen, einen Datenstrom zu manipulieren, nachdem er geschlossen wurde, kann ein <xref:System.ObjectDisposedException>ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="39056-218">Attempting to manipulate a stream after it has been closed might throw an <xref:System.ObjectDisposedException>.</span></span>

## Examples  
<span data-ttu-id="39056-219">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.BufferedStream>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="39056-219">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>

```vb
' When bufStream is closed, netStream is in turn 
' closed, which in turn shuts down the connection 
' and closes clientSocket.
Console.WriteLine(vbCrLf & "Shutting down the connection.")
bufStream.Close()
```

```csharp
// When bufStream is closed, netStream is in turn
// closed, which in turn shuts down the connection
// and closes clientSocket.
Console.WriteLine("\nShutting down the connection.");
bufStream.Close();
```

```cpp
// When bufStream is closed, netStream is in turn closed,
// which in turn shuts down the connection and closes
// clientSocket.
Console::WriteLine( "\nShutting down connection." );
bufStream->Close();

```

]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="39056-220">Beim Schließend des Streams ist ein Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="39056-220">An error occurred while trying to close the stream.</span></span></exception>
        <altmember cref="M:System.IO.BufferedStream.Flush" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="39056-221">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="39056-221">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="39056-222">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="39056-222">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="39056-223">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="39056-223">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public override void CopyTo (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub CopyTo (destination As Stream, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void CopyTo(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.IO.Stream * int -&gt; unit" Usage="bufferedStream.CopyTo (destination, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="39056-224">Der Stream, in den der Inhalt des aktuellen gepufferten Stream kopiert wird.</span><span class="sxs-lookup"><span data-stu-id="39056-224">The stream to which the contents of the current buffered stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="39056-225">Die Größe des Puffers.</span><span class="sxs-lookup"><span data-stu-id="39056-225">The size of the buffer.</span></span> <span data-ttu-id="39056-226">Dieser Wert muss größer als 0 sein.</span><span class="sxs-lookup"><span data-stu-id="39056-226">This value must be greater than zero.</span></span> <span data-ttu-id="39056-227">Die Standardgröße ist 81920.</span><span class="sxs-lookup"><span data-stu-id="39056-227">The default size is 81920.</span></span></param>
        <summary><span data-ttu-id="39056-228">Liest alle Bytes aus dem aktuellen gepufferten Stream und schreibt sie in einen anderen Datenstrom.</span><span class="sxs-lookup"><span data-stu-id="39056-228">Reads the bytes from the current buffered stream and writes them to another stream.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39056-229"><paramref name="destination" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39056-229"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="39056-230"><paramref name="bufferSize" /> ist negativ oder 0 (null).</span><span class="sxs-lookup"><span data-stu-id="39056-230"><paramref name="bufferSize" /> is negative or zero.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="39056-231">Lesevorgänge werden vom aktuellen Stream nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="39056-231">The current stream does not support reading.</span></span>

<span data-ttu-id="39056-232">- oder -</span><span class="sxs-lookup"><span data-stu-id="39056-232">-or-</span></span>

<span data-ttu-id="39056-233"><paramref name="destination" /> unterstützt das Schreiben nicht.</span><span class="sxs-lookup"><span data-stu-id="39056-233"><paramref name="destination" /> does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="39056-234">Entweder der aktuelle Stream oder <paramref name="destination" /> wurde geschlossen, bevor die <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" />-Methode aufgerufen wurde.</span><span class="sxs-lookup"><span data-stu-id="39056-234">Either the current stream or <paramref name="destination" /> was closed before the <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> method was called.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="39056-235">E/A-Fehler</span><span class="sxs-lookup"><span data-stu-id="39056-235">An I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="bufferedStream.CopyToAsync (destination, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="39056-236">Der Stream, in den der Inhalt des aktuellen gepufferten Stream kopiert wird.</span><span class="sxs-lookup"><span data-stu-id="39056-236">The stream to which the contents of the current buffered stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="39056-237">Die Größe des Cookies in Bytes.</span><span class="sxs-lookup"><span data-stu-id="39056-237">The size, in bytes, of the buffer.</span></span> <span data-ttu-id="39056-238">Dieser Wert muss größer als 0 sein.</span><span class="sxs-lookup"><span data-stu-id="39056-238">This value must be greater than zero.</span></span> <span data-ttu-id="39056-239">Die Standardgröße ist 81920.</span><span class="sxs-lookup"><span data-stu-id="39056-239">The default sizer is 81920.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="39056-240">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="39056-240">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="39056-241">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="39056-241">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="39056-242">Liest die Bytes asynchron aus dem aktuellen gepufferten Stream und schreibt sie unter Verwendung einer angegebenen Puffergröße und eines Abbruchtokens in einen anderen Stream.</span><span class="sxs-lookup"><span data-stu-id="39056-242">Asynchronously reads the bytes from the current buffered stream and writes them to another stream, using a specified buffer size and cancellation token.</span></span></summary>
        <returns><span data-ttu-id="39056-243">Eine Aufgabe, die den asynchronen Kopiervorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="39056-243">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="39056-244">Die `CopyToAsync`-Methode ermöglicht es Ihnen, ressourcenintensive e/a-Vorgänge auszuführen, ohne den Haupt Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="39056-244">The `CopyToAsync` method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="39056-245">Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert.</span><span class="sxs-lookup"><span data-stu-id="39056-245">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="39056-246">Die Async-Methoden werden in Verbindung mit den Schlüsselwörtern `async` und `await` in Visual Basic C#und verwendet.</span><span class="sxs-lookup"><span data-stu-id="39056-246">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  

<span data-ttu-id="39056-247">Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die zurückgegebene Aufgabe den <xref:System.Threading.Tasks.TaskStatus.Canceled> Wert für die <xref:System.Threading.Tasks.Task.Status%2A>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="39056-247">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  

<span data-ttu-id="39056-248">Der Kopiervorgang beginnt an der aktuellen Position im aktuellen Stream.</span><span class="sxs-lookup"><span data-stu-id="39056-248">Copying begins at the current position in the current stream.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="bufferedStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="39056-249"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="39056-249"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="39056-250">Gibt die vom gepufferten Stream verwendeten nicht verwalteten Ressourcen frei und gibt (optional) auch die verwalteten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="39056-250">Releases the unmanaged resources used by the buffered stream and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="39056-251">Sie sollten alle Ressourcen freigeben, indem Sie `true` für `disposing`angeben.</span><span class="sxs-lookup"><span data-stu-id="39056-251">You should release all resources by specifying `true` for `disposing`.</span></span> <span data-ttu-id="39056-252">Wenn `disposing` `true`ist, kann der Stream auch sicherstellen, dass Daten in den zugrunde liegenden Puffer geleert werden und auf andere finalisierbare Objekte zugreifen.</span><span class="sxs-lookup"><span data-stu-id="39056-252">When `disposing` is `true`, the stream can also ensure data is flushed to the underlying buffer, and access other finalizable objects.</span></span> <span data-ttu-id="39056-253">Dies ist möglicherweise nicht möglich, wenn der Aufruf von einem Finalizer aufgrund fehlender Reihenfolge zwischen Finalizern erfolgt.</span><span class="sxs-lookup"><span data-stu-id="39056-253">This may not be possible when called from a finalizer due a lack of ordering among finalizers.</span></span>

<span data-ttu-id="39056-254">Wenn Ihr Stream ein Betriebssystem Handle für die Kommunikation mit seiner Quelle verwendet, sollten Sie die Verwendung einer Unterklasse von <xref:System.Runtime.InteropServices.SafeHandle> zu diesem Zweck in Erwägung gezogen.</span><span class="sxs-lookup"><span data-stu-id="39056-254">If your stream is using an operating system handle to communicate with its source, consider using a subclass of <xref:System.Runtime.InteropServices.SafeHandle> for this purpose.</span></span>

<span data-ttu-id="39056-255">Diese Methode wird von der öffentlichen <xref:System.ComponentModel.Component.Dispose>-Methode und der <xref:System.Object.Finalize%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="39056-255">This method is called by the public <xref:System.ComponentModel.Component.Dispose> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="39056-256"><xref:System.ComponentModel.Component.Dispose> Ruft die geschützte `Dispose(Boolean)` Methode auf, wobei der `disposing`-Parameter auf `true`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="39056-256"><xref:System.ComponentModel.Component.Dispose> invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="39056-257"><xref:System.Object.Finalize%2A> ruft `Dispose(Boolean)` auf, bei dem `disposing` auf `false`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="39056-257"><xref:System.Object.Finalize%2A> invokes `Dispose(Boolean)` with `disposing` set to `false`.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="bufferedStream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="39056-258">Gibt die nicht verwalteten Ressourcen, die vom gepufferten Stream verwendet werden, asynchron frei.</span><span class="sxs-lookup"><span data-stu-id="39056-258">Asynchronously releases the unmanaged resources used by the buffered stream.</span></span></summary>
        <returns><span data-ttu-id="39056-259">Eine Aufgabe, die den asynchronen Löschvorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="39056-259">A task that represents the asynchronous dispose operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="39056-260">Die `DisposeAsync`-Methode ermöglicht es Ihnen, einen ressourcenintensiven Löschvorgang auszuführen, ohne den Haupt Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="39056-260">The `DisposeAsync` method enables you to perform a resource-intensive dispose operation without blocking the main thread.</span></span> <span data-ttu-id="39056-261">Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert.</span><span class="sxs-lookup"><span data-stu-id="39056-261">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="39056-262">Die Async-Methoden werden in Verbindung mit den Schlüsselwörtern `async` und `await` in Visual Basic C#und verwendet.</span><span class="sxs-lookup"><span data-stu-id="39056-262">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="39056-263">Diese Methode löscht den Datenstrom, indem alle Änderungen an den Sicherungs Speicher geschrieben und der Stream zum Freigeben von Ressourcen geschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="39056-263">This method disposes the stream by writing any changes to the backing store and closing the stream to release resources.</span></span>

<span data-ttu-id="39056-264">Durch Aufrufen von `DisposeAsync` können die Ressourcen, die vom <xref:System.IO.BufferedStream> verwendet werden, für andere Zwecke neu zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="39056-264">Calling `DisposeAsync` allows the resources used by the <xref:System.IO.BufferedStream> to be reallocated for other purposes.</span></span> <span data-ttu-id="39056-265">Weitere Informationen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="39056-265">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="bufferedStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="39056-266">Der Verweis auf die ausstehende asynchrone Anforderung, die abgewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="39056-266">The reference to the pending asynchronous request to wait for.</span></span></param>
        <summary><span data-ttu-id="39056-267">Wartet, bis der ausstehende asynchrone Lesevorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="39056-267">Waits for the pending asynchronous read operation to complete.</span></span> <span data-ttu-id="39056-268">(Verwenden Sie stattdessen <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</span><span class="sxs-lookup"><span data-stu-id="39056-268">(Consider using <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="39056-269">Die Anzahl der aus dem Stream gelesenen Bytes. Diese Anzahl kann zwischen 0 und der Anzahl der angeforderten Bytes liegen.</span><span class="sxs-lookup"><span data-stu-id="39056-269">The number of bytes read from the stream, between 0 (zero) and the number of bytes you requested.</span></span> <span data-ttu-id="39056-270">Streams geben nur am Ende des Streams nur 0 zurück, andernfalls sollten sie blockieren, bis mindestens 1 Byte verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="39056-270">Streams only return 0 only at the end of the stream, otherwise, they should block until at least 1 byte is available.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39056-271">In der .NET Framework 4 und früheren Versionen erforderlich, wie z. B. <xref:System.IO.Stream.BeginRead%2A> und <xref:System.IO.Stream.EndRead%2A> , asynchrone Datei-Vorgänge zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="39056-271">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="39056-272">Diese Methoden sind weiterhin verfügbar, in der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zur Unterstützung von legacy-Code, jedoch die neuen Async-Methoden, wie z. B. <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, und <xref:System.IO.BufferedStream.FlushAsync%2A>, Hilfe, die Sie asynchrone Dateivorgänge leichter implementieren.</span><span class="sxs-lookup"><span data-stu-id="39056-272">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="39056-273"><xref:System.IO.BufferedStream.EndRead%2A> müssen mit diesem <xref:System.IAsyncResult> aufgerufen werden, um herauszufinden, wie viele Bytes gelesen wurden.</span><span class="sxs-lookup"><span data-stu-id="39056-273"><xref:System.IO.BufferedStream.EndRead%2A> must be called with this <xref:System.IAsyncResult> to find out how many bytes were read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39056-274"><paramref name="asyncResult" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39056-274"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="39056-275">Dieses <see cref="T:System.IAsyncResult" />-Objekt wurde nicht durch Aufrufen von <see cref="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> für diese Klasse erstellt.</span><span class="sxs-lookup"><span data-stu-id="39056-275">This <see cref="T:System.IAsyncResult" /> object was not created by calling <see cref="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> on this class.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="bufferedStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="39056-276">Die ausstehende asynchrone Anforderung.</span><span class="sxs-lookup"><span data-stu-id="39056-276">The pending asynchronous request.</span></span></param>
        <summary><span data-ttu-id="39056-277">Beendet einen asynchronen Schreibvorgang und blockiert, bis die E/A-Operation abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="39056-277">Ends an asynchronous write operation and blocks until the I/O operation is complete.</span></span> <span data-ttu-id="39056-278">(Verwenden Sie stattdessen <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</span><span class="sxs-lookup"><span data-stu-id="39056-278">(Consider using <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39056-279">In der .NET Framework 4 und früheren Versionen erforderlich, wie z. B. <xref:System.IO.Stream.BeginWrite%2A> und <xref:System.IO.Stream.EndWrite%2A> , asynchrone Datei-Vorgänge zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="39056-279">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="39056-280">Diese Methoden sind weiterhin verfügbar, in der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zur Unterstützung von legacy-Code, jedoch die neuen Async-Methoden, wie z. B. <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, und <xref:System.IO.BufferedStream.FlushAsync%2A>, Hilfe, die Sie asynchrone Dateivorgänge leichter implementieren.</span><span class="sxs-lookup"><span data-stu-id="39056-280">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="39056-281"><xref:System.IO.BufferedStream.EndWrite%2A> muss genau einmal aufgerufen werden, für jeden Aufruf von <xref:System.IO.BufferedStream.BeginRead%2A>.</span><span class="sxs-lookup"><span data-stu-id="39056-281"><xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once for every call to <xref:System.IO.BufferedStream.BeginRead%2A>.</span></span> <span data-ttu-id="39056-282">Wenn ein Lesevorgang nicht beendet wird, bevor ein anderer Lesevorgang gestartet wird, kann dies zu Deadlocks oder anderem unerwünschten Verhalten führen.</span><span class="sxs-lookup"><span data-stu-id="39056-282">Failing to end a read process before beginning another read operation can cause deadlock or other undesirable behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39056-283"><paramref name="asyncResult" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39056-283"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="39056-284">Dieses <see cref="T:System.IAsyncResult" />-Objekt wurde nicht durch Aufrufen von <see cref="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> für diese Klasse erstellt.</span><span class="sxs-lookup"><span data-stu-id="39056-284">This <see cref="T:System.IAsyncResult" /> object was not created by calling <see cref="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> on this class.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="bufferedStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="39056-285">Löscht sämtliche Puffer für diesen Stream und veranlasst die Ausgabe aller gepufferten Daten an das zugrunde liegende Gerät.</span><span class="sxs-lookup"><span data-stu-id="39056-285">Clears all buffers for this stream and causes any buffered data to be written to the underlying device.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39056-286">Das Leeren des Streams leert den zugrunde liegenden Encoder nicht, es sei denn, Sie haben explizit `Flush` oder <xref:System.IO.Stream.Close%2A>aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="39056-286">Flushing the stream will not flush its underlying encoder unless you explicitly call `Flush` or <xref:System.IO.Stream.Close%2A>.</span></span>  
  
 <span data-ttu-id="39056-287">Wenn Sie den <xref:System.IO.BufferedStream.%23ctor%2A>-Konstruktor verwenden und damit die Puffergröße beim Erstellen des `BufferedStream` Objekts angeben, wird der Inhalt geleert, wenn er die Puffergröße erreicht.</span><span class="sxs-lookup"><span data-stu-id="39056-287">If you use the <xref:System.IO.BufferedStream.%23ctor%2A> constructor, thus specifying the buffer size while creating the `BufferedStream` object, the content is flushed when it reaches the buffer size.</span></span> <span data-ttu-id="39056-288">Beispielsweise wird der Inhalt durch Code wie `BufferedStream bs = new BufferedStream(bs, 5)` geleert, wenn die Puffergröße 5 Bytes erreicht.</span><span class="sxs-lookup"><span data-stu-id="39056-288">For example, code such as `BufferedStream bs = new BufferedStream(bs, 5)` will flush the content when the buffer size reaches 5 bytes.</span></span>  
  
 <span data-ttu-id="39056-289">Alle Lese-und Schreib Methoden von `BufferedStream` den Puffer automatisch verwalten, sodass es nicht erforderlich ist, `Flush` beim Wechseln zwischen Lese-und Schreib vorblicken aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="39056-289">All the read and write methods of `BufferedStream` automatically maintain the buffer, so there is no need to invoke `Flush` when switching back and forth between reading and writing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39056-290">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.BufferedStream>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="39056-290">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#6)]
 [!code-csharp[System.IO.BufferedStream1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#6)]
 [!code-vb[System.IO.BufferedStream1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="39056-291">Der Stream wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="39056-291">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="39056-292">Die Datenquelle oder das Repository ist nicht geöffnet.</span><span class="sxs-lookup"><span data-stu-id="39056-292">The data source or repository is not open.</span></span></exception>
        <altmember cref="M:System.IO.Stream.Close" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="39056-293">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="39056-293">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="39056-294">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="39056-294">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="39056-295">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="39056-295">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="bufferedStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="39056-296">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="39056-296">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="39056-297">Löscht alle Puffer für diesen Stream asynchron und veranlasst die Ausgabe aller gepufferten Daten an das zugrunde liegende Gerät und überwacht Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="39056-297">Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="39056-298">Eine Aufgabe, die die asynchrone Leerung darstellt.</span><span class="sxs-lookup"><span data-stu-id="39056-298">A task that represents the asynchronous flush operation.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="39056-299">Der Stream wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="39056-299">The stream has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.BufferedStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="39056-300">Ruft die Länge des Streams in Bytes ab.</span><span class="sxs-lookup"><span data-stu-id="39056-300">Gets the stream length in bytes.</span></span></summary>
        <value><span data-ttu-id="39056-301">Die Länge des Streams in Bytes.</span><span class="sxs-lookup"><span data-stu-id="39056-301">The stream length in bytes.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="39056-302">Der zugrunde liegende Stream ist <see langword="null" /> oder geschlossen.</span><span class="sxs-lookup"><span data-stu-id="39056-302">The underlying stream is <see langword="null" /> or closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="39056-303">Vom Stream wird Suchen nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="39056-303">The stream does not support seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="39056-304">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="39056-304">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="39056-305">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="39056-305">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="39056-306">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="39056-306">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="39056-307">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="39056-307">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.BufferedStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="39056-308">Ruft die Position im aktuellen Stream ab.</span><span class="sxs-lookup"><span data-stu-id="39056-308">Gets the position within the current stream.</span></span></summary>
        <value><span data-ttu-id="39056-309">Die Position im aktuellen Stream.</span><span class="sxs-lookup"><span data-stu-id="39056-309">The position within the current stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39056-310">Der `get`-Accessor ruft <xref:System.IO.BufferedStream.Seek%2A> auf, um die aktuelle Position im zugrunde liegenden Stream abzurufen, und passt diesen Wert dann entsprechend der aktuellen Position innerhalb des Puffers an.</span><span class="sxs-lookup"><span data-stu-id="39056-310">The `get` accessor invokes <xref:System.IO.BufferedStream.Seek%2A> to obtain the current position within the underlying stream and then adjusts this value according to the current position within the buffer.</span></span>  
  
 <span data-ttu-id="39056-311">Der `set` Accessor kopiert alle Daten, die zuvor in den Puffer geschrieben wurden, in den zugrunde liegenden Stream und ruft dann <xref:System.IO.BufferedStream.Seek%2A>auf.</span><span class="sxs-lookup"><span data-stu-id="39056-311">The `set` accessor copies any data previously written to the buffer to the underlying stream, and then invokes <xref:System.IO.BufferedStream.Seek%2A>.</span></span>  
  
 <span data-ttu-id="39056-312">Das Suchen nach einem beliebigen Speicherort über die Länge des Streams wird unterstützt.</span><span class="sxs-lookup"><span data-stu-id="39056-312">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="39056-313">Der an <see cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" /> übergebene Wert ist negativ.</span><span class="sxs-lookup"><span data-stu-id="39056-313">The value passed to <see cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="39056-314">Ein E/A-Fehler ist aufgetreten, beispielsweise durch Schließen des Streams.</span><span class="sxs-lookup"><span data-stu-id="39056-314">An I/O error occurs, such as the stream being closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="39056-315">Vom Stream wird Suchen nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="39056-315">The stream does not support seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="39056-316">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="39056-316">Methods were called after the stream was closed.</span></span></exception>
        <altmember cref="P:System.IO.BufferedStream.CanSeek" />
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="39056-317">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="39056-317">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="39056-318">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="39056-318">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="39056-319">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="39056-319">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; destination);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="bufferedStream.Read destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="39056-320">Ein Bereich im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="39056-320">A region of memory.</span></span> <span data-ttu-id="39056-321">Bei der Rückgabe dieser Methode werden die Inhalte dieses Bereichs durch die aus der aktuellen Quelle gelesenen Bytes ersetzt.</span><span class="sxs-lookup"><span data-stu-id="39056-321">When this method returns, the contents of this region are replaced by the bytes read from the current source.</span></span></param>
        <summary><span data-ttu-id="39056-322">Kopiert Bytes aus dem gepufferten Stream in eine Bytespanne und verschiebt die Position im gepufferten Stream um die Anzahl der gelesenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="39056-322">Copies bytes from the current buffered stream to a byte span and advances the position within the buffered stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="39056-323">Die Gesamtanzahl der in den Puffer eingelesenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="39056-323">The total number of bytes read into the buffer.</span></span> <span data-ttu-id="39056-324">Dies kann weniger als die Anzahl der im Puffer zugeordneten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder 0 (null), wenn das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="39056-324">This can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="39056-325">Verwenden Sie die <xref:System.IO.BufferedStream.CanRead%2A>-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt</span><span class="sxs-lookup"><span data-stu-id="39056-325">Use the <xref:System.IO.BufferedStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span> <span data-ttu-id="39056-326">Verwenden Sie die <xref:System.IO.BufferedStream.ReadAsync%2A>-Methode, um asynchron aus dem aktuellen Stream zu lesen.</span><span class="sxs-lookup"><span data-stu-id="39056-326">Use the <xref:System.IO.BufferedStream.ReadAsync%2A> method to read asynchronously from the current stream.</span></span>

<span data-ttu-id="39056-327">Implementierungen dieser Methode lesen maximal `buffer.Length` Bytes aus dem aktuellen Stream und speichern Sie in `buffer`.</span><span class="sxs-lookup"><span data-stu-id="39056-327">Implementations of this method read a maximum of `buffer.Length` bytes from the current stream and store them in `buffer`.</span></span> <span data-ttu-id="39056-328">Die aktuelle Position innerhalb des Streams wird um die Anzahl der gelesenen Bytes erweitert. Wenn jedoch eine Ausnahme auftritt, bleibt die aktuelle Position im Stream unverändert.</span><span class="sxs-lookup"><span data-stu-id="39056-328">The current position within the stream is advanced by the number of bytes read; however, if an exception occurs, the current position within the stream remains unchanged.</span></span> <span data-ttu-id="39056-329">Implementierungen geben die Anzahl der gelesenen Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="39056-329">Implementations return the number of bytes read.</span></span> <span data-ttu-id="39056-330">Die-Implementierung wird blockiert, bis mindestens ein Byte der Daten gelesen werden kann, wenn keine Daten verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="39056-330">The implementation will block until at least one byte of data can be read, in the event that no data is available.</span></span> <span data-ttu-id="39056-331">`Read` gibt 0 nur zurück, wenn keine weiteren Daten im Stream vorhanden sind und nicht mehr erwartet wird (z. b. ein geschlossener Socket oder ein Dateiende).</span><span class="sxs-lookup"><span data-stu-id="39056-331">`Read` returns 0 only when there is no more data in the stream and no more is expected (such as a closed socket or end of file).</span></span> <span data-ttu-id="39056-332">Eine-Implementierung kann weniger Bytes zurückgeben als angefordert werden, auch wenn das Ende des Streams nicht erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="39056-332">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>

<span data-ttu-id="39056-333">Verwenden Sie <xref:System.IO.BinaryReader> zum Lesen primitiver Datentypen.</span><span class="sxs-lookup"><span data-stu-id="39056-333">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] array, int32 offset, int32 count) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="bufferedStream.Read (array, offset, count)" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="39056-334">Der Puffer, in den Bytes kopiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="39056-334">The buffer to which bytes are to be copied.</span></span></param>
        <param name="offset"><span data-ttu-id="39056-335">Der Byteoffset im Puffer, ab dem mit dem Lesen von Bytes begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="39056-335">The byte offset in the buffer at which to begin reading bytes.</span></span></param>
        <param name="count"><span data-ttu-id="39056-336">Die Anzahl der zu lesenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="39056-336">The number of bytes to be read.</span></span></param>
        <summary><span data-ttu-id="39056-337">Kopiert Bytes aus dem aktuellen gepufferten Stream in ein Array.</span><span class="sxs-lookup"><span data-stu-id="39056-337">Copies bytes from the current buffered stream to an array.</span></span></summary>
        <returns><span data-ttu-id="39056-338">Die Anzahl der insgesamt in das <paramref name="array" /> gelesenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="39056-338">The total number of bytes read into <paramref name="array" />.</span></span> <span data-ttu-id="39056-339">Diese kann kleiner sein als die Anzahl der angeforderten Bytes, wenn derzeit nicht entsprechend viele Bytes verfügbar sind, oder 0, wenn das Ende des Streams erreicht ist, bevor Daten gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="39056-339">This can be less than the number of bytes requested if that many bytes are not currently available, or 0 if the end of the stream has been reached before any data can be read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39056-340">Die `Read`-Methode gibt 0 (null) nur dann zurück, wenn das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="39056-340">The `Read` method will return 0 only if the end of the stream is reached.</span></span> <span data-ttu-id="39056-341">In allen anderen Fällen liest `Read` vor der Rückgabe immer mindestens ein Byte aus dem Datenstrom.</span><span class="sxs-lookup"><span data-stu-id="39056-341">In all other cases, `Read` always reads at least one byte from the stream before returning.</span></span> <span data-ttu-id="39056-342">Definitionsgemäß gibt die `Read` Methode "0" zurück (das Ende des Streams wird automatisch erreicht), wenn keine Daten aus dem Stream bei einem `Read`verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="39056-342">By definition, if no data is available from the stream upon a call to `Read`, the `Read` method returns 0 (the end of the stream is reached automatically).</span></span> <span data-ttu-id="39056-343">Eine-Implementierung kann weniger Bytes zurückgeben als angefordert werden, auch wenn das Ende des Streams nicht erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="39056-343">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="39056-344">Verwenden Sie <xref:System.IO.BinaryReader> zum Lesen primitiver Datentypen.</span><span class="sxs-lookup"><span data-stu-id="39056-344">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39056-345">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.BufferedStream>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="39056-345">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#7)]
 [!code-csharp[System.IO.BufferedStream1#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#7)]
 [!code-vb[System.IO.BufferedStream1#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="39056-346">Die Länge von <paramref name="array" /> minus <paramref name="offset" /> ist kleiner als <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="39056-346">Length of <paramref name="array" /> minus <paramref name="offset" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39056-347"><paramref name="array" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39056-347"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="39056-348"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="39056-348"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="39056-349">Der Stream ist nicht geöffnet oder ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39056-349">The stream is not open or is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="39056-350">Lesevorgänge werden vom Stream nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="39056-350">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="39056-351">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="39056-351">Methods were called after the stream was closed.</span></span></exception>
        <altmember cref="M:System.Buffer.BlockCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="P:System.IO.BufferedStream.CanRead" />
        <altmember cref="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="39056-352">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="39056-352">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="39056-353">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="39056-353">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="39056-354">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="39056-354">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="bufferedStream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="39056-355">Der Bereich im Arbeitsspeicher, in den die Daten geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="39056-355">The region of memory to write the data into.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="39056-356">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="39056-356">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="39056-357">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="39056-357">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="39056-358">Liest eine Bytesequenz asynchron aus dem aktuellen gepufferten Stream und setzt die Position in diesem gepufferten Stream um die Anzahl der gelesenen Bytes nach vorn.</span><span class="sxs-lookup"><span data-stu-id="39056-358">Asynchronously reads a sequence of bytes from the current buffered stream and advances the position within the buffered stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="39056-359">Eine Aufgabe, die den asynchronen Lesevorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="39056-359">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="39056-360">Der Wert seiner <see cref="P:System.Threading.Tasks.ValueTask`1.Result" />-Eigenschaft enthält die Gesamtzahl der Bytes, die in den Puffer gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="39056-360">The value of its <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> property contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="39056-361">Der Ergebniswert kann weniger als die Anzahl der im Puffer zugeordneten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder er kann 0 (null) sein, wenn das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="39056-361">The result value can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="39056-362">Die `ReadAsync`-Methode ermöglicht es Ihnen, ressourcenintensive e/a-Vorgänge auszuführen, ohne den Haupt Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="39056-362">The `ReadAsync` method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="39056-363">Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert.</span><span class="sxs-lookup"><span data-stu-id="39056-363">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="39056-364">Die Async-Methoden werden in Verbindung mit den Schlüsselwörtern `async` und `await` in Visual Basic C#und verwendet.</span><span class="sxs-lookup"><span data-stu-id="39056-364">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="39056-365">Verwenden Sie die <xref:System.IO.BufferedStream.CanRead%2A>-Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt</span><span class="sxs-lookup"><span data-stu-id="39056-365">Use the <xref:System.IO.BufferedStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>

<span data-ttu-id="39056-366">Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die zurückgegebene Aufgabe den <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> Wert für die <xref:System.Threading.Tasks.Task.Status>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="39056-366">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status> property.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="bufferedStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="39056-367">Der Puffer, in den die Daten geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="39056-367">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="39056-368">Der Byteoffset im <paramref name="buffer" />, ab dem Daten aus dem Stream geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="39056-368">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="39056-369">Die maximale Anzahl der zu lesenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="39056-369">The maximum number of bytes to read.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="39056-370">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="39056-370">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="39056-371">Liest eine Folge von Bytes asynchron aus aktuellen Stream, erhöht die Position im Stream um die Anzahl der gelesenen Bytes und überwacht Abbruchanfragen.</span><span class="sxs-lookup"><span data-stu-id="39056-371">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="39056-372">Eine Aufgabe, die den asynchronen Lesevorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="39056-372">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="39056-373">Der Wert des <paramref name="TResult" />-Parameters enthält die Gesamtzahl der Bytes, die in den Puffer gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="39056-373">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="39056-374">Der Ergebniswert kann niedriger als die Anzahl der angeforderten Bytes sein, wenn die Anzahl an derzeit verfügbaren Bytes kleiner ist als die angeforderte Anzahl, oder sie kann 0 (null) sein, wenn das Datenstromende erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="39056-374">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39056-375">Sie können ein Abbruch Token erstellen, indem Sie eine Instanz der <xref:System.Threading.CancellationTokenSource>-Klasse erstellen und die <xref:System.Threading.CancellationTokenSource.Token%2A>-Eigenschaft als `cancellationToken`-Parameter übergeben.</span><span class="sxs-lookup"><span data-stu-id="39056-375">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39056-376"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39056-376"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="39056-377"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="39056-377"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="39056-378">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Pufferlänge.</span><span class="sxs-lookup"><span data-stu-id="39056-378">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="39056-379">Lesevorgänge werden vom Stream nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="39056-379">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="39056-380">Der Stream wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="39056-380">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="39056-381">Der Stream wird zurzeit von einem vorherigen Lesevorgang verwendet.</span><span class="sxs-lookup"><span data-stu-id="39056-381">The stream is currently in use by a previous read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="bufferedStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="39056-382">Liest ein Byte aus dem zugrunde liegenden Stream und gibt dieses in ein <see langword="int" /> umgewandelt zurück, bzw. wird -1 zurückgegeben, wenn das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="39056-382">Reads a byte from the underlying stream and returns the byte cast to an <see langword="int" />, or returns -1 if reading from the end of the stream.</span></span></summary>
        <returns><span data-ttu-id="39056-383">Das Byte, umgewandelt in ein <see langword="int" />, oder -1, wenn das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="39056-383">The byte cast to an <see langword="int" />, or -1 if reading from the end of the stream.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="39056-384">Ein E/A-Fehler ist aufgetreten, beispielsweise durch Schließen des Streams.</span><span class="sxs-lookup"><span data-stu-id="39056-384">An I/O error occurs, such as the stream being closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="39056-385">Lesevorgänge werden vom Stream nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="39056-385">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="39056-386">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="39056-386">Methods were called after the stream was closed.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="39056-387">Die Standard Implementierung auf <see langword="Stream" /> erstellt ein neues Einzel Byte Array und ruft dann <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />auf.</span><span class="sxs-lookup"><span data-stu-id="39056-387">The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />.</span></span> <span data-ttu-id="39056-388">Obwohl dies formal korrekt ist, ist es ineffizient.</span><span class="sxs-lookup"><span data-stu-id="39056-388">While this is formally correct, it is inefficient.</span></span> <span data-ttu-id="39056-389">Jeder Datenstrom mit einem internen Puffer sollte diese Methode überschreiben und eine wesentlich effizientere Version bereitstellen, die den Puffer direkt liest, wobei die zusätzliche Array Zuordnung bei jedem-Befehl vermieden wird.</span><span class="sxs-lookup"><span data-stu-id="39056-389">Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</span></span></para></block>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="39056-390">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="39056-390">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="39056-391">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="39056-391">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="39056-392">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="39056-392">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="bufferedStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="39056-393">Ein Byteoffset im Verhältnis zu <paramref name="origin" />.</span><span class="sxs-lookup"><span data-stu-id="39056-393">A byte offset relative to <paramref name="origin" />.</span></span></param>
        <param name="origin"><span data-ttu-id="39056-394">Ein Wert vom Typ <see cref="T:System.IO.SeekOrigin" />, der den Bezugspunkt angibt, von dem aus die neue Position ermittelt wird.</span><span class="sxs-lookup"><span data-stu-id="39056-394">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the reference point from which to obtain the new position.</span></span></param>
        <summary><span data-ttu-id="39056-395">Legt die Position im aktuellen gepufferten Stream fest.</span><span class="sxs-lookup"><span data-stu-id="39056-395">Sets the position within the current buffered stream.</span></span></summary>
        <returns><span data-ttu-id="39056-396">Die neue Position innerhalb des aktuellen gepufferten Streams.</span><span class="sxs-lookup"><span data-stu-id="39056-396">The new position within the current buffered stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39056-397">Wenn `offset` negativ ist, liegt die die neue Position um die durch `origin` angegebene Anzahl von Bytes vor der durch `offset` angegebenen Position.</span><span class="sxs-lookup"><span data-stu-id="39056-397">If `offset` is negative, the new position will precede the position specified by `origin` by the number of bytes specified by `offset`.</span></span> <span data-ttu-id="39056-398">Wenn `offset` 0 ist, ist die neue Position die Position, die von `origin`angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="39056-398">If `offset` is 0, the new position will be the position specified by `origin`.</span></span> <span data-ttu-id="39056-399">Wenn `offset` positiv ist, liegt die neue Position um die durch `origin` angegebene Anzahl an Bytes hinter der durch `offset` angegebenen Position.</span><span class="sxs-lookup"><span data-stu-id="39056-399">If `offset` is positive, the new position will follow the position specified by `origin` by the number of bytes specified by `offset`.</span></span>  
  
 <span data-ttu-id="39056-400">Wenn ein <xref:System.IO.BufferedStream> Objekt der Basisstream für ein <xref:System.IO.StreamReader> Objekt ist, kann das Aufrufen der <xref:System.IO.BufferedStream.Seek%2A>-Methode bewirken, dass die Position des Streams nicht mehr mit der Position des internen Puffers im Reader identisch ist.</span><span class="sxs-lookup"><span data-stu-id="39056-400">When a <xref:System.IO.BufferedStream> object is the base stream for a <xref:System.IO.StreamReader> object, calling the <xref:System.IO.BufferedStream.Seek%2A> method can cause the position of the stream to no longer match the position of the internal buffer in the reader.</span></span> <span data-ttu-id="39056-401">Um den internen Puffer zurückzusetzen, müssen Sie die <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=nameWithType>-Methode abrufen. Diese Methode verlangsamt jedoch die Leistung und sollte nur aufgerufen werden, wenn dies unbedingt erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="39056-401">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=nameWithType> method; however, this method slows performance and should be called only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="39056-402">Das Suchen nach einem beliebigen Speicherort über die Länge des Streams wird unterstützt.</span><span class="sxs-lookup"><span data-stu-id="39056-402">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="39056-403">Der Stream ist nicht geöffnet oder ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39056-403">The stream is not open or is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="39056-404">Vom Stream wird Suchen nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="39056-404">The stream does not support seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="39056-405">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="39056-405">Methods were called after the stream was closed.</span></span></exception>
        <altmember cref="T:System.IO.SeekOrigin" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="39056-406">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="39056-406">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="39056-407">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="39056-407">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="39056-408">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="39056-408">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="bufferedStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="39056-409">Eine ganze Zahl, die die gewünschte Länge des aktuellen gepufferten Streams in Bytes angibt.</span><span class="sxs-lookup"><span data-stu-id="39056-409">An integer indicating the desired length of the current buffered stream in bytes.</span></span></param>
        <summary><span data-ttu-id="39056-410">Legt die Länge des gepufferten Streams fest.</span><span class="sxs-lookup"><span data-stu-id="39056-410">Sets the length of the buffered stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39056-411">Der Puffer wird geleert, bevor die Länge der zugrunde liegenden Datenquelle oder des zugrunde liegenden Repository festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="39056-411">The buffer is flushed before setting the length of the underlying data source or repository.</span></span> <span data-ttu-id="39056-412">Wenn der angegebene Wert kleiner als die aktuelle Länge des gepufferten Streams ist, wird der gepufferte Stream abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="39056-412">If the specified value is less than the current length of the buffered stream, the buffered stream is truncated.</span></span> <span data-ttu-id="39056-413">Wenn der angegebene Wert größer als die aktuelle Länge des gepufferten Streams ist, wird der gepufferte Stream erweitert.</span><span class="sxs-lookup"><span data-stu-id="39056-413">If the specified value is larger than the current length of the buffered stream, the buffered stream is expanded.</span></span> <span data-ttu-id="39056-414">Wenn der gepufferte Datenstrom erweitert wird, werden die Inhalte des gepufferten Streams zwischen der alten und der neuen Länge nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="39056-414">If the buffered stream is expanded, the contents of the buffered stream between the old and the new lengths are not defined.</span></span>  
  
 <span data-ttu-id="39056-415">`SetLength` leert ggf. alle gepufferten Schreibvorgänge.</span><span class="sxs-lookup"><span data-stu-id="39056-415">`SetLength` flushes any buffered writes if necessary.</span></span>  
  
 <span data-ttu-id="39056-416">Ein Datenstrom muss sowohl das Schreiben als auch das Suchen nach `SetLength` unterstützen.</span><span class="sxs-lookup"><span data-stu-id="39056-416">A stream must support both writing and seeking for `SetLength` to work.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="39056-417"><paramref name="value" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="39056-417"><paramref name="value" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="39056-418">Der Stream ist nicht geöffnet oder ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39056-418">The stream is not open or is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="39056-419">Der Stream unterstützt nicht gleichzeitig Schreib- und Suchvorgänge.</span><span class="sxs-lookup"><span data-stu-id="39056-419">The stream does not support both writing and seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="39056-420">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="39056-420">Methods were called after the stream was closed.</span></span></exception>
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="39056-421">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="39056-421">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="39056-422">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="39056-422">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="39056-423">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="39056-423">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream UnderlyingStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream UnderlyingStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.UnderlyingStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ UnderlyingStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingStream : System.IO.Stream" Usage="System.IO.BufferedStream.UnderlyingStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="39056-424">Ruft die zugrunde liegende <see cref="T:System.IO.Stream" />-Instanz für diesen gepufferten Stream ab.</span><span class="sxs-lookup"><span data-stu-id="39056-424">Gets the underlying <see cref="T:System.IO.Stream" /> instance for this buffered stream.</span></span></summary>
        <value><span data-ttu-id="39056-425">Die zugrunde liegende Streaminstanz.</span><span class="sxs-lookup"><span data-stu-id="39056-425">The underlying stream instance.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="bufferedStream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="39056-426">Ein Bereich im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="39056-426">A region of memory.</span></span> <span data-ttu-id="39056-427">Diese Methode kopiert den Inhalt dieses Bereichs in den aktuellen gepufferten Stream.</span><span class="sxs-lookup"><span data-stu-id="39056-427">This method copies the contents of this region to the current buffered stream.</span></span></param>
        <summary><span data-ttu-id="39056-428">Schreibt eine Bytesequenz in den aktuellen gepufferten Stream und setzt die aktuelle Position in diesem gepufferten Stream um die Anzahl der geschriebenen Bytes nach vorn.</span><span class="sxs-lookup"><span data-stu-id="39056-428">Writes a sequence of bytes to the current buffered stream and advances the current position within this buffered stream by the number of bytes written.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="39056-429">Verwenden Sie die Eigenschaft <xref:System.IO.BufferedStream.CanWrite%2A>, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="39056-429">Use the <xref:System.IO.BufferedStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="39056-430">Verwenden Sie die <xref:System.IO.BufferedStream.WriteAsync%2A>-Methode, um asynchron in den aktuellen gepufferten Stream zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="39056-430">Use the <xref:System.IO.BufferedStream.WriteAsync%2A> method to write asynchronously to the current buffered stream.</span></span>

<span data-ttu-id="39056-431">Wenn der Schreibvorgang erfolgreich ist, wird die Position im gepufferten Datenstrom um die Anzahl der geschriebenen Bytes fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="39056-431">If the write operation is successful, the position within the buffered stream advances by the number of bytes written.</span></span> <span data-ttu-id="39056-432">Wenn eine Ausnahme auftritt, bleibt die Position im gepufferten Stream unverändert.</span><span class="sxs-lookup"><span data-stu-id="39056-432">If an exception occurs, the position within the buffered stream remains unchanged.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="bufferedStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="39056-433">Das Bytearray, aus dem <paramref name="count" /> Bytes in den aktuellen gepufferten Stream kopiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="39056-433">The byte array from which to copy <paramref name="count" /> bytes to the current buffered stream.</span></span></param>
        <param name="offset"><span data-ttu-id="39056-434">Der Offset im Puffer, ab dem Bytes in den aktuellen gepufferten Stream kopiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="39056-434">The offset in the buffer at which to begin copying bytes to the current buffered stream.</span></span></param>
        <param name="count"><span data-ttu-id="39056-435">Die Anzahl der Bytes, die in den aktuellen gepufferten Stream geschrieben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="39056-435">The number of bytes to be written to the current buffered stream.</span></span></param>
        <summary><span data-ttu-id="39056-436">Kopiert Bytes in den gepufferten Stream und verschiebt die aktuelle Position im gepufferten Stream um die Anzahl der geschriebenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="39056-436">Copies bytes to the buffered stream and advances the current position within the buffered stream by the number of bytes written.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="39056-437">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.BufferedStream>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="39056-437">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#6)]
 [!code-csharp[System.IO.BufferedStream1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#6)]
 [!code-vb[System.IO.BufferedStream1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="39056-438">Die Länge von <paramref name="array" /> minus <paramref name="offset" /> ist kleiner als <paramref name="count" />.</span><span class="sxs-lookup"><span data-stu-id="39056-438">Length of <paramref name="array" /> minus <paramref name="offset" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39056-439"><paramref name="array" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39056-439"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="39056-440"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="39056-440"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="39056-441">Der Stream ist geschlossen oder <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39056-441">The stream is closed or <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="39056-442">Der Stream unterstützt das Schreiben nicht.</span><span class="sxs-lookup"><span data-stu-id="39056-442">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="39056-443">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="39056-443">Methods were called after the stream was closed.</span></span></exception>
        <altmember cref="P:System.IO.BufferedStream.CanWrite" />
        <altmember cref="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="39056-444">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="39056-444">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="39056-445">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="39056-445">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="39056-446">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="39056-446">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="bufferedStream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="39056-447">Die Region im Arbeitsspeicher, aus der die Daten für das Schreiben gelesen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="39056-447">The region of memory to write data from.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="39056-448">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="39056-448">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="39056-449">Der Standardwert ist <see cref="P:System.Threading.CancellationToken.None" />.</span><span class="sxs-lookup"><span data-stu-id="39056-449">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="39056-450">Schreibt beim Überschreiben in einer abgeleiteten Klasse eine Folge von Bytes asynchron in den aktuellen gepufferten Stream und erhöht die aktuelle Position im gepufferten Stream um die Anzahl der geschriebenen Bytes und überwacht Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="39056-450">Asynchronously writes a sequence of bytes to the current buffered stream, advances the current position within this buffered stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="39056-451">Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="39056-451">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="39056-452">Die `WriteAsync`-Methode ermöglicht es Ihnen, ressourcenintensive e/a-Vorgänge auszuführen, ohne den Haupt Thread zu blockieren.</span><span class="sxs-lookup"><span data-stu-id="39056-452">The `WriteAsync` method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="39056-453">Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert.</span><span class="sxs-lookup"><span data-stu-id="39056-453">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="39056-454">Die Async-Methoden werden in Verbindung mit den Schlüsselwörtern `async` und `await` in Visual Basic C#und verwendet.</span><span class="sxs-lookup"><span data-stu-id="39056-454">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="39056-455">Verwenden Sie die Eigenschaft <xref:System.IO.BufferedStream.CanWrite%2A>, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="39056-455">Use the <xref:System.IO.BufferedStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>

<span data-ttu-id="39056-456">Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen ist, enthält die zurückgegebene Aufgabe den <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> Wert für die <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="39056-456">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="bufferedStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="39056-457">Der Puffer, aus dem die Daten geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="39056-457">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="39056-458">Der nullbasierte Byteoffset im <paramref name="buffer" />, ab dem Bytes in den Stream kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="39056-458">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="39056-459">Die maximal zu schreibende Anzahl von Byte.</span><span class="sxs-lookup"><span data-stu-id="39056-459">The maximum number of bytes to write.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="39056-460">Das Token zum Überwachen von Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="39056-460">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="39056-461">Schreibt beim Überschreiben in einer abgeleiteten Klasse eine Folge von Bytes asynchron in den aktuellen Stream und erhöht die aktuelle Position im Stream um die Anzahl der geschriebenen Bytes und überwacht Abbruchanforderungen.</span><span class="sxs-lookup"><span data-stu-id="39056-461">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="39056-462">Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="39056-462">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39056-463">Sie können ein Abbruch Token erstellen, indem Sie eine Instanz der <xref:System.Threading.CancellationTokenSource>-Klasse erstellen und die <xref:System.Threading.CancellationTokenSource.Token%2A>-Eigenschaft als `cancellationToken`-Parameter übergeben.</span><span class="sxs-lookup"><span data-stu-id="39056-463">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39056-464"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39056-464"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="39056-465"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="39056-465"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="39056-466">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Pufferlänge.</span><span class="sxs-lookup"><span data-stu-id="39056-466">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="39056-467">Der Stream unterstützt das Schreiben nicht.</span><span class="sxs-lookup"><span data-stu-id="39056-467">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="39056-468">Der Stream wurde verworfen.</span><span class="sxs-lookup"><span data-stu-id="39056-468">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="39056-469">Der Stream wird zurzeit von einem vorherigen Schreibvorgang verwendet.</span><span class="sxs-lookup"><span data-stu-id="39056-469">The stream is currently in use by a previous write operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="bufferedStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="39056-470">Ein Byte, das in den Stream geschrieben werden soll.</span><span class="sxs-lookup"><span data-stu-id="39056-470">A byte to write to the stream.</span></span></param>
        <summary><span data-ttu-id="39056-471">Schreibt ein Byte an die aktuelle Position im gepufferten Stream.</span><span class="sxs-lookup"><span data-stu-id="39056-471">Writes a byte to the current position in the buffered stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="39056-472">Verwenden Sie die Eigenschaft <xref:System.IO.BufferedStream.CanWrite%2A>, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="39056-472">Use the <xref:System.IO.BufferedStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="39056-473">Der Stream unterstützt das Schreiben nicht.</span><span class="sxs-lookup"><span data-stu-id="39056-473">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="39056-474"><paramref name="value" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="39056-474"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="39056-475">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="39056-475">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="39056-476">Datei- und Stream-E/A</span><span class="sxs-lookup"><span data-stu-id="39056-476">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="39056-477">Gewusst wie: Lesen aus einer Textdatei</span><span class="sxs-lookup"><span data-stu-id="39056-477">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="39056-478">Gewusst wie: Schreiben von Text in eine Datei</span><span class="sxs-lookup"><span data-stu-id="39056-478">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
