<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="BufferedStream.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac50565905affcad56d23c9b51bc2aa664f02fdc654.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0565905affcad56d23c9b51bc2aa664f02fdc654</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.IO.BufferedStream">
          <source>Adds a buffering layer to read and write operations on another stream.</source>
          <target state="translated">Fügt eine Pufferebene zu Lese- und Schreibvorgängen auf einem anderen Stream hinzu.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.IO.BufferedStream">
          <source>This class cannot be inherited.</source>
          <target state="translated">Diese Klasse kann nicht vererbt werden.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source>A buffer is a block of bytes in memory used to cache data, thereby reducing the number of calls to the operating system.</source>
          <target state="translated">Ein Puffer ist, einen Block von Bytes im Speicher zum Zwischenspeichern von Daten, wodurch die Anzahl der Aufrufe an das Betriebssystem verwendet wird.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source>Buffers improve read and write performance.</source>
          <target state="translated">Puffer lesen verbessern und schreibleistung.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source>A buffer can be used for either reading or writing, but never both simultaneously.</source>
          <target state="translated">Ein Puffer kann für entweder lesen oder schreiben, aber nicht beides gleichzeitig verwendet werden.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source>The <ph id="ph1">&lt;xref:System.IO.BufferedStream.Read%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.BufferedStream.Write%2A&gt;</ph> methods of <ph id="ph3">`BufferedStream`</ph> automatically maintain the buffer.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.IO.BufferedStream.Read%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.IO.BufferedStream.Write%2A&gt;</ph> Methoden der <ph id="ph3">`BufferedStream`</ph> automatisch verwalten den Puffer.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">Dieser Typ implementiert die <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> Schnittstelle.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source>When you have finished using the type, you should dispose of it either directly or indirectly.</source>
          <target state="translated">Wenn Sie mithilfe des Typs abgeschlossen haben, sollten Sie es entweder direkt oder indirekt freigeben.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">Aufrufen, um den Typ direkt zu verwerfen, dessen <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> Methode in einer <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> Block.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
          <target state="translated">Um es indirekt freizugeben, verwenden Sie ein Sprachkonstrukt z. B. <ph id="ph1">`using`</ph> (in c#) oder <ph id="ph2">`Using`</ph> (in Visual Basic).</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
          <target state="translated">Weitere Informationen finden Sie im Abschnitt "Verwenden eines Objekts, implementiert IDisposable" in der <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> Thema zur Schnittstelle.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source><ph id="ph1">`BufferedStream`</ph> can be composed around certain types of streams.</source>
          <target state="translated"><ph id="ph1">`BufferedStream`</ph> können auf bestimmte Arten von Streams zusammengesetzt werden.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source>It provides implementations for reading and writing bytes to an underlying data source or repository.</source>
          <target state="translated">Er enthält Implementierungen, zum Lesen und Schreiben von Bytes in einer zugrunde liegenden Datenquelle oder das Repository.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source>Use <ph id="ph1">&lt;xref:System.IO.BinaryReader&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.BinaryWriter&gt;</ph> for reading and writing other data types.</source>
          <target state="translated">Verwendung <ph id="ph1">&lt;xref:System.IO.BinaryReader&gt;</ph> und <ph id="ph2">&lt;xref:System.IO.BinaryWriter&gt;</ph> zum Lesen und Schreiben anderer Datentypen.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source><ph id="ph1">`BufferedStream`</ph> is designed to prevent the buffer from slowing down input and output when the buffer is not needed.</source>
          <target state="translated"><ph id="ph1">`BufferedStream`</ph> Dient zum verhindern, dass des Puffers Eingabe und Ausgabe verlangsamt, wenn der Puffer nicht benötigt wird.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source>If you always read and write for sizes greater than the internal buffer size, then <ph id="ph1">`BufferedStream`</ph> might not even allocate the internal buffer.</source>
          <target state="translated">Wenn Sie immer lesen und dann größer als die Größe des internen Puffers schreiben <ph id="ph1">`BufferedStream`</ph> möglicherweise nicht den internen Puffer selbst zuweisen.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source><ph id="ph1">`BufferedStream`</ph> also buffers reads and writes in a shared buffer.</source>
          <target state="translated"><ph id="ph1">`BufferedStream`</ph> Außerdem puffert liest und schreibt in einen gemeinsamen Puffer.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source>It is assumed that you will almost always be doing a series of reads or writes, but rarely alternate between the two of them.</source>
          <target state="translated">Es wird vorausgesetzt, dass Sie fast immer werden eine Reihe von Lese- oder Schreibvorgänge ausführen, jedoch selten zwischen den beiden von ihnen wechseln.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source>The following code examples show how to use the <ph id="ph1">`BufferedStream`</ph> class over the <ph id="ph2">`NetworkStream`</ph> class to increase the performance of certain I/O operations.</source>
          <target state="translated">Die folgenden Codebeispiele zeigen, wie mithilfe der <ph id="ph1">`BufferedStream`</ph> Klasse über die <ph id="ph2">`NetworkStream`</ph> Klasse, um die Leistung bestimmter e/a-Vorgänge zu erhöhen.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source>Start the server on a remote computer before starting the client.</source>
          <target state="translated">Starten Sie den Server vor dem Starten des Clients auf einem Remotecomputer befindet.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source>Specify the remote computer name as a command-line argument when starting the client.</source>
          <target state="translated">Geben Sie als Befehlszeilenargument Namen des Remotecomputers an, beim Starten des Clients.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source>Vary the <ph id="ph1">`dataArraySize`</ph> and <ph id="ph2">`streamBufferSize`</ph> constants to view their effect on performance.</source>
          <target state="translated">Verändern der <ph id="ph1">`dataArraySize`</ph> und <ph id="ph2">`streamBufferSize`</ph> Konstanten, um deren Auswirkung auf die Leistung anzuzeigen.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source>The first example shows the code that runs on the client, and the second example shows the code that runs on the server.</source>
          <target state="translated">Das erste Beispiel zeigt den Code, der auf dem Client ausgeführt wird, und das zweite Beispiel zeigt den Code, der auf dem Server ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source><bpt id="p1">**</bpt>Example 1: Code that runs on the client<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Beispiel 1: Code, der auf dem Client ausgeführt wird.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.IO.BufferedStream">
          <source><bpt id="p1">**</bpt>Example 2: Code that runs on the server<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Beispiel 2: Code, der auf dem Server ausgeführt wird.<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="T:System.IO.BufferedStream">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.BufferedStream" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.IO.BufferedStream" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.#ctor(System.IO.Stream)">
          <source>The current stream.</source>
          <target state="translated">Der aktuelle Stream.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.#ctor(System.IO.Stream)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.BufferedStream" /&gt;</ph> class with a default buffer size of 4096 bytes.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.IO.BufferedStream" /&gt;</ph>-Klasse mit einer Standardpuffergröße von 4096 Bytes.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.#ctor(System.IO.Stream)">
          <source>A shared read/write buffer is allocated the first time a <ph id="ph1">`BufferedStream`</ph> object is initialized with this constructor.</source>
          <target state="translated">Ein freigegebenen Lese-/Schreibzugriff Puffer erhält erstmalig eine <ph id="ph1">`BufferedStream`</ph> Objekt wird mit diesem Konstruktor initialisiert.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.#ctor(System.IO.Stream)">
          <source>The shared buffer is not used if all reads and writes are greater than or equal to <ph id="ph1">`bufferSize`</ph>.</source>
          <target state="translated">Der gemeinsam verwendete Puffer wird nicht verwendet werden, wenn alle Lese- und Schreibvorgänge größer als oder gleich sind <ph id="ph1">`bufferSize`</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.#ctor(System.IO.Stream)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)">
          <source>The current stream.</source>
          <target state="translated">Der aktuelle Stream.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)">
          <source>The buffer size in bytes.</source>
          <target state="translated">Die Puffergröße in Byte.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.IO.BufferedStream" /&gt;</ph> class with the specified buffer size.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.IO.BufferedStream" /&gt;</ph>-Klasse mit der angegebenen Puffergröße.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)">
          <source>A shared read/write buffer is allocated the first time a <ph id="ph1">`BufferedStream`</ph> object is initialized with this constructor.</source>
          <target state="translated">Ein freigegebenen Lese-/Schreibzugriff Puffer erhält erstmalig eine <ph id="ph1">`BufferedStream`</ph> Objekt wird mit diesem Konstruktor initialisiert.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)">
          <source>The shared buffer is not used if all reads and writes are greater than or equal to <ph id="ph1">`bufferSize`</ph>.</source>
          <target state="translated">Der gemeinsam verwendete Puffer wird nicht verwendet werden, wenn alle Lese- und Schreibvorgänge größer als oder gleich sind <ph id="ph1">`bufferSize`</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.BufferedStream&gt;</ph> class.</source>
          <target state="translated">Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <ph id="ph1">&lt;xref:System.IO.BufferedStream&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bufferSize" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The buffer to read the data into.</source>
          <target state="translated">Der Puffer, in den die Daten gelesen werden sollen.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin writing data read from the stream.</source>
          <target state="translated">Der Byteoffset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept>, ab dem gelesene Daten aus dem Stream geschrieben werden sollen.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The maximum number of bytes to read.</source>
          <target state="translated">Die maximale Anzahl der zu lesenden Bytes.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>An optional asynchronous callback, to be called when the read is complete.</source>
          <target state="translated">Ein optionaler asynchroner Rückruf, der nach Abschluss des Lesevorgangs aufgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous read request from other requests.</source>
          <target state="translated">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Leseanforderung von anderen Anforderungen unterscheidet.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous read operation.</source>
          <target state="translated">Beginnt einen asynchronen Lesevorgang.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>(Consider using <ph id="ph1">&lt;see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph> instead.)</source>
          <target state="translated">(Verwenden Sie stattdessen <ph id="ph1">&lt;see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>An object that represents the asynchronous read, which could still be pending.</source>
          <target state="translated">Ein Objekt, das den asynchronen Lesevorgang darstellt, der möglicherweise noch aussteht.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>In the .NET Framework 4 and earlier versions, you have to use methods such as <ph id="ph1">&lt;xref:System.IO.Stream.BeginRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph> to implement asynchronous file operations.</source>
          <target state="translated">In der .NET Framework 4 und früheren Versionen müssen Sie Methoden verwenden, z. B. <ph id="ph1">&lt;xref:System.IO.Stream.BeginRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph> zum Implementieren asynchroner Vorgänge.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>These methods are still available in the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> to support legacy code; however, the new async methods, such as <ph id="ph2">&lt;xref:System.IO.BufferedStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.BufferedStream.WriteAsync%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.IO.BufferedStream.FlushAsync%2A&gt;</ph>, help you implement asynchronous file operations more easily.</source>
          <target state="translated">Diese Methoden sind weiterhin verfügbar, in der <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> zur Unterstützung von legacy-Code; allerdings der neuen asynchronen Methoden, wie z. B. <ph id="ph2">&lt;xref:System.IO.BufferedStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.BufferedStream.WriteAsync%2A&gt;</ph>, und <ph id="ph4">&lt;xref:System.IO.BufferedStream.FlushAsync%2A&gt;</ph>, Hilfe, die Sie implementieren leichter asynchrone Dateivorgänge.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.BufferedStream.EndWrite%2A&gt;</ph> must be called exactly once for every call to <ph id="ph2">&lt;xref:System.IO.BufferedStream.BeginRead%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.BufferedStream.EndWrite%2A&gt;</ph> muss genau einmal für jeden Aufruf aufgerufen werden <ph id="ph2">&lt;xref:System.IO.BufferedStream.BeginRead%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</source>
          <target state="translated">Wegen eines Fehlers beim ein Lesevorgang beendet vor dem Beginn einer anderen Lesevorgang kann unerwünschtes Verhalten wie z. B. Deadlocks verursachen.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Use the <ph id="ph1">&lt;xref:System.IO.BufferedStream.CanRead%2A&gt;</ph> property to determine whether the current instance supports reading.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.IO.BufferedStream.CanRead%2A&gt;</ph> Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.BufferedStream.EndRead%2A&gt;</ph> must be called with this <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to find out how many bytes were read.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.BufferedStream.EndRead%2A&gt;</ph> muss aufgerufen werden, dabei <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> um herauszufinden, wie viele Bytes gelesen wurden.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Attempted an asynchronous read past the end of the stream.</source>
          <target state="translated">Es wurde ein asynchroner Lesevorgang über das Streamende hinaus versucht.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The buffer length minus <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated">Die Länge des Puffers minus <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist kleiner als <ph id="ph2">&lt;paramref name="count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The current stream does not support the read operation.</source>
          <target state="translated">Der aktuelle Stream unterstützt den Lesevorgang nicht.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The buffer containing data to write to the current stream.</source>
          <target state="translated">Der Puffer mit den Daten, die in den aktuellen Stream geschrieben werden sollen.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin copying bytes to the current stream.</source>
          <target state="translated">Der nullbasierte Byteoffset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept>, ab dem Daten in den aktuellen Stream kopiert werden sollen.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">Die maximale Anzahl der zu schreibenden Bytes.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The method to be called when the asynchronous write operation is completed.</source>
          <target state="translated">Die Methode, die aufgerufen werden soll, wenn der asynchrone Schreibvorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-provided object that distinguishes this particular asynchronous write request from other requests.</source>
          <target state="translated">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Schreibanforderung von anderen Anforderungen unterscheidet.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous write operation.</source>
          <target state="translated">Beginnt einen asynchronen Schreibvorgang.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>(Consider using <ph id="ph1">&lt;see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph> instead.)</source>
          <target state="translated">(Verwenden Sie stattdessen <ph id="ph1">&lt;see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>An object that references the asynchronous write which could still be pending.</source>
          <target state="translated">Ein Objekt, das auf den asynchronen Schreibvorgang verweist, der möglicherweise noch aussteht.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>In the .NET Framework 4 and earlier versions, you have to use methods such as <ph id="ph1">&lt;xref:System.IO.Stream.BeginWrite%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.Stream.EndWrite%2A&gt;</ph> to implement asynchronous file operations.</source>
          <target state="translated">In der .NET Framework 4 und früheren Versionen müssen Sie Methoden verwenden, z. B. <ph id="ph1">&lt;xref:System.IO.Stream.BeginWrite%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.IO.Stream.EndWrite%2A&gt;</ph> zum Implementieren asynchroner Vorgänge.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>These methods are still available in the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> to support legacy code; however, the new async methods, such as <ph id="ph2">&lt;xref:System.IO.BufferedStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.BufferedStream.WriteAsync%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.IO.BufferedStream.FlushAsync%2A&gt;</ph>, help you implement asynchronous file operations more easily.</source>
          <target state="translated">Diese Methoden sind weiterhin verfügbar, in der <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> zur Unterstützung von legacy-Code; allerdings der neuen asynchronen Methoden, wie z. B. <ph id="ph2">&lt;xref:System.IO.BufferedStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.BufferedStream.WriteAsync%2A&gt;</ph>, und <ph id="ph4">&lt;xref:System.IO.BufferedStream.FlushAsync%2A&gt;</ph>, Hilfe, die Sie implementieren leichter asynchrone Dateivorgänge.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.BufferedStream.EndWrite%2A&gt;</ph> must be called exactly once on every <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> from <ph id="ph3">&lt;xref:System.IO.BufferedStream.BeginWrite%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.BufferedStream.EndWrite%2A&gt;</ph> muss genau einmal aufgerufen werden, für jede <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> aus <ph id="ph3">&lt;xref:System.IO.BufferedStream.BeginWrite%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.IO.BufferedStream.EndWrite%2A&gt;</ph> will block until the I/O operation has completed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.BufferedStream.EndWrite%2A&gt;</ph> blockiert, bis die e/a-Operation abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> length minus <ph id="ph2">&lt;paramref name="offset" /&gt;</ph> is less than <ph id="ph3">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> minus <ph id="ph2">&lt;paramref name="offset" /&gt;</ph> ist kleiner als <ph id="ph3">&lt;paramref name="count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <source>The stream does not support writing.</source>
          <target state="translated">Der Stream unterstützt das Schreiben nicht.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="P:System.IO.BufferedStream.CanRead">
          <source>Gets a value indicating whether the current stream supports reading.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der aktuelle Stream Lesevorgänge unterstützt.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.BufferedStream.CanRead">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream supports reading; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the stream is closed or was opened with write-only access.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der Stream Lesevorgänge unterstützt, <ph id="ph2">&lt;see langword="false" /&gt;</ph>, wenn der Stream geschlossen ist oder ausschließlich mit Schreibzugriff geöffnet wurde.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.BufferedStream.CanRead">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support reading, calls to the <ph id="ph2">&lt;xref:System.IO.BufferedStream.Read%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.BufferedStream.ReadByte%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.BeginRead%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph>, and the <ph id="ph6">`Peek`</ph> methods of <ph id="ph7">&lt;xref:System.IO.StreamReader&gt;</ph>, <ph id="ph8">&lt;xref:System.IO.StringReader&gt;</ph>, and <ph id="ph9">&lt;xref:System.IO.TextReader&gt;</ph> throw a <ph id="ph10">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Wenn von eine Klasse abgeleitet <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> keine Lesevorgänge unterstützt, werden Aufrufe von der <ph id="ph2">&lt;xref:System.IO.BufferedStream.Read%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.BufferedStream.ReadByte%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.Stream.BeginRead%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph>, und die <ph id="ph6">`Peek`</ph> Methoden der <ph id="ph7">&lt;xref:System.IO.StreamReader&gt;</ph>, <ph id="ph8">&lt;xref:System.IO.StringReader&gt;</ph>, und <ph id="ph9">&lt;xref:System.IO.TextReader&gt;</ph> Auslösen einer <ph id="ph10">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.BufferedStream.CanRead">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Wenn der Stream geschlossen ist, gibt diese Eigenschaft <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.BufferedStream.CanRead">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.BufferedStream&gt;</ph> class.</source>
          <target state="translated">Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <ph id="ph1">&lt;xref:System.IO.BufferedStream&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="P:System.IO.BufferedStream.CanSeek">
          <source>Gets a value indicating whether the current stream supports seeking.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der aktuelle Stream Suchvorgänge unterstützt.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.BufferedStream.CanSeek">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream supports seeking; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the stream is closed or if the stream was constructed from an operating system handle such as a pipe or output to the console.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der Stream Suchvorgänge unterstützt, <ph id="ph2">&lt;see langword="false" /&gt;</ph>, wenn der Stream geschlossen ist oder von einem Betriebssystemhandle, z. B. einer Pipe oder einer Ausgabe an die Konsole, erstellt wurde.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.BufferedStream.CanSeek">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support seeking, calls to <ph id="ph2">&lt;xref:System.IO.BufferedStream.Length%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.BufferedStream.SetLength%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.BufferedStream.Position%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.IO.BufferedStream.Seek%2A&gt;</ph> throw a <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Wenn von eine Klasse abgeleitet <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> Suchvorgänge nicht unterstützt, werden Aufrufe von <ph id="ph2">&lt;xref:System.IO.BufferedStream.Length%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.BufferedStream.SetLength%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.IO.BufferedStream.Position%2A&gt;</ph>, und <ph id="ph5">&lt;xref:System.IO.BufferedStream.Seek%2A&gt;</ph> Auslösen einer <ph id="ph6">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.BufferedStream.CanSeek">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Wenn der Stream geschlossen ist, gibt diese Eigenschaft <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.BufferedStream.CanSeek">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.BufferedStream&gt;</ph> class.</source>
          <target state="translated">Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <ph id="ph1">&lt;xref:System.IO.BufferedStream&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="P:System.IO.BufferedStream.CanWrite">
          <source>Gets a value indicating whether the current stream supports writing.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der aktuelle Stream Schreibvorgänge unterstützt.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.BufferedStream.CanWrite">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the stream supports writing; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the stream is closed or was opened with read-only access.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der Stream Schreibvorgänge unterstützt, <ph id="ph2">&lt;see langword="false" /&gt;</ph>, wenn der Stream geschlossen ist oder mit schreibgeschütztem Zugriff geöffnet wurde.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.BufferedStream.CanWrite">
          <source>If a class derived from <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> does not support writing, a call to <ph id="ph2">&lt;xref:System.IO.BufferedStream.SetLength%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.BufferedStream.Write%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.IO.BufferedStream.WriteByte%2A&gt;</ph> throws a <ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>.</source>
          <target state="translated">Wenn von eine Klasse abgeleitet <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> unterstützt nicht das Schreiben von einem Aufruf von <ph id="ph2">&lt;xref:System.IO.BufferedStream.SetLength%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.BufferedStream.Write%2A&gt;</ph>, oder <ph id="ph4">&lt;xref:System.IO.BufferedStream.WriteByte%2A&gt;</ph> löst eine <ph id="ph5">&lt;xref:System.NotSupportedException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.BufferedStream.CanWrite">
          <source>If the stream is closed, this property returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Wenn der Stream geschlossen ist, gibt diese Eigenschaft <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.BufferedStream.CanWrite">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.BufferedStream&gt;</ph> class.</source>
          <target state="translated">Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <ph id="ph1">&lt;xref:System.IO.BufferedStream&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.EndRead(System.IAsyncResult)">
          <source>The reference to the pending asynchronous request to wait for.</source>
          <target state="translated">Der Verweis auf die ausstehende asynchrone Anforderung, die abgewartet werden soll.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.EndRead(System.IAsyncResult)">
          <source>Waits for the pending asynchronous read operation to complete.</source>
          <target state="translated">Wartet, bis der ausstehende asynchrone Lesevorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.EndRead(System.IAsyncResult)">
          <source>(Consider using <ph id="ph1">&lt;see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph> instead.)</source>
          <target state="translated">(Verwenden Sie stattdessen <ph id="ph1">&lt;see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.EndRead(System.IAsyncResult)">
          <source>The number of bytes read from the stream, between 0 (zero) and the number of bytes you requested.</source>
          <target state="translated">Die Anzahl der aus dem Stream gelesenen Bytes. Diese Anzahl kann zwischen 0 und der Anzahl der angeforderten Bytes liegen.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.EndRead(System.IAsyncResult)">
          <source>Streams only return 0 only at the end of the stream, otherwise, they should block until at least 1 byte is available.</source>
          <target state="translated">Streams geben nur am Ende des Streams nur 0 zurück, andernfalls sollten sie blockieren, bis mindestens 1 Byte verfügbar ist.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.EndRead(System.IAsyncResult)">
          <source>In the .NET Framework 4 and earlier versions, you have to use methods such as <ph id="ph1">&lt;xref:System.IO.Stream.BeginRead%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph> to implement asynchronous file operations.</source>
          <target state="translated">In der .NET Framework 4 und früheren Versionen müssen Sie Methoden verwenden, z. B. <ph id="ph1">&lt;xref:System.IO.Stream.BeginRead%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.IO.Stream.EndRead%2A&gt;</ph> zum Implementieren asynchroner Vorgänge.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.EndRead(System.IAsyncResult)">
          <source>These methods are still available in the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> to support legacy code; however, the new async methods, such as <ph id="ph2">&lt;xref:System.IO.BufferedStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.BufferedStream.WriteAsync%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.IO.BufferedStream.FlushAsync%2A&gt;</ph>, help you implement asynchronous file operations more easily.</source>
          <target state="translated">Diese Methoden sind weiterhin verfügbar, in der <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> zur Unterstützung von legacy-Code; allerdings der neuen asynchronen Methoden, wie z. B. <ph id="ph2">&lt;xref:System.IO.BufferedStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.BufferedStream.WriteAsync%2A&gt;</ph>, und <ph id="ph4">&lt;xref:System.IO.BufferedStream.FlushAsync%2A&gt;</ph>, Hilfe, die Sie implementieren leichter asynchrone Dateivorgänge.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.EndRead(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.IO.BufferedStream.EndRead%2A&gt;</ph> must be called with this <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to find out how many bytes were read.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.BufferedStream.EndRead%2A&gt;</ph> muss aufgerufen werden, dabei <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> um herauszufinden, wie viele Bytes gelesen wurden.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.EndRead(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.EndRead(System.IAsyncResult)">
          <source>This <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object was not created by calling <ph id="ph2">&lt;see cref="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> on this class.</source>
          <target state="translated">Dieses <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>-Objekt wurde nicht durch Aufrufen von <ph id="ph2">&lt;see cref="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> für diese Klasse erstellt.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.EndWrite(System.IAsyncResult)">
          <source>The pending asynchronous request.</source>
          <target state="translated">Die ausstehende asynchrone Anforderung.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.EndWrite(System.IAsyncResult)">
          <source>Ends an asynchronous write operation and blocks until the I/O operation is complete.</source>
          <target state="translated">Beendet einen asynchronen Schreibvorgang und blockiert, bis die E/A-Operation abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.EndWrite(System.IAsyncResult)">
          <source>(Consider using <ph id="ph1">&lt;see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph> instead.)</source>
          <target state="translated">(Verwenden Sie stattdessen <ph id="ph1">&lt;see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.EndWrite(System.IAsyncResult)">
          <source>In the .NET Framework 4 and earlier versions, you have to use methods such as <ph id="ph1">&lt;xref:System.IO.Stream.BeginWrite%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.IO.Stream.EndWrite%2A&gt;</ph> to implement asynchronous file operations.</source>
          <target state="translated">In der .NET Framework 4 und früheren Versionen müssen Sie Methoden verwenden, z. B. <ph id="ph1">&lt;xref:System.IO.Stream.BeginWrite%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.IO.Stream.EndWrite%2A&gt;</ph> zum Implementieren asynchroner Vorgänge.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.EndWrite(System.IAsyncResult)">
          <source>These methods are still available in the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> to support legacy code; however, the new async methods, such as <ph id="ph2">&lt;xref:System.IO.BufferedStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.BufferedStream.WriteAsync%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.IO.BufferedStream.FlushAsync%2A&gt;</ph>, help you implement asynchronous file operations more easily.</source>
          <target state="translated">Diese Methoden sind weiterhin verfügbar, in der <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> zur Unterstützung von legacy-Code; allerdings der neuen asynchronen Methoden, wie z. B. <ph id="ph2">&lt;xref:System.IO.BufferedStream.ReadAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.IO.BufferedStream.WriteAsync%2A&gt;</ph>, und <ph id="ph4">&lt;xref:System.IO.BufferedStream.FlushAsync%2A&gt;</ph>, Hilfe, die Sie implementieren leichter asynchrone Dateivorgänge.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.EndWrite(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.IO.BufferedStream.EndWrite%2A&gt;</ph> must be called exactly once for every call to <ph id="ph2">&lt;xref:System.IO.BufferedStream.BeginRead%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IO.BufferedStream.EndWrite%2A&gt;</ph> muss genau einmal für jeden Aufruf aufgerufen werden <ph id="ph2">&lt;xref:System.IO.BufferedStream.BeginRead%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.EndWrite(System.IAsyncResult)">
          <source>Failing to end a read process before beginning another read operation can cause deadlock or other undesirable behavior.</source>
          <target state="translated">Wegen eines Fehlers beim Beenden eines Prozesses lesen, stellen Sie vor Beginn kann ein anderer Lesevorgang Deadlocks oder anderen unerwünschtes Verhalten verursachen.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.EndWrite(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.EndWrite(System.IAsyncResult)">
          <source>This <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object was not created by calling <ph id="ph2">&lt;see cref="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> on this class.</source>
          <target state="translated">Dieses <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>-Objekt wurde nicht durch Aufrufen von <ph id="ph2">&lt;see cref="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /&gt;</ph> für diese Klasse erstellt.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Flush">
          <source>Clears all buffers for this stream and causes any buffered data to be written to the underlying device.</source>
          <target state="translated">Löscht sämtliche Puffer für diesen Stream und veranlasst die Ausgabe aller gepufferten Daten an das zugrunde liegende Gerät.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.Flush">
          <source>Flushing the stream will not flush its underlying encoder unless you explicitly call <ph id="ph1">`Flush`</ph> or <ph id="ph2">&lt;xref:System.IO.Stream.Close%2A&gt;</ph>.</source>
          <target state="translated">Das Leeren des Streams wird die zugrunde liegende Encoder nicht entleert, es sei denn, Sie explizit aufrufen <ph id="ph1">`Flush`</ph> oder <ph id="ph2">&lt;xref:System.IO.Stream.Close%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.Flush">
          <source>If you use the <ph id="ph1">&lt;xref:System.IO.BufferedStream.%23ctor%2A&gt;</ph> constructor, thus specifying the buffer size while creating the <ph id="ph2">`BufferedStream`</ph> object, the content is flushed when it reaches the buffer size.</source>
          <target state="translated">Bei Verwendung der <ph id="ph1">&lt;xref:System.IO.BufferedStream.%23ctor%2A&gt;</ph> Konstruktor angeben somit die Größe des Puffers beim Erstellen der <ph id="ph2">`BufferedStream`</ph> -Objekt, der Inhalt wird geleert, wenn sie die Größe des Puffers erreicht.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.Flush">
          <source>For example, code such as <ph id="ph1">`BufferedStream bs = new BufferedStream(bs, 5)`</ph> will flush the content when the buffer size reaches 5 bytes.</source>
          <target state="translated">Angenommen, code wie z. B. <ph id="ph1">`BufferedStream bs = new BufferedStream(bs, 5)`</ph> wegschreibt den Inhalt aus, wenn die Puffergröße 5 Bytes erreicht.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.Flush">
          <source>All the read and write methods of <ph id="ph1">`BufferedStream`</ph> automatically maintain the buffer, so there is no need to invoke <ph id="ph2">`Flush`</ph> when switching back and forth between reading and writing.</source>
          <target state="translated">Alle Lese- und Schreibberechtigungen Methoden der <ph id="ph1">`BufferedStream`</ph> automatisch verwalten den Puffer, daher keine Notwendigkeit zum Aufrufen besteht <ph id="ph2">`Flush`</ph> beim hin und her wechseln zwischen Lesen und schreiben.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.Flush">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.BufferedStream&gt;</ph> class.</source>
          <target state="translated">Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <ph id="ph1">&lt;xref:System.IO.BufferedStream&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Flush">
          <source>The stream has been disposed.</source>
          <target state="translated">Der Stream wurde verworfen.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Flush">
          <source>The data source or repository is not open.</source>
          <target state="translated">Die Datenquelle oder das Repository ist nicht geöffnet.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">Das Token zum überwachen von Abbruchanforderungen.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)">
          <source>Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.</source>
          <target state="translated">Löscht alle Puffer für diesen Stream asynchron, veranlasst die Ausgabe aller gepufferten Daten an das zugrunde liegende Gerät und überwacht Abbruchanforderungen.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous flush operation.</source>
          <target state="translated">Eine Aufgabe, die die asynchrone Leerung darstellt.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">Der Stream wurde verworfen.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="P:System.IO.BufferedStream.Length">
          <source>Gets the stream length in bytes.</source>
          <target state="translated">Ruft die Länge des Streams in Bytes ab.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.BufferedStream.Length">
          <source>The stream length in bytes.</source>
          <target state="translated">Die Länge des Streams in Bytes.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="P:System.IO.BufferedStream.Length">
          <source>The underlying stream is <ph id="ph1">&lt;see langword="null" /&gt;</ph> or closed.</source>
          <target state="translated">Der zugrunde liegende Stream ist <ph id="ph1">&lt;see langword="null" /&gt;</ph> oder geschlossen.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="P:System.IO.BufferedStream.Length">
          <source>The stream does not support seeking.</source>
          <target state="translated">Vom Stream wird Suchen nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="P:System.IO.BufferedStream.Length">
          <source>Methods were called after the stream was closed.</source>
          <target state="translated">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="P:System.IO.BufferedStream.Position">
          <source>Gets the position within the current stream.</source>
          <target state="translated">Ruft die Position im aktuellen Stream ab.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.BufferedStream.Position">
          <source>The position within the current stream.</source>
          <target state="translated">Die Position im aktuellen Stream.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.BufferedStream.Position">
          <source>The <ph id="ph1">`get`</ph> accessor invokes <ph id="ph2">&lt;xref:System.IO.BufferedStream.Seek%2A&gt;</ph> to obtain the current position within the underlying stream and then adjusts this value according to the current position within the buffer.</source>
          <target state="translated">Die <ph id="ph1">`get`</ph> Accessor ruft <ph id="ph2">&lt;xref:System.IO.BufferedStream.Seek%2A&gt;</ph> zum Abrufen der aktuellen Position im zugrunde liegenden Stream und anschließend diesen Wert entsprechend der aktuellen Position innerhalb des Puffers passt.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.BufferedStream.Position">
          <source>The <ph id="ph1">`set`</ph> accessor copies any data previously written to the buffer to the underlying stream, and then invokes <ph id="ph2">&lt;xref:System.IO.BufferedStream.Seek%2A&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">`set`</ph> Accessor kopiert alle Daten, die zuvor in den Puffer in den zugrunde liegenden Stream geschrieben, und ruft dann <ph id="ph2">&lt;xref:System.IO.BufferedStream.Seek%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.IO.BufferedStream.Position">
          <source>Seeking to any location beyond the length of the stream is supported.</source>
          <target state="translated">Suchvorgänge, die an einem beliebigen Speicherort überschreitet die Länge des Streams wird unterstützt.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="P:System.IO.BufferedStream.Position">
          <source>The value passed to <ph id="ph1">&lt;see cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" /&gt;</ph> is negative.</source>
          <target state="translated">Der an <ph id="ph1">&lt;see cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" /&gt;</ph> übergebene Wert ist negativ.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="P:System.IO.BufferedStream.Position">
          <source>An I/O error occurs, such as the stream being closed.</source>
          <target state="translated">Ein E/A-Fehler ist aufgetreten, beispielsweise durch Schließen des Streams.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="P:System.IO.BufferedStream.Position">
          <source>The stream does not support seeking.</source>
          <target state="translated">Vom Stream wird Suchen nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="P:System.IO.BufferedStream.Position">
          <source>Methods were called after the stream was closed.</source>
          <target state="translated">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The buffer to which bytes are to be copied.</source>
          <target state="translated">Der Puffer, in den Bytes kopiert werden sollen.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The byte offset in the buffer at which to begin reading bytes.</source>
          <target state="translated">Der Byteoffset im Puffer, ab dem mit dem Lesen von Bytes begonnen werden soll.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to be read.</source>
          <target state="translated">Die Anzahl der zu lesenden Bytes.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Copies bytes from the current buffered stream to an array.</source>
          <target state="translated">Kopiert Bytes aus dem aktuellen gepufferten Stream in ein Array.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The total number of bytes read into <ph id="ph1">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">Die Anzahl der insgesamt in das <ph id="ph1">&lt;paramref name="array" /&gt;</ph> gelesenen Bytes.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>This can be less than the number of bytes requested if that many bytes are not currently available, or 0 if the end of the stream has been reached before any data can be read.</source>
          <target state="translated">Diese kann kleiner sein als die Anzahl der angeforderten Bytes, wenn derzeit nicht entsprechend viele Bytes verfügbar sind, oder 0, wenn das Ende des Streams erreicht ist, bevor Daten gelesen werden können.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`Read`</ph> method will return 0 only if the end of the stream is reached.</source>
          <target state="translated">Die <ph id="ph1">`Read`</ph> Methode gibt 0 zurück, nur dann, wenn das Ende des Streams erreicht ist.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>In all other cases, <ph id="ph1">`Read`</ph> always reads at least one byte from the stream before returning.</source>
          <target state="translated">In allen anderen Fällen <ph id="ph1">`Read`</ph> liest immer mindestens ein Byte aus dem Stream vor der Rückgabe.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>By definition, if no data is available from the stream upon a call to <ph id="ph1">`Read`</ph>, the <ph id="ph2">`Read`</ph> method returns 0 (the end of the stream is reached automatically).</source>
          <target state="translated">Per Definition, wenn keine Daten verfügbar, aus dem Stream bei einem Aufruf sind <ph id="ph1">`Read`</ph>die <ph id="ph2">`Read`</ph> Methode gibt 0 (das Ende des Streams erreicht ist automatisch) zurück.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</source>
          <target state="translated">Eine Implementierung kann weniger Bytes als angefordert zurückgeben, selbst wenn das Ende des Streams nicht erreicht wurde.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Use <ph id="ph1">&lt;xref:System.IO.BinaryReader&gt;</ph> for reading primitive data types.</source>
          <target state="translated">Verwendung <ph id="ph1">&lt;xref:System.IO.BinaryReader&gt;</ph> zum Lesen von primitiven Datentypen.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.BufferedStream&gt;</ph> class.</source>
          <target state="translated">Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <ph id="ph1">&lt;xref:System.IO.BufferedStream&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Length of <ph id="ph1">&lt;paramref name="array" /&gt;</ph> minus <ph id="ph2">&lt;paramref name="offset" /&gt;</ph> is less than <ph id="ph3">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="array" /&gt;</ph> minus <ph id="ph2">&lt;paramref name="offset" /&gt;</ph> ist kleiner als <ph id="ph3">&lt;paramref name="count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The stream is not open or is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der Stream ist nicht geöffnet oder ist <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>The stream does not support reading.</source>
          <target state="translated">Lesevorgänge werden vom Stream nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)">
          <source>Methods were called after the stream was closed.</source>
          <target state="translated">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The buffer to write the data into.</source>
          <target state="translated">Der Puffer, in den die Daten geschrieben werden sollen.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin writing data from the stream.</source>
          <target state="translated">Der Byteoffset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept>, ab dem Daten aus dem Stream geschrieben werden sollen.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The maximum number of bytes to read.</source>
          <target state="translated">Die maximale Anzahl der zu lesenden Bytes.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">Das Token zum überwachen von Abbruchanforderungen.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</source>
          <target state="translated">Liest eine Folge von Bytes asynchron aus dem aktuellen Stream, erhöht die Position im Stream um die Anzahl der gelesenen Bytes und überwacht Abbruchanfragen.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous read operation.</source>
          <target state="translated">Eine Aufgabe, die den asynchronen Lesevorgang darstellt.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The value of the <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph> parameter contains the total number of bytes read into the buffer.</source>
          <target state="translated">Der Wert des <ph id="ph1">&lt;paramref name="TResult" /&gt;</ph>-Parameters enthält die Gesamtzahl der Bytes, die in den Puffer gelesen werden.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</source>
          <target state="translated">Der Ergebniswert kann niedriger als die Anzahl der angeforderten Bytes sein, wenn die Anzahl an derzeit verfügbaren Bytes kleiner ist als die angeforderte Anzahl, oder sie kann 0 (null) sein, wenn das Datenstromende erreicht ist.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>You can create a cancellation token by creating an instance of the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> class and passing the <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> property as the <ph id="ph3">`cancellationToken`</ph> parameter.</source>
          <target state="translated">Können Sie erstellen ein Abbruchtoken, das Erstellen einer Instanz von der <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> Klasse und die Übertragung der <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> -Eigenschaft der <ph id="ph3">`cancellationToken`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The sum of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is larger than the buffer length.</source>
          <target state="translated">Die Summe von <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> und <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ist größer als die Pufferlänge.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream does not support reading.</source>
          <target state="translated">Lesevorgänge werden vom Stream nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">Der Stream wurde verworfen.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream is currently in use by a previous read operation.</source>
          <target state="translated">Der Stream wird zurzeit von einem vorherigen Lesevorgang verwendet.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.ReadByte">
          <source>Reads a byte from the underlying stream and returns the byte cast to an <ph id="ph1">&lt;see langword="int" /&gt;</ph>, or returns -1 if reading from the end of the stream.</source>
          <target state="translated">Liest ein Byte aus dem zugrunde liegenden Stream und gibt dieses in ein <ph id="ph1">&lt;see langword="int" /&gt;</ph> umgewandelt zurück, bzw. wird -1 zurückgegeben, wenn das Ende des Streams erreicht ist.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.ReadByte">
          <source>The byte cast to an <ph id="ph1">&lt;see langword="int" /&gt;</ph>, or -1 if reading from the end of the stream.</source>
          <target state="translated">Das Byte, umgewandelt in ein <ph id="ph1">&lt;see langword="int" /&gt;</ph>, oder -1, wenn das Ende des Streams erreicht ist.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.ReadByte">
          <source>An I/O error occurs, such as the stream being closed.</source>
          <target state="translated">Ein E/A-Fehler ist aufgetreten, beispielsweise durch Schließen des Streams.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.ReadByte">
          <source>The stream does not support reading.</source>
          <target state="translated">Lesevorgänge werden vom Stream nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.ReadByte">
          <source>Methods were called after the stream was closed.</source>
          <target state="translated">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.ReadByte">
          <source>The default implementation on <ph id="ph1">&lt;see langword="Stream" /&gt;</ph> creates a new single-byte array and then calls <ph id="ph2">&lt;see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /&gt;</ph>.</source>
          <target state="translated">Die standardmäßige Implementierung auf <ph id="ph1">&lt;see langword="Stream" /&gt;</ph> erstellt ein neues Single-Byte-Array und ruft dann <ph id="ph2">&lt;see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.ReadByte">
          <source>While this is formally correct, it is inefficient.</source>
          <target state="translated">Während dies formal richtig ist, ist es ineffizient.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.ReadByte">
          <source>Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</source>
          <target state="translated">Jeder Stream mit einem internen Puffer sollte diese Methode überschreiben und eine wesentlich effizienter Version, die den Puffer direkt, liest die Zuordnung zusätzlichen Array bei jedem Aufruf zu vermeiden.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>A byte offset relative to <bpt id="p1">&lt;c&gt;</bpt>origin<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Ein Byteoffset, das relativ zu <bpt id="p1">&lt;c&gt;</bpt>origin<ept id="p1">&lt;/c&gt;</ept> ist.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>A value of type <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph> indicating the reference point from which to obtain the new position.</source>
          <target state="translated">Ein Wert vom Typ <ph id="ph1">&lt;see cref="T:System.IO.SeekOrigin" /&gt;</ph>, der den Bezugspunkt angibt, von dem aus die neue Position ermittelt wird.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Sets the position within the current buffered stream.</source>
          <target state="translated">Legt die Position im aktuellen gepufferten Stream fest.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The new position within the current buffered stream.</source>
          <target state="translated">Die neue Position innerhalb des aktuellen gepufferten Streams.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>If <ph id="ph1">`offset`</ph> is negative, the new position will precede the position specified by <ph id="ph2">`origin`</ph> by the number of bytes specified by <ph id="ph3">`offset`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`offset`</ph> negativ ist, liegt die die neue Position um die durch <ph id="ph2">`origin`</ph> angegebene Anzahl von Bytes vor der durch <ph id="ph3">`offset`</ph> angegebenen Position.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>If <ph id="ph1">`offset`</ph> is 0, the new position will be the position specified by <ph id="ph2">`origin`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`offset`</ph> beträgt 0, ist die neue Position der angegebenen Position <ph id="ph2">`origin`</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>If <ph id="ph1">`offset`</ph> is positive, the new position will follow the position specified by <ph id="ph2">`origin`</ph> by the number of bytes specified by <ph id="ph3">`offset`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`offset`</ph> positiv ist, liegt die neue Position um die durch <ph id="ph2">`origin`</ph> angegebene Anzahl an Bytes hinter der durch <ph id="ph3">`offset`</ph> angegebenen Position.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>When a <ph id="ph1">&lt;xref:System.IO.BufferedStream&gt;</ph> object is the base stream for a <ph id="ph2">&lt;xref:System.IO.StreamReader&gt;</ph> object, calling the <ph id="ph3">&lt;xref:System.IO.BufferedStream.Seek%2A&gt;</ph> method can cause the position of the stream to no longer match the position of the internal buffer in the reader.</source>
          <target state="translated">Wenn eine <ph id="ph1">&lt;xref:System.IO.BufferedStream&gt;</ph> Objekt ist der basisdatenstrom für eine <ph id="ph2">&lt;xref:System.IO.StreamReader&gt;</ph> -Objekt Aufrufen der <ph id="ph3">&lt;xref:System.IO.BufferedStream.Seek%2A&gt;</ph> Methode kann dazu führen, dass die Position im Stream um die Position des internen Puffers im Reader nicht mehr übereinstimmen.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>To reset the internal buffer, call the <ph id="ph1">&lt;xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=nameWithType&gt;</ph> method; however, this method slows performance and should be called only when absolutely necessary.</source>
          <target state="translated">Um den internen Puffer zurückzusetzen, rufen Sie die <ph id="ph1">&lt;xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=nameWithType&gt;</ph> Methode jedoch diese Methode durch die die Leistung und sollte aufgerufen werden, nur wenn unbedingt nötig.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Seeking to any location beyond the length of the stream is supported.</source>
          <target state="translated">Suchvorgänge, die an einem beliebigen Speicherort überschreitet die Länge des Streams wird unterstützt.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The stream is not open or is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der Stream ist nicht geöffnet oder ist <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>The stream does not support seeking.</source>
          <target state="translated">Vom Stream wird Suchen nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)">
          <source>Methods were called after the stream was closed.</source>
          <target state="translated">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.SetLength(System.Int64)">
          <source>An integer indicating the desired length of the current buffered stream in bytes.</source>
          <target state="translated">Eine ganze Zahl, die die gewünschte Länge des aktuellen gepufferten Streams in Bytes angibt.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.SetLength(System.Int64)">
          <source>Sets the length of the buffered stream.</source>
          <target state="translated">Legt die Länge des gepufferten Streams fest.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.SetLength(System.Int64)">
          <source>The buffer is flushed before setting the length of the underlying data source or repository.</source>
          <target state="translated">Der Puffer wird vor dem Festlegen der Länge der zugrunde liegenden Datenquelle oder Repository geleert.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.SetLength(System.Int64)">
          <source>If the specified value is less than the current length of the buffered stream, the buffered stream is truncated.</source>
          <target state="translated">Wenn der angegebene Wert kleiner als die aktuelle Länge der gepufferten Datenstrom ist, wird der gepufferte Datenstrom abgeschnitten.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.SetLength(System.Int64)">
          <source>If the specified value is larger than the current length of the buffered stream, the buffered stream is expanded.</source>
          <target state="translated">Wenn der angegebene Wert größer als die aktuelle Länge der gepufferten Datenstrom ist, wird der gepufferte Datenstrom erweitert.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.SetLength(System.Int64)">
          <source>If the buffered stream is expanded, the contents of the buffered stream between the old and the new lengths are not defined.</source>
          <target state="translated">Der gepufferte Datenstrom erweitert ist, werden die Inhalte den gepufferten Datenstrom zwischen den alten und neuen Länge nicht definiert.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.SetLength(System.Int64)">
          <source><ph id="ph1">`SetLength`</ph> flushes any buffered writes if necessary.</source>
          <target state="translated"><ph id="ph1">`SetLength`</ph> Leert alle gepufferten Schreibvorgänge an, bei Bedarf.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.SetLength(System.Int64)">
          <source>A stream must support both writing and seeking for <ph id="ph1">`SetLength`</ph> to work.</source>
          <target state="translated">Ein Stream muss Schreib- und Suchvorgänge für unterstützen <ph id="ph1">`SetLength`</ph> arbeiten.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.SetLength(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.SetLength(System.Int64)">
          <source>The stream is not open or is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der Stream ist nicht geöffnet oder ist <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.SetLength(System.Int64)">
          <source>The stream does not support both writing and seeking.</source>
          <target state="translated">Der Stream unterstützt nicht gleichzeitig Schreib- und Suchvorgänge.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.SetLength(System.Int64)">
          <source>Methods were called after the stream was closed.</source>
          <target state="translated">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The byte array from which to copy <bpt id="p1">&lt;c&gt;</bpt>count<ept id="p1">&lt;/c&gt;</ept> bytes to the current buffered stream.</source>
          <target state="translated">Das Bytearray, aus dem <bpt id="p1">&lt;c&gt;</bpt>count<ept id="p1">&lt;/c&gt;</ept>-Bytes in den aktuellen gepufferten Stream kopiert werden sollen.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The offset in the buffer at which to begin copying bytes to the current buffered stream.</source>
          <target state="translated">Der Offset im Puffer, ab dem Bytes in den aktuellen gepufferten Stream kopiert werden sollen.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to be written to the current buffered stream.</source>
          <target state="translated">Die Anzahl der Bytes, die in den aktuellen gepufferten Stream geschrieben werden sollen.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Copies bytes to the buffered stream and advances the current position within the buffered stream by the number of bytes written.</source>
          <target state="translated">Kopiert Bytes in den gepufferten Stream und verschiebt die aktuelle Position im gepufferten Stream um die Anzahl der geschriebenen Bytes.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.IO.BufferedStream&gt;</ph> class.</source>
          <target state="translated">Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <ph id="ph1">&lt;xref:System.IO.BufferedStream&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Length of <ph id="ph1">&lt;paramref name="array" /&gt;</ph> minus <ph id="ph2">&lt;paramref name="offset" /&gt;</ph> is less than <ph id="ph3">&lt;paramref name="count" /&gt;</ph>.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="array" /&gt;</ph> minus <ph id="ph2">&lt;paramref name="offset" /&gt;</ph> ist kleiner als <ph id="ph3">&lt;paramref name="count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The stream is closed or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der Stream ist geschlossen oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>The stream does not support writing.</source>
          <target state="translated">Der Stream unterstützt das Schreiben nicht.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)">
          <source>Methods were called after the stream was closed.</source>
          <target state="translated">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The buffer to write data from.</source>
          <target state="translated">Der Puffer, aus dem Daten geschrieben werden sollen.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The zero-based byte offset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> from which to begin copying bytes to the stream.</source>
          <target state="translated">Der nullbasierte Byteoffset in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept>, ab dem Bytes in den Stream kopiert werden sollen.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">Die maximale Anzahl der zu schreibenden Bytes.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The token to monitor for cancellation requests.</source>
          <target state="translated">Das Token zum überwachen von Abbruchanforderungen.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</source>
          <target state="translated">Schreibt eine Folge von Bytes asynchron in den aktuellen Stream, erhöht die aktuelle Position im Stream um die Anzahl der geschriebenen Bytes und überwacht Abbruchanforderungen.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the asynchronous write operation.</source>
          <target state="translated">Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>You can create a cancellation token by creating an instance of the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> class and passing the <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> property as the <ph id="ph3">`cancellationToken`</ph> parameter.</source>
          <target state="translated">Können Sie erstellen ein Abbruchtoken, das Erstellen einer Instanz von der <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> Klasse und die Übertragung der <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Token%2A&gt;</ph> -Eigenschaft der <ph id="ph3">`cancellationToken`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The sum of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is larger than the buffer length.</source>
          <target state="translated">Die Summe von <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> und <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ist größer als die Pufferlänge.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream does not support writing.</source>
          <target state="translated">Der Stream unterstützt das Schreiben nicht.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream has been disposed.</source>
          <target state="translated">Der Stream wurde verworfen.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <source>The stream is currently in use by a previous write operation.</source>
          <target state="translated">Der Stream wird zurzeit von einem vorherigen Schreibvorgang verwendet.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.WriteByte(System.Byte)">
          <source>A byte to write to the stream.</source>
          <target state="translated">Ein Byte, das in den Stream geschrieben werden soll.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.WriteByte(System.Byte)">
          <source>Writes a byte to the current position in the buffered stream.</source>
          <target state="translated">Schreibt ein Byte an die aktuelle Position im gepufferten Stream.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.WriteByte(System.Byte)">
          <source>The stream does not support writing.</source>
          <target state="translated">Der Stream unterstützt das Schreiben nicht.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.WriteByte(System.Byte)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.IO.BufferedStream.WriteByte(System.Byte)">
          <source>Methods were called after the stream was closed.</source>
          <target state="translated">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>