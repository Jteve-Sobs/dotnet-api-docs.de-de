<Type Name="BufferedStream" FullName="System.IO.BufferedStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="306740042d2bab4ace7bf8d697e61b17e4a7d8f7" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37652846" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class BufferedStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BufferedStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.BufferedStream" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BufferedStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class BufferedStream sealed : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type BufferedStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="851b2-101">Fügt eine Pufferebene zu Lese- und Schreibvorgängen auf einem anderen Stream hinzu.</span>
      <span class="sxs-lookup">
        <span data-stu-id="851b2-101">Adds a buffering layer to read and write operations on another stream.</span>
      </span>
      <span data-ttu-id="851b2-102">Diese Klasse kann nicht vererbt werden.</span>
      <span class="sxs-lookup">
        <span data-stu-id="851b2-102">This class cannot be inherited.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="851b2-103">Ein Puffer ist, einen Block von Bytes im Arbeitsspeicher, der zum Zwischenspeichern von Daten, wodurch die Anzahl der Aufrufe des Betriebssystems verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="851b2-103">A buffer is a block of bytes in memory used to cache data, thereby reducing the number of calls to the operating system.</span></span> <span data-ttu-id="851b2-104">Puffer verbessern lesen und schreiben die Leistung.</span><span class="sxs-lookup"><span data-stu-id="851b2-104">Buffers improve read and write performance.</span></span> <span data-ttu-id="851b2-105">Ein Puffer kann für entweder lesen oder schreiben, aber nicht beides gleichzeitig verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="851b2-105">A buffer can be used for either reading or writing, but never both simultaneously.</span></span> <span data-ttu-id="851b2-106">Die <xref:System.IO.BufferedStream.Read%2A> und <xref:System.IO.BufferedStream.Write%2A> Methoden `BufferedStream` automatisch verwalten den Puffer.</span><span class="sxs-lookup"><span data-stu-id="851b2-106">The <xref:System.IO.BufferedStream.Read%2A> and <xref:System.IO.BufferedStream.Write%2A> methods of `BufferedStream` automatically maintain the buffer.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="851b2-107">Dieser Typ implementiert die <xref:System.IDisposable> Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="851b2-107">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="851b2-108">Wenn Sie mit dem Typ haben, sollten Sie es entweder direkt oder indirekt freigeben.</span><span class="sxs-lookup"><span data-stu-id="851b2-108">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="851b2-109">Damit des Typs direkt freigegeben werden, rufen Sie die <xref:System.IDisposable.Dispose%2A> -Methode in einer `try` / `catch` Block.</span><span class="sxs-lookup"><span data-stu-id="851b2-109">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="851b2-110">Um sie indirekt löschen, verwenden Sie ein Sprachkonstrukt wie `using` (in c#) oder `Using` (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="851b2-110">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="851b2-111">Weitere Informationen finden Sie im Abschnitt "mithilfe von ein-Objekt, das implementiert" IDisposable "" in der <xref:System.IDisposable> schnittstellenthema.</span><span class="sxs-lookup"><span data-stu-id="851b2-111">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="851b2-112">`BufferedStream` können auf bestimmte Arten von Streams zusammengesetzt werden.</span><span class="sxs-lookup"><span data-stu-id="851b2-112">`BufferedStream` can be composed around certain types of streams.</span></span> <span data-ttu-id="851b2-113">Es stellt Implementierungen für das Lesen und Schreiben von Bytes in einer zugrunde liegenden Datenquelle oder das Repository bereit.</span><span class="sxs-lookup"><span data-stu-id="851b2-113">It provides implementations for reading and writing bytes to an underlying data source or repository.</span></span> <span data-ttu-id="851b2-114">Verwendung <xref:System.IO.BinaryReader> und <xref:System.IO.BinaryWriter> lesen und Schreiben von anderen Datentypen.</span><span class="sxs-lookup"><span data-stu-id="851b2-114">Use <xref:System.IO.BinaryReader> and <xref:System.IO.BinaryWriter> for reading and writing other data types.</span></span> <span data-ttu-id="851b2-115">`BufferedStream` Dient zum verhindern, dass des Puffers ein- und Ausgabe verlangsamen, wenn der Puffer nicht erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="851b2-115">`BufferedStream` is designed to prevent the buffer from slowing down input and output when the buffer is not needed.</span></span> <span data-ttu-id="851b2-116">Wenn Sie immer lesen und schreiben dann für die Größen, die größer als die Größe des internen Puffers `BufferedStream` möglicherweise nicht den internen Puffer selbst zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="851b2-116">If you always read and write for sizes greater than the internal buffer size, then `BufferedStream` might not even allocate the internal buffer.</span></span> <span data-ttu-id="851b2-117">`BufferedStream` puffert auch Lese- und Schreibvorgänge in einem freigegebenen Puffer.</span><span class="sxs-lookup"><span data-stu-id="851b2-117">`BufferedStream` also buffers reads and writes in a shared buffer.</span></span> <span data-ttu-id="851b2-118">Es wird vorausgesetzt, dass Sie fast immer werden eine Reihe von Lese- und Schreibvorgänge ausführen, aber nur selten zwischen diesen beiden wechseln.</span><span class="sxs-lookup"><span data-stu-id="851b2-118">It is assumed that you will almost always be doing a series of reads or writes, but rarely alternate between the two of them.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="851b2-119">Die folgenden Codebeispiele zeigen, wie mit der `BufferedStream` Klasse über die `NetworkStream` Klasse zur Steigerung der Leistung für bestimmte e/a-Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="851b2-119">The following code examples show how to use the `BufferedStream` class over the `NetworkStream` class to increase the performance of certain I/O operations.</span></span> <span data-ttu-id="851b2-120">Starten Sie den Server vor dem Starten des Clients auf einem Remotecomputer befindet.</span><span class="sxs-lookup"><span data-stu-id="851b2-120">Start the server on a remote computer before starting the client.</span></span> <span data-ttu-id="851b2-121">Geben Sie den Remotecomputernamen als Befehlszeilenargument, beim Starten des Clients.</span><span class="sxs-lookup"><span data-stu-id="851b2-121">Specify the remote computer name as a command-line argument when starting the client.</span></span> <span data-ttu-id="851b2-122">Variieren die `dataArraySize` und `streamBufferSize` Konstanten, um die Auswirkungen auf die Leistung anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="851b2-122">Vary the `dataArraySize` and `streamBufferSize` constants to view their effect on performance.</span></span>  
  
 <span data-ttu-id="851b2-123">Das erste Beispiel zeigt den Code, der auf dem Client ausgeführt wird, und das zweite Beispiel zeigt den Code, der auf dem Server ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="851b2-123">The first example shows the code that runs on the client, and the second example shows the code that runs on the server.</span></span>  
  
 <span data-ttu-id="851b2-124">**Beispiel 1: Code, der auf dem Client ausgeführt wird.**</span><span class="sxs-lookup"><span data-stu-id="851b2-124">**Example 1: Code that runs on the client**</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#1)]
 [!code-csharp[System.IO.BufferedStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#1)]
 [!code-vb[System.IO.BufferedStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#1)]  
  
 <span data-ttu-id="851b2-125">**Beispiel 2: Code, der auf dem Server ausgeführt wird.**</span><span class="sxs-lookup"><span data-stu-id="851b2-125">**Example 2: Code that runs on the server**</span></span>  
  
 [!code-cpp[System.IO.BufferedStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream2/CPP/server.cpp#1)]
 [!code-csharp[System.IO.BufferedStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream2/CS/server.cs#1)]
 [!code-vb[System.IO.BufferedStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream2/VB/server.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.FileStream" />
    <altmember cref="T:System.IO.MemoryStream" />
    <altmember cref="T:System.IO.Stream" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="851b2-126">Initialisiert eine neue Instanz der <see cref="T:System.IO.BufferedStream" />-Klasse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-126">Initializes a new instance of the <see cref="T:System.IO.BufferedStream" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BufferedStream (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BufferedStream(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.IO.BufferedStream : System.IO.Stream -&gt; System.IO.BufferedStream" Usage="new System.IO.BufferedStream stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="851b2-127">Der aktuelle Stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-127">The current stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="851b2-128">Initialisiert eine neue Instanz der <see cref="T:System.IO.BufferedStream" />-Klasse mit einer Standardpuffergröße von 4096 Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-128">Initializes a new instance of the <see cref="T:System.IO.BufferedStream" /> class with a default buffer size of 4096 bytes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="851b2-129">Ein Puffer freigegebene Lese-/Schreibzugriff wird beim ersten zugeordnet eine `BufferedStream` Objekt wird mit diesem Konstruktor initialisiert.</span><span class="sxs-lookup"><span data-stu-id="851b2-129">A shared read/write buffer is allocated the first time a `BufferedStream` object is initialized with this constructor.</span></span> <span data-ttu-id="851b2-130">Der gemeinsam verwendete Puffer wird nicht verwendet werden, wenn alle Lese- und Schreibvorgänge größer als oder gleich sind `bufferSize`.</span><span class="sxs-lookup"><span data-stu-id="851b2-130">The shared buffer is not used if all reads and writes are greater than or equal to `bufferSize`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="851b2-131">
            <paramref name="stream" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-131">
              <paramref name="stream" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BufferedStream (System.IO.Stream stream, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BufferedStream(System::IO::Stream ^ stream, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.BufferedStream : System.IO.Stream * int -&gt; System.IO.BufferedStream" Usage="new System.IO.BufferedStream (stream, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream">
          <span data-ttu-id="851b2-132">Der aktuelle Stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-132">The current stream.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="851b2-133">Die Puffergröße in Byte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-133">The buffer size in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="851b2-134">Initialisiert eine neue Instanz der <see cref="T:System.IO.BufferedStream" />-Klasse mit der angegebenen Puffergröße.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-134">Initializes a new instance of the <see cref="T:System.IO.BufferedStream" /> class with the specified buffer size.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="851b2-135">Ein Puffer freigegebene Lese-/Schreibzugriff wird beim ersten zugeordnet eine `BufferedStream` Objekt wird mit diesem Konstruktor initialisiert.</span><span class="sxs-lookup"><span data-stu-id="851b2-135">A shared read/write buffer is allocated the first time a `BufferedStream` object is initialized with this constructor.</span></span> <span data-ttu-id="851b2-136">Der gemeinsam verwendete Puffer wird nicht verwendet werden, wenn alle Lese- und Schreibvorgänge größer als oder gleich sind `bufferSize`.</span><span class="sxs-lookup"><span data-stu-id="851b2-136">The shared buffer is not used if all reads and writes are greater than or equal to `bufferSize`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="851b2-137">Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.BufferedStream> Klasse.</span><span class="sxs-lookup"><span data-stu-id="851b2-137">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#2)]
 [!code-csharp[System.IO.BufferedStream1#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#2)]
 [!code-vb[System.IO.BufferedStream1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="851b2-138">
            <paramref name="stream" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-138">
              <paramref name="stream" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="851b2-139">
            <paramref name="bufferSize" /> ist ein negativer Wert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-139">
              <paramref name="bufferSize" /> is negative.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="bufferedStream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="851b2-140">Der Puffer, in den die Daten gelesen werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-140">The buffer to read the data into.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="851b2-141">Der Byteoffset in <c>buffer</c>, ab dem gelesene Daten aus dem Stream geschrieben werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-141">The byte offset in <c>buffer</c> at which to begin writing data read from the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="851b2-142">Die maximale Anzahl der zu lesenden Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-142">The maximum number of bytes to read.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="851b2-143">Ein optionaler asynchroner Rückruf, der nach Abschluss des Lesevorgangs aufgerufen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-143">An optional asynchronous callback, to be called when the read is complete.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="851b2-144">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Leseanforderung von anderen Anforderungen unterscheidet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-144">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="851b2-145">Beginnt einen asynchronen Lesevorgang.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-145">Begins an asynchronous read operation.</span>
          </span>
          <span data-ttu-id="851b2-146">(Verwenden Sie stattdessen <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-146">(Consider using <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="851b2-147">Ein Objekt, das den asynchronen Lesevorgang darstellt, der möglicherweise noch aussteht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-147">An object that represents the asynchronous read, which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="851b2-148">In der .NET Framework 4 und früheren Versionen erforderlich, wie z. B. <xref:System.IO.Stream.BeginRead%2A> und <xref:System.IO.Stream.EndRead%2A> , asynchrone Datei-Vorgänge zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="851b2-148">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="851b2-149">Diese Methoden sind weiterhin verfügbar, in der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zur Unterstützung von legacy-Code, jedoch die neuen Async-Methoden, wie z. B. <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, und <xref:System.IO.BufferedStream.FlushAsync%2A>, Hilfe, die Sie asynchrone Dateivorgänge leichter implementieren.</span><span class="sxs-lookup"><span data-stu-id="851b2-149">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="851b2-150"><xref:System.IO.BufferedStream.EndWrite%2A> muss genau einmal aufgerufen werden, für jeden Aufruf von <xref:System.IO.BufferedStream.BeginRead%2A>.</span><span class="sxs-lookup"><span data-stu-id="851b2-150"><xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once for every call to <xref:System.IO.BufferedStream.BeginRead%2A>.</span></span> <span data-ttu-id="851b2-151">Wenn ein Lesevorgang vor einem anderen Lesevorgang beendet kann unerwünschtes Verhalten wie z. B. Deadlocks führen.</span><span class="sxs-lookup"><span data-stu-id="851b2-151">Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="851b2-152">Verwenden der <xref:System.IO.BufferedStream.CanRead%2A> Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt.</span><span class="sxs-lookup"><span data-stu-id="851b2-152">Use the <xref:System.IO.BufferedStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="851b2-153"><xref:System.IO.BufferedStream.EndRead%2A> muss aufgerufen werden, dabei <xref:System.IAsyncResult> zu ermitteln, wie viele Bytes gelesen wurden.</span><span class="sxs-lookup"><span data-stu-id="851b2-153"><xref:System.IO.BufferedStream.EndRead%2A> must be called with this <xref:System.IAsyncResult> to find out how many bytes were read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="851b2-154">
            <paramref name="buffer" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-154">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="851b2-155">
            <paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-155">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="851b2-156">Es wurde ein asynchroner Lesevorgang über das Streamende hinaus versucht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-156">Attempted an asynchronous read past the end of the stream.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="851b2-157">Die Länge des Puffers minus <paramref name="offset" /> ist kleiner als <paramref name="count" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-157">The buffer length minus <paramref name="offset" /> is less than <paramref name="count" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="851b2-158">Der aktuelle Stream unterstützt den Lesevorgang nicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-158">The current stream does not support the read operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="bufferedStream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="851b2-159">Der Puffer mit den Daten, die in den aktuellen Stream geschrieben werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-159">The buffer containing data to write to the current stream.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="851b2-160">Der nullbasierte Byteoffset in <c>buffer</c>, ab dem Daten in den aktuellen Stream kopiert werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-160">The zero-based byte offset in <c>buffer</c> at which to begin copying bytes to the current stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="851b2-161">Die maximale Anzahl der zu schreibenden Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-161">The maximum number of bytes to write.</span>
          </span>
        </param>
        <param name="callback">
          <span data-ttu-id="851b2-162">Die Methode, die aufgerufen werden soll, wenn der asynchrone Schreibvorgang abgeschlossen ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-162">The method to be called when the asynchronous write operation is completed.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="851b2-163">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Schreibanforderung von anderen Anforderungen unterscheidet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-163">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="851b2-164">Beginnt einen asynchronen Schreibvorgang.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-164">Begins an asynchronous write operation.</span>
          </span>
          <span data-ttu-id="851b2-165">(Verwenden Sie stattdessen <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-165">(Consider using <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="851b2-166">Ein Objekt, das auf den asynchronen Schreibvorgang verweist, der möglicherweise noch aussteht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-166">An object that references the asynchronous write which could still be pending.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="851b2-167">In der .NET Framework 4 und früheren Versionen erforderlich, wie z. B. <xref:System.IO.Stream.BeginWrite%2A> und <xref:System.IO.Stream.EndWrite%2A> , asynchrone Datei-Vorgänge zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="851b2-167">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="851b2-168">Diese Methoden sind weiterhin verfügbar, in der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zur Unterstützung von legacy-Code, jedoch die neuen Async-Methoden, wie z. B. <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, und <xref:System.IO.BufferedStream.FlushAsync%2A>, Hilfe, die Sie asynchrone Dateivorgänge leichter implementieren.</span><span class="sxs-lookup"><span data-stu-id="851b2-168">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="851b2-169"><xref:System.IO.BufferedStream.EndWrite%2A> muss genau einmal aufgerufen werden, für jede <xref:System.IAsyncResult> aus <xref:System.IO.BufferedStream.BeginWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="851b2-169"><xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once on every <xref:System.IAsyncResult> from <xref:System.IO.BufferedStream.BeginWrite%2A>.</span></span> <span data-ttu-id="851b2-170"><xref:System.IO.BufferedStream.EndWrite%2A> blockiert, bis der e/a-Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="851b2-170"><xref:System.IO.BufferedStream.EndWrite%2A> will block until the I/O operation has completed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="851b2-171">Die Länge von <paramref name="buffer" /> minus <paramref name="offset" /> ist kleiner als <paramref name="count" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-171">
              <paramref name="buffer" /> length minus <paramref name="offset" /> is less than <paramref name="count" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="851b2-172">
            <paramref name="buffer" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-172">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="851b2-173">
            <paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-173">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="851b2-174">Der Stream unterstützt das Schreiben nicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-174">The stream does not support writing.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BufferSize">
      <MemberSignature Language="C#" Value="public int BufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.BufferSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BufferSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BufferSize : int" Usage="System.IO.BufferedStream.BufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.BufferedStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="851b2-175">Ruft einen Wert ab, der angibt, ob der aktuelle Stream Lesevorgänge unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-175">Gets a value indicating whether the current stream supports reading.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="851b2-176">
            <see langword="true" />, wenn der Stream Lesevorgänge unterstützt, <see langword="false" />, wenn der Stream geschlossen ist oder ausschließlich mit Schreibzugriff geöffnet wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-176">
              <see langword="true" /> if the stream supports reading; <see langword="false" /> if the stream is closed or was opened with write-only access.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="851b2-177">Wenn von eine Klasse abgeleitet <xref:System.IO.Stream> unterstützt keine Lesevorgänge, werden Aufrufe von der <xref:System.IO.BufferedStream.Read%2A>, <xref:System.IO.BufferedStream.ReadByte%2A>, <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.EndRead%2A>, und die `Peek` Methoden <xref:System.IO.StreamReader>, <xref:System.IO.StringReader>, und <xref:System.IO.TextReader> Auslösen einer <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="851b2-177">If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.BufferedStream.Read%2A>, <xref:System.IO.BufferedStream.ReadByte%2A>, <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.EndRead%2A>, and the `Peek` methods of <xref:System.IO.StreamReader>, <xref:System.IO.StringReader>, and <xref:System.IO.TextReader> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="851b2-178">Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`.</span><span class="sxs-lookup"><span data-stu-id="851b2-178">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="851b2-179">Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.BufferedStream> Klasse.</span><span class="sxs-lookup"><span data-stu-id="851b2-179">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#5)]
 [!code-csharp[System.IO.BufferedStream1#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#5)]
 [!code-vb[System.IO.BufferedStream1#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.BufferedStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="851b2-180">Ruft einen Wert ab, der angibt, ob der aktuelle Stream Suchvorgänge unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-180">Gets a value indicating whether the current stream supports seeking.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="851b2-181">
            <see langword="true" />, wenn der Stream Suchvorgänge unterstützt, <see langword="false" />, wenn der Stream geschlossen ist oder von einem Betriebssystemhandle, z. B. einer Pipe oder einer Ausgabe an die Konsole, erstellt wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-181">
              <see langword="true" /> if the stream supports seeking; <see langword="false" /> if the stream is closed or if the stream was constructed from an operating system handle such as a pipe or output to the console.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="851b2-182">Wenn eine Klasse von abgeleitet <xref:System.IO.Stream> unterstützt keine Suchvorgänge, werden Aufrufe von <xref:System.IO.BufferedStream.Length%2A>, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>, und <xref:System.IO.BufferedStream.Seek%2A> Auslösen einer <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="851b2-182">If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.BufferedStream.Length%2A>, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>, and <xref:System.IO.BufferedStream.Seek%2A> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="851b2-183">Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`.</span><span class="sxs-lookup"><span data-stu-id="851b2-183">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="851b2-184">Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.BufferedStream> Klasse.</span><span class="sxs-lookup"><span data-stu-id="851b2-184">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#3)]
 [!code-csharp[System.IO.BufferedStream1#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#3)]
 [!code-vb[System.IO.BufferedStream1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.SetLength(System.Int64)" />
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.BufferedStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="851b2-185">Ruft einen Wert ab, der angibt, ob der aktuelle Stream Schreibvorgänge unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-185">Gets a value indicating whether the current stream supports writing.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="851b2-186">
            <see langword="true" />, wenn der Stream Schreibvorgänge unterstützt, <see langword="false" />, wenn der Stream geschlossen ist oder mit schreibgeschütztem Zugriff geöffnet wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-186">
              <see langword="true" /> if the stream supports writing; <see langword="false" /> if the stream is closed or was opened with read-only access.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="851b2-187">Wenn eine Klasse von abgeleitet <xref:System.IO.Stream> unterstützt nicht das Schreiben, handelt es sich bei eines Aufrufs von <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Write%2A>, oder <xref:System.IO.BufferedStream.WriteByte%2A> löst eine <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="851b2-187">If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Write%2A>, or <xref:System.IO.BufferedStream.WriteByte%2A> throws a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="851b2-188">Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`.</span><span class="sxs-lookup"><span data-stu-id="851b2-188">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="851b2-189">Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.BufferedStream> Klasse.</span><span class="sxs-lookup"><span data-stu-id="851b2-189">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#4)]
 [!code-csharp[System.IO.BufferedStream1#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#4)]
 [!code-vb[System.IO.BufferedStream1#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="bufferedStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="bufferedStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="bufferedStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="851b2-190">Der Verweis auf die ausstehende asynchrone Anforderung, die abgewartet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-190">The reference to the pending asynchronous request to wait for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="851b2-191">Wartet, bis der ausstehende asynchrone Lesevorgang abgeschlossen ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-191">Waits for the pending asynchronous read operation to complete.</span>
          </span>
          <span data-ttu-id="851b2-192">(Verwenden Sie stattdessen <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-192">(Consider using <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="851b2-193">Die Anzahl der aus dem Stream gelesenen Bytes. Diese Anzahl kann zwischen 0 und der Anzahl der angeforderten Bytes liegen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-193">The number of bytes read from the stream, between 0 (zero) and the number of bytes you requested.</span>
          </span>
          <span data-ttu-id="851b2-194">Streams geben nur am Ende des Streams nur 0 zurück, andernfalls sollten sie blockieren, bis mindestens 1 Byte verfügbar ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-194">Streams only return 0 only at the end of the stream, otherwise, they should block until at least 1 byte is available.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="851b2-195">In der .NET Framework 4 und früheren Versionen erforderlich, wie z. B. <xref:System.IO.Stream.BeginRead%2A> und <xref:System.IO.Stream.EndRead%2A> , asynchrone Datei-Vorgänge zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="851b2-195">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="851b2-196">Diese Methoden sind weiterhin verfügbar, in der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zur Unterstützung von legacy-Code, jedoch die neuen Async-Methoden, wie z. B. <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, und <xref:System.IO.BufferedStream.FlushAsync%2A>, Hilfe, die Sie asynchrone Dateivorgänge leichter implementieren.</span><span class="sxs-lookup"><span data-stu-id="851b2-196">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="851b2-197"><xref:System.IO.BufferedStream.EndRead%2A> muss aufgerufen werden, dabei <xref:System.IAsyncResult> zu ermitteln, wie viele Bytes gelesen wurden.</span><span class="sxs-lookup"><span data-stu-id="851b2-197"><xref:System.IO.BufferedStream.EndRead%2A> must be called with this <xref:System.IAsyncResult> to find out how many bytes were read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="851b2-198">
            <paramref name="asyncResult" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-198">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="851b2-199">Dieses <see cref="T:System.IAsyncResult" />-Objekt wurde nicht durch Aufrufen von <see cref="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> für diese Klasse erstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-199">This <see cref="T:System.IAsyncResult" /> object was not created by calling <see cref="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> on this class.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="bufferedStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="851b2-200">Die ausstehende asynchrone Anforderung.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-200">The pending asynchronous request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="851b2-201">Beendet einen asynchronen Schreibvorgang und blockiert, bis die E/A-Operation abgeschlossen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-201">Ends an asynchronous write operation and blocks until the I/O operation is complete.</span>
          </span>
          <span data-ttu-id="851b2-202">(Verwenden Sie stattdessen <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-202">(Consider using <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="851b2-203">In der .NET Framework 4 und früheren Versionen erforderlich, wie z. B. <xref:System.IO.Stream.BeginWrite%2A> und <xref:System.IO.Stream.EndWrite%2A> , asynchrone Datei-Vorgänge zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="851b2-203">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="851b2-204">Diese Methoden sind weiterhin verfügbar, in der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zur Unterstützung von legacy-Code, jedoch die neuen Async-Methoden, wie z. B. <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, und <xref:System.IO.BufferedStream.FlushAsync%2A>, Hilfe, die Sie asynchrone Dateivorgänge leichter implementieren.</span><span class="sxs-lookup"><span data-stu-id="851b2-204">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="851b2-205"><xref:System.IO.BufferedStream.EndWrite%2A> muss genau einmal aufgerufen werden, für jeden Aufruf von <xref:System.IO.BufferedStream.BeginRead%2A>.</span><span class="sxs-lookup"><span data-stu-id="851b2-205"><xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once for every call to <xref:System.IO.BufferedStream.BeginRead%2A>.</span></span> <span data-ttu-id="851b2-206">Fehler beim Beenden eines Prozesses lesen, bevor Sie beginnen kann einem anderen Lesevorgang Deadlocks oder anderen unerwünschten Verhalten führen.</span><span class="sxs-lookup"><span data-stu-id="851b2-206">Failing to end a read process before beginning another read operation can cause deadlock or other undesirable behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="851b2-207">
            <paramref name="asyncResult" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-207">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="851b2-208">Dieses <see cref="T:System.IAsyncResult" />-Objekt wurde nicht durch Aufrufen von <see cref="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> für diese Klasse erstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-208">This <see cref="T:System.IAsyncResult" /> object was not created by calling <see cref="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> on this class.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="bufferedStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="851b2-209">Löscht sämtliche Puffer für diesen Stream und veranlasst die Ausgabe aller gepufferten Daten an das zugrunde liegende Gerät.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-209">Clears all buffers for this stream and causes any buffered data to be written to the underlying device.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="851b2-210">Das Leeren der Datenstrom wird die zugrunde liegende Encoder nicht geleert, es sei denn, Sie explizit aufrufen, `Flush` oder <xref:System.IO.Stream.Close%2A>.</span><span class="sxs-lookup"><span data-stu-id="851b2-210">Flushing the stream will not flush its underlying encoder unless you explicitly call `Flush` or <xref:System.IO.Stream.Close%2A>.</span></span>  
  
 <span data-ttu-id="851b2-211">Bei Verwendung der <xref:System.IO.BufferedStream.%23ctor%2A> Konstruktor angeben daher die Größe des Puffers beim Erstellen der `BufferedStream` Objekt ist, wird der Inhalt wird geleert, wenn sie die Größe des Puffers erreicht.</span><span class="sxs-lookup"><span data-stu-id="851b2-211">If you use the <xref:System.IO.BufferedStream.%23ctor%2A> constructor, thus specifying the buffer size while creating the `BufferedStream` object, the content is flushed when it reaches the buffer size.</span></span> <span data-ttu-id="851b2-212">Code wird beispielsweise wie z. B. `BufferedStream bs = new BufferedStream(bs, 5)` den Inhalt wird geleert werden, wenn die Größe des Puffers 5 Bytes erreicht.</span><span class="sxs-lookup"><span data-stu-id="851b2-212">For example, code such as `BufferedStream bs = new BufferedStream(bs, 5)` will flush the content when the buffer size reaches 5 bytes.</span></span>  
  
 <span data-ttu-id="851b2-213">Alle Lese- und Schreibvorgänge Methoden der `BufferedStream` automatisch den Puffer bewahrt, daher keine Notwendigkeit zum Aufrufen besteht `Flush` beim hin und her wechseln zwischen Lesen und schreiben.</span><span class="sxs-lookup"><span data-stu-id="851b2-213">All the read and write methods of `BufferedStream` automatically maintain the buffer, so there is no need to invoke `Flush` when switching back and forth between reading and writing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="851b2-214">Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.BufferedStream> Klasse.</span><span class="sxs-lookup"><span data-stu-id="851b2-214">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#6)]
 [!code-csharp[System.IO.BufferedStream1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#6)]
 [!code-vb[System.IO.BufferedStream1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="851b2-215">Der Stream wurde verworfen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-215">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="851b2-216">Die Datenquelle oder das Repository ist nicht geöffnet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-216">The data source or repository is not open.</span>
          </span>
        </exception>
        <altmember cref="M:System.IO.Stream.Close" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="bufferedStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">
          <span data-ttu-id="851b2-217">Das Token zum überwachen von Abbruchanforderungen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-217">The token to monitor for cancellation requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="851b2-218">Löscht alle Puffer für diesen Stream asynchron, veranlasst die Ausgabe aller gepufferten Daten an das zugrunde liegende Gerät und überwacht Abbruchanforderungen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-218">Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="851b2-219">Eine Aufgabe, die die asynchrone Leerung darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-219">A task that represents the asynchronous flush operation.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="851b2-220">Der Stream wurde verworfen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-220">The stream has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.BufferedStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="851b2-221">Ruft die Länge des Streams in Bytes ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-221">Gets the stream length in bytes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="851b2-222">Die Länge des Streams in Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-222">The stream length in bytes.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="851b2-223">Der zugrunde liegende Stream ist <see langword="null" /> oder geschlossen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-223">The underlying stream is <see langword="null" /> or closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="851b2-224">Vom Stream wird Suchen nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-224">The stream does not support seeking.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="851b2-225">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-225">Methods were called after the stream was closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.BufferedStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="851b2-226">Ruft die Position im aktuellen Stream ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-226">Gets the position within the current stream.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="851b2-227">Die Position im aktuellen Stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-227">The position within the current stream.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="851b2-228">Die `get` Accessor ruft <xref:System.IO.BufferedStream.Seek%2A> zum Abrufen der aktuellen Position im zugrunde liegenden Stream und passt dann diesen Wert entsprechend der aktuellen Position innerhalb des Puffers.</span><span class="sxs-lookup"><span data-stu-id="851b2-228">The `get` accessor invokes <xref:System.IO.BufferedStream.Seek%2A> to obtain the current position within the underlying stream and then adjusts this value according to the current position within the buffer.</span></span>  
  
 <span data-ttu-id="851b2-229">Die `set` Accessor kopiert alle Daten, die zuvor in den Puffer in den zugrunde liegenden Stream geschrieben, und ruft dann <xref:System.IO.BufferedStream.Seek%2A>.</span><span class="sxs-lookup"><span data-stu-id="851b2-229">The `set` accessor copies any data previously written to the buffer to the underlying stream, and then invokes <xref:System.IO.BufferedStream.Seek%2A>.</span></span>  
  
 <span data-ttu-id="851b2-230">An einem beliebigen Speicherort über die Länge des Streams hinaus Suchvorgänge werden unterstützt.</span><span class="sxs-lookup"><span data-stu-id="851b2-230">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="851b2-231">Der an <see cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" /> übergebene Wert ist negativ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-231">The value passed to <see cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="851b2-232">Ein E/A-Fehler ist aufgetreten, beispielsweise durch Schließen des Streams.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-232">An I/O error occurs, such as the stream being closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="851b2-233">Vom Stream wird Suchen nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-233">The stream does not support seeking.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="851b2-234">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-234">Methods were called after the stream was closed.</span>
          </span>
        </exception>
        <altmember cref="P:System.IO.BufferedStream.CanSeek" />
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="bufferedStream.Read (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="851b2-235">Der Puffer, in den Bytes kopiert werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-235">The buffer to which bytes are to be copied.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="851b2-236">Der Byteoffset im Puffer, ab dem mit dem Lesen von Bytes begonnen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-236">The byte offset in the buffer at which to begin reading bytes.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="851b2-237">Die Anzahl der zu lesenden Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-237">The number of bytes to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="851b2-238">Kopiert Bytes aus dem aktuellen gepufferten Stream in ein Array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-238">Copies bytes from the current buffered stream to an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="851b2-239">Die Anzahl der insgesamt in das <paramref name="array" /> gelesenen Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-239">The total number of bytes read into <paramref name="array" />.</span>
          </span>
          <span data-ttu-id="851b2-240">Diese kann kleiner sein als die Anzahl der angeforderten Bytes, wenn derzeit nicht entsprechend viele Bytes verfügbar sind, oder 0, wenn das Ende des Streams erreicht ist, bevor Daten gelesen werden können.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-240">This can be less than the number of bytes requested if that many bytes are not currently available, or 0 if the end of the stream has been reached before any data can be read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="851b2-241">Die `Read` Methode 0 zurück, nur, wenn das Ende des Streams erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="851b2-241">The `Read` method will return 0 only if the end of the stream is reached.</span></span> <span data-ttu-id="851b2-242">In allen anderen Fällen `Read` immer mindestens ein Byte aus dem Stream liest, vor der Rückgabe.</span><span class="sxs-lookup"><span data-stu-id="851b2-242">In all other cases, `Read` always reads at least one byte from the stream before returning.</span></span> <span data-ttu-id="851b2-243">Per Definition, wenn keine Daten verfügbar, aus dem Stream bei einem Aufruf von sind `Read`, `Read` Methode gibt 0 (das Ende des Streams wird automatisch erreicht) zurück.</span><span class="sxs-lookup"><span data-stu-id="851b2-243">By definition, if no data is available from the stream upon a call to `Read`, the `Read` method returns 0 (the end of the stream is reached automatically).</span></span> <span data-ttu-id="851b2-244">Eine Implementierung ist weniger Bytes als angefordert zurückgeben, selbst wenn Sie nicht das Ende des Streams erreicht wurde.</span><span class="sxs-lookup"><span data-stu-id="851b2-244">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="851b2-245">Verwendung <xref:System.IO.BinaryReader> zum Lesen von primitiven Datentypen.</span><span class="sxs-lookup"><span data-stu-id="851b2-245">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="851b2-246">Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.BufferedStream> Klasse.</span><span class="sxs-lookup"><span data-stu-id="851b2-246">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#7)]
 [!code-csharp[System.IO.BufferedStream1#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#7)]
 [!code-vb[System.IO.BufferedStream1#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="851b2-247">Die Länge von <paramref name="array" /> minus <paramref name="offset" /> ist kleiner als <paramref name="count" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-247">Length of <paramref name="array" /> minus <paramref name="offset" /> is less than <paramref name="count" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="851b2-248">
            <paramref name="array" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-248">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="851b2-249">
            <paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-249">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="851b2-250">Der Stream ist nicht geöffnet oder ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-250">The stream is not open or is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="851b2-251">Lesevorgänge werden vom Stream nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-251">The stream does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="851b2-252">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-252">Methods were called after the stream was closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.Buffer.BlockCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="P:System.IO.BufferedStream.CanRead" />
        <altmember cref="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="bufferedStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="851b2-253">Der Puffer, in den die Daten geschrieben werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-253">The buffer to write the data into.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="851b2-254">Der Byteoffset in <c>buffer</c>, ab dem Daten aus dem Stream geschrieben werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-254">The byte offset in <c>buffer</c> at which to begin writing data from the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="851b2-255">Die maximale Anzahl der zu lesenden Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-255">The maximum number of bytes to read.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="851b2-256">Das Token zum überwachen von Abbruchanforderungen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-256">The token to monitor for cancellation requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="851b2-257">Liest eine Folge von Bytes asynchron aus dem aktuellen Stream, erhöht die Position im Stream um die Anzahl der gelesenen Bytes und überwacht Abbruchanfragen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-257">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="851b2-258">Eine Aufgabe, die den asynchronen Lesevorgang darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-258">A task that represents the asynchronous read operation.</span>
          </span>
          <span data-ttu-id="851b2-259">Der Wert des <paramref name="TResult" />-Parameters enthält die Gesamtzahl der Bytes, die in den Puffer gelesen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-259">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span>
          </span>
          <span data-ttu-id="851b2-260">Der Ergebniswert kann niedriger als die Anzahl der angeforderten Bytes sein, wenn die Anzahl an derzeit verfügbaren Bytes kleiner ist als die angeforderte Anzahl, oder sie kann 0 (null) sein, wenn das Datenstromende erreicht ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-260">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="851b2-261">Können Sie erstellen ein Abbruchtoken, das Erstellen einer Instanz der <xref:System.Threading.CancellationTokenSource> -Klasse und übergeben die <xref:System.Threading.CancellationTokenSource.Token%2A> -Eigenschaft, wie die `cancellationToken` Parameter.</span><span class="sxs-lookup"><span data-stu-id="851b2-261">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="851b2-262">
            <paramref name="buffer" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-262">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="851b2-263">
            <paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-263">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="851b2-264">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Pufferlänge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-264">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="851b2-265">Lesevorgänge werden vom Stream nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-265">The stream does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="851b2-266">Der Stream wurde verworfen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-266">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="851b2-267">Der Stream wird zurzeit von einem vorherigen Lesevorgang verwendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-267">The stream is currently in use by a previous read operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="bufferedStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="851b2-268">Liest ein Byte aus dem zugrunde liegenden Stream und gibt dieses in ein <see langword="int" /> umgewandelt zurück, bzw. wird -1 zurückgegeben, wenn das Ende des Streams erreicht ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-268">Reads a byte from the underlying stream and returns the byte cast to an <see langword="int" />, or returns -1 if reading from the end of the stream.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="851b2-269">Das Byte, umgewandelt in ein <see langword="int" />, oder -1, wenn das Ende des Streams erreicht ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-269">The byte cast to an <see langword="int" />, or -1 if reading from the end of the stream.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="851b2-270">Ein E/A-Fehler ist aufgetreten, beispielsweise durch Schließen des Streams.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-270">An I/O error occurs, such as the stream being closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="851b2-271">Lesevorgänge werden vom Stream nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-271">The stream does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="851b2-272">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-272">Methods were called after the stream was closed.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="851b2-273">
            <para>Die Standardimplementierung für <see langword="Stream" /> erstellt ein neues Single-Byte-Array und ruft dann <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. Während dies formell richtig ist, ist es ineffizient. Jeder Stream mit einem internen Puffer sollte diese Methode überschreiben, und geben Sie eine effizientere Version, die den Puffer direkt, liest die zusätzlichen Array Zuordnung bei jedem Aufruf zu vermeiden.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-273">
              <para>The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. While this is formally correct, it is inefficient. Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="bufferedStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">
          <span data-ttu-id="851b2-274">Ein Byteoffset, das relativ zu <c>origin</c> ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-274">A byte offset relative to <c>origin</c>.</span>
          </span>
        </param>
        <param name="origin">
          <span data-ttu-id="851b2-275">Ein Wert vom Typ <see cref="T:System.IO.SeekOrigin" />, der den Bezugspunkt angibt, von dem aus die neue Position ermittelt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-275">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the reference point from which to obtain the new position.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="851b2-276">Legt die Position im aktuellen gepufferten Stream fest.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-276">Sets the position within the current buffered stream.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="851b2-277">Die neue Position innerhalb des aktuellen gepufferten Streams.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-277">The new position within the current buffered stream.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="851b2-278">Wenn `offset` negativ ist, liegt die die neue Position um die durch `origin` angegebene Anzahl von Bytes vor der durch `offset` angegebenen Position.</span><span class="sxs-lookup"><span data-stu-id="851b2-278">If `offset` is negative, the new position will precede the position specified by `origin` by the number of bytes specified by `offset`.</span></span> <span data-ttu-id="851b2-279">Wenn `offset` ist 0, ist die neue Position der angegebenen Position `origin`.</span><span class="sxs-lookup"><span data-stu-id="851b2-279">If `offset` is 0, the new position will be the position specified by `origin`.</span></span> <span data-ttu-id="851b2-280">Wenn `offset` positiv ist, liegt die neue Position um die durch `origin` angegebene Anzahl an Bytes hinter der durch `offset` angegebenen Position.</span><span class="sxs-lookup"><span data-stu-id="851b2-280">If `offset` is positive, the new position will follow the position specified by `origin` by the number of bytes specified by `offset`.</span></span>  
  
 <span data-ttu-id="851b2-281">Wenn eine <xref:System.IO.BufferedStream> Objekt ist der basisdatenstrom für eine <xref:System.IO.StreamReader> Objekt Aufrufen der <xref:System.IO.BufferedStream.Seek%2A> Methode kann dazu führen, dass die Position im Stream um die Position des internen Puffers im Reader nicht mehr übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="851b2-281">When a <xref:System.IO.BufferedStream> object is the base stream for a <xref:System.IO.StreamReader> object, calling the <xref:System.IO.BufferedStream.Seek%2A> method can cause the position of the stream to no longer match the position of the internal buffer in the reader.</span></span> <span data-ttu-id="851b2-282">Rufen Sie zum Zurücksetzen des internen Puffers der <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=nameWithType> Methode jedoch diese Methode wird, verlangsamt sich, und nur wenn unbedingt nötig aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="851b2-282">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=nameWithType> method; however, this method slows performance and should be called only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="851b2-283">An einem beliebigen Speicherort über die Länge des Streams hinaus Suchvorgänge werden unterstützt.</span><span class="sxs-lookup"><span data-stu-id="851b2-283">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="851b2-284">Der Stream ist nicht geöffnet oder ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-284">The stream is not open or is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="851b2-285">Vom Stream wird Suchen nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-285">The stream does not support seeking.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="851b2-286">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-286">Methods were called after the stream was closed.</span>
          </span>
        </exception>
        <altmember cref="T:System.IO.SeekOrigin" />
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="bufferedStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="851b2-287">Eine ganze Zahl, die die gewünschte Länge des aktuellen gepufferten Streams in Bytes angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-287">An integer indicating the desired length of the current buffered stream in bytes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="851b2-288">Legt die Länge des gepufferten Streams fest.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-288">Sets the length of the buffered stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="851b2-289">Der Puffer wird geleert, bevor Sie die Länge des zugrunde liegenden Datenquelle oder Repository festlegen.</span><span class="sxs-lookup"><span data-stu-id="851b2-289">The buffer is flushed before setting the length of the underlying data source or repository.</span></span> <span data-ttu-id="851b2-290">Wenn der angegebene Wert kleiner als die aktuelle Länge des gepufferten Streams ist, wird der gepufferte Datenstrom abgeschnitten.</span><span class="sxs-lookup"><span data-stu-id="851b2-290">If the specified value is less than the current length of the buffered stream, the buffered stream is truncated.</span></span> <span data-ttu-id="851b2-291">Wenn der angegebene Wert größer als die aktuelle Länge des gepufferten Streams ist, wird der gepufferte Datenstrom erweitert.</span><span class="sxs-lookup"><span data-stu-id="851b2-291">If the specified value is larger than the current length of the buffered stream, the buffered stream is expanded.</span></span> <span data-ttu-id="851b2-292">Wenn der gepufferte Datenstrom erweitert ist, wird den Inhalt des gepufferten Streams zwischen den alten und neuen Größen sind nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="851b2-292">If the buffered stream is expanded, the contents of the buffered stream between the old and the new lengths are not defined.</span></span>  
  
 <span data-ttu-id="851b2-293">`SetLength` Leert alle gepufferten Schreibvorgänge an, bei Bedarf.</span><span class="sxs-lookup"><span data-stu-id="851b2-293">`SetLength` flushes any buffered writes if necessary.</span></span>  
  
 <span data-ttu-id="851b2-294">Ein Stream muss unterstützen sowohl Schreib- und Lesevorgänge für `SetLength` funktioniert.</span><span class="sxs-lookup"><span data-stu-id="851b2-294">A stream must support both writing and seeking for `SetLength` to work.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="851b2-295">
            <paramref name="value" /> ist ein negativer Wert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-295">
              <paramref name="value" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="851b2-296">Der Stream ist nicht geöffnet oder ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-296">The stream is not open or is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="851b2-297">Der Stream unterstützt nicht gleichzeitig Schreib- und Suchvorgänge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-297">The stream does not support both writing and seeking.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="851b2-298">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-298">Methods were called after the stream was closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream UnderlyingStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream UnderlyingStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.UnderlyingStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ UnderlyingStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingStream : System.IO.Stream" Usage="System.IO.BufferedStream.UnderlyingStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="bufferedStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="851b2-299">Das Bytearray, aus dem <c>count</c>-Bytes in den aktuellen gepufferten Stream kopiert werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-299">The byte array from which to copy <c>count</c> bytes to the current buffered stream.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="851b2-300">Der Offset im Puffer, ab dem Bytes in den aktuellen gepufferten Stream kopiert werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-300">The offset in the buffer at which to begin copying bytes to the current buffered stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="851b2-301">Die Anzahl der Bytes, die in den aktuellen gepufferten Stream geschrieben werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-301">The number of bytes to be written to the current buffered stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="851b2-302">Kopiert Bytes in den gepufferten Stream und verschiebt die aktuelle Position im gepufferten Stream um die Anzahl der geschriebenen Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-302">Copies bytes to the buffered stream and advances the current position within the buffered stream by the number of bytes written.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="851b2-303">Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.BufferedStream> Klasse.</span><span class="sxs-lookup"><span data-stu-id="851b2-303">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#6)]
 [!code-csharp[System.IO.BufferedStream1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#6)]
 [!code-vb[System.IO.BufferedStream1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="851b2-304">Die Länge von <paramref name="array" /> minus <paramref name="offset" /> ist kleiner als <paramref name="count" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-304">Length of <paramref name="array" /> minus <paramref name="offset" /> is less than <paramref name="count" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="851b2-305">
            <paramref name="array" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-305">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="851b2-306">
            <paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-306">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="851b2-307">Der Stream ist geschlossen oder <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-307">The stream is closed or <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="851b2-308">Der Stream unterstützt das Schreiben nicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-308">The stream does not support writing.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="851b2-309">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-309">Methods were called after the stream was closed.</span>
          </span>
        </exception>
        <altmember cref="P:System.IO.BufferedStream.CanWrite" />
        <altmember cref="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="bufferedStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="851b2-310">Der Puffer, aus dem Daten geschrieben werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-310">The buffer to write data from.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="851b2-311">Der nullbasierte Byteoffset in <c>buffer</c>, ab dem Bytes in den Stream kopiert werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-311">The zero-based byte offset in <c>buffer</c> from which to begin copying bytes to the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="851b2-312">Die maximale Anzahl der zu schreibenden Bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-312">The maximum number of bytes to write.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="851b2-313">Das Token zum überwachen von Abbruchanforderungen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-313">The token to monitor for cancellation requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="851b2-314">Schreibt eine Folge von Bytes asynchron in den aktuellen Stream, erhöht die aktuelle Position im Stream um die Anzahl der geschriebenen Bytes und überwacht Abbruchanforderungen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-314">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="851b2-315">Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-315">A task that represents the asynchronous write operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="851b2-316">Können Sie erstellen ein Abbruchtoken, das Erstellen einer Instanz der <xref:System.Threading.CancellationTokenSource> -Klasse und übergeben die <xref:System.Threading.CancellationTokenSource.Token%2A> -Eigenschaft, wie die `cancellationToken` Parameter.</span><span class="sxs-lookup"><span data-stu-id="851b2-316">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="851b2-317">
            <paramref name="buffer" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-317">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="851b2-318">
            <paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-318">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="851b2-319">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Pufferlänge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-319">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="851b2-320">Der Stream unterstützt das Schreiben nicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-320">The stream does not support writing.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="851b2-321">Der Stream wurde verworfen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-321">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="851b2-322">Der Stream wird zurzeit von einem vorherigen Schreibvorgang verwendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-322">The stream is currently in use by a previous write operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="bufferedStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="851b2-323">Ein Byte, das in den Stream geschrieben werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-323">A byte to write to the stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="851b2-324">Schreibt ein Byte an die aktuelle Position im gepufferten Stream.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-324">Writes a byte to the current position in the buffered stream.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="851b2-325">Der Stream unterstützt das Schreiben nicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-325">The stream does not support writing.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="851b2-326">
            <paramref name="value" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-326">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="851b2-327">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="851b2-327">Methods were called after the stream was closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>