<Type Name="SecurityTokenHandler" FullName="System.IdentityModel.Tokens.SecurityTokenHandler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="150d892884e4958b20bdde55fc1889994ef6ee77" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52604873" /></Metadata><TypeSignature Language="C#" Value="public abstract class SecurityTokenHandler : System.IdentityModel.Configuration.ICustomIdentityConfiguration" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenHandler extends System.Object implements class System.IdentityModel.Configuration.ICustomIdentityConfiguration" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityTokenHandler&#xA;Implements ICustomIdentityConfiguration" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityTokenHandler abstract : System::IdentityModel::Configuration::ICustomIdentityConfiguration" />
  <TypeSignature Language="F#" Value="type SecurityTokenHandler = class&#xA;    interface ICustomIdentityConfiguration" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IdentityModel.Configuration.ICustomIdentityConfiguration</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Die abstrakte Basisklasse für Sicherheitstokenhandler.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler> Klasse ist die Basisklasse, die alle Tokenhandler abgeleitet. Ein Sicherheitstoken-Handler ist verantwortlich für:  
  
-   Überprüfen von Sicherheitstoken (<xref:System.IdentityModel.Tokens.SecurityToken>) des Typs dieser dient zum Verarbeiten und Verpacken, die die Ansprüche im Token in einem <xref:System.Security.Claims.ClaimsIdentity> Objekt.  
  
-   Serialisieren und Deserialisieren von Sicherheitstoken vom Typ dient es zum verarbeiten.  
  
-   Serialisieren und Deserialisieren von schlüsselbezeichnerklauseln (<xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause>), die finden Sie in Token des Typs entwickelt wurde, um in den und aus verarbeiten `<wsse:SecurityTokenReference>` Elemente.  
  
-   Erstellen von Sicherheitstokens aus einer <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor> Implementierungen von übergebenes Objekt die <xref:System.IdentityModel.SecurityTokenService> Klasse.  
  
-   Erstellen von schlüsselbezeichnerklauseln aus einem Sicherheitstoken für Implementierungen von der <xref:System.IdentityModel.SecurityTokenService> Klasse.  
  
 Windows Identity Foundation (WIF) wird die folgende Sicherheitstokenhandler standardmäßig geliefert:  
  
-   <xref:System.IdentityModel.Tokens.EncryptedSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.KerberosSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Services.Tokens.MembershipUserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.RsaSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.Saml2SecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.SamlSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.UserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.WindowsUserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.X509SecurityTokenHandler>  
  
 Die meisten dieser Klassen verfügbar machen, zusätzliche Member, die Funktionalität zu implementieren, die spezifisch für die Verarbeitung von Token für den die Klasse vorgesehen ist. In vielen Fällen ist es möglicherweise besser für die Ableitung einer dieser Klassen anstatt direkt von der <xref:System.IdentityModel.Tokens.SecurityTokenHandler> Klasse.  
  
 Ein Sicherheitstoken-Handler kann hinzugefügt oder entfernt Sie aus einer Auflistung der Tokenhandler, durch Angabe der [ &lt;hinzufügen&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md), [ &lt;entfernen&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/remove.md), oder [ &lt;löschen&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/clear.md) Elemente unter dem [ &lt;SecurityTokenHandlers&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlers.md) Element in einer Konfigurationsdatei. Die <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration> Objekt, das die Konfigurationseinstellungen für die Handler-Sammlung enthält zugegriffen werden kann, über die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> -Eigenschaft und die Ereignishandler-Auflistung, die der Tokenhandler ein Mitglied ist aus zugegriffen werden kann die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection%2A> Eigenschaft. Sie können außer Kraft setzen der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration%2A> Methode, um benutzerdefinierte Konfigurationselemente zu verarbeiten, die der Handler verwendet.  
  
 Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler> Klasse verfügbar macht, einige andere Eigenschaften und Methoden. Abhängig von den Funktionen, den Sie implementieren möchten, können Sie einige oder alle der folgenden Member überschreiben.  
  
 Müssen Sie überschreiben die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> Eigenschaft und die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> Methode, um Informationen über den Typ des Sicherheitstokens die WIF-Infrastruktur bereit, die Ihre Klasse entwickelt, um zu verarbeiten.  
  
 Validierung, Serialisierung und Deserialisierung Funktionalität verfügbar gemacht wird, über Eigenschaften oder Methoden, die angeben, ob der Handler für eine bestimmte Funktion, die in Kombination mit der Methode oder Methoden, die die Funktionalität zu implementieren ist, ausführen kann. Die folgende Liste-Paaren, die Eigenschaften oder Methoden, die Funktionen mit den Methoden angeben, die diese Funktionalität zu implementieren:  
  
-   Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken%2A> Eigenschaft und die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> Methode: überprüft ein Token und die Ansprüche im Token in enthaltenen Pakete eine <xref:System.Security.Claims.ClaimsIdentity>.  
  
-   Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> Eigenschaft und die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> Methoden: Serialisierung-Token.  
  
-   Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A> Methoden und die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A> Methoden: Deserialisierung-Token.  
  
-   Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A> Methode und die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause%2A> Methode: Deserialisieren der schlüsselbezeichnerklausel.  
  
-   Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A> Methode und die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause%2A> Methode: schlüsselbezeichnerklauseln serialisieren.  
  
 Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken%2A> und <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference%2A> Methoden werden aufgerufen, aus der Pipeline in Implementierungen von der <xref:System.IdentityModel.SecurityTokenService> Klasse.  
  
 Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken%2A> Methode wird aufgerufen, indem der WIF-Infrastruktur, um festzustellen, ob das angegebene Token bereits empfangen wurde. Standardmäßig gibt diese Methode `false`, was bedeutet, dass das Token noch nicht empfangen wurde. Sie können überschreiben Sie die Methode, und stellen die Logik, um wiedergegebene Token erkennen.  
  
   
  
## Examples  
 Die Codebeispiele in allen der <xref:System.IdentityModel.Tokens.SecurityTokenHandler> Themen stammen aus der `Custom Token` Beispiel. Dieses Beispiel enthält die benutzerdefinierte Klassen, die Verarbeitung von Simple Web Token (SWT) zu ermöglichen. Weitere Informationen zu diesem Beispiel und andere Beispiele sind für WIF und wo Sie sie herunterladen, finden Sie unter [Index für WIF-Codebeispiele](~/docs/framework/security/wif-code-sample-index.md). Das folgende XML zeigt, wie den SWT-Tokenhandler, der Tokenhandler-Auflistung hinzugefügt wird.  
  
```xml  
<system.identityModel>  
  <identityConfiguration saveBootstrapContext="true">  
    <issuerTokenResolver type="SimpleWebToken.CustomIssuerTokenResolver, SimpleWebToken">  
      <AddAudienceKeyPair  symmetricKey="wAVkldQiFypTQ+kdNdGWCYCHRcee8XmXxOvgmak8vSY=" audience="http://localhost:19851/" />  
    </issuerTokenResolver>  
    <issuerNameRegistry type="RelyingParty.TrustedIssuerNameRegistry, RelyingParty"/>  
    <audienceUris>  
      <add value="http://localhost:19851/"/>  
    </audienceUris>  
    <securityTokenHandlers>  
      <add type="SimpleWebToken.SimpleWebTokenHandler, SimpleWebToken" />  
    </securityTokenHandlers>  
  </identityConfiguration>  
</system.identityModel>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Tokens.SecurityToken" />
    <altmember cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifier" />
    <altmember cref="T:System.IdentityModel.SecurityTokenService" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityTokenHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Wird von Konstruktoren in abgeleiteten Klassen aufgerufen, um die <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" />-Klasse zu initialisieren.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReadKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual bool CanReadKeyIdentifierClause (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadKeyIdentifierClause(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadKeyIdentifierClause (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadKeyIdentifierClause(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member CanReadKeyIdentifierClause : System.Xml.XmlReader -&gt; bool&#xA;override this.CanReadKeyIdentifierClause : System.Xml.XmlReader -&gt; bool" Usage="securityTokenHandler.CanReadKeyIdentifierClause reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Ein XML-Reader, beim Start-Element positioniert. Der Reader sollte durch diese Methode nicht erweitert werden.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob das XML-Element, auf das aus dem angegebenen XML-Reader verwiesen wird, eine Schlüsselbezeichnerklausel ist, die von dieser Instanz deserialisiert werden kann.</summary>
        <returns><see langword="true" />, wenn die <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause(System.Xml.XmlReader)" />-Methode das Element lesen kann, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung gibt `false` um anzugeben, dass die angegebene schlüsselbezeichnerklausel nicht gelesen werden kann.  
  
 Eine abgeleitete Klasse überprüft das Element, dem der Reader auf bezieht, um festzustellen, ob die Instanz eine schlüsselbezeichnerklausel deserialisiert werden kann. Dies erfolgt normalerweise durch einen Aufruf der <xref:System.Xml.XmlReader.IsStartElement%2A?displayProperty=nameWithType> -Methode mit den entsprechenden Element und den Namespace-Zeichenfolgen angegeben. Wenn Sie außer Kraft setzen <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A>, müssen Sie auch überschreiben die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause%2A> Methode, um die Logik zum Deserialisieren der schlüsselbezeichnerklausel bereitzustellen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob das angegebene Token als Token des Typs deserialisiert werden kann, der von dieser Instanz verarbeitet wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public virtual bool CanReadToken (string tokenString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadToken(string tokenString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadToken (tokenString As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadToken(System::String ^ tokenString);" />
      <MemberSignature Language="F#" Value="abstract member CanReadToken : string -&gt; bool&#xA;override this.CanReadToken : string -&gt; bool" Usage="securityTokenHandler.CanReadToken tokenString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tokenString">Die zu lesende Tokenzeichenfolge.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Zeichenfolge als Token des Typs deserialisiert werden kann, der von dieser Instanz verarbeitet wird.</summary>
        <returns><see langword="true" />, wenn die <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.String)" />-Methode das Element lesen kann, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung gibt immer `false` zurück.  
  
 Wenn Sie diese Methode überschreiben, müssen Sie auch überschreiben die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> Methode, um die Logik zum Deserialisieren des Tokens bereitzustellen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public virtual bool CanReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadToken (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member CanReadToken : System.Xml.XmlReader -&gt; bool&#xA;override this.CanReadToken : System.Xml.XmlReader -&gt; bool" Usage="securityTokenHandler.CanReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Ein XML-Reader, bei einem Start-Element positioniert. Der Reader sollte durch diese Methode nicht erweitert werden.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob das XML-Element, auf das aus dem angegebenen XML-Reader verwiesen wird, als Token des Typs gelesen werden kann, der von dieser Instanz verarbeitet wird.</summary>
        <returns><see langword="true" />, wenn die <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader)" />-Methode das Element lesen kann, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung gibt immer `false` zurück.  
  
 Eine abgeleitete Klasse überprüft das Element, dem der Reader auf bezieht, um festzustellen, ob ein Sicherheitstoken von die Instanz deserialisiert werden kann. Dies erfolgt normalerweise durch einen Aufruf der <xref:System.Xml.XmlReader.IsStartElement%2A> -Methode mit den entsprechenden Element und den Namespace-Zeichenfolgen angegeben. Wenn Sie außer Kraft setzen <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A>, müssen Sie auch überschreiben die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> Methode oder der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> Methode, um die Logik zum Deserialisieren der schlüsselbezeichnerklausel bereitzustellen.  
  
   
  
## Examples  
 Der folgende Code veranschaulicht das Überschreiben der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A> Methode, um zu bestimmen, ob ein Token von einem Handler gelesen werden kann. Der Code stammt aus dem `Custom Token` Beispiel. Dieses Beispiel enthält die benutzerdefinierte Klassen, die Verarbeitung von Simple Web Token (SWT) zu ermöglichen. Weitere Informationen zu diesem Beispiel und andere Beispiele sind für WIF und wo Sie sie herunterladen, finden Sie unter [Index für WIF-Codebeispiele](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanValidateToken">
      <MemberSignature Language="C#" Value="public virtual bool CanValidateToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanValidateToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanValidateToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanValidateToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanValidateToken : bool" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Handler die Validierung von Sicherheitstoken unterstützt.</summary>
        <value><see langword="true" />, wenn die Klasse zum Überprüfen von Sicherheitstoken in der Lage ist; andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Implementieren von Validierung in einer abgeleiteten Klasse außer Kraft setzen dieser Eigenschaft zurückgegeben `true` und überschreiben die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> Methode, um die Validierungslogik zu implementieren.  
  
   
  
## Examples  
 Der folgende Code veranschaulicht das Überschreiben der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken%2A> Eigenschaft, um anzugeben, dass ein benutzerdefinierter Handler Token überprüfen kann. Der Code stammt aus dem `Custom Token` Beispiel. Dieses Beispiel enthält die benutzerdefinierte Klassen, die Verarbeitung von Simple Web Token (SWT) zu ermöglichen. Weitere Informationen zu diesem Beispiel und andere Beispiele sind für WIF und wo Sie sie herunterladen, finden Sie unter [Index für WIF-Codebeispiele](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#2](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual bool CanWriteKeyIdentifierClause (System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanWriteKeyIdentifierClause(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanWriteKeyIdentifierClause(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ securityKeyIdentifierClause);" />
      <MemberSignature Language="F#" Value="abstract member CanWriteKeyIdentifierClause : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool&#xA;override this.CanWriteKeyIdentifierClause : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool" Usage="securityTokenHandler.CanWriteKeyIdentifierClause securityKeyIdentifierClause" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="securityKeyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="securityKeyIdentifierClause">Die zu überprüfende Schlüsselbezeichnerklausel.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Schlüsselbezeichnerklausel von dieser Instanz serialisiert werden kann.</summary>
        <returns><see langword="true" />, wenn die angegebene Schlüsselbezeichnerklausel serialisiert kann, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung gibt immer `false` zurück.  
  
 Wenn Sie außer Kraft setzen <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A>, müssen Sie auch überschreiben die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause%2A> Methode, um die Logik zum Serialisieren der Sicherheitsschlüsselbezeichner-Klausel bereitzustellen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteToken">
      <MemberSignature Language="C#" Value="public virtual bool CanWriteToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWriteToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanWriteToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWriteToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWriteToken : bool" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Handler Sicherheitstoken serialisieren kann.</summary>
        <value><see langword="true" />, wenn die Klasse zum Serialisieren von Token in der Lage ist; andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um Serialisierung in einer abgeleiteten Klasse zu implementieren, überschreiben Sie diese Eigenschaft zurückgeben `true` und überschreiben die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> Methoden, die die Serialisierungslogik implementiert.  
  
   
  
## Examples  
 Der folgende Code veranschaulicht das Überschreiben der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> Eigenschaft, um anzugeben, dass ein benutzerdefinierter Handler Token serialisieren kann. Der Code stammt aus dem `Custom Token` Beispiel. Dieses Beispiel enthält die benutzerdefinierte Klassen, die Verarbeitung von Simple Web Token (SWT) zu ermöglichen. Weitere Informationen zu diesem Beispiel und andere Beispiele sind für WIF und wo Sie sie herunterladen, finden Sie unter [Index für WIF-Codebeispiele](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Configuration">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration Configuration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration Configuration" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" />
      <MemberSignature Language="VB.NET" Value="Public Property Configuration As SecurityTokenHandlerConfiguration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ Configuration { System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ get(); void set(System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Configuration : System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration with get, set" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration" />-Objekt ab, das die Konfiguration für die aktuelle Instanz bereitstellt, oder legt dieses fest.</summary>
        <value>Das Konfigurationsobjekt für die aktuelle Instanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> Eigenschaftensatz wird in der Regel von der Konfigurationsinfrastruktur aus der [ &lt;SecurityTokenHandlerConfiguration&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlerconfiguration.md) Element in der Konfigurationsdatei, bei der Anwendung gestartet.  
  
 In abgeleiteten Klassen, die Sie verwenden die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> Eigenschaft, um auf Konfigurationseinstellungen zuzugreifen, z. B. die Ausstellernamen-Registrierung für die Verwendung in der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> Methode zugegriffen werden kann, aus der <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.IssuerNameRegistry%2A?displayProperty=nameWithType> Eigenschaft des Konfigurationsobjekts.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainingCollection">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityTokenHandlerCollection ContainingCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenHandlerCollection ContainingCollection" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainingCollection As SecurityTokenHandlerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Tokens::SecurityTokenHandlerCollection ^ ContainingCollection { System::IdentityModel::Tokens::SecurityTokenHandlerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainingCollection : System.IdentityModel.Tokens.SecurityTokenHandlerCollection" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandlerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Token Handler-Sammlung ab, die die aktuelle Instanz beinhaltet.</summary>
        <value>Die Tokenhandlerauflistung, die die aktuelle Instanz enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die token-Handler hinzugefügt wird eine <xref:System.IdentityModel.Tokens.SecurityTokenHandlerCollection> Instanz, die diese Eigenschaft wird automatisch festgelegt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSecurityTokenReference">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateSecurityTokenReference (System.IdentityModel.Tokens.SecurityToken token, bool attached);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateSecurityTokenReference(class System.IdentityModel.Tokens.SecurityToken token, bool attached) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference(System.IdentityModel.Tokens.SecurityToken,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSecurityTokenReference (token As SecurityToken, attached As Boolean) As SecurityKeyIdentifierClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ CreateSecurityTokenReference(System::IdentityModel::Tokens::SecurityToken ^ token, bool attached);" />
      <MemberSignature Language="F#" Value="abstract member CreateSecurityTokenReference : System.IdentityModel.Tokens.SecurityToken * bool -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause&#xA;override this.CreateSecurityTokenReference : System.IdentityModel.Tokens.SecurityToken * bool -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="securityTokenHandler.CreateSecurityTokenReference (token, attached)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="attached" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="token">Das Token, für das der Verweis erstellt werden soll.</param>
        <param name="attached"><see langword="true" />, wenn ein angefügter Verweis erstellt werden soll; <see langword="false" />, wenn ein nicht angefügter Verweis erstellt werden soll.</param>
        <summary>Erstellt bei Überschreibung in einer abgeleiteten Klasse den Sicherheitstokenverweis für die von dieser Klasse verarbeiteten Token. Diese Methode wird in der Regel von einem Sicherheitstokendienst (STS) aufgerufen.</summary>
        <returns>Eine Schlüsselbezeichnerklausel, die auf das angegebene Token verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig löst diese Methode eine <xref:System.NotImplementedException> Ausnahme.  
  
 Abgeleitete Klassen überschreiben diese Methode, um eine schlüsselbezeichnerklausel zurückgeben (<xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause>), die verwendet werden kann, zum Erstellen einer `<wsse:SecurityTokenReference>` -Element für das angegebene Token.  
  
 Aufgerufen von Implementierungen der <xref:System.IdentityModel.SecurityTokenService> Klasse.  
  
 In der Regel eine <xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause> muss nicht als verwendet werden, wenn ein benutzerdefinierter Sicherheitstokendienst erstellt wird. Wenn ein Sicherheitstokendienst ein Sicherheitstoken zurückgibt, enthält das ausgegebene Sicherheitstoken Verweise auf angefügte und nicht angefügte Sicherheitstoken. Die angefügten Verweise beziehen sich auf Sicherheitstoken, die im Sicherheitsheader einer SOAP-Nachricht enthalten sind, und nicht angehängte Verweise beziehen sich auf Sicherheitstoken, die nicht im Sicherheitsheader einer SOAP-Nachricht enthalten sind. Diese Verweise bestätigen in der Regel die Echtheit des ausgegebenen Sicherheitstokens.  
  
   
  
## Examples  
 Der folgende Code veranschaulicht das Überschreiben der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference%2A> Methode, um eine schlüsselbezeichnerklausel aus dem angegebenen Token zu erstellen. Der Code stammt aus dem `Custom Token` Beispiel. Dieses Beispiel enthält die benutzerdefinierte Klassen, die Verarbeitung von Simple Web Token (SWT) zu ermöglichen. Weitere Informationen zu diesem Beispiel und andere Beispiele sind für WIF und wo Sie sie herunterladen, finden Sie unter [Index für WIF-Codebeispiele](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken CreateToken (System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken CreateToken(class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken(System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateToken (tokenDescriptor As SecurityTokenDescriptor) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ CreateToken(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="abstract member CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.CreateToken tokenDescriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="tokenDescriptor">Der Sicherheitstokendeskriptor, von dem das Token erstellt werden soll. Eigenschaften des Tokensdeskriptors werden festgelegt, bevor diese Methode aufgerufen wird.</param>
        <summary>Erstellt, wenn in einer abgeleiteten Klasse überschrieben, ein Sicherheitstoken mithilfe der angegebenen Tokenbeschreibung. Diese Methode wird von einem Sicherheitstokendienst (STS) aufgerufen.</summary>
        <returns>Ein Sicherheitstoken, das mit den Eigenschaften des Tokensdeskriptors übereinstimmt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig löst diese Methode eine <xref:System.NotImplementedException> Ausnahme.  
  
 Aufgerufen von Implementierungen der <xref:System.IdentityModel.SecurityTokenService> Klasse.  
  
   
  
## Examples  
 Der folgende Code veranschaulicht das Überschreiben der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken%2A> -Methode zum Erstellen und ein Token zurück, anhand eines tokendeskriptors. Der Code stammt aus dem `Custom Token` Beispiel. Dieses Beispiel enthält die benutzerdefinierte Klassen, die Verarbeitung von Simple Web Token (SWT) zu ermöglichen. Weitere Informationen zu diesem Beispiel und andere Beispiele sind für WIF und wo Sie sie herunterladen, finden Sie unter [Index für WIF-Codebeispiele](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetectReplayedToken">
      <MemberSignature Language="C#" Value="protected virtual void DetectReplayedToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DetectReplayedToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DetectReplayedToken (token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DetectReplayedToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member DetectReplayedToken : System.IdentityModel.Tokens.SecurityToken -&gt; unit&#xA;override this.DetectReplayedToken : System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.DetectReplayedToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Das auf Wiedergabe zu überprüfende Token.</param>
        <summary>Löst beim Überschreiben in einer abgeleiteten Klasse eine Ausnahme aus, wenn das angegebene Token als wiedergegeben erkannt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Standardimplementierung wird keine Aktion ausgeführt.  
  
 Abgeleitete Klassen sollten Auslösen einer <xref:System.IdentityModel.Tokens.SecurityTokenReplayDetectedException> , wenn das Token bereits verwendet wurde.  
  
 Windows Identity Foundation (WIF) bietet die <xref:System.IdentityModel.Tokens.TokenReplayCache> Klasse, die von der Wiedergabe Caches abgeleitet werden können und die [ &lt;TokenReplayCache&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/tokenreplaycache.md) Konfigurationselement an, die verwendet werden kann, so konfigurieren Sie die Wiedergeben von Tokenhandler in einer Anwendung verwendeten Cache; jedoch die genaue Implementierung der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken%2A> Methode ist, bis der Designer der abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenTypeIdentifiers">
      <MemberSignature Language="C#" Value="public abstract string[] GetTokenTypeIdentifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetTokenTypeIdentifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetTokenTypeIdentifiers () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::String ^&gt; ^ GetTokenTypeIdentifiers();" />
      <MemberSignature Language="F#" Value="abstract member GetTokenTypeIdentifiers : unit -&gt; string[]" Usage="securityTokenHandler.GetTokenTypeIdentifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt bei Überschreibung in einer abgeleiteten Klasse den Satz von URIs zurück, die in Anforderungen verwendet werden, um einen Token des Typs zu identifizieren, der von dieser Klasse verarbeitet wird.</summary>
        <returns>Der Gruppe der URIs, die den Tokentyp identifizieren, den dieser Handler unterstützt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type> des Tokens von der aktuellen Instanz verarbeitet erfolgt über die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> Eigenschaft. Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> Methode gibt den Satz der zulässigen Bezeichner, die verwendet werden kann, Nachrichten zum Verweisen auf den Typ des Sicherheitstokens. Z. B. der URI-Wert verwendet, der `<wst:TokenType>` Element unter der `<wst:RequestSecurityToken>` Element eine bestimmte Art von Token anfordern (dargestellt durch die <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.TokenType%2A?displayProperty=nameWithType> Eigenschaft im Objektmodell).  
  
   
  
## Examples  
 Der folgende Code veranschaulicht das Überschreiben der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A> Methode, um die Tokentyp-Bezeichner für ein benutzerdefiniertes Token zurückzugeben. Der Code stammt aus dem `Custom Token` Beispiel. Dieses Beispiel enthält die benutzerdefinierte Klassen, die Verarbeitung von Simple Web Token (SWT) zu ermöglichen. Weitere Informationen zu diesem Beispiel und andere Beispiele sind für WIF und wo Sie sie herunterladen, finden Sie unter [Index für WIF-Codebeispiele](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#17](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#17)]  
[!code-csharp[WifRcCustomToken#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCustomConfiguration">
      <MemberSignature Language="C#" Value="public virtual void LoadCustomConfiguration (System.Xml.XmlNodeList nodelist);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadCustomConfiguration(class System.Xml.XmlNodeList nodelist) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration(System.Xml.XmlNodeList)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub LoadCustomConfiguration (nodelist As XmlNodeList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void LoadCustomConfiguration(System::Xml::XmlNodeList ^ nodelist);" />
      <MemberSignature Language="F#" Value="abstract member LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit&#xA;override this.LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit" Usage="securityTokenHandler.LoadCustomConfiguration nodelist" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IdentityModel.Configuration.ICustomIdentityConfiguration.LoadCustomConfiguration(System.Xml.XmlNodeList)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodelist" Type="System.Xml.XmlNodeList" />
      </Parameters>
      <Docs>
        <param name="nodelist">Das Konfigurations-XML-Element. Jeder Knoten in der Liste ist vom Typ <see cref="T:System.Xml.XmlElement" />.</param>
        <summary>Lädt beim Überschreiben in einer abgeleiteten Klasse die benutzerdefinierte Konfiguration aus XML ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration%2A> Methode wird von der Konfigurationsinfrastruktur aufgerufen. Wenn diese Methode aufgerufen wird, die `nodelist` enthält der obersten Ebene der untergeordneten Elemente der tokenvalidierungslogik des Handlers [ &lt;hinzufügen&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md) Element aus der Konfigurationsdatei. Jede dieser kann wiederum enthalten Attribute oder untergeordnete Elemente abhängig von dem Konfigurationsschema, die, das Sie für die abgeleitete Klasse zu definieren.  
  
 Die Standardimplementierung löst eine <xref:System.NotImplementedException>. Überschreiben Sie diese Methode in der abgeleiteten Klasse auf die Initialisierung von Ihrem Sicherheitstoken-Handler aus einer Konfigurationsdatei zu aktivieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKeyIdentifierClause ReadKeyIdentifierClause (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKeyIdentifierClause ReadKeyIdentifierClause(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadKeyIdentifierClause (reader As XmlReader) As SecurityKeyIdentifierClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ ReadKeyIdentifierClause(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadKeyIdentifierClause : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause&#xA;override this.ReadKeyIdentifierClause : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="securityTokenHandler.ReadKeyIdentifierClause reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Ein XML-Reader, positioniert am XML-Startelement, das in in die Schlüsselbezeichnerklausel zu deserialisieren ist.</param>
        <summary>Deserialisiert bei Überschreibung in einer abgeleiteten Klasse das XML, auf das durch den angegebenen XML-Reader verwiesen wird, in eine Schlüsselbezeichnerklausel, die auf ein Token verweist, das von der abgeleiteten Klasse verarbeitet wird.</summary>
        <returns>Die Schlüsselbezeichnerklausel, die von der XML deserialisiert wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig löst diese Methode eine <xref:System.NotImplementedException> Ausnahme.  
  
 Überschreiben Sie diese Methode, um die Logik, um eine schlüsselbezeichnerklausel aus XML deserialisiert bereitstellen. Wenn Sie diese Methode überschreiben, sollten Sie auch überschreiben die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Deserialisiert bei Überschreibung in einer abgeleiteten Klasse das angegebene XML in ein Token des Typs, der von der abgeleiteten Klasse verarbeitet wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (string tokenString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(string tokenString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (tokenString As String) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::String ^ tokenString);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : string -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : string -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken tokenString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tokenString">Die zu deserialisierende Zeichenfolge.</param>
        <summary>Deserialisiert bei Überschreibung in einer abgeleiteten Klasse die angegebene Zeichenfolge in ein Token des Typs, der von der abgeleiteten Klasse verarbeitet wird.</summary>
        <returns>Der Sicherheitstoken, der von der angegebenen Zeichenfolge deserialisiert wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 Standardmäßig löst diese Methode eine <xref:System.NotImplementedException> Ausnahme.  
  
 Überschreiben Sie diese Methode, um Funktionen bereitzustellen, die ein Sicherheitstoken aus einer Zeichenfolge deserialisiert werden kann. Wenn Sie, diese Methode überschreiben, sollten Sie auch überschreiben die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (reader As XmlReader) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Ein XML-Reader, der am Start-Element des Tokens positioniert ist.</param>
        <summary>Deserialisiert bei Überschreibung in einer abgeleiteten Klasse das XML, auf das durch den angegebenen XML-Reader verwiesen wird, in ein Token des Typs, der von der abgeleiteten Klasse verarbeitet wird.</summary>
        <returns>Das Sicherheitstoken, das aus der XML deserialisiert wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 Standardmäßig löst diese Methode eine <xref:System.NotImplementedException> Ausnahme.  
  
 Überschreiben Sie diese Methode, um die Logik, um ein Sicherheitstoken aus XML deserialisiert bereitstellen. Wenn Sie diese Methode überschreiben, sollten Sie auch überschreiben die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> Methode. In der Regel in abgeleiteten Klassen, wenn die Methode das Token aus der XML-verwiesen wird, deserialisiert werden kann, löst eine <xref:System.Xml.XmlException>.  
  
   
  
## Examples  
 Der folgende Code veranschaulicht das Überschreiben der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A> Methode, um ein benutzerdefiniertes Token aus dem angegebenen XML-Reader zu lesen. Der Code stammt aus dem `Custom Token` Beispiel. Dieses Beispiel enthält die benutzerdefinierte Klassen, die Verarbeitung von Simple Web Token (SWT) zu ermöglichen. Weitere Informationen zu diesem Beispiel und andere Beispiele sind für WIF und wo Sie sie herunterladen, finden Sie unter [Index für WIF-Codebeispiele](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#7)]  
[!code-csharp[WifRcCustomToken#8](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#8)]  
[!code-csharp[WifRcCustomToken#14](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader,System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (reader As XmlReader, tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken (reader, tokenResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="reader">Ein XML-Reader, der am Start-Element des Tokens positioniert ist.</param>
        <param name="tokenResolver">Ein Tokenresolver, der die Out-of-Band und zwischengespeicherten Token enthält.</param>
        <summary>Deserialisiert bei Überschreibung in einer abgeleiteten Klasse das XML, auf das durch den angegebenen XML-Reader verwiesen wird, in ein Token des Typs, der von dieser Klasse unter Verwendung des angegebenen Tokenresolvers verarbeitet wird.</summary>
        <returns>Das Sicherheitstoken, das aus der XML deserialisiert wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 Die standardmäßige Implementierung ignoriert die `tokenResolver` Parameter und den Aufruf an die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType> Methode.  
  
 Überschreiben Sie diese Methode, um die Logik, um ein Sicherheitstoken aus XML deserialisiert bereitstellen. Wenn Sie diese Methode überschreiben, sollten Sie auch überschreiben die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType> Methode. In der Regel in abgeleiteten Klassen, wenn die Methode das Token aus der XML-verwiesen wird, deserialisiert werden kann, löst eine <xref:System.Xml.XmlException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenType">
      <MemberSignature Language="C#" Value="public abstract Type TokenType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TokenType" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property TokenType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ TokenType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenType : Type" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.TokenType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft bei Überschreibung in einer abgeleiteten Klasse den Typ des Sicherheitstoken ab, der von dieser Instanz verarbeitetet wird.</summary>
        <value>Der Typ des Sicherheitstoken, das von dieser Instanz verarbeitet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen diese Eigenschaft in abgeleiteten Klassen überschreiben und Zurückgeben der <xref:System.Type> des Sicherheitstokens (<xref:System.IdentityModel.Tokens.SecurityToken>), die von der abgeleiteten Klasse verarbeitet wird.  
  
   
  
## Examples  
 Der folgende Code veranschaulicht das Überschreiben der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A> zurückzugebende Eigenschaft der <xref:System.Type> von der Sicherheitstoken, die durch einen benutzerdefinierten Handler verarbeitet werden. Der Code stammt aus dem `Custom Token` Beispiel. Dieses Beispiel enthält die benutzerdefinierte Klassen, die Verarbeitung von Simple Web Token (SWT) zu ermöglichen. Weitere Informationen zu diesem Beispiel und andere Beispiele sind für WIF und wo Sie sie herunterladen, finden Sie unter [Index für WIF-Codebeispiele](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#18](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceTokenValidationFailure">
      <MemberSignature Language="C#" Value="protected void TraceTokenValidationFailure (System.IdentityModel.Tokens.SecurityToken token, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void TraceTokenValidationFailure(class System.IdentityModel.Tokens.SecurityToken token, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.TraceTokenValidationFailure(System.IdentityModel.Tokens.SecurityToken,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub TraceTokenValidationFailure (token As SecurityToken, errorMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void TraceTokenValidationFailure(System::IdentityModel::Tokens::SecurityToken ^ token, System::String ^ errorMessage);" />
      <MemberSignature Language="F#" Value="member this.TraceTokenValidationFailure : System.IdentityModel.Tokens.SecurityToken * string -&gt; unit" Usage="securityTokenHandler.TraceTokenValidationFailure (token, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="token">Das Sicherheitstoken, das überprüft wird.</param>
        <param name="errorMessage">Die in die Ablaufverfolgung zu schreibende Meldung.</param>
        <summary>Verfolgt das Fehlerereignis während der Validierung von Sicherheitstoken, wenn die Ablaufverfolgung aktiviert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte aufgerufen werden, aus der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> Methode, wenn die Überprüfung des Tokens ein Fehler auftritt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceTokenValidationSuccess">
      <MemberSignature Language="C#" Value="protected void TraceTokenValidationSuccess (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void TraceTokenValidationSuccess(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.TraceTokenValidationSuccess(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub TraceTokenValidationSuccess (token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void TraceTokenValidationSuccess(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="member this.TraceTokenValidationSuccess : System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.TraceTokenValidationSuccess token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Das Token, das überprüft wurde.</param>
        <summary>Verfolgt die erfolgreiche Validierung des Sicherheitstokenereignisses, wenn die Ablaufverfolgung aktiviert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte aufgerufen werden, aus der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> -Methode auf, nachdem das Token wurde erfolgreich überprüft wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValidateToken (token As SecurityToken) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;&#xA;override this.ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;" Usage="securityTokenHandler.ValidateToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Das zu validierende Token.</param>
        <summary>Validiert beim Überschreiben in einer abgeleiteten Klasse das angegebene Sicherheitstoken. Das Token muss von dem von der abgeleiteten Klasse verarbeiteten Typ sein.</summary>
        <returns>Die Identitäten im Token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig löst diese Methode eine <xref:System.NotImplementedException> Ausnahme.  
  
 Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> Methode wird aufgerufen, von der Infrastruktur, um zu überprüfen, und extrahieren die Ansprüche aus das deserialisierte Sicherheitstoken. Diese Ansprüche werden zurückgegeben, in der Auflistung der <xref:System.Security.Claims.ClaimsIdentity> Objekte, die von der Methode zurückgegeben. In der Regel enthält diese Auflistung eine einzelne Identität.  
  
 Validierung enthält in abgeleiteten Klassen in der Regel überprüfen die beabsichtigte Zielgruppe, die im Token für die angegebenen URIs in Zielgruppe angegeben die <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.AudienceRestriction%2A?displayProperty=nameWithType> Eigenschaft des Konfigurationsobjekts Tokenhandler angegeben wird, auf die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> Eigenschaft. Diese URIs werden in der Regel legen Sie in der Konfigurationsdatei unter dem [ &lt;AudienceUris&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/audienceuris.md) Element. Wenn die Zielgruppe kann nicht überprüft werden, ein <xref:System.IdentityModel.Tokens.AudienceUriValidationFailedException> Ausnahme ausgelöst werden soll.  
  
 Beim Verarbeiten von Token wird der Aussteller in der Regel durch das ausstellertoken auf einen der Übergabe überprüft die <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> Methoden für die <xref:System.IdentityModel.Tokens.IssuerNameRegistry> -Objekt, das für den Handler über konfiguriert ist die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> Eigenschaft. Die Ausstellernamen-Registrierung wird in der Regel über konfiguriert die [ &lt;"issuerNameRegistry"&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/issuernameregistry.md) Element in der Konfigurationsdatei. Die <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> gibt den Namen des Ausstellers zurück. Dieser Name sollte verwendet werden, Festlegen der <xref:System.Security.Claims.Claim.Issuer%2A?displayProperty=nameWithType> -Eigenschaft in der im Token enthaltenen Ansprüche. Wenn die Ausstellernamen-Registrierung einen Eintrag für das ausstellertoken keinen enthält <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> gibt `null`. In diesem Fall eine <xref:System.IdentityModel.Tokens.SecurityTokenException> wird in der Regel in abgeleiteten Klassen ausgelöst, aber dieses Verhalten ist bis zu den Designer der-Klasse.  
  
   
  
## Examples  
 Der folgende Code zeigt eine Überschreibung von der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> -Methode für einen Sicherheitstokenhandler, die einfache webtoken (SWT) verarbeitet. Der Code stammt aus dem `CustomToken` Beispiel. Weitere Informationen zu diesem Beispiel und andere Beispiele sind für WIF und wo Sie sie herunterladen, finden Sie unter [Index für WIF-Codebeispiele](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#9](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#9)]  
  
 Der folgende code zeigt `CreateClaims` -Methode, die aufgerufen wird, von der Überschreibung von der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> -Methode in der im vorherigen Beispiel. Diese Methode gibt eine <xref:System.Security.Claims.ClaimsIdentity> -Objekt, das aus der Ansprüche im Token erstellt wird. Der Code stammt aus dem `CustomToken` Beispiel. Weitere Informationen zu diesem Beispiel und andere Beispiele sind für WIF und wo Sie sie herunterladen, finden Sie unter [Index für WIF-Codebeispiele](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#15](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#15)]  
  
 Der folgende code zeigt `ValidateSignature` -Methode, die aufgerufen wird, von der Überschreibung von der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> -Methode in der simple Web token-Handler. Diese Methode überprüft die Signatur des Tokens mithilfe der konfigurierten <xref:System.IdentityModel.Tokens.IssuerTokenResolver>. Der Code stammt aus dem `CustomToken` Beispiel. Weitere Informationen zu diesem Beispiel und andere Beispiele sind für WIF und wo Sie sie herunterladen, finden Sie unter [Index für WIF-Codebeispiele](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#12](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#12)]  
[!code-csharp[WifRcCustomToken#11](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#11)]  
  
 Der folgende code zeigt `ValidateAudience` -Methode, die aufgerufen wird, von der Überschreibung von der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A> -Methode in der simple Web token-Handler. Diese Methode überprüft, ob die Zielgruppe, die innerhalb des Tokens anhand der Zielgruppen-URIs, die in der Konfiguration angegeben wurden. Der Code stammt aus dem `CustomToken` Beispiel. Weitere Informationen zu diesem Beispiel und andere Beispiele sind für WIF und wo Sie sie herunterladen, finden Sie unter [Index für WIF-Codebeispiele](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#13](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual void WriteKeyIdentifierClause (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteKeyIdentifierClause(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteKeyIdentifierClause(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ securityKeyIdentifierClause);" />
      <MemberSignature Language="F#" Value="abstract member WriteKeyIdentifierClause : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; unit&#xA;override this.WriteKeyIdentifierClause : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; unit" Usage="securityTokenHandler.WriteKeyIdentifierClause (writer, securityKeyIdentifierClause)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="securityKeyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="writer">Der XML-Writer.</param>
        <param name="securityKeyIdentifierClause">Die zu serialisierende Schlüsselbezeichnerklausel.</param>
        <summary>Serialisiert beim Überschreiben in einer abgeleiteten Klasse die angegebene Schlüsselbezeichnerklausel in XML. Die Schlüsselbezeichnerklausel muss einen Typ besitzen, der von der abgeleiteten Klasse unterstützt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig löst diese Methode eine <xref:System.NotImplementedException> Ausnahme.  
  
 Überschreiben Sie diese Methode zum Bereitstellen der Logik, um eine schlüsselbezeichnerklausel in XML zu serialisieren. Wenn Sie diese Methode überschreiben, sollten Sie auch überschreiben die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Serialisiert bei Überschreibung in einer abgeleiteten Klasse das angegebene Sicherheitstoken. Das Token muss von dem von der abgeleiteten Klasse verarbeiteten Typ sein.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual string WriteToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string WriteToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteToken (token As SecurityToken) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ WriteToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member WriteToken : System.IdentityModel.Tokens.SecurityToken -&gt; string&#xA;override this.WriteToken : System.IdentityModel.Tokens.SecurityToken -&gt; string" Usage="securityTokenHandler.WriteToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Das zu serialisierende Token</param>
        <summary>Serialisiert bei Überschreibung in einer abgeleiteten Klasse das angegebene Sicherheitstoken in eine Zeichenfolge. Das Token muss von dem von der abgeleiteten Klasse verarbeiteten Typ sein.</summary>
        <returns>Der serialisierte Token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig löst diese Methode eine <xref:System.NotImplementedException> Ausnahme.  
  
 Überschreiben Sie diese Methode zum Bereitstellen der Logik, um ein Sicherheitstoken in XML zu serialisieren. Wenn Sie diese Methode überschreiben, sollten Sie auch überschreiben die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual void WriteToken (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteToken(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteToken (writer As XmlWriter, token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteToken(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit&#xA;override this.WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.WriteToken (writer, token)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="writer">Der XML-Writer.</param>
        <param name="token">Das zu serialisierende Token</param>
        <summary>Serialisiert beim Überschreiben in einer abgeleiteten Klasse das angegebene Sicherheitstoken in XML. Das Token muss von dem von der abgeleiteten Klasse verarbeiteten Typ sein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig löst diese Methode eine <xref:System.NotImplementedException> Ausnahme.  
  
 Überschreiben Sie diese Methode zum Bereitstellen der Logik, um ein Sicherheitstoken in XML zu serialisieren. Wenn Sie diese Methode überschreiben, sollten Sie auch überschreiben die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A> Eigenschaft.  
  
   
  
## Examples  
 Der folgende Code veranschaulicht das Überschreiben der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> Methode, um ein benutzerdefiniertes Token zu serialisieren. Der Code stammt aus dem `Custom Token` Beispiel. Dieses Beispiel enthält die benutzerdefinierte Klassen, die Verarbeitung von Simple Web Token (SWT) zu ermöglichen. Weitere Informationen zu diesem Beispiel und andere Beispiele sind für WIF und wo Sie sie herunterladen, finden Sie unter [Index für WIF-Codebeispiele](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#10](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#10)]  
[!code-csharp[WifRcCustomToken#11](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>