<Type Name="SecurityTokenHandler" FullName="System.IdentityModel.Tokens.SecurityTokenHandler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="79a1f1c77754da0a474777b66c2d40de010dbf06" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78823442" /></Metadata><TypeSignature Language="C#" Value="public abstract class SecurityTokenHandler : System.IdentityModel.Configuration.ICustomIdentityConfiguration" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenHandler extends System.Object implements class System.IdentityModel.Configuration.ICustomIdentityConfiguration" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Tokens.SecurityTokenHandler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityTokenHandler&#xA;Implements ICustomIdentityConfiguration" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityTokenHandler abstract : System::IdentityModel::Configuration::ICustomIdentityConfiguration" />
  <TypeSignature Language="F#" Value="type SecurityTokenHandler = class&#xA;    interface ICustomIdentityConfiguration" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IdentityModel.Configuration.ICustomIdentityConfiguration</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Die abstrakte Basisklasse für Sicherheitstokenhandler.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler>-Klasse ist die Basisklasse, von der alle Sicherheitstokenhandler abgeleitet werden. Ein Sicherheitstokenhandler ist für Folgendes zuständig:  
  
-   Validieren von Sicherheits Token (<xref:System.IdentityModel.Tokens.SecurityToken>) des Typs, der zum Verarbeiten und Verpacken der im Token enthaltenen Ansprüche in ein <xref:System.Security.Claims.ClaimsIdentity> Objekt entworfen wurde.  
  
-   Serialisieren und Deserialisieren von Sicherheits Token des Typs, der verarbeitet werden soll.  
  
-   Serialisieren und Deserialisieren von Schlüsselbezeichnerklauseln (<xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause>), die auf Token des Typs verweisen, der für die Verarbeitung in und von `<wsse:SecurityTokenReference>` Elementen konzipiert ist.  
  
-   Erstellen von Sicherheits Token aus einem <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor> Objekt, das von Implementierungen der <xref:System.IdentityModel.SecurityTokenService>-Klasse übermittelt wird.  
  
-   Erstellen von Schlüsselbezeichnerklauseln aus einem Sicherheits Token für Implementierungen der <xref:System.IdentityModel.SecurityTokenService>-Klasse.  
  
 Die folgenden Sicherheitstokenhandler werden von Windows Identity Foundation (WIF) standardmäßig ausgeliefert:  
  
-   <xref:System.IdentityModel.Tokens.EncryptedSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.KerberosSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Services.Tokens.MachineKeySessionSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Services.Tokens.MembershipUserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.RsaSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.Saml2SecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.SamlSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.UserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.WindowsUserNameSecurityTokenHandler>  
  
-   <xref:System.IdentityModel.Tokens.X509SecurityTokenHandler>  
  
 Die meisten dieser Klassen machen zusätzliche Member verfügbar, die Funktionen implementieren, die für die Verarbeitung der Token spezifisch sind, für die die Klasse entworfen wurde. In vielen Fällen ist es möglicherweise besser, von einer dieser Klassen anstatt direkt von der <xref:System.IdentityModel.Tokens.SecurityTokenHandler> Klasse abzuleiten.  
  
 Ein Sicherheitstokenhandler kann einer tokenhandlerauflistung hinzugefügt oder daraus entfernt werden, indem der [&lt;Add&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md), [&lt;Remove&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/remove.md)oder [&lt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/clear.md)&gt;Elemente unter dem&lt;[securitytokenhandlers&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlers.md) Element in einer Konfigurationsdatei angegeben wird. Der Zugriff auf das <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration> Objekt, das die Konfigurationseinstellungen für die Handlerauflistung enthält, kann über die Eigenschaft <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> und die Handlerauflistung, in der der Tokenhandler Mitglied ist, über die Eigenschaft <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection%2A> aufgerufen werden. Sie können die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration%2A>-Methode überschreiben, um alle benutzerdefinierten Konfigurationselemente zu verarbeiten, die der Handler annimmt.  
  
 Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler>-Klasse macht mehrere andere Eigenschaften und Methoden verfügbar. Abhängig von der Funktion, die Sie implementieren möchten, können Sie einige oder alle dieser Member überschreiben.  
  
 Sie müssen die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A>-Eigenschaft und die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A>-Methode überschreiben, um der WIF-Infrastruktur Informationen über den Typ des Sicherheits Tokens bereitzustellen, für dessen Verarbeitung die Klasse vorgesehen ist.  
  
 Validierungs-, Serialisierungs-und Deserialisierungsfunktionen werden durch Eigenschaften oder Methoden verfügbar gemacht, die angeben, ob der Handler eine bestimmte Funktion in Kombination mit der Methode oder den Methoden ausführen kann, die die Funktionalität implementieren. In der folgenden Liste sind die Eigenschaften oder Methoden, die die Funktionalität angeben, mit den Methoden verknüpft, die diese Funktionalität implementieren:  
  
-   Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken%2A>-Eigenschaft und die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A>-Methode: überprüft ein Token und verpackt die im Token enthaltenen Ansprüche in eine <xref:System.Security.Claims.ClaimsIdentity>.  
  
-   Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A>-Eigenschaft und die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> Methoden: Tokenserialisierung.  
  
-   Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A> Methoden und die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A> Methoden: tokendeserialisierung.  
  
-   Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A>-Methode und die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause%2A>-Methode: Deserialisieren der Schlüsselbezeichnerklauseln.  
  
-   Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A>-Methode und die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause%2A>-Methode: Serialisieren der Schlüsselbezeichnerklauseln.  
  
 Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken%2A> und die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference%2A> Methoden werden von der Pipeline in Implementierungen der <xref:System.IdentityModel.SecurityTokenService>-Klasse aufgerufen.  
  
 Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken%2A>-Methode wird von der WIF-Infrastruktur aufgerufen, um zu bestimmen, ob das angegebene Token bereits empfangen wurde. Standardmäßig gibt diese Methode `false`zurück, das angibt, dass das Token noch nicht empfangen wurde. Sie können die-Methode überschreiben und Logik bereitstellen, um wiedergegebene Token zu erkennen.  
  
   
  
## Examples  
 Die Codebeispiele in allen <xref:System.IdentityModel.Tokens.SecurityTokenHandler> Themen stammen aus dem `Custom Token` Beispiel. Dieses Beispiel stellt benutzerdefinierte Klassen bereit, die die Verarbeitung von Simple Web Tokens (Swap) ermöglichen. Informationen zu diesem Beispiel und anderen Beispielen, die für WIF verfügbar sind und wo Sie heruntergeladen werden können, finden Sie unter [Beispiel Index für WIF-Code](~/docs/framework/security/wif-code-sample-index.md). Der folgende XML-Code zeigt, wie der-tokenhandlerauflistung der tokenhandlerauflistung hinzugefügt wird.  
  
```xml  
<system.identityModel>  
  <identityConfiguration saveBootstrapContext="true">  
    <issuerTokenResolver type="SimpleWebToken.CustomIssuerTokenResolver, SimpleWebToken">  
      <AddAudienceKeyPair  symmetricKey="wAVkldQiFypTQ+kdNdGWCYCHRcee8XmXxOvgmak8vSY=" audience="http://localhost:19851/" />  
    </issuerTokenResolver>  
    <issuerNameRegistry type="RelyingParty.TrustedIssuerNameRegistry, RelyingParty"/>  
    <audienceUris>  
      <add value="http://localhost:19851/"/>  
    </audienceUris>  
    <securityTokenHandlers>  
      <add type="SimpleWebToken.SimpleWebTokenHandler, SimpleWebToken" />  
    </securityTokenHandlers>  
  </identityConfiguration>  
</system.identityModel>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Tokens.SecurityToken" />
    <altmember cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifier" />
    <altmember cref="T:System.IdentityModel.SecurityTokenService" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityTokenHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Wird von Konstruktoren in abgeleiteten Klassen aufgerufen, um die <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" />-Klasse zu initialisieren.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReadKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual bool CanReadKeyIdentifierClause (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadKeyIdentifierClause(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadKeyIdentifierClause (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadKeyIdentifierClause(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member CanReadKeyIdentifierClause : System.Xml.XmlReader -&gt; bool&#xA;override this.CanReadKeyIdentifierClause : System.Xml.XmlReader -&gt; bool" Usage="securityTokenHandler.CanReadKeyIdentifierClause reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Ein XML-Reader, beim Start-Element positioniert. Der Reader sollte durch diese Methode nicht erweitert werden.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob das XML-Element, auf das aus dem angegebenen XML-Reader verwiesen wird, eine Schlüsselbezeichnerklausel ist, die von dieser Instanz deserialisiert werden kann.</summary>
        <returns><see langword="true" />, wenn die <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause(System.Xml.XmlReader)" />-Methode das Element lesen kann, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung gibt `false` zurück, um anzugeben, dass die Schlüsselbezeichnerklausel nicht gelesen werden kann.  
  
 Eine abgeleitete Klasse überprüft das Element, auf das der Reader verweist, um zu bestimmen, ob die Instanz eine Schlüsselbezeichnerklausel deserialisieren kann. Dies erfolgt in der Regel über einen aufzurufenden <xref:System.Xml.XmlReader.IsStartElement%2A?displayProperty=nameWithType>-Methode mit den entsprechenden Element-und Namespace Zeichenfolgen. Wenn Sie <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A>überschreiben, müssen Sie auch die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause%2A>-Methode überschreiben, um die Logik zum Deserialisieren der Schlüsselbezeichnerklausel bereitzustellen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob das angegebene Token als Token des Typs deserialisiert werden kann, der von dieser Instanz verarbeitet wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public virtual bool CanReadToken (string tokenString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadToken(string tokenString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadToken (tokenString As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadToken(System::String ^ tokenString);" />
      <MemberSignature Language="F#" Value="abstract member CanReadToken : string -&gt; bool&#xA;override this.CanReadToken : string -&gt; bool" Usage="securityTokenHandler.CanReadToken tokenString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tokenString">Die zu lesende Tokenzeichenfolge.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Zeichenfolge als Token des Typs deserialisiert werden kann, der von dieser Instanz verarbeitet wird.</summary>
        <returns><see langword="true" />, wenn die <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.String)" />-Methode das Element lesen kann, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung gibt immer `false` zurück.  
  
 Wenn Sie diese Methode überschreiben, müssen Sie auch die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType>-Methode überschreiben, um die Logik zum Deserialisieren des Tokens bereitzustellen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanReadToken">
      <MemberSignature Language="C#" Value="public virtual bool CanReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanReadToken (reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member CanReadToken : System.Xml.XmlReader -&gt; bool&#xA;override this.CanReadToken : System.Xml.XmlReader -&gt; bool" Usage="securityTokenHandler.CanReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Ein XML-Reader, bei einem Start-Element positioniert. Der Reader sollte durch diese Methode nicht erweitert werden.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob das XML-Element, auf das aus dem angegebenen XML-Reader verwiesen wird, als Token des Typs gelesen werden kann, der von dieser Instanz verarbeitet wird.</summary>
        <returns><see langword="true" />, wenn die <see cref="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader)" />-Methode das Element lesen kann, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung gibt immer `false` zurück.  
  
 Eine abgeleitete Klasse überprüft das Element, auf das der Reader verweist, um zu bestimmen, ob die Instanz ein Sicherheits Token deserialisieren kann. Dies erfolgt in der Regel über einen aufzurufenden <xref:System.Xml.XmlReader.IsStartElement%2A>-Methode mit den entsprechenden Element-und Namespace Zeichenfolgen. Wenn Sie <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A>überschreiben, müssen Sie auch die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType>-Methode oder die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType>-Methode überschreiben, um die Logik zum Deserialisieren der Schlüsselbezeichnerklausel bereitzustellen.  
  
   
  
## Examples  
 Der folgende Code zeigt, wie Sie die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A>-Methode überschreiben, um zu bestimmen, ob ein Token von einem Handler gelesen werden kann. Der Code wird aus dem `Custom Token`-Beispiel entnommen. Dieses Beispiel stellt benutzerdefinierte Klassen bereit, die die Verarbeitung von Simple Web Tokens (Swap) ermöglichen. Informationen zu diesem Beispiel und anderen Beispielen, die für WIF verfügbar sind und wo Sie heruntergeladen werden können, finden Sie unter [Beispiel Index für WIF-Code](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanValidateToken">
      <MemberSignature Language="C#" Value="public virtual bool CanValidateToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanValidateToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanValidateToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanValidateToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanValidateToken : bool" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Handler die Validierung von Sicherheitstoken unterstützt.</summary>
        <value><see langword="true" />, wenn die Klasse zum Überprüfen von Sicherheitstoken in der Lage ist; andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Implementieren der Validierung in einer abgeleiteten Klasse überschreiben Sie diese Eigenschaft, um `true` zurückzugeben und die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A>-Methode zu überschreiben, um die Validierungs Logik zu implementieren  
  
   
  
## Examples  
 Der folgende Code zeigt, wie Sie die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanValidateToken%2A>-Eigenschaft überschreiben, um anzugeben, dass ein benutzerdefinierter Handler Token validieren kann. Der Code wird aus dem `Custom Token`-Beispiel entnommen. Dieses Beispiel stellt benutzerdefinierte Klassen bereit, die die Verarbeitung von Simple Web Tokens (Swap) ermöglichen. Informationen zu diesem Beispiel und anderen Beispielen, die für WIF verfügbar sind und wo Sie heruntergeladen werden können, finden Sie unter [Beispiel Index für WIF-Code](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#2](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual bool CanWriteKeyIdentifierClause (System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanWriteKeyIdentifierClause(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanWriteKeyIdentifierClause (securityKeyIdentifierClause As SecurityKeyIdentifierClause) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanWriteKeyIdentifierClause(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ securityKeyIdentifierClause);" />
      <MemberSignature Language="F#" Value="abstract member CanWriteKeyIdentifierClause : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool&#xA;override this.CanWriteKeyIdentifierClause : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; bool" Usage="securityTokenHandler.CanWriteKeyIdentifierClause securityKeyIdentifierClause" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="securityKeyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="securityKeyIdentifierClause">Die zu überprüfende Schlüsselbezeichnerklausel.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Schlüsselbezeichnerklausel von dieser Instanz serialisiert werden kann.</summary>
        <returns><see langword="true" />, wenn die angegebene Schlüsselbezeichnerklausel serialisiert kann, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung gibt immer `false` zurück.  
  
 Wenn Sie <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A>überschreiben, müssen Sie auch die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause%2A>-Methode überschreiben, um die Logik zum Serialisieren der Schlüsselbezeichnerklausel bereitzustellen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWriteToken">
      <MemberSignature Language="C#" Value="public virtual bool CanWriteToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWriteToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanWriteToken As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWriteToken { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWriteToken : bool" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Handler Sicherheitstoken serialisieren kann.</summary>
        <value><see langword="true" />, wenn die Klasse zum Serialisieren von Token in der Lage ist; andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Implementieren der Serialisierung in einer abgeleiteten Klasse überschreiben Sie diese Eigenschaft, um `true` zurückzugeben und die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A> Methoden zum Implementieren der Serialisierungslogik zu überschreiben.  
  
   
  
## Examples  
 Der folgende Code zeigt, wie Sie die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A>-Eigenschaft überschreiben, um anzugeben, dass ein benutzerdefinierter Handler Token serialisieren kann. Der Code wird aus dem `Custom Token`-Beispiel entnommen. Dieses Beispiel stellt benutzerdefinierte Klassen bereit, die die Verarbeitung von Simple Web Tokens (Swap) ermöglichen. Informationen zu diesem Beispiel und anderen Beispielen, die für WIF verfügbar sind und wo Sie heruntergeladen werden können, finden Sie unter [Beispiel Index für WIF-Code](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Configuration">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration Configuration { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration Configuration" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" />
      <MemberSignature Language="VB.NET" Value="Public Property Configuration As SecurityTokenHandlerConfiguration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ Configuration { System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ get(); void set(System::IdentityModel::Tokens::SecurityTokenHandlerConfiguration ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Configuration : System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration with get, set" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.Configuration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration" />-Objekt ab, das die Konfiguration für die aktuelle Instanz bereitstellt, oder legt dieses fest.</summary>
        <value>Das Konfigurationsobjekt für die aktuelle Instanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A>-Eigenschaft wird in der Regel von der Konfigurations Infrastruktur aus dem [&lt;securitytokenhandlerconfiguration&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/securitytokenhandlerconfiguration.md) -Element in der Konfigurationsdatei beim Starten der Anwendung festgelegt.  
  
 In abgeleiteten Klassen verwenden Sie die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A>-Eigenschaft, um auf Konfigurationseinstellungen zuzugreifen. der Zugriff auf die Aussteller Namen Registrierung, die in der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A>-Methode verwendet werden soll, kann beispielsweise über die <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.IssuerNameRegistry%2A?displayProperty=nameWithType>-Eigenschaft des Konfigurations Objekts erfolgen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainingCollection">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityTokenHandlerCollection ContainingCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenHandlerCollection ContainingCollection" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainingCollection As SecurityTokenHandlerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Tokens::SecurityTokenHandlerCollection ^ ContainingCollection { System::IdentityModel::Tokens::SecurityTokenHandlerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainingCollection : System.IdentityModel.Tokens.SecurityTokenHandlerCollection" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.ContainingCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandlerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Token Handler-Sammlung ab, die die aktuelle Instanz beinhaltet.</summary>
        <value>Die Tokenhandlerauflistung, die die aktuelle Instanz enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Tokenhandler einer <xref:System.IdentityModel.Tokens.SecurityTokenHandlerCollection>-Instanz hinzugefügt wird, wird diese Eigenschaft automatisch festgelegt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSecurityTokenReference">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateSecurityTokenReference (System.IdentityModel.Tokens.SecurityToken token, bool attached);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKeyIdentifierClause CreateSecurityTokenReference(class System.IdentityModel.Tokens.SecurityToken token, bool attached) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference(System.IdentityModel.Tokens.SecurityToken,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSecurityTokenReference (token As SecurityToken, attached As Boolean) As SecurityKeyIdentifierClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ CreateSecurityTokenReference(System::IdentityModel::Tokens::SecurityToken ^ token, bool attached);" />
      <MemberSignature Language="F#" Value="abstract member CreateSecurityTokenReference : System.IdentityModel.Tokens.SecurityToken * bool -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause&#xA;override this.CreateSecurityTokenReference : System.IdentityModel.Tokens.SecurityToken * bool -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="securityTokenHandler.CreateSecurityTokenReference (token, attached)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="attached" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="token">Das Token, für das der Verweis erstellt werden soll.</param>
        <param name="attached"><see langword="true" />, wenn ein angefügter Verweis erstellt werden soll; <see langword="false" />, wenn ein nicht angefügter Verweis erstellt werden soll.</param>
        <summary>Erstellt bei Überschreibung in einer abgeleiteten Klasse den Sicherheitstokenverweis für die von dieser Klasse verarbeiteten Token. Diese Methode wird in der Regel von einem Sicherheitstokendienst (STS) aufgerufen.</summary>
        <returns>Eine Schlüsselbezeichnerklausel, die auf das angegebene Token verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig löst diese Methode eine <xref:System.NotImplementedException> Ausnahme aus.  
  
 Abgeleitete Klassen überschreiben diese Methode, um eine Schlüsselbezeichnerklausel (<xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause>) zurückzugeben, die zum Erstellen eines `<wsse:SecurityTokenReference>`-Elements für das angegebene Token verwendet werden kann.  
  
 Wird von Implementierungen der <xref:System.IdentityModel.SecurityTokenService>-Klasse aufgerufen.  
  
 In der Regel muss ein <xref:System.IdentityModel.Tokens.SecurityKeyIdentifierClause> nicht verwendet werden, außer wenn ein benutzerdefinierter Sicherheitstokendienst erstellt wird. Wenn ein Sicherheitstokendienst ein Sicherheitstoken zurückgibt, enthält das ausgegebene Sicherheitstoken Verweise auf angefügte und nicht angefügte Sicherheitstoken. Die angefügten Verweise beziehen sich auf Sicherheitstoken, die im Sicherheitsheader einer SOAP-Nachricht enthalten sind, und nicht angehängte Verweise beziehen sich auf Sicherheitstoken, die nicht im Sicherheitsheader einer SOAP-Nachricht enthalten sind. Diese Verweise bestätigen in der Regel die Echtheit des ausgegebenen Sicherheitstokens.  
  
   
  
## Examples  
 Der folgende Code zeigt, wie Sie die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateSecurityTokenReference%2A>-Methode überschreiben, um eine Schlüsselbezeichnerklausel aus dem angegebenen Token zu erstellen. Der Code wird aus dem `Custom Token`-Beispiel entnommen. Dieses Beispiel stellt benutzerdefinierte Klassen bereit, die die Verarbeitung von Simple Web Tokens (Swap) ermöglichen. Informationen zu diesem Beispiel und anderen Beispielen, die für WIF verfügbar sind und wo Sie heruntergeladen werden können, finden Sie unter [Beispiel Index für WIF-Code](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken CreateToken (System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken CreateToken(class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken(System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateToken (tokenDescriptor As SecurityTokenDescriptor) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ CreateToken(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="abstract member CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.CreateToken : System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.CreateToken tokenDescriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="tokenDescriptor">Der Sicherheitstokendeskriptor, von dem das Token erstellt werden soll. Eigenschaften des Tokensdeskriptors werden festgelegt, bevor diese Methode aufgerufen wird.</param>
        <summary>Erstellt, wenn in einer abgeleiteten Klasse überschrieben, ein Sicherheitstoken mithilfe der angegebenen Tokenbeschreibung. Diese Methode wird von einem Sicherheitstokendienst (STS) aufgerufen.</summary>
        <returns>Ein Sicherheitstoken, das mit den Eigenschaften des Tokensdeskriptors übereinstimmt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig löst diese Methode eine <xref:System.NotImplementedException> Ausnahme aus.  
  
 Wird von Implementierungen der <xref:System.IdentityModel.SecurityTokenService>-Klasse aufgerufen.  
  
   
  
## Examples  
 Der folgende Code zeigt, wie Sie die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CreateToken%2A>-Methode überschreiben, um ein Token von einem tokendeskriptor zu erstellen und zurückzugeben. Der Code wird aus dem `Custom Token`-Beispiel entnommen. Dieses Beispiel stellt benutzerdefinierte Klassen bereit, die die Verarbeitung von Simple Web Tokens (Swap) ermöglichen. Informationen zu diesem Beispiel und anderen Beispielen, die für WIF verfügbar sind und wo Sie heruntergeladen werden können, finden Sie unter [Beispiel Index für WIF-Code](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetectReplayedToken">
      <MemberSignature Language="C#" Value="protected virtual void DetectReplayedToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DetectReplayedToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DetectReplayedToken (token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DetectReplayedToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member DetectReplayedToken : System.IdentityModel.Tokens.SecurityToken -&gt; unit&#xA;override this.DetectReplayedToken : System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.DetectReplayedToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Das auf Wiedergabe zu überprüfende Token.</param>
        <summary>Löst beim Überschreiben in einer abgeleiteten Klasse eine Ausnahme aus, wenn das angegebene Token als wiedergegeben erkannt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Standardimplementierung wird keine Aktion ausgeführt.  
  
 Abgeleitete Klassen sollten eine <xref:System.IdentityModel.Tokens.SecurityTokenReplayDetectedException> auslösen, wenn das Token bereits verwendet wurde.  
  
 Windows Identity Foundation (WIF) stellt die <xref:System.IdentityModel.Tokens.TokenReplayCache> Klasse bereit, von der Wiedergabe Caches abgeleitet werden können, und das [&lt;tokenreplaycache&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/tokenreplaycache.md) Configuration-Element, das verwendet werden kann, um den Wiedergabe Cache zu konfigurieren, der von tokenhandlern in einer Anwendung verwendet wird. Allerdings ist die genaue Implementierung der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.DetectReplayedToken%2A> Methode der Designer der abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTokenTypeIdentifiers">
      <MemberSignature Language="C#" Value="public abstract string[] GetTokenTypeIdentifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetTokenTypeIdentifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetTokenTypeIdentifiers () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::String ^&gt; ^ GetTokenTypeIdentifiers();" />
      <MemberSignature Language="F#" Value="abstract member GetTokenTypeIdentifiers : unit -&gt; string[]" Usage="securityTokenHandler.GetTokenTypeIdentifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt bei Überschreibung in einer abgeleiteten Klasse den Satz von URIs zurück, die in Anforderungen verwendet werden, um einen Token des Typs zu identifizieren, der von dieser Klasse verarbeitet wird.</summary>
        <returns>Der Gruppe der URIs, die den Tokentyp identifizieren, den dieser Handler unterstützt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Zugriff auf den <xref:System.Type> des Tokens, das von der aktuellen Instanz verarbeitet wird, erfolgt über die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A>-Eigenschaft. Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A>-Methode gibt den Satz zulässiger Bezeichner zurück, die in Nachrichten verwendet werden können, um auf den Tokentyp zu verweisen. Beispielsweise der URI-Wert, der im `<wst:TokenType>`-Element unter dem `<wst:RequestSecurityToken>`-Element verwendet wird, um eine bestimmte Art von Token anzufordern (dargestellt durch die <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.TokenType%2A?displayProperty=nameWithType>-Eigenschaft im-Objektmodell).  
  
   
  
## Examples  
 Der folgende Code zeigt, wie Sie die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.GetTokenTypeIdentifiers%2A>-Methode überschreiben, um die Tokentyp Bezeichner für ein benutzerdefiniertes Token zurückzugeben. Der Code wird aus dem `Custom Token`-Beispiel entnommen. Dieses Beispiel stellt benutzerdefinierte Klassen bereit, die die Verarbeitung von Simple Web Tokens (Swap) ermöglichen. Informationen zu diesem Beispiel und anderen Beispielen, die für WIF verfügbar sind und wo Sie heruntergeladen werden können, finden Sie unter [Beispiel Index für WIF-Code](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#17](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#17)]  
[!code-csharp[WifRcCustomToken#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCustomConfiguration">
      <MemberSignature Language="C#" Value="public virtual void LoadCustomConfiguration (System.Xml.XmlNodeList nodelist);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadCustomConfiguration(class System.Xml.XmlNodeList nodelist) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration(System.Xml.XmlNodeList)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub LoadCustomConfiguration (nodelist As XmlNodeList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void LoadCustomConfiguration(System::Xml::XmlNodeList ^ nodelist);" />
      <MemberSignature Language="F#" Value="abstract member LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit&#xA;override this.LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit" Usage="securityTokenHandler.LoadCustomConfiguration nodelist" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IdentityModel.Configuration.ICustomIdentityConfiguration.LoadCustomConfiguration(System.Xml.XmlNodeList)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodelist" Type="System.Xml.XmlNodeList" />
      </Parameters>
      <Docs>
        <param name="nodelist">Das Konfigurations-XML-Element. Jeder Knoten in der Liste ist vom Typ <see cref="T:System.Xml.XmlElement" />.</param>
        <summary>Lädt beim Überschreiben in einer abgeleiteten Klasse die benutzerdefinierte Konfiguration aus XML ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.LoadCustomConfiguration%2A>-Methode wird von der-Konfigurations Infrastruktur aufgerufen. Wenn diese Methode aufgerufen wird, enthält die `nodelist` die untergeordneten Elemente der obersten Ebene des [&lt;hinzufügen&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/add.md) Elements aus der Konfigurationsdatei. Diese können wiederum Attribute oder untergeordnete Elemente enthalten, je nach dem Konfigurations Schema, das Sie für die abgeleitete Klasse definieren.  
  
 Die Standard Implementierung löst eine <xref:System.NotImplementedException>aus. Überschreiben Sie diese Methode in der abgeleiteten Klasse, um die Initialisierung Ihres Sicherheitstokenhandlers aus einer Konfigurationsdatei zu aktivieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityKeyIdentifierClause ReadKeyIdentifierClause (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityKeyIdentifierClause ReadKeyIdentifierClause(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadKeyIdentifierClause(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadKeyIdentifierClause (reader As XmlReader) As SecurityKeyIdentifierClause" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ ReadKeyIdentifierClause(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadKeyIdentifierClause : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause&#xA;override this.ReadKeyIdentifierClause : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityKeyIdentifierClause" Usage="securityTokenHandler.ReadKeyIdentifierClause reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKeyIdentifierClause</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Ein XML-Reader, positioniert am XML-Startelement, das in in die Schlüsselbezeichnerklausel zu deserialisieren ist.</param>
        <summary>Deserialisiert bei Überschreibung in einer abgeleiteten Klasse das XML, auf das durch den angegebenen XML-Reader verwiesen wird, in eine Schlüsselbezeichnerklausel, die auf ein Token verweist, das von der abgeleiteten Klasse verarbeitet wird.</summary>
        <returns>Die Schlüsselbezeichnerklausel, die von der XML deserialisiert wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig löst diese Methode eine <xref:System.NotImplementedException> Ausnahme aus.  
  
 Überschreiben Sie diese Methode, um die Logik zum Deserialisieren einer Schlüsselbezeichnerklausel aus XML bereitzustellen. Wenn Sie diese Methode überschreiben, sollten Sie auch die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadKeyIdentifierClause%2A?displayProperty=nameWithType>-Methode überschreiben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Deserialisiert bei Überschreibung in einer abgeleiteten Klasse das angegebene XML in ein Token des Typs, der von der abgeleiteten Klasse verarbeitet wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (string tokenString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(string tokenString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (tokenString As String) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::String ^ tokenString);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : string -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : string -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken tokenString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokenString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tokenString">Die zu deserialisierende Zeichenfolge.</param>
        <summary>Deserialisiert bei Überschreibung in einer abgeleiteten Klasse die angegebene Zeichenfolge in ein Token des Typs, der von der abgeleiteten Klasse verarbeitet wird.</summary>
        <returns>Der Sicherheitstoken, der von der angegebenen Zeichenfolge deserialisiert wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 Standardmäßig löst diese Methode eine <xref:System.NotImplementedException> Ausnahme aus.  
  
 Überschreiben Sie diese Methode, um Funktionen bereitzustellen, die ein Sicherheits Token aus einer Zeichenfolge deserialisieren können. Wenn Sie diese Methode überschreiben, sollten Sie auch die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType>-Methode überschreiben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (reader As XmlReader) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : System.Xml.XmlReader -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Ein XML-Reader, der am Start-Element des Tokens positioniert ist.</param>
        <summary>Deserialisiert bei Überschreibung in einer abgeleiteten Klasse das XML, auf das durch den angegebenen XML-Reader verwiesen wird, in ein Token des Typs, der von der abgeleiteten Klasse verarbeitet wird.</summary>
        <returns>Das Sicherheitstoken, das aus der XML deserialisiert wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 Standardmäßig löst diese Methode eine <xref:System.NotImplementedException> Ausnahme aus.  
  
 Überschreiben Sie diese Methode, um die Logik zum Deserialisieren eines Sicherheits Tokens aus XML bereitzustellen. Wenn Sie diese Methode überschreiben, sollten Sie auch die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType>-Methode überschreiben. In der Regel wird in abgeleiteten Klassen eine <xref:System.Xml.XmlException>ausgelöst, wenn die Methode das Token nicht aus dem XML-Code deserialisieren kann, auf das verwiesen wird.  
  
   
  
## Examples  
 Der folgende Code zeigt, wie Sie die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A>-Methode überschreiben, um ein benutzerdefiniertes Token aus dem angegebenen XML-Reader zu lesen. Der Code wird aus dem `Custom Token`-Beispiel entnommen. Dieses Beispiel stellt benutzerdefinierte Klassen bereit, die die Verarbeitung von Simple Web Tokens (Swap) ermöglichen. Informationen zu diesem Beispiel und anderen Beispielen, die für WIF verfügbar sind und wo Sie heruntergeladen werden können, finden Sie unter [Beispiel Index für WIF-Code](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#7)]  
[!code-csharp[WifRcCustomToken#8](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#8)]  
[!code-csharp[WifRcCustomToken#14](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SecurityToken ReadToken (System.Xml.XmlReader reader, System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityToken ReadToken(class System.Xml.XmlReader reader, class System.IdentityModel.Selectors.SecurityTokenResolver tokenResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken(System.Xml.XmlReader,System.IdentityModel.Selectors.SecurityTokenResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToken (reader As XmlReader, tokenResolver As SecurityTokenResolver) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Tokens::SecurityToken ^ ReadToken(System::Xml::XmlReader ^ reader, System::IdentityModel::Selectors::SecurityTokenResolver ^ tokenResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken&#xA;override this.ReadToken : System.Xml.XmlReader * System.IdentityModel.Selectors.SecurityTokenResolver -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenHandler.ReadToken (reader, tokenResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="tokenResolver" Type="System.IdentityModel.Selectors.SecurityTokenResolver" />
      </Parameters>
      <Docs>
        <param name="reader">Ein XML-Reader, der am Start-Element des Tokens positioniert ist.</param>
        <param name="tokenResolver">Ein Tokenresolver, der die Out-of-Band und zwischengespeicherten Token enthält.</param>
        <summary>Deserialisiert bei Überschreibung in einer abgeleiteten Klasse das XML, auf das durch den angegebenen XML-Reader verwiesen wird, in ein Token des Typs, der von dieser Klasse unter Verwendung des angegebenen Tokenresolvers verarbeitet wird.</summary>
        <returns>Das Sicherheitstoken, das aus der XML deserialisiert wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-method-note](~/includes/untrusted-data-method-note.md)]
  
 Die Standard Implementierung ignoriert den `tokenResolver`-Parameter und delegiert den Aufrufen an die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ReadToken%2A?displayProperty=nameWithType>-Methode.  
  
 Überschreiben Sie diese Methode, um die Logik zum Deserialisieren eines Sicherheits Tokens aus XML bereitzustellen. Wenn Sie diese Methode überschreiben, sollten Sie auch die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanReadToken%2A?displayProperty=nameWithType>-Methode überschreiben. In der Regel wird in abgeleiteten Klassen eine <xref:System.Xml.XmlException>ausgelöst, wenn die Methode das Token nicht aus dem XML-Code deserialisieren kann, auf das verwiesen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenType">
      <MemberSignature Language="C#" Value="public abstract Type TokenType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TokenType" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property TokenType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ TokenType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenType : Type" Usage="System.IdentityModel.Tokens.SecurityTokenHandler.TokenType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft bei Überschreibung in einer abgeleiteten Klasse den Typ des Sicherheitstoken ab, der von dieser Instanz verarbeitetet wird.</summary>
        <value>Der Typ des Sicherheitstoken, das von dieser Instanz verarbeitet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie müssen diese Eigenschaft in abgeleiteten Klassen überschreiben und die <xref:System.Type> des Sicherheits Tokens (<xref:System.IdentityModel.Tokens.SecurityToken>) zurückgeben, das von der abgeleiteten Klasse verarbeitet wird.  
  
   
  
## Examples  
 Der folgende Code zeigt, wie Sie die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.TokenType%2A>-Eigenschaft überschreiben, um die <xref:System.Type> der Sicherheits Token zurückzugeben, die von einem benutzerdefinierten Handler verarbeitet werden. Der Code wird aus dem `Custom Token`-Beispiel entnommen. Dieses Beispiel stellt benutzerdefinierte Klassen bereit, die die Verarbeitung von Simple Web Tokens (Swap) ermöglichen. Informationen zu diesem Beispiel und anderen Beispielen, die für WIF verfügbar sind und wo Sie heruntergeladen werden können, finden Sie unter [Beispiel Index für WIF-Code](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#18](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceTokenValidationFailure">
      <MemberSignature Language="C#" Value="protected void TraceTokenValidationFailure (System.IdentityModel.Tokens.SecurityToken token, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void TraceTokenValidationFailure(class System.IdentityModel.Tokens.SecurityToken token, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.TraceTokenValidationFailure(System.IdentityModel.Tokens.SecurityToken,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub TraceTokenValidationFailure (token As SecurityToken, errorMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void TraceTokenValidationFailure(System::IdentityModel::Tokens::SecurityToken ^ token, System::String ^ errorMessage);" />
      <MemberSignature Language="F#" Value="member this.TraceTokenValidationFailure : System.IdentityModel.Tokens.SecurityToken * string -&gt; unit" Usage="securityTokenHandler.TraceTokenValidationFailure (token, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="token">Das Sicherheitstoken, das überprüft wird.</param>
        <param name="errorMessage">Die in die Ablaufverfolgung zu schreibende Meldung.</param>
        <summary>Verfolgt das Fehlerereignis während der Validierung von Sicherheitstoken, wenn die Ablaufverfolgung aktiviert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte von der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A>-Methode aufgerufen werden, wenn die Validierung des Tokens fehlschlägt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceTokenValidationSuccess">
      <MemberSignature Language="C#" Value="protected void TraceTokenValidationSuccess (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void TraceTokenValidationSuccess(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.TraceTokenValidationSuccess(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub TraceTokenValidationSuccess (token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void TraceTokenValidationSuccess(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="member this.TraceTokenValidationSuccess : System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.TraceTokenValidationSuccess token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Das Token, das überprüft wurde.</param>
        <summary>Verfolgt die erfolgreiche Validierung des Sicherheitstokenereignisses, wenn die Ablaufverfolgung aktiviert ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte von der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A>-Methode aufgerufen werden, nachdem das Token erfolgreich überprüft wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateToken">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ValidateToken (token As SecurityToken) As ReadOnlyCollection(Of ClaimsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;&#xA;override this.ValidateToken : System.IdentityModel.Tokens.SecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;" Usage="securityTokenHandler.ValidateToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Das zu validierende Token.</param>
        <summary>Validiert beim Überschreiben in einer abgeleiteten Klasse das angegebene Sicherheitstoken. Das Token muss von dem von der abgeleiteten Klasse verarbeiteten Typ sein.</summary>
        <returns>Die Identitäten im Token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig löst diese Methode eine <xref:System.NotImplementedException> Ausnahme aus.  
  
 Die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A>-Methode wird von der-Infrastruktur aufgerufen, um die Ansprüche aus dem deserialisierten Sicherheits Token zu validieren und zu extrahieren. Diese Ansprüche werden in der Auflistung von <xref:System.Security.Claims.ClaimsIdentity>-Objekten zurückgegeben, die von der-Methode zurückgegeben werden. Im Normalfall enthält diese Sammlung eine einzige Identität.  
  
 In abgeleiteten Klassen umfasst die Validierung in der Regel das Überprüfen der im Token angegebenen Zielgruppe mit den Zielgruppen-URIs, die in der <xref:System.IdentityModel.Tokens.SecurityTokenHandlerConfiguration.AudienceRestriction%2A?displayProperty=nameWithType>-Eigenschaft des tokenhandlerkonfigurationsobjekt angegeben sind, das in der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A> Diese URIs werden in der Regel in der Konfigurationsdatei unter dem [&lt;audienceUris&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/audienceuris.md) -Element festgelegt. Wenn die Zielgruppe nicht überprüft werden kann, sollte eine <xref:System.IdentityModel.Tokens.AudienceUriValidationFailedException> Ausnahme ausgelöst werden.  
  
 Bei der Verarbeitung des Tokens wird der Aussteller normalerweise durch Übergeben des Aussteller Tokens an eine der <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> Methoden für das <xref:System.IdentityModel.Tokens.IssuerNameRegistry> Objekt überprüft, das über die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.Configuration%2A>-Eigenschaft für den Handler konfiguriert wurde. Die Aussteller Namen Registrierung wird in der Regel über das [&lt;issuerNameRegistry&gt;](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/issuernameregistry.md) -Element in der Konfigurationsdatei konfiguriert. Der <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> gibt den Namen des Ausstellers zurück. Dieser Name sollte verwendet werden, um die <xref:System.Security.Claims.Claim.Issuer%2A?displayProperty=nameWithType>-Eigenschaft in Ansprüchen festzulegen, die im Token enthalten sind. Wenn die Aussteller Namen Registrierung keinen Eintrag für das Aussteller Token enthält, gibt <xref:System.IdentityModel.Tokens.IssuerNameRegistry.GetIssuerName%2A> `null`zurück. In diesem Fall wird eine <xref:System.IdentityModel.Tokens.SecurityTokenException> in der Regel in abgeleiteten Klassen ausgelöst, aber dieses Verhalten ist der Designer der Klasse.  
  
   
  
## Examples  
 Der folgende Code zeigt eine außer Kraft setzung der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A>-Methode für einen Sicherheitstokenhandler, der einfache webtoken verarbeitet. Der Code wird aus dem `CustomToken`-Beispiel entnommen. Informationen zu diesem Beispiel und anderen Beispielen, die für WIF verfügbar sind und wo Sie heruntergeladen werden können, finden Sie unter [Beispiel Index für WIF-Code](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#9](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#9)]  
  
 Der folgende Code zeigt `CreateClaims` Methode, die im vorherigen Beispiel von der Überschreibung der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A>-Methode aufgerufen wird. Diese Methode gibt ein <xref:System.Security.Claims.ClaimsIdentity> Objekt zurück, das aus den Ansprüchen im Token erstellt wird. Der Code wird aus dem `CustomToken`-Beispiel entnommen. Informationen zu diesem Beispiel und anderen Beispielen, die für WIF verfügbar sind und wo Sie heruntergeladen werden können, finden Sie unter [Beispiel Index für WIF-Code](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#15](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#15)]  
  
 Der folgende Code zeigt `ValidateSignature` Methode, die von der Überschreibung der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A>-Methode im einfachen webtokenhandler aufgerufen wird. Diese Methode überprüft die Signatur auf dem Token mithilfe der konfigurierten <xref:System.IdentityModel.Tokens.IssuerTokenResolver>. Der Code wird aus dem `CustomToken`-Beispiel entnommen. Informationen zu diesem Beispiel und anderen Beispielen, die für WIF verfügbar sind und wo Sie heruntergeladen werden können, finden Sie unter [Beispiel Index für WIF-Code](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#12](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#12)]  
[!code-csharp[WifRcCustomToken#11](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#11)]  
  
 Der folgende Code zeigt `ValidateAudience` Methode, die von der Überschreibung der <xref:System.IdentityModel.Tokens.SecurityTokenHandler.ValidateToken%2A>-Methode im einfachen webtokenhandler aufgerufen wird. Diese Methode überprüft die Zielgruppe, die im Token enthalten ist, gegen die Zielgruppen-URIs, die in der Konfiguration angegeben wurden. Der Code wird aus dem `CustomToken`-Beispiel entnommen. Informationen zu diesem Beispiel und anderen Beispielen, die für WIF verfügbar sind und wo Sie heruntergeladen werden können, finden Sie unter [Beispiel Index für WIF-Code](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#13](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteKeyIdentifierClause">
      <MemberSignature Language="C#" Value="public virtual void WriteKeyIdentifierClause (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteKeyIdentifierClause(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityKeyIdentifierClause securityKeyIdentifierClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteKeyIdentifierClause(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteKeyIdentifierClause (writer As XmlWriter, securityKeyIdentifierClause As SecurityKeyIdentifierClause)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteKeyIdentifierClause(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ securityKeyIdentifierClause);" />
      <MemberSignature Language="F#" Value="abstract member WriteKeyIdentifierClause : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; unit&#xA;override this.WriteKeyIdentifierClause : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; unit" Usage="securityTokenHandler.WriteKeyIdentifierClause (writer, securityKeyIdentifierClause)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="securityKeyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="writer">Der XML-Writer.</param>
        <param name="securityKeyIdentifierClause">Die zu serialisierende Schlüsselbezeichnerklausel.</param>
        <summary>Serialisiert beim Überschreiben in einer abgeleiteten Klasse die angegebene Schlüsselbezeichnerklausel in XML. Die Schlüsselbezeichnerklausel muss einen Typ besitzen, der von der abgeleiteten Klasse unterstützt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig löst diese Methode eine <xref:System.NotImplementedException> Ausnahme aus.  
  
 Überschreiben Sie diese Methode, um die Logik zum Serialisieren einer Schlüsselbezeichnerklausel in XML bereitzustellen. Wenn Sie diese Methode überschreiben, sollten Sie auch die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteKeyIdentifierClause%2A>-Methode überschreiben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Serialisiert bei Überschreibung in einer abgeleiteten Klasse das angegebene Sicherheitstoken. Das Token muss von dem von der abgeleiteten Klasse verarbeiteten Typ sein.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual string WriteToken (System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string WriteToken(class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken(System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteToken (token As SecurityToken) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ WriteToken(System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member WriteToken : System.IdentityModel.Tokens.SecurityToken -&gt; string&#xA;override this.WriteToken : System.IdentityModel.Tokens.SecurityToken -&gt; string" Usage="securityTokenHandler.WriteToken token" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="token">Das zu serialisierende Token</param>
        <summary>Serialisiert bei Überschreibung in einer abgeleiteten Klasse das angegebene Sicherheitstoken in eine Zeichenfolge. Das Token muss von dem von der abgeleiteten Klasse verarbeiteten Typ sein.</summary>
        <returns>Der serialisierte Token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig löst diese Methode eine <xref:System.NotImplementedException> Ausnahme aus.  
  
 Überschreiben Sie diese Methode, um die Logik zum Serialisieren eines Sicherheits Tokens in XML bereitzustellen. Wenn Sie diese Methode überschreiben, sollten Sie auch die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A>-Eigenschaft überschreiben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteToken">
      <MemberSignature Language="C#" Value="public virtual void WriteToken (System.Xml.XmlWriter writer, System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteToken(class System.Xml.XmlWriter writer, class System.IdentityModel.Tokens.SecurityToken token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken(System.Xml.XmlWriter,System.IdentityModel.Tokens.SecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub WriteToken (writer As XmlWriter, token As SecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteToken(System::Xml::XmlWriter ^ writer, System::IdentityModel::Tokens::SecurityToken ^ token);" />
      <MemberSignature Language="F#" Value="abstract member WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit&#xA;override this.WriteToken : System.Xml.XmlWriter * System.IdentityModel.Tokens.SecurityToken -&gt; unit" Usage="securityTokenHandler.WriteToken (writer, token)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" />
      </Parameters>
      <Docs>
        <param name="writer">Der XML-Writer.</param>
        <param name="token">Das zu serialisierende Token</param>
        <summary>Serialisiert beim Überschreiben in einer abgeleiteten Klasse das angegebene Sicherheitstoken in XML. Das Token muss von dem von der abgeleiteten Klasse verarbeiteten Typ sein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig löst diese Methode eine <xref:System.NotImplementedException> Ausnahme aus.  
  
 Überschreiben Sie diese Methode, um die Logik zum Serialisieren eines Sicherheits Tokens in XML bereitzustellen. Wenn Sie diese Methode überschreiben, sollten Sie auch die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.CanWriteToken%2A>-Eigenschaft überschreiben.  
  
   
  
## Examples  
 Der folgende Code zeigt, wie Sie die <xref:System.IdentityModel.Tokens.SecurityTokenHandler.WriteToken%2A>-Methode überschreiben, um ein benutzerdefiniertes Token zu serialisieren. Der Code wird aus dem `Custom Token`-Beispiel entnommen. Dieses Beispiel stellt benutzerdefinierte Klassen bereit, die die Verarbeitung von Simple Web Tokens (Swap) ermöglichen. Informationen zu diesem Beispiel und anderen Beispielen, die für WIF verfügbar sind und wo Sie heruntergeladen werden können, finden Sie unter [Beispiel Index für WIF-Code](~/docs/framework/security/wif-code-sample-index.md).  
  
 [!code-csharp[WifRcCustomToken#10](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#10)]  
[!code-csharp[WifRcCustomToken#11](~/samples/snippets/csharp/VS_Snippets_Misc/wifrccustomtoken/cs/simplewebtoken/simplewebtokenhandler.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
