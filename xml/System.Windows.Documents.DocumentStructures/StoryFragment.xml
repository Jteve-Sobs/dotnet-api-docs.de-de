<Type Name="StoryFragment" FullName="System.Windows.Documents.DocumentStructures.StoryFragment">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c07ce239f829a4284d9ac8435e6c3247d7b18e65" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31911479" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class StoryFragment : System.Collections.Generic.IEnumerable&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt;, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit StoryFragment extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Documents.DocumentStructures.BlockElement&gt;, class System.Collections.IEnumerable, class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.DocumentStructures.StoryFragment" />
  <TypeSignature Language="VB.NET" Value="Public Class StoryFragment&#xA;Implements IAddChild, IEnumerable(Of BlockElement)" />
  <TypeSignature Language="C++ CLI" Value="public ref class StoryFragment : System::Collections::Generic::IEnumerable&lt;System::Windows::Documents::DocumentStructures::BlockElement ^&gt;, System::Windows::Markup::IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("BlockElementList")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt den gesamten oder einen Teil eines Textabschnitts in einem XPS-Dokument dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein XPS-Textabschnitt in einem [!INCLUDE[TLA2#tla_xps](~/includes/tla2sharptla-xps-md.md)] Dokument entspricht im Wesentlichen auf eine Story in Zeitungen und Zeitschriften. Es ist eine Passage Text und Grafiken, in der Regel auf ein Thema innerhalb einer einzelnen [!INCLUDE[TLA2#tla_xps](~/includes/tla2sharptla-xps-md.md)] Dokument. In der Regel sich auf mehrere Seiten erstreckt, aber es kann kürzer als eine Seite ähnelt einer Randleiste – geschachtelte Story – in einem Magazin. Eine Story kann auch wie eine Zeitung nicht zusammenhängend sein, die auf der Seite 4 fortgesetzt wird. Folglich kann eine gegebenen Seite mehr als eine Story "und" Teile von mehr als eine Story haben. Eine Kopf- oder Fußzeile ist auch eine besondere Art von Story, die vollständig auf einer einzigen Seite enthalten ist.  
  
 Ein <xref:System.Windows.Documents.DocumentStructures.StoryFragment> stellt alle oder einen Teil einer Story. Zudem können Sie niemals über mehrere Seiten umfassen, jedoch kann die gesamte Seite belegen oder Freigeben eine Seite mit anderen Teilen. Wenn eine Story auf mehr als eine Seite ist, ist jeder Teil auf jeder Seite ein eigenes Fragment an. Obwohl Storys unterbrochenen Sätze von Fragmente enthalten können, kann kein Fragment selbst nicht zusammenhängend sein.  
  
 Nur eine <xref:System.Windows.Documents.DocumentStructures.StoryFragments> Element kann ein übergeordnetes Element einer <xref:System.Windows.Documents.DocumentStructures.StoryFragment>.  Der Speicherort des der <xref:System.Windows.Documents.DocumentStructures.StoryBreak> Elemente innerhalb einer <xref:System.Windows.Documents.DocumentStructures.StoryFragment> gibt an, ob der Textabschnitt in mehreren Fragmenten enthalten ist und wenn zusätzliche Fragmente entweder vor oder nach der aktuellen Fragment.  
  
 Wenn eine <xref:System.Windows.Documents.DocumentStructures.StoryFragment> endet in der Mitte einige strukturelles Element; Say eine `<TableRowGroupStructure>`, klicken Sie dann [!INCLUDE[TLA2#tla_xps](~/includes/tla2sharptla-xps-md.md)] Dokument erzeugen Anwendungen müssen eine entsprechende Endtag für das Element eingefügt (in diesem Fall `</TableRowGroupStructure>`) vor der `</StoryFragment>` tag, selbst Allerdings wird die Struktur in einem späteren Fragment fortgesetzt. (Dies ist erforderlich, um sicherzustellen, dass die Elementstruktur innerhalb der <xref:System.Windows.Documents.DocumentStructures.StoryFragment> gültiger XML-Code ist.) Das Fragment, das die Story weiterhin muss mit der ein öffnendes-Tag für die unterbrochene Struktur beginnen. Die gesamte Struktur der unterbrochenen Strukturen muss die gleiche Weise (mit einer Ausnahme wie unten erläutert) behandelt: Endtags müssen für jede nicht übereinstimmende Starttag über den Zeitpunkt der Unterbrechung hinzugefügt werden.  
  
 Die Ausnahme gilt, wenn unmittelbar nach die Story Unterbrechung kommt eine `</TableCellStructure>` tag, und klicken Sie dann die Anwendung auf eine leere Zelle Tabellenstruktur einfügen muss (`<TableCellStructure></TableCellStructure>`) am entsprechenden Punkt in das Fragment, das den Textabschnitt fortgesetzt wird. Dies ist erforderlich, sodass fungierende Anwendungen, die zum Zusammenführen einer bestimmten Story alle Fragmente müssen einen einfachen Algorithmus zu diesem Zweck verwenden können.  
  
 Angenommen, möchte, dass eine Anwendung die folgenden Material, das Hinzufügen einer [!INCLUDE[TLA2#tla_xps](~/includes/tla2sharptla-xps-md.md)] Dokument:  
  
```  
<SectionStructure>  
   <TableStructure>  
      <TableRowGroupStructure>  
         <TableRowStructure>  
            <TableCellStructure>  
               <ParagraphStructure>  
                  <NamedElement NameReference="SomeContent" />  
               </ParagraphStructure>  
            </TableCellStructure>  
            <TableCellStructure>  
               <ParagraphStructure>  
                  <NamedElement NameReference="MoreContent" />  
               </ParagraphStructure>  
            </TableCellStructure>  
         </TableRowStructure>  
         <TableRowStructure>  
            <TableCellStructure>  
               <ParagraphStructure>  
                  <NamedElement NameReference="EvenMoreContent" />  
               </ParagraphStructure>  
            </TableCellStructure>  
            <TableCellStructure>  
               <ParagraphStructure>  
                  <NamedElement NameReference="LastContent" />  
               </ParagraphStructure>  
            </TableCellStructure>  
         </TableRowStructure>  
      </TableRowGroupStructure>  
   </TableStructure>  
</SectionStructure>  
```  
  
 Wenn ein Seitenumbruch Ende dem Fragment erzwungen wird direkt nach der `</TableCellStructure>` für "SomeContent", muss die Anwendung die Teilung erstellen, wie im folgenden Beispiel gezeigt:  
  
```  
<StoryFragment StoryName="MyStory" FragmentType="Content">  
 <SectionStructure>  
    <TableStructure>  
       <TableRowGroupStructure>  
          <TableRowStructure>  
             <TableCellStructure>  
                <ParagraphStructure>  
                   <NamedElement NameReference="SomeContent" />  
                </ParagraphStructure>   
             </TableCellStructure>  
<!-- lines from here to end of fragment added by producer-->  
          </TableRowStructure>  
       </TableRowGroupStructure>  
    </TableStructure>  
 </SectionStructure>  
</StoryFragment>  
  
<StoryFragment StoryName="MyStory" FragmentType="Content">  
 <SectionStructure>  
    <TableStructure>  
       <TableRowGroupStructure>  
          <TableRowStructure>  
             <TableCellStructure>   
              <!-- extra cell added by producer-->  
             </TableCellStructure>  
<!-- lines from here to start of fragment added by producer-->  
             <TableCellStructure>  
                <ParagraphStructure>  
                   <NamedElement NameReference="MoreContent" />  
                </ParagraphStructure>  
             </TableCellStructure>  
          </TableRowStructure>  
          <TableRowStructure>  
             <TableCellStructure>  
                <ParagraphStructure>  
                   <NamedElement NameReference="EvenMoreContent" />  
                </ParagraphStructure>  
             </TableCellStructure>  
             <TableCellStructure>  
                <ParagraphStructure>  
                   <NamedElement NameReference="LastContent" />  
                </ParagraphStructure>  
             </TableCellStructure>  
          </TableRowStructure>  
       </TableRowGroupStructure>  
    </TableStructure>  
 </SectionStructure>  
</StoryFragment>  
```  
  
 Eine Anwendung, die das Dokument liest müssen möglicherweise diesen Inhalt zusammenführen. Betrachten Sie z. B. mit einen XPS-Viewer eine **gesamten Story Zwischenablage kopieren** Schaltfläche; oder ein **XPS für Blinde** Anwendung, die Storys an eine Stimme Synthesizer übergeben.  Einige Anwendungen, die das Dokument lesen müssen möglicherweise eine Teilmenge der Fragmente einer Story zusammenführen. Angenommen, ein Feature, das ein ganzer Absatz in die Zwischenablage kopiert werden, durch Triple-klicken müssen immer dann eine Zusammenführung ausführen, wenn der Absatz einen Seitenumbruch erstreckt, da dieser Absatz zwischen zwei aufgeteilt würde <xref:System.Windows.Documents.DocumentStructures.StoryFragment>s.  
  
 **Zusammenführen dieser Algorithmus verwendet:**  
  
1.  Löschen der `</StoryFragment>` am Ende das erste Fragment zusammengeführt werden, und löschen die `<StoryFragment>` vom Anfang des zweiten.  
  
2.  Wenn das letzte Endtag des ersten Fragments desselben Typs wie das erste Starttag des zweiten Fragments ist (und nicht `<NamedElement>` Tags), müssen sie beide löschen.  
  
3.  Wiederholen Sie Schritt 2, bis in beiden Fragmenten sind *entweder* dieser Zustände:  
  
    -   Es ist nicht mehr das letzte Endtag des vorhergehenden Fragments das erste Starttag des folgenden Fragments Typ übereinstimmen.  
  
    -   Das letzte Endtag der führenden fragment das erste Starttag des folgenden Fragments befinden sich beide `<NamedElement>` Tags.  
  
 Im obigen Beispiel, wenn die leere Zelle nicht von der Anwendung hinzugefügt wurde würde dann eine Zusammenführung der Fragmente erzeugen Sie eine Tabelle, deren erste Zeile nur eine Zelle, die zuerst enthält die Verweise "SomeContent" und "MoreContent" statt der ursprünglichen hatte Zeile mit zwei Zellen mit jeweils einem einzelnen Verweis auf  
  
 Bei den gesamte Story zusammengeführt wird, sollte der Algorithmus für jedes nachfolgende Fragment wiederholt werden, die Teil der gleichen Story. Die Fragmente auf eine Story werden indiziert, der `<Story>` Element. Finden Sie im Abschnitt 9.1.15 der [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] -Spezifikation, die Sie am erhalten [XPS: Specification and License Downloads](http://www.microsoft.com/whdc/xps/downloads.mspx). Das letzte Fragment einer bestimmten Story müssen eine <xref:System.Windows.Documents.DocumentStructures.StoryBreak> als letztes untergeordnetes Element.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die `<StoryFragment>` Teil einer [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] Dokument.  
  
 [!code-xaml[DocumentStructure#DocStructStoryFragContent1](~/samples/snippets/csharp/VS_Snippets_Wpf/DocumentStructure/CSharp/Content/FixedPage1_structure.xaml#docstructstoryfragcontent1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.DocumentStructures.StoryBreak" />
    <altmember cref="T:System.Windows.Documents.DocumentStructures.StoryFragments" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StoryFragment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.DocumentStructures.StoryFragment.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StoryFragment();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Documents.DocumentStructures.StoryFragment" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.Windows.Documents.DocumentStructures.BlockElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class System.Windows.Documents.DocumentStructures.BlockElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.DocumentStructures.StoryFragment.Add(System.Windows.Documents.DocumentStructures.BlockElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (element As BlockElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Windows::Documents::DocumentStructures::BlockElement ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.Documents.DocumentStructures.BlockElement" />
      </Parameters>
      <Docs>
        <param name="element">Der hinzuzufügende Block.</param>
        <summary>Fügt dem Textabschnittsfragment einen Block hinzu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der übergebene Block ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FragmentName">
      <MemberSignature Language="C#" Value="public string FragmentName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FragmentName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.DocumentStructures.StoryFragment.FragmentName" />
      <MemberSignature Language="VB.NET" Value="Public Property FragmentName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FragmentName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Textabschnittsfragments ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.String" />, der den Namen dieses Fragments darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu der `FragmentName` Attribut des der `</StoryFragment>` Teil ein [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] dokumentieren, finden Sie in Kapitel 9 von der [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] -Spezifikation, die Sie an abrufen können [XPS: Specification and License Downloads](http://www.microsoft.com/whdc/xps/downloads.mspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.DocumentStructures.StoryFragment.FragmentType" />
        <altmember cref="P:System.Windows.Documents.DocumentStructures.StoryFragment.StoryName" />
      </Docs>
    </Member>
    <Member MemberName="FragmentType">
      <MemberSignature Language="C#" Value="public string FragmentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FragmentType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.DocumentStructures.StoryFragment.FragmentType" />
      <MemberSignature Language="VB.NET" Value="Public Property FragmentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FragmentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des Fragments ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.String" />, der den Typ des Fragments darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mögliche Werte sind "Header", "Footer" und "Content".  
  
 Weitere Informationen zu der `FragmentType` Attribut des der `</StoryFragment>` Teil ein [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] dokumentieren, finden Sie in Kapitel 9 von der [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] -Spezifikation, die Sie an abrufen können [XPS: Specification and License Downloads](http://www.microsoft.com/whdc/xps/downloads.mspx).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die `FragmentType` Attribut von der `<StoryFragment>` Teil einer [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] Dokument.  
  
 [!code-xaml[DocumentStructure#DocStructStoryFragContent1](~/samples/snippets/csharp/VS_Snippets_Wpf/DocumentStructure/CSharp/Content/FixedPage1_structure.xaml#docstructstoryfragcontent1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.DocumentStructures.StoryFragment.FragmentName" />
      </Docs>
    </Member>
    <Member MemberName="StoryName">
      <MemberSignature Language="C#" Value="public string StoryName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StoryName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.DocumentStructures.StoryFragment.StoryName" />
      <MemberSignature Language="VB.NET" Value="Public Property StoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StoryName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Textabschnitts ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.String" />, der den Namen des aktuellen Textabschnitts darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Fragmente einer bestimmten Story müssen den gleichen Wert für diese Eigenschaft aufweisen. Mit übereinstimmen muss die `StoryName` Attribut von der `<Story>` Element. Finden Sie im Abschnitt 9.1.15 der [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] -Spezifikation, die Sie am erhalten [XPS: Specification and License Downloads](http://www.microsoft.com/whdc/xps/downloads.mspx).  
  
 Diese Eigenschaft kann nicht angegeben werden, wenn <xref:System.Windows.Documents.DocumentStructures.StoryFragment.FragmentType%2A> Kopf- oder Fußzeile handelt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die `StoryName` Attribut von der `<StoryFragment>` Teil einer [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] Dokument.  
  
 [!code-xaml[DocumentStructure#DocStructStoryFragContent1](~/samples/snippets/csharp/VS_Snippets_Wpf/DocumentStructure/CSharp/Content/FixedPage1_structure.xaml#docstructstoryfragcontent1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.DocumentStructures.StoryFragment.FragmentName" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt; IEnumerable&lt;BlockElement&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;class System.Windows.Documents.DocumentStructures.BlockElement&gt; System.Collections.Generic.IEnumerable&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.DocumentStructures.StoryFragment.System#Collections#Generic#IEnumerable&lt;System#Windows#Documents#DocumentStructures#BlockElement&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of BlockElement) Implements IEnumerable(Of BlockElement).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Windows::Documents::DocumentStructures::BlockElement ^&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Windows::Documents::DocumentStructures::BlockElement ^&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Diese Methode wurde nicht implementiert.</summary>
        <returns>Löst immer <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.DocumentStructures.StoryFragment.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Diese Methode wurde nicht implementiert.</summary>
        <returns>Löst immer <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.DocumentStructures.StoryFragment.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das hinzugefügte untergeordnete <see cref="T:System.Object" />.</param>
        <summary>Dieser Member unterstützt die .NET Framework-Infrastruktur und ist nicht für die direkte Verwendung in Code vorgesehen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fügt dem <xref:System.Windows.Documents.DocumentStructures.StoryFragment>-Objekt ein untergeordnetes Objekt hinzu.  
  
 Es muss mindestens ein untergeordnetes Element eines der <xref:System.Windows.Documents.DocumentStructures.StoryFragment> und die untergeordneten Elemente können nur dieser Typen sein: <xref:System.Windows.Documents.DocumentStructures.ParagraphStructure>, <xref:System.Windows.Documents.DocumentStructures.FigureStructure>, <xref:System.Windows.Documents.DocumentStructures.ListStructure>, <xref:System.Windows.Documents.DocumentStructures.TableStructure>, <xref:System.Windows.Documents.DocumentStructures.SectionStructure>, und <xref:System.Windows.Documents.DocumentStructures.StoryBreak>.  
  
 Ein <xref:System.Windows.Documents.DocumentStructures.StoryBreak> kann nur das erste oder letzte untergeordnete Element von einem <xref:System.Windows.Documents.DocumentStructures.StoryFragment>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> ist kein Typ, der als untergeordnetes Element dieser Klasse fungieren kann. Siehe **Hinweise**.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.DocumentStructures.StoryFragment.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Der dem Objekt hinzuzufügende Text.</param>
        <summary>Fügt dem Objekt den Textinhalt eines Knotens hinzu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>