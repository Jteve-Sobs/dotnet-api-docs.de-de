<Type Name="BufferManager" FullName="System.ServiceModel.Channels.BufferManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e09f1cae75665c715eef7faac732b3fa0ddd6374" /><Meta Name="ms.sourcegitcommit" Value="7461f9e28c2f184bd1596e6f07c25a3f34984516" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/28/2019" /><Meta Name="ms.locfileid" Value="58548379" /></Metadata><TypeSignature Language="C#" Value="public abstract class BufferManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit BufferManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.BufferManager" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class BufferManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class BufferManager abstract" />
  <TypeSignature Language="F#" Value="type BufferManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.5.0.1</AssemblyVersion>
    <AssemblyVersion>4.5.0.3</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Viele WCF-Features erfordern die Verwendung von Puffern, deren Erstellung und Löschung kostenaufwändig ist. Mit der <see cref="T:System.ServiceModel.Channels.BufferManager" />-Klasse können Sie einen Pufferpool verwalten. Der Pool und die zugehörigen Puffer werden beim Instanziieren dieser Klasse erstellt und nach der Freigabe von der Garbage Collection wieder zerstört. Wenn Sie einen Puffer verwenden möchten, können Sie einen aus dem Pool nehmen und nach Abschluss der Arbeit wieder im Pool ablegen. Dieser Vorgang ist wesentlich schneller, als jedes Mal, wenn Sie einen Puffer benötigen, eine neuen zu erstellen und wieder zu zerstören.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse wird im Allgemeinen verwendet, während Sie benutzerdefinierte Encoder oder benutzerdefinierte Transportkanäle implementieren.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected BufferManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.BufferManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; BufferManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ServiceModel.Channels.BufferManager" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da dieser Konstruktor `protected` ist, können Sie ihn nur von einer abgeleiteten Klasse aufrufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public abstract void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.BufferManager.Clear" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit" Usage="bufferManager.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die derzeit im Manager zwischengespeicherten Puffer frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateBufferManager">
      <MemberSignature Language="C#" Value="public static System.ServiceModel.Channels.BufferManager CreateBufferManager (long maxBufferPoolSize, int maxBufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.ServiceModel.Channels.BufferManager CreateBufferManager(int64 maxBufferPoolSize, int32 maxBufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.BufferManager.CreateBufferManager(System.Int64,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateBufferManager (maxBufferPoolSize As Long, maxBufferSize As Integer) As BufferManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::ServiceModel::Channels::BufferManager ^ CreateBufferManager(long maxBufferPoolSize, int maxBufferSize);" />
      <MemberSignature Language="F#" Value="static member CreateBufferManager : int64 * int -&gt; System.ServiceModel.Channels.BufferManager" Usage="System.ServiceModel.Channels.BufferManager.CreateBufferManager (maxBufferPoolSize, maxBufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BufferManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxBufferPoolSize" Type="System.Int64" />
        <Parameter Name="maxBufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxBufferPoolSize">Die maximale Größe des Pools.</param>
        <param name="maxBufferSize">Die maximale Größe eines einzelnen Puffers.</param>
        <summary>Erstellt einen neuen Puffermanager mit einer angegebenen maximalen Pufferpoolgröße und einer maximalen Größe für jeden einzelnen Puffer im Pool</summary>
        <returns>Gibt ein <see cref="T:System.ServiceModel.Channels.BufferManager" />-Objekt mit den angegebenen Parametern zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode können Sie einen neuen Pufferpool mit so vielen Puffern, wie erstellt werden können, erstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InsufficientMemoryException"><block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.OutOfMemoryException" /> ab.  
  
</para>
          </block>  
  
 Der Arbeitsspeicher reichte nicht aus, um den angeforderten Pufferpool zu erstellen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxBufferPoolSize" /> oder <paramref name="maxBufferSize" /> war kleiner als 0 (Null).</exception>
      </Docs>
    </Member>
    <Member MemberName="ReturnBuffer">
      <MemberSignature Language="C#" Value="public abstract void ReturnBuffer (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReturnBuffer(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.BufferManager.ReturnBuffer(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ReturnBuffer (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ReturnBuffer(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member ReturnBuffer : byte[] -&gt; unit" Usage="bufferManager.ReturnBuffer buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Verweis auf den Puffer, der zurückgegeben wird.</param>
        <summary>Gibt einen Puffer an den Pool zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Puffer wird an den Pool zurückgegeben und steht für eine erneute Verwendung zur Verfügung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" />-Verweis darf nicht <see langword="null" /> sein.</exception>
        <exception cref="T:System.ArgumentException">Die Länge des <paramref name="buffer" /> entspricht nicht der Pufferlängeneigenschaft des Pools.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeBuffer">
      <MemberSignature Language="C#" Value="public abstract byte[] TakeBuffer (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] TakeBuffer(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.BufferManager.TakeBuffer(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function TakeBuffer (bufferSize As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Byte&gt; ^ TakeBuffer(int bufferSize);" />
      <MemberSignature Language="F#" Value="abstract member TakeBuffer : int -&gt; byte[]" Usage="bufferManager.TakeBuffer bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.5.0.1</AssemblyVersion>
        <AssemblyVersion>4.5.0.3</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Die Größe des angeforderten Puffers in Byte.</param>
        <summary>Ruft einen Puffer mit mindestens der angegebenen Größe aus dem Pool ab.</summary>
        <returns>Ein Bytearray, das der angeforderten Größe des Puffers entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Falls erfolgreich, gibt das System einen Bytearray-Puffer mit mindestens der angeforderten Größe zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> darf nicht kleiner 0 (null) sein.</exception>
      </Docs>
    </Member>
  </Members>
</Type>