<Type Name="RuntimeHelpers" FullName="System.Runtime.CompilerServices.RuntimeHelpers">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8fd95580fa170a4f0ed0633871193981360115d3" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49132940" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class RuntimeHelpers" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit RuntimeHelpers extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.RuntimeHelpers" />
  <TypeSignature Language="VB.NET" Value="Public Class RuntimeHelpers" />
  <TypeSignature Language="C++ CLI" Value="public ref class RuntimeHelpers abstract sealed" />
  <TypeSignature Language="F#" Value="type RuntimeHelpers = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="253e3-101">Stellt einen Satz statischer Methoden und Eigenschaften zur Compiler-Unterstützung bereit.</span>
      <span class="sxs-lookup">
        <span data-stu-id="253e3-101">Provides a set of static methods and properties that provide support for compilers.</span>
      </span>
      <span data-ttu-id="253e3-102">Diese Klasse kann nicht vererbt werden.</span>
      <span class="sxs-lookup">
        <span data-stu-id="253e3-102">This class cannot be inherited.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="253e3-103">Im folgenden Beispiel wird gezeigt, wie zum zuverlässig Handles mit dem <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="253e3-103">The following example shows how to reliably set handles by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method.</span></span> <span data-ttu-id="253e3-104">Um ein Handle für ein angegebenes bereits vorhandene Handle zuverlässig zu festzulegen, Sie müssen sicherstellen, dass die Zuordnung von das systemeigene Handle und die nachfolgenden Aufzeichnung dieses Handle in einen <xref:System.Runtime.InteropServices.SafeHandle> -Objekt atomar ist.</span><span class="sxs-lookup"><span data-stu-id="253e3-104">To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <xref:System.Runtime.InteropServices.SafeHandle> object is atomic.</span></span> <span data-ttu-id="253e3-105">Jeder Fehler zwischen diesen Operationen (z. B. eines Threadabbruchs oder Out-of-Memory-Ausnahme) führt das systemeigene Handle zugreifen.</span><span class="sxs-lookup"><span data-stu-id="253e3-105">Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</span></span>  <span data-ttu-id="253e3-106">Sie können die <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> Methode, um sicherzustellen, dass das Handle nicht verloren geht.</span><span class="sxs-lookup"><span data-stu-id="253e3-106">You can use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method to make sure that the handle is not leaked.</span></span>  
  
 [!code-csharp[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/cs/sample.cs#1)]
 [!code-vb[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="EnsureSufficientExecutionStack">
      <MemberSignature Language="C#" Value="public static void EnsureSufficientExecutionStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsureSufficientExecutionStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsureSufficientExecutionStack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnsureSufficientExecutionStack();" />
      <MemberSignature Language="F#" Value="static member EnsureSufficientExecutionStack : unit -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="253e3-107">Stellt sicher, dass der verbleibende Stapelspeicher groß genug ist, um die durchschnittliche .NET Framework-Funktion auszuführen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-107">Ensures that the remaining stack space is large enough to execute the average .NET Framework function.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="253e3-108"><xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A> enthält Informationen über einen künstlich eingeschränkten Stapel, der genügend Platz für eine Ausnahme ausgelöst wird, werden beibehalten und Wiederherstellungsaktionen ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="253e3-108"><xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A> provides information about an artificially limited stack that preserves enough space for an exception to be raised and recovery action to be taken.</span></span> <span data-ttu-id="253e3-109">Die künstliche Stapelgrenze wird von der common Language Runtime ausgewählt, um sicherzustellen, dass genügend Speicherplatz verbleibt, bevor er eine Ausnahme auslöst, sicher.</span><span class="sxs-lookup"><span data-stu-id="253e3-109">The artificial stack limit is chosen by the common language runtime to ensure that enough space remains to throw an exception safely.</span></span>  
  
 <span data-ttu-id="253e3-110">Diese Methode ist hilfreich in Situationen, in denen Stapelüberlauf aufgrund einer ungebundenen Rekursion auftreten können.</span><span class="sxs-lookup"><span data-stu-id="253e3-110">This method is useful in situations where stack overflow might occur as a result of unbounded recursion.</span></span> <span data-ttu-id="253e3-111">Es dient zur Verwendung in Szenarios mit Compilerdiensten, jedoch auch problemlos in anderen Entwicklungsszenarien verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="253e3-111">It is intended for use in compiler services scenarios, although it can also be used safely in other development scenarios.</span></span>  
  
 <span data-ttu-id="253e3-112">Wenn der Stapelspeicher ausreichend ist, wird die Ausnahme ausgelöst, und die meisten .NET Framework-Typen und Member immer noch aufgerufen werden können.</span><span class="sxs-lookup"><span data-stu-id="253e3-112">If the stack space is sufficient, the exception is not thrown, and most .NET Framework types and members can still be called.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="253e3-113">Diese Methode ist nicht Teil der Unterstützung des eingeschränkten Ausführungsbereichs (CER) und sollte nicht zu verwechseln mit der <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="253e3-113">This method is not part of the constrained execution region (CER) support, and should not be confused with the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InsufficientExecutionStackException">
          <span data-ttu-id="253e3-114">Der verfügbare Stapelspeicher ist nicht groß genug, um die durchschnittliche .NET Framework-Funktion auszuführen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-114">The available stack space is insufficient to execute the average .NET Framework function.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object o1, object o2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object o1, object o2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (o1 As Object, o2 As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ o1, System::Object ^ o2);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.Runtime.CompilerServices.RuntimeHelpers.Equals (o1, o2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o1" Type="System.Object" />
        <Parameter Name="o2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o1">
          <span data-ttu-id="253e3-115">Das erste zu vergleichende Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-115">The first object to compare.</span>
          </span>
        </param>
        <param name="o2">
          <span data-ttu-id="253e3-116">Das zweite zu vergleichende Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-116">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="253e3-117">Stellt fest, ob die angegebenen <see cref="T:System.Object" />-Instanzen als gleich betrachtet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-117">Determines whether the specified <see cref="T:System.Object" /> instances are considered equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="253e3-118">
            <see langword="true" />, wenn der <paramref name="o1" />-Parameter dieselbe Instanz wie der <paramref name="o2" />-Parameter ist, beide <see langword="null" /> sind oder <c>o1.Equals(o2)</c><see langword="true" /> zurückgibt, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-118">
              <see langword="true" /> if the <paramref name="o1" /> parameter is the same instance as the <paramref name="o2" /> parameter, or if both are <see langword="null" />, or if <c>o1.Equals(o2)</c> returns <see langword="true" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="253e3-119">Diese Methode wird von Compilern verwendet.</span><span class="sxs-lookup"><span data-stu-id="253e3-119">This method is used by compilers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="253e3-120">Im folgende Beispiel wird veranschaulicht, wie vergleicht zwei Objekte mithilfe der <xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="253e3-120">The following example demonstrates how to compare two objects by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A> method.</span></span>  
  
 [!code-csharp[Runtime.CompilerServices.RuntimeHelpers.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.Equals/cs/example.cs#1)]
 [!code-vb[Runtime.CompilerServices.RuntimeHelpers.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.Equals/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteCodeWithGuaranteedCleanup">
      <MemberSignature Language="C#" Value="public static void ExecuteCodeWithGuaranteedCleanup (System.Runtime.CompilerServices.RuntimeHelpers.TryCode code, System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode backoutCode, object userData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExecuteCodeWithGuaranteedCleanup(class System.Runtime.CompilerServices.RuntimeHelpers/TryCode code, class System.Runtime.CompilerServices.RuntimeHelpers/CleanupCode backoutCode, object userData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExecuteCodeWithGuaranteedCleanup (code As RuntimeHelpers.TryCode, backoutCode As RuntimeHelpers.CleanupCode, userData As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExecuteCodeWithGuaranteedCleanup(System::Runtime::CompilerServices::RuntimeHelpers::TryCode ^ code, System::Runtime::CompilerServices::RuntimeHelpers::CleanupCode ^ backoutCode, System::Object ^ userData);" />
      <MemberSignature Language="F#" Value="static member ExecuteCodeWithGuaranteedCleanup : System.Runtime.CompilerServices.RuntimeHelpers.TryCode * System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode * obj -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup (code, backoutCode, userData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="code" Type="System.Runtime.CompilerServices.RuntimeHelpers+TryCode" />
        <Parameter Name="backoutCode" Type="System.Runtime.CompilerServices.RuntimeHelpers+CleanupCode" />
        <Parameter Name="userData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="code">
          <span data-ttu-id="253e3-121">Ein Delegat des auszuführenden Codes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-121">A delegate to the code to try.</span>
          </span>
        </param>
        <param name="backoutCode">
          <span data-ttu-id="253e3-122">Ein Delegat des Codes, der beim Auftreten einer Ausnahme ausgeführt werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-122">A delegate to the code to run if an exception occurs.</span>
          </span>
        </param>
        <param name="userData">
          <span data-ttu-id="253e3-123">Die an <c>code</c> und <c>backoutCode</c> zu übergebenden Daten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-123">The data to pass to <c>code</c> and <c>backoutCode</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="253e3-124">Führt Code unter Verwendung eines <see cref="T:System.Delegate" /> aus und verwendet einen weiteren <see cref="T:System.Delegate" />, um bei einer Ausnahme zusätzlichen Code auszuführen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-124">Executes code using a <see cref="T:System.Delegate" /> while using another <see cref="T:System.Delegate" /> to execute additional code in case of an exception.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="253e3-125">Diese Methode wird von Compilern verwendet.</span><span class="sxs-lookup"><span data-stu-id="253e3-125">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="253e3-126">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-126">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="253e3-127">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-127">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (o As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : obj -&gt; int" Usage="System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="253e3-128">Ein Objekt, für das der Hash abgerufen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-128">An object to retrieve the hash code for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="253e3-129">Fungiert als Hashfunktion für ein bestimmtes Objekt und eignet sich für die Verwendung in Hashalgorithmen und Hashdatenstrukturen, die Hashcodes verwenden, z. B. in einer Hashtabelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-129">Serves as a hash function for a particular object, and is suitable for use in algorithms and data structures that use hash codes, such as a hash table.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="253e3-130">Ein Hashcode für das Objekt , das vom <paramref name="o" />-Parameter bezeichnet wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-130">A hash code for the object identified by the <paramref name="o" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="253e3-131">Die <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> Methode ruft immer die <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> Methode nicht virtuell, selbst wenn der Typ des Objekts außer Kraft gesetzt hat die <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="253e3-131">The <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> method always calls the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method non-virtually, even if the object's type has overridden the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="253e3-132">Daher wird die Verwendung <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> unterscheiden sich von aufrufenden `GetHashCode` direkt auf das Objekt mit der <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="253e3-132">Therefore, using <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> might differ from calling `GetHashCode` directly on the object with the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="253e3-133">Obwohl die <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> Methodenrückgabe identische Hashcodes für identische Objektverweise, sollten Sie nicht mit dieser Methode für die Objektidentität zu testen, da dieser Hashcode Objektverweis nicht eindeutig identifiziert.</span><span class="sxs-lookup"><span data-stu-id="253e3-133">Although the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> method returns identical hash codes for identical object references, you should not use this method to test for object identity, because this hash code does not uniquely identify an object reference.</span></span> <span data-ttu-id="253e3-134">Zum Testen, für das Objekt identifizieren (testen Sie, dass zwei Objekte Verweis das gleiche Objekt im Arbeitsspeicher), rufen Sie die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="253e3-134">To test for object identify (that is, to test that two objects reference the same object in memory), call the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="253e3-135">Oder verwenden Sie <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> zu testen, ob zwei Zeichenfolgen gleich Objektverweise, darstellen, da die Zeichenfolge internalisiert ist.</span><span class="sxs-lookup"><span data-stu-id="253e3-135">Nor should you use <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> to test whether two strings represent equal object references, because the string is interned.</span></span> <span data-ttu-id="253e3-136">Um die Internalisierung zu testen, rufen Sie die <xref:System.String.IsInterned%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="253e3-136">To test for string interning, call the <xref:System.String.IsInterned%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="253e3-137">Die <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> und <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> Methoden unterscheiden sich wie folgt:</span><span class="sxs-lookup"><span data-stu-id="253e3-137">The <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> and <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> methods differ as follows:</span></span>  
  
-   <span data-ttu-id="253e3-138"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> Gibt einen Hashcode aus, der auf die Objektdefinition von Gleichheit basieren.</span><span class="sxs-lookup"><span data-stu-id="253e3-138"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> returns a hash code that is based on the object's definition of equality.</span></span> <span data-ttu-id="253e3-139">Beispielsweise werden zwei Zeichenfolgen mit identischem Inhalt den gleichen Wert für zurückgeben <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="253e3-139">For example, two strings with identical contents will return the same value for <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="253e3-140"><xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> Gibt einen Hashcode, der Identität des Objekts angibt.</span><span class="sxs-lookup"><span data-stu-id="253e3-140"><xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> returns a hash code that indicates object identity.</span></span> <span data-ttu-id="253e3-141">D. h. eine Zeichenfolge zwei Variablen, deren Inhalt und identisch sind, die eine Zeichenfolge, die internalisiert ist darstellen (finden Sie unter der [Internalisieren von Zeichenfolgen](#interning) Abschnitt) oder die Hashcodes, die darstellen, eine einzige Zeichenfolge im Arbeitsspeicher zurück identisch.</span><span class="sxs-lookup"><span data-stu-id="253e3-141">That is, two string variables whose contents are identical and that represent a string that is interned (see the [String Interning](#interning) section) or that represent a single string in memory return identical hash codes.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="253e3-142">Beachten Sie, dass <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> immer identische Hashcodes für Objektverweise gleich zurück.</span><span class="sxs-lookup"><span data-stu-id="253e3-142">Note that <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> always returns identical hash codes for equal object references.</span></span> <span data-ttu-id="253e3-143">Das Gegenteil ist jedoch nicht "true": gleich Hashcodes nicht angegeben wird, gleich Objekt verweist.</span><span class="sxs-lookup"><span data-stu-id="253e3-143">However, the reverse is not true: equal hash codes do not indicate equal object references.</span></span> <span data-ttu-id="253e3-144">Ein bestimmten Hashcodewert ist nicht nur für einen bestimmten Objektverweis; verschiedene Objektverweise können identische Hashcodes generieren.</span><span class="sxs-lookup"><span data-stu-id="253e3-144">A particular hash code value is not unique to a particular object reference; different object references can generate identical hash codes.</span></span>  
  
 <span data-ttu-id="253e3-145">Diese Methode wird von Compilern verwendet.</span><span class="sxs-lookup"><span data-stu-id="253e3-145">This method is used by compilers.</span></span>  
  
<a name="interning"></a>   
## <a name="string-interning"></a><span data-ttu-id="253e3-146">Internalisieren von Zeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="253e3-146">String Interning</span></span>  
 <span data-ttu-id="253e3-147">Die common Language Runtime (CLR) verwaltet einen internen Pool von Zeichenfolgen und Literale im Pool gespeichert.</span><span class="sxs-lookup"><span data-stu-id="253e3-147">The common language runtime (CLR) maintains an internal pool of strings and stores literals in the pool.</span></span> <span data-ttu-id="253e3-148">Wenn zwei Zeichenfolgen (z. B. `str1` und `str2`) werden über eine identische Zeichenfolge, die Literale, die CLR wird festgelegt, gebildet `str1` und `str2` , zeigen Sie an den gleichen Speicherort auf dem verwalteten Heap, um Speicherplatz zu sparen.</span><span class="sxs-lookup"><span data-stu-id="253e3-148">If two strings (for example, `str1` and `str2`) are formed from an identical string literal, the CLR will set `str1` and `str2` to point to the same location on the managed heap to conserve memory.</span></span> <span data-ttu-id="253e3-149">Aufrufen von <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> Objekte erzeugt für diese beiden Zeichenfolgenobjekte denselben Hashcode, im Gegensatz zum zweiten Aufzählungspunkt im vorherigen Abschnitt.</span><span class="sxs-lookup"><span data-stu-id="253e3-149">Calling <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> on these two string objects will produce the same hash code, contrary to the second bulleted item in the previous section.</span></span>  
  
 <span data-ttu-id="253e3-150">Die CLR hinzugefügt den Pool nur Literale.</span><span class="sxs-lookup"><span data-stu-id="253e3-150">The CLR adds only literals to the pool.</span></span> <span data-ttu-id="253e3-151">Ergebnisse von Zeichenfolgenoperationen wie z. B. die Verkettung werden dem Pool nicht hinzugefügt werden, es sei denn, der Compiler die Verkettung von Zeichenfolgen als einzelne Zeichenfolgenliteral löst.</span><span class="sxs-lookup"><span data-stu-id="253e3-151">Results of string operations such as concatenation are not added to the pool, unless the compiler resolves the string concatenation as a single string literal.</span></span> <span data-ttu-id="253e3-152">Aus diesem Grund Wenn `str2` erstellt wurde, als Ergebnis eines verkettungsvorgangs und `str2` ist identisch mit `str1`mit <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> für diese zwei Zeichenfolgenobjekte werden Objekte nicht den gleichen Hashcode erzeugen.</span><span class="sxs-lookup"><span data-stu-id="253e3-152">Therefore, if `str2` was created as the result of a concatenation operation, and `str2` is identical to `str1`, using <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> on these two string objects will not produce the same hash code.</span></span>  
  
 <span data-ttu-id="253e3-153">Wenn Sie eine verkettete Zeichenfolge explizit in den Pool hinzufügen möchten, verwenden Sie die <xref:System.String.Intern%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="253e3-153">If you want to add a concatenated string to the pool explicitly, use the <xref:System.String.Intern%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="253e3-154">Sie können auch die <xref:System.String.IsInterned%2A?displayProperty=nameWithType> -Methode überprüft, ob eine Zeichenfolge einen Verweis im Internpool vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="253e3-154">You can also use the <xref:System.String.IsInterned%2A?displayProperty=nameWithType> method to check whether a string has an interned reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="253e3-155">Das folgende Beispiel veranschaulicht den Unterschied zwischen der <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> und <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> Methoden.</span><span class="sxs-lookup"><span data-stu-id="253e3-155">The following example demonstrates the difference between the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> and <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="253e3-156">Die Ausgabe im Beispiel veranschaulicht Folgendes:</span><span class="sxs-lookup"><span data-stu-id="253e3-156">The output from the example illustrates the following:</span></span>  
  
-   <span data-ttu-id="253e3-157">Beide Sätze von Hashcodes für die erste Gruppe von Zeichenfolgen, die an die `ShowHashCodes` Methode unterscheiden, da die Zeichenfolgen völlig unterschiedlich sind.</span><span class="sxs-lookup"><span data-stu-id="253e3-157">Both sets of hash codes for the first set of strings passed to the `ShowHashCodes` method are different, because the strings are completely different.</span></span>  
  
-   <span data-ttu-id="253e3-158"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> generiert von den gleichen Hashcode für die zweite Gruppe von Zeichenfolgen übergeben die `ShowHashCodes` -Methode, da die Zeichenfolgen gleich sind.</span><span class="sxs-lookup"><span data-stu-id="253e3-158"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> generates the same hash code for the second set of strings passed to the `ShowHashCodes` method, because the strings are equal.</span></span> <span data-ttu-id="253e3-159">Allerdings die <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> Methode nicht.</span><span class="sxs-lookup"><span data-stu-id="253e3-159">However, the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> method does not.</span></span> <span data-ttu-id="253e3-160">Die erste Zeichenfolge wird mithilfe eines Zeichenfolgenliterals definiert und ist daher intern gespeichert.</span><span class="sxs-lookup"><span data-stu-id="253e3-160">The first string is defined by using a string literal and so is interned.</span></span> <span data-ttu-id="253e3-161">Obwohl der Wert der zweiten Zeichenfolge identisch ist, es ist nicht intern gespeichert, da es durch einen Aufruf zurückgegeben wird das <xref:System.String.Format%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="253e3-161">Although the value of the second string is the same, it is not interned, because it is returned by a call to the <xref:System.String.Format%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="253e3-162">Im Fall von dritten Zeichenfolge, die Hashcodes erzeugten <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> für beide Zeichenfolgen identisch sind, sind die Hashcodes erzeugten <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="253e3-162">In the case of the third string, the hash codes produced by <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> for both strings are identical, as are the hash codes produced by <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="253e3-163">Dies ist, da der Compiler den beide Zeichenfolgen als einzelne Zeichenfolgenliteral zugewiesenen Wert behandelt wurde und die Zeichenfolgenvariablen auf dieselbe Zeichenfolge, die im Internpool vorhanden verweisen.</span><span class="sxs-lookup"><span data-stu-id="253e3-163">This is because the compiler has treated the value assigned to both strings as a single string literal, and so the string variables refer to the same interned string.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.runtimehelpers.gethashcode/cs/gethashcodeex1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.runtimehelpers.gethashcode/vb/gethashcodeex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectValue">
      <MemberSignature Language="C#" Value="public static object GetObjectValue (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectValue(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectValue (obj As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObjectValue(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjectValue : obj -&gt; obj" Usage="System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="253e3-164">Der zu schachtelnde Werttyp.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-164">The value type to be boxed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="253e3-165">Schachtelt einen Werttyp.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-165">Boxes a value type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="253e3-166">Eine geschachtelte Kopie von <paramref name="obj" />, wenn es eine Wertklasse ist, andernfalls <paramref name="obj" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-166">A boxed copy of <paramref name="obj" /> if it is a value class; otherwise, <paramref name="obj" /> itself.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="253e3-167">Beim Boxing eines Werttyps erstellt ein Objekt und führt eine flache Kopie der Felder des Typs angegebenen Wert in das neue Objekt.</span><span class="sxs-lookup"><span data-stu-id="253e3-167">Boxing a value type creates an object and performs a shallow copy of the fields of the specified value type into the new object.</span></span>  
  
 <span data-ttu-id="253e3-168">Diese Methode ermöglicht eine Wertklasse als Objekt bearbeitet werden, während er das Aliasverhalten einer Wertklasse beibehalten wird.</span><span class="sxs-lookup"><span data-stu-id="253e3-168">This method allows a value class to be manipulated as an object while it retains the aliasing behavior of a value class.</span></span>  
  
 <span data-ttu-id="253e3-169">Der zurückgegebene Wert hängt davon ab, ob die Wertklasse änderbare ist oder unveränderlich ist:</span><span class="sxs-lookup"><span data-stu-id="253e3-169">The return value depends on whether the value class is mutable or immutable:</span></span>  
  
-   <span data-ttu-id="253e3-170">Wenn der Wert zugewiesen wird, eine Wertklasse ist, gibt die Methode eine flache Kopie der Klasse zurück, da Wertklassen Kopiersemantik verfügen.</span><span class="sxs-lookup"><span data-stu-id="253e3-170">If the value being assigned is a mutable value class, the method returns a shallow copy of the class, because value classes have copy semantics.</span></span>  
  
-   <span data-ttu-id="253e3-171">Wenn der Wert zugewiesen wird, eine Wertklasse ist, wird das Objekt selbst, anstatt eine Kopie der Klasse von der Methode zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="253e3-171">If the value being assigned is an immutable value class, the method returns the object itself, instead of a copy of the class.</span></span>  
  
 <span data-ttu-id="253e3-172">Compiler dynamisch typisierte Sprachen können diese Methode verwenden, um sicherzustellen, dass geschachtelte Werttypen identisch und nicht geschachtelte Werttypen arbeiten zu können.</span><span class="sxs-lookup"><span data-stu-id="253e3-172">Compilers of dynamically typed languages can use this method to make sure that boxed value types work identically to unboxed value types.</span></span> <span data-ttu-id="253e3-173">Geschachtelte Werttypen zu erhalten, also geklont, wenn übergeben, und sie werden immer als Wert übergeben.</span><span class="sxs-lookup"><span data-stu-id="253e3-173">That is, boxed value types get cloned when you pass them around, and they are always passed by value.</span></span> <span data-ttu-id="253e3-174">Der Compiler kann Aufrufen <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> zu einem Objekt einen Werttyp zuweisen oder um einen Werttyp als Parameter eines Objekts vom Typ übergeben.</span><span class="sxs-lookup"><span data-stu-id="253e3-174">The compiler can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> to assign a value type to an object or to pass a value type as a parameter of a type object.</span></span>  
  
 <span data-ttu-id="253e3-175">Diese Methode wird von Compilern verwendet.</span><span class="sxs-lookup"><span data-stu-id="253e3-175">This method is used by compilers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="253e3-176">Das folgende Beispiel zeigt, wie Sie das Feld einer Wertklasse mithilfe der <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="253e3-176">The following example demonstrates how to box a value class by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> method.</span></span>  
  
 [!code-csharp[Runtime.CompilerServices.RuntimeHelpers.GetObjectValue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.GetObjectValue/cs/example.cs#1)]
 [!code-vb[Runtime.CompilerServices.RuntimeHelpers.GetObjectValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.GetObjectValue/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUninitializedObject">
      <MemberSignature Language="C#" Value="public static object GetUninitializedObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetUninitializedObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetUninitializedObject(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetUninitializedObject(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetUninitializedObject : Type -&gt; obj" Usage="System.Runtime.CompilerServices.RuntimeHelpers.GetUninitializedObject type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeArray">
      <MemberSignature Language="C#" Value="public static void InitializeArray (Array array, RuntimeFieldHandle fldHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InitializeArray(class System.Array array, valuetype System.RuntimeFieldHandle fldHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InitializeArray(Array ^ array, RuntimeFieldHandle fldHandle);" />
      <MemberSignature Language="F#" Value="static member InitializeArray : Array * RuntimeFieldHandle -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray (array, fldHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="fldHandle" Type="System.RuntimeFieldHandle" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="253e3-177">Das zu initialisierende Array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-177">The array to be initialized.</span>
          </span>
        </param>
        <param name="fldHandle">
          <span data-ttu-id="253e3-178">Ein Feldhandle, das den Speicherort der zum Initialisieren des Arrays verwendeten Daten angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-178">A field handle that specifies the location of the data used to initialize the array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="253e3-179">Stellt eine schnelle Methode zum Initialisieren eines Arrays aus in einem Modul gespeicherten Daten bereit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-179">Provides a fast way to initialize an array from data that is stored in a module.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="253e3-180">Diese Methode wird von Compilern verwendet.</span><span class="sxs-lookup"><span data-stu-id="253e3-180">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReferenceOrContainsReferences&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsReferenceOrContainsReferences&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsReferenceOrContainsReferences&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsReferenceOrContainsReferences(Of T) () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool IsReferenceOrContainsReferences();" />
      <MemberSignature Language="F#" Value="static member IsReferenceOrContainsReferences : unit -&gt; bool" Usage="System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OffsetToStringData">
      <MemberSignature Language="C#" Value="public static int OffsetToStringData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 OffsetToStringData" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OffsetToStringData As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int OffsetToStringData { int get(); };" />
      <MemberSignature Language="F#" Value="member this.OffsetToStringData : int" Usage="System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="253e3-181">Ruft den Offset in Bytes zu den Daten in der angegebenen Zeichenfolge ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-181">Gets the offset, in bytes, to the data in the given string.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="253e3-182">Der Byteoffset vom Start des <see cref="T:System.String" />-Objekts bis zum ersten Zeichen der Zeichenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-182">The byte offset, from the start of the <see cref="T:System.String" /> object to the first character in the string.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="253e3-183">Compiler verwenden diese Eigenschaft für unsichere, jedoch effizienter, Zeigeroperationen anhand der Zeichen in eine verwaltete Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="253e3-183">Compilers use this property for unsafe, but efficient, pointer operations on the characters in a managed string.</span></span> <span data-ttu-id="253e3-184">Compiler sollten die Zeichenfolge für die datenverschiebung durch den Garbage Collector vor der Verwendung fixieren.</span><span class="sxs-lookup"><span data-stu-id="253e3-184">Compilers should pin the string against movement by the garbage collector before use.</span></span> <span data-ttu-id="253e3-185">Beachten Sie, dass die common Language Runtime-Zeichenfolgen unveränderlich sind. d. h. deren Inhalt können gelesen, aber nicht geändert.</span><span class="sxs-lookup"><span data-stu-id="253e3-185">Note that common language runtime strings are immutable; that is, their contents can be read but not changed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareConstrainedRegions">
      <MemberSignature Language="C#" Value="public static void PrepareConstrainedRegions ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareConstrainedRegions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareConstrainedRegions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareConstrainedRegions();" />
      <MemberSignature Language="F#" Value="static member PrepareConstrainedRegions : unit -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="253e3-186">Kennzeichnet einen Codeabschnitt als eingeschränkten Ausführungsbereich (Constrained Execution Region, CER).</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-186">Designates a body of code as a constrained execution region (CER).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="253e3-187">Compiler verwenden diese Methode, um zu markieren `catch`, `finally`, und `fault` Blöcke als eingeschränkte Ausführungsbereiche (CERs).</span><span class="sxs-lookup"><span data-stu-id="253e3-187">Compilers use this method to mark `catch`, `finally`, and `fault` blocks as constrained execution regions (CERs).</span></span> <span data-ttu-id="253e3-188">Code, der als eingeschränkter Bereich nur anderen Code mit starken zuverlässigkeitsvereinbarungen aufrufen, muss markiert ist.</span><span class="sxs-lookup"><span data-stu-id="253e3-188">Code that is marked as a constrained region must only call other code with strong reliability contracts.</span></span> <span data-ttu-id="253e3-189">Es sollte nicht zuordnen oder virtuelle Aufrufe für unvorbereiteten oder nicht zuverlässigen Methoden vornehmen, es sei denn, es vorbereitet wird, um Fehler zu behandeln.</span><span class="sxs-lookup"><span data-stu-id="253e3-189">It should not allocate or make virtual calls to unprepared or unreliable methods unless it is prepared to handle failures.</span></span>  
  
 <span data-ttu-id="253e3-190">Beachten Sie, die Language-Opcodes, nicht nur für fortgeschrittene `NOP`, dürfen zwischen einem Aufruf von der <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> Methode und die `try` Block.</span><span class="sxs-lookup"><span data-stu-id="253e3-190">Note that no intermediate language opcodes, except `NOP`, are allowed between a call to the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method and the `try` block.</span></span> <span data-ttu-id="253e3-191">Weitere Informationen über CERs, finden Sie unter den Klassen in der <xref:System.Runtime.ConstrainedExecution> Namespace.</span><span class="sxs-lookup"><span data-stu-id="253e3-191">For more information about CERs, see the classes in the <xref:System.Runtime.ConstrainedExecution> namespace.</span></span>  
  
 <span data-ttu-id="253e3-192">CERs, die markiert sind, mit der <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> Methode funktionieren nicht perfekt bei der ein <xref:System.StackOverflowException> wird generiert aus der `try` Block.</span><span class="sxs-lookup"><span data-stu-id="253e3-192">CERs that are marked using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method do not work perfectly when a <xref:System.StackOverflowException> is generated from the `try` block.</span></span> <span data-ttu-id="253e3-193">Weitere Informationen finden Sie unter der Methode <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A>.</span><span class="sxs-lookup"><span data-stu-id="253e3-193">For more information, see the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> method.</span></span>  
  
 <span data-ttu-id="253e3-194">Die <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>-Methode ruft die <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A>-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="253e3-194">The <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method calls the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="253e3-195">Im folgenden Beispiel wird gezeigt, wie zum zuverlässig Handles mit dem <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="253e3-195">The following example shows how to reliably set handles by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method.</span></span> <span data-ttu-id="253e3-196">Um ein Handle für ein angegebenes bereits vorhandene Handle zuverlässig zu festzulegen, Sie müssen sicherstellen, dass die Zuordnung von das systemeigene Handle und die nachfolgenden Aufzeichnung dieses Handle in einen <xref:System.Runtime.InteropServices.SafeHandle> -Objekt atomar ist.</span><span class="sxs-lookup"><span data-stu-id="253e3-196">To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <xref:System.Runtime.InteropServices.SafeHandle> object is atomic.</span></span> <span data-ttu-id="253e3-197">Jeder Fehler zwischen diesen Operationen (z. B. eines Threadabbruchs oder Out-of-Memory-Ausnahme) führt das systemeigene Handle zugreifen.</span><span class="sxs-lookup"><span data-stu-id="253e3-197">Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</span></span> <span data-ttu-id="253e3-198">Sie können die <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> Methode, um sicherzustellen, dass das Handle nicht verloren geht.</span><span class="sxs-lookup"><span data-stu-id="253e3-198">You can use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method to make sure that the handle is not leaked.</span></span>  
  
 [!code-csharp[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/cs/sample.cs#1)]
 [!code-vb[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="253e3-199">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-199">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="253e3-200">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-200">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareConstrainedRegionsNoOP">
      <MemberSignature Language="C#" Value="public static void PrepareConstrainedRegionsNoOP ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareConstrainedRegionsNoOP() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareConstrainedRegionsNoOP ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareConstrainedRegionsNoOP();" />
      <MemberSignature Language="F#" Value="static member PrepareConstrainedRegionsNoOP : unit -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="253e3-201">Kennzeichnet einen Codeabschnitt als eingeschränkten Ausführungsbereich (Constrained Execution Region, CER), ohne dass eine Überprüfung durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-201">Designates a body of code as a constrained execution region (CER) without performing any probing.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="253e3-202">Diese Methode sollte nicht direkt vom Compiler aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="253e3-202">Compilers should not call this method directly.</span></span> <span data-ttu-id="253e3-203">Definieren Sie stattdessen eine CER durch Aufrufen der <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="253e3-203">Instead, define a CER by calling the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="253e3-204">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-204">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="253e3-205">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-205">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareContractedDelegate">
      <MemberSignature Language="C#" Value="public static void PrepareContractedDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareContractedDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareContractedDelegate (d As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareContractedDelegate(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="static member PrepareContractedDelegate : Delegate -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="253e3-206">Der vorzubereitende Ereignisdelegat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-206">The event delegate to prepare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="253e3-207">Bietet Anwendungen die Möglichkeit, <see cref="T:System.AppDomain" />-Ereignisdelegaten dynamisch vorzubereiten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-207">Provides a way for applications to dynamically prepare <see cref="T:System.AppDomain" /> event delegates.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="253e3-208"><xref:System.AppDomain> -Ereignisdelegaten wie z. B. <xref:System.AppDomain.DomainUnload>, <xref:System.AppDomain.ProcessExit>, und <xref:System.AppDomain.UnhandledException> werden beim Start nicht automatisch vorbereitet.</span><span class="sxs-lookup"><span data-stu-id="253e3-208"><xref:System.AppDomain> event delegates such as <xref:System.AppDomain.DomainUnload>, <xref:System.AppDomain.ProcessExit>, and <xref:System.AppDomain.UnhandledException> are not automatically prepared at startup.</span></span> <span data-ttu-id="253e3-209">Sie können die folgenden Methoden verwenden, zu deren Vorbereitung:</span><span class="sxs-lookup"><span data-stu-id="253e3-209">You can use the following methods to prepare them:</span></span>  
  
-   <span data-ttu-id="253e3-210">-Attribut die Methode mithilfe der <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> Attribut.</span><span class="sxs-lookup"><span data-stu-id="253e3-210">Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="253e3-211">-Attribut die Methode mithilfe der <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> Attribut.</span><span class="sxs-lookup"><span data-stu-id="253e3-211">Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="253e3-212">Rufen Sie die <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A> Methode, um den Delegaten dynamisch vorzubereiten.</span><span class="sxs-lookup"><span data-stu-id="253e3-212">Call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A> method to dynamically prepare the delegate.</span></span>  
  
 <span data-ttu-id="253e3-213">Weitere Informationen finden Sie im Artikel [behalten Your Code Running with the Reliability Features von .NET Framework](http://go.microsoft.com/fwlink/?LinkId=145491) im MSDN Magazin.</span><span class="sxs-lookup"><span data-stu-id="253e3-213">For more information, see the article [Keep Your Code Running with the Reliability Features of the .NET Framework](http://go.microsoft.com/fwlink/?LinkId=145491) in the MSDN Magazine.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="253e3-214">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-214">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="253e3-215">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-215">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareDelegate">
      <MemberSignature Language="C#" Value="public static void PrepareDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareDelegate (d As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareDelegate(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="static member PrepareDelegate : Delegate -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="253e3-216">Der vorzubereitende Delegattyp.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-216">The delegate type to prepare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="253e3-217">Gibt an, dass der angegebene Delegat für die Aufnahme in einen eingeschränkten Ausführungsbereich (Constrained Execution Region, CER) vorbereitet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-217">Indicates that the specified delegate should be prepared for inclusion in a constrained execution region (CER).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="253e3-218">Compiler verwenden diese Methode einen Delegaten vorbereiten und das Ziel dieses Aufrufs (und des Delegaten statisch bestimmbare Aufrufdiagramm) vorbereiten, als einen eingeschränkten Ausführungsbereich (CER).</span><span class="sxs-lookup"><span data-stu-id="253e3-218">Compilers use this method to prepare a delegate's invocation method and to prepare the target of that invocation (and the delegate's statically determinable call graph) as a constrained execution region (CER).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="253e3-219">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-219">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="253e3-220">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-220">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="PrepareMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="253e3-221">Bereitet eine Methode für die Aufnahme in einen eingeschränkten Ausführungsbereich (Constrained Execution Region, CER) vor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-221">Prepares a method for inclusion in a constrained execution region (CER).</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PrepareMethod">
      <MemberSignature Language="C#" Value="public static void PrepareMethod (RuntimeMethodHandle method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareMethod(valuetype System.RuntimeMethodHandle method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareMethod (method As RuntimeMethodHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareMethod(RuntimeMethodHandle method);" />
      <MemberSignature Language="F#" Value="static member PrepareMethod : RuntimeMethodHandle -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="253e3-222">Ein Handle auf die vorzubereitende Methode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-222">A handle to the method to prepare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="253e3-223">Bereitet eine Methode für die Aufnahme in einen eingeschränkten Ausführungsbereich (Constrained Execution Region, CER) vor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-223">Prepares a method for inclusion in a constrained execution region (CER).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="253e3-224">Verwenden der Compiler die <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> Methode, um virtuelle Aufrufe zu verarbeiten, die in einem eingeschränkten Ausführungsbereich (CER) vorgenommen werden.</span><span class="sxs-lookup"><span data-stu-id="253e3-224">Compilers use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> method to handle virtual calls that are made inside a constrained execution region (CER).</span></span> <span data-ttu-id="253e3-225">Zum Zeitpunkt der JIT-Kompilierung muss die common Language Runtime nicht in der Regel genügend Informationen über das Ziel eines virtuellen Aufrufs.</span><span class="sxs-lookup"><span data-stu-id="253e3-225">At JIT compilation time, the common language runtime does not usually have enough information about the target of a virtual call.</span></span> <span data-ttu-id="253e3-226">Aus diesem Grund ist die Runtime nicht zuerst dieses Segment des Aufrufdiagramms vorbereitet werden.</span><span class="sxs-lookup"><span data-stu-id="253e3-226">Therefore, the runtime does not initially prepare that segment of the call graph.</span></span> <span data-ttu-id="253e3-227">Wenn der Code, die der CER verwendet so viel wissen verfügt, um zu bestimmen, das Ziel zu einem beliebigen Zeitpunkt vor der CER tatsächlich eingegeben wird, werden, Aufrufen <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> Vorbereitung normalerweise automatisch ausgeführt, als Argument angegebene Methode eine CER als Stamm der gleichen Runtime ausführen.</span><span class="sxs-lookup"><span data-stu-id="253e3-227">If the code that is using the CER has enough knowledge to determine the target at any point in time before the CER is actually entered, it can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> to perform the same runtime preparation normally done for a CER rooted at the method specified as an argument.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="253e3-228">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-228">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="253e3-229">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-229">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareMethod">
      <MemberSignature Language="C#" Value="public static void PrepareMethod (RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareMethod(valuetype System.RuntimeMethodHandle method, valuetype System.RuntimeTypeHandle[] instantiation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareMethod (method As RuntimeMethodHandle, instantiation As RuntimeTypeHandle())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareMethod(RuntimeMethodHandle method, cli::array &lt;RuntimeTypeHandle&gt; ^ instantiation);" />
      <MemberSignature Language="F#" Value="static member PrepareMethod : RuntimeMethodHandle * RuntimeTypeHandle[] -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod (method, instantiation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
        <Parameter Name="instantiation" Type="System.RuntimeTypeHandle[]" />
      </Parameters>
      <Docs>
        <param name="method">
          <span data-ttu-id="253e3-230">Ein Handle auf die vorzubereitende Methode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-230">A handle to the method to prepare.</span>
          </span>
        </param>
        <param name="instantiation">
          <span data-ttu-id="253e3-231">Die an die Methode zu übergebende Instanziierung.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-231">The instantiation to pass to the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="253e3-232">Bereitet eine Methode für die Aufnahme in einen eingeschränkten Ausführungsbereich (Constrained Execution Region, CER) mit der angegebenen Instanziierung vor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-232">Prepares a method for inclusion in a constrained execution region (CER) with the specified instantiation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="253e3-233">Sie können angeben, Unterstützung von Generika für Compiler mithilfe der <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> Methode.</span><span class="sxs-lookup"><span data-stu-id="253e3-233">You can provide generics support for compilers by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method.</span></span> <span data-ttu-id="253e3-234">Die common Language Runtime kann nicht eingeschränkte Ausführungsbereiche (CERs), die auf eine Methode, die generischen Typparameter (Typparameter in der Klasse, die mit der Methode oder für die Methode selbst) aufweist, Vorbereiten Wenn diese Typparameter instanziiert werden als Verweistypen.</span><span class="sxs-lookup"><span data-stu-id="253e3-234">The common language runtime cannot prepare constrained execution regions (CERs) rooted in a method that has generic type parameters (either a type parameter on the class containing the method or one on the method itself) when those type parameters are instantiated as reference types.</span></span>  
  
 <span data-ttu-id="253e3-235">Sie können diese Überladung verwenden, um eine bestimmte Instanziierung (z. B. ein Array von Typen) zu übergeben Klassentypparameter zuerst angeben, (sofern vorhanden), gefolgt von der Methode Typparameter (sofern vorhanden).</span><span class="sxs-lookup"><span data-stu-id="253e3-235">You can use this overload to pass a specific instantiation (such as an array of types), specifying class type parameters first (if any), followed by method type parameters (if any).</span></span> <span data-ttu-id="253e3-236">Die Laufzeit vorbereitet, Instanziierungen der Methode.</span><span class="sxs-lookup"><span data-stu-id="253e3-236">The runtime prepares that instantiation of the method.</span></span> <span data-ttu-id="253e3-237">(Dies ist nur erforderlich, wenn die Instanziierungen an, die Sie verwenden mindestens einen Verweisparameter Typ enthalten.) Daher können Sie eine CER-Format `try` -Klausel in einer generischen Methode (oder eine nicht generische Methode für eine generische Klasse) und es funktioniert zuverlässig mit Instanziierungen von <xref:System.Int32> oder andere Werttypen.</span><span class="sxs-lookup"><span data-stu-id="253e3-237">(This is necessary only if the instantiations you use contain at least one reference type parameter.) Thus, you can use a CER-style `try` clause in a generic method (or a nongeneric method on a generic class) and it will work reliably with instantiations of <xref:System.Int32> or other value types.</span></span> <span data-ttu-id="253e3-238">Referenz zu instanziieren Typen wie <xref:System.String>, verwenden Sie eine explizite <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> Methode für die CER-Stammmethode.</span><span class="sxs-lookup"><span data-stu-id="253e3-238">To instantiate reference types such as <xref:System.String>, you must use an explicit <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method on the CER root method first.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="253e3-239">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-239">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="253e3-240">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-240">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ProbeForSufficientStack">
      <MemberSignature Language="C#" Value="public static void ProbeForSufficientStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ProbeForSufficientStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ProbeForSufficientStack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ProbeForSufficientStack();" />
      <MemberSignature Language="F#" Value="static member ProbeForSufficientStack : unit -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="253e3-241">Führt eine Überprüfung auf eine bestimmte Menge an Stapelspeicher durch, um sicherzustellen, dass in einem nachfolgenden Codeblock kein Stapelüberlauf auftreten kann (vorausgesetzt, dass der Code selbst nur eine begrenzte und mittlere Menge an Stapelspeicher belegt).</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-241">Probes for a certain amount of stack space to ensure that a stack overflow cannot happen within a subsequent block of code (assuming that your code uses only a finite and moderate amount of stack space).</span>
          </span>
          <span data-ttu-id="253e3-242">Es wird empfohlen, anstelle dieser Methode einen eingeschränkten Ausführungsbereich (CER) zu verwenden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-242">We recommend that you use a constrained execution region (CER) instead of this method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="253e3-243">Diese Methode wird von der Ausführung mit eingeschränkten Ausführungsbereichs (CER)-Infrastruktur verwendet, wenn auf den Hosts ausgeführt werden, die auf einen Stapelüberlauf, z. B. Microsoft SQL Server und Microsoft Exchange Server stabil sind.</span><span class="sxs-lookup"><span data-stu-id="253e3-243">This method is used by the constrained execution region (CER) infrastructure when running in hosts that are resilient to stack overflow such as Microsoft SQL Server and Microsoft Exchange Server.</span></span> <span data-ttu-id="253e3-244">Diese Methode führt derzeit eine Überprüfung auf 48 KB an Stapelspeicher für die X86-Plattform, aber die genaue Durchsatzmenge, die im Laufe der Zeit ändern kann und auf anderen Plattformen abweichen.</span><span class="sxs-lookup"><span data-stu-id="253e3-244">This method currently probes for 48 KB of stack space on the x86 platform, but the exact amount may change over time and may vary on other platforms.</span></span>  
  
 <span data-ttu-id="253e3-245">Diese Methode wird auch vom Compiler verwendet.</span><span class="sxs-lookup"><span data-stu-id="253e3-245">This method is also used by compilers.</span></span>  
  
 <span data-ttu-id="253e3-246">Anstatt die <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> -Methode, sollten Sie einen standard-CER verwenden.</span><span class="sxs-lookup"><span data-stu-id="253e3-246">Instead of using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method, you should use a standard CER.</span></span> <span data-ttu-id="253e3-247">D. h., wenn Sie eine mittlere Menge an Stapelspeicher verwenden möchten, rufen die <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> Methode unmittelbar vor Ihrer `try` / `finally` oder `try` / `catch` Block.</span><span class="sxs-lookup"><span data-stu-id="253e3-247">That is, if you are planning to use a moderate amount of stack space, call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> method immediately before your `try`/`finally` or `try`/`catch` block.</span></span> <span data-ttu-id="253e3-248">Wenn Sie eine rekursive Methode oder einen Plan mit viel Stapelspeicher aufrufen, müssen Sie verwenden die <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="253e3-248">If you are calling a recursive method or plan to use a lot of stack space, you must use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="253e3-249">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-249">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="253e3-250">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-250">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="RunClassConstructor">
      <MemberSignature Language="C#" Value="public static void RunClassConstructor (RuntimeTypeHandle type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RunClassConstructor(valuetype System.RuntimeTypeHandle type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RunClassConstructor (type As RuntimeTypeHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RunClassConstructor(RuntimeTypeHandle type);" />
      <MemberSignature Language="F#" Value="static member RunClassConstructor : RuntimeTypeHandle -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="253e3-251">Ein Typhandle, das die auszuführende Klassenkonstruktormethode angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-251">A type handle that specifies the class constructor method to run.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="253e3-252">Führt eine angegebene Klassenkonstruktormethode aus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-252">Runs a specified class constructor method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="253e3-253">Diese Methode wird von Compilern verwendet.</span><span class="sxs-lookup"><span data-stu-id="253e3-253">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeInitializationException">
          <span data-ttu-id="253e3-254">Der Klasseninitialisierer löst eine Ausnahme aus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-254">The class initializer throws an exception.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RunModuleConstructor">
      <MemberSignature Language="C#" Value="public static void RunModuleConstructor (ModuleHandle module);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RunModuleConstructor(valuetype System.ModuleHandle module) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RunModuleConstructor (module As ModuleHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RunModuleConstructor(ModuleHandle module);" />
      <MemberSignature Language="F#" Value="static member RunModuleConstructor : ModuleHandle -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor module" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="module" Type="System.ModuleHandle" />
      </Parameters>
      <Docs>
        <param name="module">
          <span data-ttu-id="253e3-255">Ein Handle, das die auszuführende Modulkonstruktormethode angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-255">A handle that specifies the module constructor method to run.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="253e3-256">Führt eine angegebene Modulkonstruktormethode aus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-256">Runs a specified module constructor method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="253e3-257">Diese Methode wird von Compilern verwendet.</span><span class="sxs-lookup"><span data-stu-id="253e3-257">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeInitializationException">
          <span data-ttu-id="253e3-258">Der Modulkonstruktor löst eine Ausnahme aus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="253e3-258">The module constructor throws an exception.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnsureSufficientExecutionStack">
      <MemberSignature Language="C#" Value="public static bool TryEnsureSufficientExecutionStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnsureSufficientExecutionStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.TryEnsureSufficientExecutionStack" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnsureSufficientExecutionStack () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnsureSufficientExecutionStack();" />
      <MemberSignature Language="F#" Value="static member TryEnsureSufficientExecutionStack : unit -&gt; bool" Usage="System.Runtime.CompilerServices.RuntimeHelpers.TryEnsureSufficientExecutionStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>