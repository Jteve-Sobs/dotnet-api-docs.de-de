<Type Name="ConditionalWeakTable&lt;TKey,TValue&gt;" FullName="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="02c733ea9cf442ef3946e06cdf60d559321c5457" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52195592" /></Metadata><TypeSignature Language="C#" Value="public sealed class ConditionalWeakTable&lt;TKey,TValue&gt; where TKey : class where TValue : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ConditionalWeakTable`2&lt;class TKey, class TValue&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ConditionalWeakTable(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA; where TKey : class where TValue : classpublic ref class ConditionalWeakTable sealed" />
  <TypeSignature Language="F#" Value="type ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="TValue">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Der Verweistyp, an den das Feld angefügt ist.</typeparam>
    <typeparam name="TValue">Der Typ des Felds. Dieser Typ muss ein Referenztyp sein.</typeparam>
    <summary>Ermöglicht, dass Compiler dynamisch Objektfelder an verwaltete Objekte anfügen können.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Klasse ermöglicht, dass Language Compiler beliebige Eigenschaften zur Laufzeit an verwaltete Objekte anfügen. Ein <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Objekt ist ein Wörterbuch, das ein verwaltetes Objekt, das dargestellt wird, anhand eines Schlüssels, der angefügten Eigenschaft, die durch einen Wert dargestellt wird, bindet. Die Schlüssel des Objekts werden die einzelnen Instanzen von der `TKey` -Klasse, die Eigenschaft angefügt ist, und seine Werte sind die Eigenschaftswerte, die mit den entsprechenden Objekten zugewiesen sind.  
  
 Schlüssel müssen eindeutig sein; Das heißt, die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> -Klasse unterstützt einen angefügten Wert pro verwaltetes Objekt. Zwei Schlüssel sind gleich, wenn sie übergeben die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methodenrückgabe `true`.  
  
> [!NOTE]
>  Sie können nicht die Durchführung von Gleichheitsvergleichen steuern, durch Überschreiben <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> explizit den Hashcode für einen Schlüssel festzulegen. Die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Klasse verwendet nicht die <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> Methode berechnet die Hashcodes und daher nicht aufgerufen <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> überschreibt.  
  
 Obwohl die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> -Klasse enthält eine Auflistung von Schlüssel/Wert-Paare, es am besten versteht man eine Tabelle, sondern als ein Dictionary-Objekt. Die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Klasse unterscheidet sich von einem Wörterbuch auf verschiedene Weise:  
  
-   Es werden keine Schlüssel beibehalten. Ein Schlüssel ist, also nicht aktiv beibehalten, da es sich um einen Member der Auflistung ist.  
  
-   Alle Methoden sind nicht enthalten (z. B. `GetEnumerator` oder `Contains`), das ein Wörterbuch in der Regel verfügt.  
  
-   Sie implementiert nicht die <xref:System.Collections.Generic.IDictionary%602> Schnittstelle.  
  
 Die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Klasse unterscheidet sich von anderen Auflistungsobjekten in die Verwaltung der Objektlebensdauer in der Auflistung gespeicherten Schlüssel. Wenn ein Objekt in einer Sammlung gespeichert werden, dauert seine Lebensdauer normalerweise, bis er entfernt ist (und es keine weiteren Verweise auf das Objekt gibt) oder das Auflistungsobjekt selbst zerstört wird. In der <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> -Klasse, indem die Schlüssel/Wert-Paar in die Tabelle wird nicht sichergestellt, dass der Schlüssel beibehalten wird, auch wenn er direkt aus einem Wert, der in der Tabelle (z. B., wenn die Tabelle einen Schlüssel ein, mit dem Wert V1 enthält gespeicherte erreicht werden kann und eine zweite Taste B, mit dem Wert von P2, der einen Verweis auf ein enthält). Stattdessen <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> den Schlüssel/Wert-Eintrag automatisch entfernt, sobald keine anderen Verweise auf einen Schlüssel außerhalb der Tabelle vorhanden sind. Dies wird im Beispiel veranschaulicht.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, dass ein Schlüssel, in gespeichert der <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> nach Verweise darauf außerhalb der Tabelle gelöscht werden, wird die Tabelle nicht beibehalten. Im Beispiel werden zwei Klassen definiert: `ManagedClass`, steht für den Schlüssel in der Tabelle und `ClassData`, der den Wert des Schlüssels darstellt. Im Beispiel werden drei Objekte jedes Typs instanziiert. Instanziiert auch ein <xref:System.WeakReference> -Objekt, das die Sekunde darstellt `ManagedClass`, und klicken Sie dann zerstört das zweite `ManagedClass` Instanz. Beim Abrufen der zweiten `ManagedClass` -Objekt aus der <xref:System.WeakReference.Target%2A> Eigenschaft gibt an, dass keine Verweise auf das Objekt bleiben.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/cs/example1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/vb/example1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Instanzen der <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> Klasse sind threadsicher. Sie erfordern keine Aufrufer weiteren Sperren führen.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConditionalWeakTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> Konstruktor instanziiert einen leeren <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Tabelle; d. h., der die Tabelle keine Schlüssel/Wert-Paare enthält. Sie können die Schlüssel/Wert-Paare hinzufügen, durch den Aufruf der <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>, oder <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> Methode.  
  
 Jeder Schlüssel im einem <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Objekt muss eindeutig sein. Schlüssel sind nicht eindeutig, wenn sie auf das gleiche Objekt verweisen (d. h., wenn diese übergeben als Argumente an die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methodenrückgabe `true`).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.Add : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.Add (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">Der hinzuzufügende Schlüssel. <paramref name="key" /> stellt das Objekt dar, an das die Eigenschaft angefügt ist.</param>
        <param name="value">Der Eigenschaftswert des Schlüssels.</param>
        <summary>Fügt der Tabelle einen Schlüssel hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel im einem <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Objekt muss eindeutig sein. Schlüssel sind nicht eindeutig, wenn sie auf das gleiche Objekt verweisen (d. h., wenn diese übergeben als Argumente an die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methodenrückgabe `true`).  
  
 Wenn der Schlüssel Garbage collection während des Vorgangs hinzufügen, vorhandene Schlüssel/Wert-Paar entfernt wird und neue Schlüssel/Wert-Paar wird hinzugefügt, ohne eine Ausnahme ausgelöst wird.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine `MainClass` Klasse und ein `MainInfo` -Klasse, die Informationen zu den `MainClass` Instanz. Das Beispiel ruft dann die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> -Methode zum Hinzufügen einer `MainClass` Objekt und seine angefügten `MainInfo` -Objekt an eine <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Tabelle. Das Beispiel veranschaulicht auch Aufrufe an die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> und <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> Methoden zum Hinzufügen von Schlüssel/Wert-Paare in der Tabelle, und klicken Sie auf die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> Methode zum Abrufen des Werts eines vorhandenen Schlüssels.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="key" /> ist bereits vorhanden.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate">
      <MemberSignature Language="C#" Value="public void AddOrUpdate (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOrUpdate(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.AddOrUpdate(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOrUpdate (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOrUpdate(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.AddOrUpdate : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.AddOrUpdate (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="conditionalWeakTable.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ConditionalWeakTable`2 ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="conditionalWeakTable.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt das Freigeben von Ressourcen und das Ausführen anderer Garbage Collector-Vorgänge sicher, wenn der Garbage Collector das <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />-Objekt verarbeitet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Garbage Collector ruft <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A> Wenn das aktuelle Objekt wird finalisiert werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateValue">
      <MemberSignature Language="C#" Value="public TValue GetOrCreateValue (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrCreateValue(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrCreateValue (key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetOrCreateValue(TKey key);" />
      <MemberSignature Language="F#" Value="member this.GetOrCreateValue : 'Key -&gt; 'Value" Usage="conditionalWeakTable.GetOrCreateValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der zu suchende Schlüssel. <paramref name="key" /> stellt das Objekt dar, an das die Eigenschaft angefügt ist.</param>
        <summary>Sucht atomar nach einem angegebenen Schlüssel in der Tabelle und gibt den entsprechenden Wert zurück. Wenn der Schlüssel in der Tabelle nicht vorhanden ist, ruft die Methode den Standardkonstruktor der Klasse auf, die den Wert der Tabelle darstellt, um einen Wert zu erstellen, der an den angegebenen Schlüssel gebunden wird.</summary>
        <returns>Der Wert, der <paramref name="key" /> entspricht, wenn <paramref name="key" /> bereits in der Tabelle vorhanden ist, andernfalls ein von dem vom generischen <paramref name="TValue" />-Typparameter definierten Standardkonstruktor der Klasse erstellter neuer Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `key` existiert nicht in der Tabelle der Methode hinzugefügt, zusammen mit dem Objekt, die instanziiert wird, durch den Aufruf der Standardkonstruktor der Klasse definiert werden, indem die `TValue` generischen Typparameter. Wenn die `TValue` -Klasse verfügt über keinen Standardkonstruktor eine <xref:System.MissingMethodException> ausgelöst.  
  
 Dies ist die empfohlene Methode zum Abrufen eines vorhandenen Werts oder Hinzufügen eines neuen Werts, der <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Tabelle, wenn die Klasse den Wert der Tabelle einen standardmäßigen Konstruktor definiert. Wenn sie einen Standardkonstruktor nicht definiert, können Sie stattdessen Aufrufen der <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> -Methode, die basiert auf eine Methode bereitgestellten Rückruf zum Instanziieren des Objekts, das den Wert der Tabelle darstellt.  
  
 Den Wert eines vorhandenen Schlüssels abrufen, ohne Hinzufügen von Schlüssel/Wert-Paar aufrufen, wenn der Schlüssel nicht, in der Tabelle gefunden wird die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine `MainClass` Klasse und ein `MainInfo` -Klasse, die Informationen zu den `MainClass` Instanz. Im Beispiel wird die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> -Methode zum Hinzufügen einer `MainClass` Objekt und seine angefügten `MainInfo` -Objekt an eine <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Tabelle. Das Beispiel veranschaulicht auch Aufrufe an die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> und <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> Methoden zum Hinzufügen von Schlüssel/Wert-Paare in der Tabelle, und klicken Sie auf die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> Methode zum Abrufen des Werts eines vorhandenen Schlüssels.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException"><block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.MissingMemberException" /> ab.  
  
</para>
          </block>  
  
 Die Klasse, die den Wert der Tabelle darstellt, definiert keinen Standardkonstruktor.</exception>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public TValue GetValue (TKey key, System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;.CreateValueCallback createValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetValue(!TKey key, class System.Runtime.CompilerServices.ConditionalWeakTable`2/CreateValueCallback&lt;!TKey, !TValue&gt; createValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetValue(TKey key, System::Runtime::CompilerServices::ConditionalWeakTable&lt;TKey, TValue&gt;::CreateValueCallback ^ createValueCallback);" />
      <MemberSignature Language="F#" Value="member this.GetValue : 'Key * System.Runtime.CompilerServices.ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt;.CreateValueCallback -&gt; 'Value" Usage="conditionalWeakTable.GetValue (key, createValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="createValueCallback" Type="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;+CreateValueCallback" />
      </Parameters>
      <Docs>
        <param name="key">Der zu suchende Schlüssel. <paramref name="key" /> stellt das Objekt dar, an das die Eigenschaft angefügt ist.</param>
        <param name="createValueCallback">Ein Delegat zu einer Methode, die einen Wert für den angegebenen <paramref name="key" /> erstellen kann. Er verfügt über einen einzelnen Parameter vom Typ <c>TKey</c> und gibt einen Wert vom Typ <c>TValue</c> zurück.</param>
        <summary>Sucht atomar nach einem angegebenen Schlüssel in der Tabelle und gibt den entsprechenden Wert zurück. Wenn der Schlüssel in der Tabelle nicht vorhanden ist, ruft die Methode eine Rückrufmethode auf, um einen Wert zu erstellen, der an den angegebenen Schlüssel gebunden ist.</summary>
        <returns>Der an <paramref name="key" /> angefügte Wert, wenn <paramref name="key" /> bereits in der Tabelle vorhanden ist, andernfalls der vom <paramref name="createValueCallback" />-Delegaten zurückgegebene neue Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `key` existiert nicht in der Tabelle <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> Ruft die Methode, die von definiert ist die `createValueCallback` Parameter und übergibt sie den Schlüssel. Ein neuer Wert wurde an den Schlüssel in der Tabelle gebunden und als Ergebnis zurückgegeben.  
  
 Verwenden Sie diese Methode nur, wenn die Klasse, die den Wert der Tabelle stellt einen standardmäßigen Konstruktor nicht definiert ist. Wenn sie einen standardmäßigen Konstruktor definiert, verwendet der <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> Methode stattdessen. Den Wert eines vorhandenen Schlüssels abrufen, ohne Hinzufügen von Schlüssel/Wert-Paar aufrufen, wenn der Schlüssel nicht, in der Tabelle gefunden wird die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> Methode.  
  
 Wenn mehrere Threads versuchen, den gleichen Schlüssel erstellen `createValueCallback` kann mehrere Male aufgerufen werden, mit dem gleichen Schlüssel. Nur eine dieser Aufrufe ist erfolgreich, und der zurückgegebene Wert wird in der Tabelle hinzugefügt werden. Der Thread ist erfolgreich, bei der Erstellung des Werts ist unbestimmt. Diese Regel erlaubt, in der Tabelle aufrufen `createValueCallback` außerhalb der internen Tabellensperre, um Deadlocks zu verhindern.  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine `MainClass` Klasse und ein `MainInfo` -Klasse, die Informationen zu den `MainClass` Instanz. Sie definiert außerdem eine statische (`Shared` in Visual Basic) `CreateAttachedValue` -Methode, die zugewiesen werden kann die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> delegieren und an die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> Methode. Im Beispiel wird die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> -Methode zum Hinzufügen einer `MainClass` Objekt und seine angefügten `MainInfo` -Objekt an eine <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Tabelle. Das Beispiel veranschaulicht auch Aufrufe an die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> und <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> Methoden zum Hinzufügen von Schlüssel/Wert-Paare in der Tabelle, und klicken Sie auf die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> Methode zum Abrufen des Werts eines vorhandenen Schlüssels.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> oder <paramref name="createValueCallback" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
        <altmember cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="member this.Remove : 'Key -&gt; bool" Usage="conditionalWeakTable.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der zu entfernende Schlüssel.</param>
        <summary>Entfernt einen Schlüssel und seinen Wert aus der Tabelle.</summary>
        <returns><see langword="true" />, wenn der Schlüssel gefunden und entfernt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Schlüssel Garbage collection während dieses Vorgangs ist, die Methode löst keine Ausnahme aus, und der Rückgabewert nicht definiert ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key *  -&gt; bool" Usage="conditionalWeakTable.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel, der ein Objekt mit einer angefügten Eigenschaft darstellt.</param>
        <param name="value">Enthält nach dem Beenden dieser Methode den angefügten Eigenschaftswert. <paramref name="key" /> enthält den Standardwert, wenn <paramref name="value" /> nicht gefunden wird.</param>
        <summary>Ruft den Wert des angegebenen Schlüssels ab.</summary>
        <returns><see langword="true" />, wenn <paramref name="key" /> gefunden wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Schlüssel Garbage collection während dieses Vorgangs ist, kann die Methode zurückgeben `false` und `value` auf den Standardwert Wert (als ob der Schlüssel nicht vorhanden waren).  
  
   
  
## Examples  
 Das folgende Beispiel definiert eine `MainClass` Klasse und ein `MainInfo` -Klasse, die Informationen zu den `MainClass` Instanz. Im Beispiel wird die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>, und <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> Methoden zum Hinzufügen von Schlüssel/Wert-Paare, um eine <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Tabelle. In jedem Fall im Beispiel wird die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> Methode, um sicherzustellen, dass die Schlüssel/Wert-Paar in der Tabelle hinzugefügt wurde.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
      </Docs>
    </Member>
  </Members>
</Type>