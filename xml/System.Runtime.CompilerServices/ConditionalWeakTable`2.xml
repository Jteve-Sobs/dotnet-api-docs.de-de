<Type Name="ConditionalWeakTable&lt;TKey,TValue&gt;" FullName="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="02c733ea9cf442ef3946e06cdf60d559321c5457" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52195592" /></Metadata><TypeSignature Language="C#" Value="public sealed class ConditionalWeakTable&lt;TKey,TValue&gt; where TKey : class where TValue : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ConditionalWeakTable`2&lt;class TKey, class TValue&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ConditionalWeakTable(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA; where TKey : class where TValue : classpublic ref class ConditionalWeakTable sealed" />
  <TypeSignature Language="F#" Value="type ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="TValue">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey"><span data-ttu-id="43891-101">Der Verweistyp, an den das Feld angefügt ist.</span><span class="sxs-lookup"><span data-stu-id="43891-101">The reference type to which the field is attached.</span></span></typeparam>
    <typeparam name="TValue"><span data-ttu-id="43891-102">Der Typ des Felds.</span><span class="sxs-lookup"><span data-stu-id="43891-102">The field's type.</span></span> <span data-ttu-id="43891-103">Dieser Typ muss ein Referenztyp sein.</span><span class="sxs-lookup"><span data-stu-id="43891-103">This must be a reference type.</span></span></typeparam>
    <summary><span data-ttu-id="43891-104">Ermöglicht, dass Compiler dynamisch Objektfelder an verwaltete Objekte anfügen können.</span><span class="sxs-lookup"><span data-stu-id="43891-104">Enables compilers to dynamically attach object fields to managed objects.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43891-105">Die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Klasse ermöglicht, dass Language Compiler beliebige Eigenschaften zur Laufzeit an verwaltete Objekte anfügen.</span><span class="sxs-lookup"><span data-stu-id="43891-105">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class enables language compilers to attach arbitrary properties to managed objects at run time.</span></span> <span data-ttu-id="43891-106">Ein <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Objekt ist ein Wörterbuch, das ein verwaltetes Objekt, das dargestellt wird, anhand eines Schlüssels, der angefügten Eigenschaft, die durch einen Wert dargestellt wird, bindet.</span><span class="sxs-lookup"><span data-stu-id="43891-106">A <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object is a dictionary that binds a managed object, which is represented by a key, to its attached property, which is represented by a value.</span></span> <span data-ttu-id="43891-107">Die Schlüssel des Objekts werden die einzelnen Instanzen von der `TKey` -Klasse, die Eigenschaft angefügt ist, und seine Werte sind die Eigenschaftswerte, die mit den entsprechenden Objekten zugewiesen sind.</span><span class="sxs-lookup"><span data-stu-id="43891-107">The object's keys are the individual instances of the `TKey` class to which the property is attached, and its values are the property values that are assigned to the corresponding objects.</span></span>  
  
 <span data-ttu-id="43891-108">Schlüssel müssen eindeutig sein; Das heißt, die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> -Klasse unterstützt einen angefügten Wert pro verwaltetes Objekt.</span><span class="sxs-lookup"><span data-stu-id="43891-108">Keys must be unique; in other words, the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class supports one attached value per managed object.</span></span> <span data-ttu-id="43891-109">Zwei Schlüssel sind gleich, wenn sie übergeben die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methodenrückgabe `true`.</span><span class="sxs-lookup"><span data-stu-id="43891-109">Two keys are equal if passing them to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="43891-110">Sie können nicht die Durchführung von Gleichheitsvergleichen steuern, durch Überschreiben <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> explizit den Hashcode für einen Schlüssel festzulegen.</span><span class="sxs-lookup"><span data-stu-id="43891-110">You cannot control equality comparisons by overriding <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> to explicitly set the hash code for a key.</span></span> <span data-ttu-id="43891-111">Die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Klasse verwendet nicht die <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> Methode berechnet die Hashcodes und daher nicht aufgerufen <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> überschreibt.</span><span class="sxs-lookup"><span data-stu-id="43891-111">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class does not use the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method to compute hash codes, and therefore does not invoke <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> overrides.</span></span>  
  
 <span data-ttu-id="43891-112">Obwohl die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> -Klasse enthält eine Auflistung von Schlüssel/Wert-Paare, es am besten versteht man eine Tabelle, sondern als ein Dictionary-Objekt.</span><span class="sxs-lookup"><span data-stu-id="43891-112">Although the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class holds a collection of key/value pairs, it is best thought of as a table rather than a dictionary object.</span></span> <span data-ttu-id="43891-113">Die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Klasse unterscheidet sich von einem Wörterbuch auf verschiedene Weise:</span><span class="sxs-lookup"><span data-stu-id="43891-113">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class differs from a dictionary in several ways:</span></span>  
  
-   <span data-ttu-id="43891-114">Es werden keine Schlüssel beibehalten.</span><span class="sxs-lookup"><span data-stu-id="43891-114">It does not persist keys.</span></span> <span data-ttu-id="43891-115">Ein Schlüssel ist, also nicht aktiv beibehalten, da es sich um einen Member der Auflistung ist.</span><span class="sxs-lookup"><span data-stu-id="43891-115">That is, a key is not kept alive only because it is a member of the collection.</span></span>  
  
-   <span data-ttu-id="43891-116">Alle Methoden sind nicht enthalten (z. B. `GetEnumerator` oder `Contains`), das ein Wörterbuch in der Regel verfügt.</span><span class="sxs-lookup"><span data-stu-id="43891-116">It does not include all the methods (such as `GetEnumerator` or `Contains`) that a dictionary typically has.</span></span>  
  
-   <span data-ttu-id="43891-117">Sie implementiert nicht die <xref:System.Collections.Generic.IDictionary%602> Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="43891-117">It does not implement the <xref:System.Collections.Generic.IDictionary%602> interface.</span></span>  
  
 <span data-ttu-id="43891-118">Die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Klasse unterscheidet sich von anderen Auflistungsobjekten in die Verwaltung der Objektlebensdauer in der Auflistung gespeicherten Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="43891-118">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class differs from other collection objects in its management of the object lifetime of keys stored in the collection.</span></span> <span data-ttu-id="43891-119">Wenn ein Objekt in einer Sammlung gespeichert werden, dauert seine Lebensdauer normalerweise, bis er entfernt ist (und es keine weiteren Verweise auf das Objekt gibt) oder das Auflistungsobjekt selbst zerstört wird.</span><span class="sxs-lookup"><span data-stu-id="43891-119">Ordinarily, when an object is stored in a collection, its lifetime lasts until it is removed (and there are no additional references to the object) or until the collection object itself is destroyed.</span></span> <span data-ttu-id="43891-120">In der <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> -Klasse, indem die Schlüssel/Wert-Paar in die Tabelle wird nicht sichergestellt, dass der Schlüssel beibehalten wird, auch wenn er direkt aus einem Wert, der in der Tabelle (z. B., wenn die Tabelle einen Schlüssel ein, mit dem Wert V1 enthält gespeicherte erreicht werden kann und eine zweite Taste B, mit dem Wert von P2, der einen Verweis auf ein enthält).</span><span class="sxs-lookup"><span data-stu-id="43891-120">However, in the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class, adding a key/value pair to the table does not ensure that the key will persist, even if it can be reached directly from a value stored in the table (for example, if the table contains one key, A, with a value V1, and a second key, B, with a value P2 that contains a reference to A).</span></span> <span data-ttu-id="43891-121">Stattdessen <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> den Schlüssel/Wert-Eintrag automatisch entfernt, sobald keine anderen Verweise auf einen Schlüssel außerhalb der Tabelle vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="43891-121">Instead, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> automatically removes the key/value entry as soon as no other references to a key exist outside the table.</span></span> <span data-ttu-id="43891-122">Dies wird im Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="43891-122">The example provides an illustration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43891-123">Das folgende Beispiel zeigt, dass ein Schlüssel, in gespeichert der <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> nach Verweise darauf außerhalb der Tabelle gelöscht werden, wird die Tabelle nicht beibehalten.</span><span class="sxs-lookup"><span data-stu-id="43891-123">The following example illustrates that a key stored in the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table does not persist after references to it outside the table are destroyed.</span></span> <span data-ttu-id="43891-124">Im Beispiel werden zwei Klassen definiert: `ManagedClass`, steht für den Schlüssel in der Tabelle und `ClassData`, der den Wert des Schlüssels darstellt.</span><span class="sxs-lookup"><span data-stu-id="43891-124">The example defines two classes: `ManagedClass`, which represents the key in the table, and `ClassData`, which represents the key's value.</span></span> <span data-ttu-id="43891-125">Im Beispiel werden drei Objekte jedes Typs instanziiert.</span><span class="sxs-lookup"><span data-stu-id="43891-125">The example instantiates three objects of each type.</span></span> <span data-ttu-id="43891-126">Instanziiert auch ein <xref:System.WeakReference> -Objekt, das die Sekunde darstellt `ManagedClass`, und klicken Sie dann zerstört das zweite `ManagedClass` Instanz.</span><span class="sxs-lookup"><span data-stu-id="43891-126">It also instantiates a <xref:System.WeakReference> object that represents the second `ManagedClass`, and then destroys the second `ManagedClass` instance.</span></span> <span data-ttu-id="43891-127">Beim Abrufen der zweiten `ManagedClass` -Objekt aus der <xref:System.WeakReference.Target%2A> Eigenschaft gibt an, dass keine Verweise auf das Objekt bleiben.</span><span class="sxs-lookup"><span data-stu-id="43891-127">The attempt to retrieve the second `ManagedClass` object from the <xref:System.WeakReference.Target%2A> property indicates that no references to the object remain.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/cs/example1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/vb/example1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="43891-128">Instanzen der <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> Klasse sind threadsicher.</span><span class="sxs-lookup"><span data-stu-id="43891-128">Instances of the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> class are thread safe.</span></span> <span data-ttu-id="43891-129">Sie erfordern keine Aufrufer weiteren Sperren führen.</span><span class="sxs-lookup"><span data-stu-id="43891-129">They do not require callers to do any additional locking.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConditionalWeakTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43891-130">Initialisiert eine neue Instanz der <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="43891-130">Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43891-131">Die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> Konstruktor instanziiert einen leeren <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Tabelle; d. h., der die Tabelle keine Schlüssel/Wert-Paare enthält.</span><span class="sxs-lookup"><span data-stu-id="43891-131">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> constructor instantiates an empty <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table; that is, the table contains no key/value pairs.</span></span> <span data-ttu-id="43891-132">Sie können die Schlüssel/Wert-Paare hinzufügen, durch den Aufruf der <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>, oder <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="43891-132">You can add key/value pairs by calling the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>, or <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method.</span></span>  
  
 <span data-ttu-id="43891-133">Jeder Schlüssel im einem <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Objekt muss eindeutig sein.</span><span class="sxs-lookup"><span data-stu-id="43891-133">Every key in a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object must be unique.</span></span> <span data-ttu-id="43891-134">Schlüssel sind nicht eindeutig, wenn sie auf das gleiche Objekt verweisen (d. h., wenn diese übergeben als Argumente an die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methodenrückgabe `true`).</span><span class="sxs-lookup"><span data-stu-id="43891-134">Keys are not unique if they refer to the same object (that is, if passing them as arguments to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.Add : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.Add (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="43891-135">Der hinzuzufügende Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="43891-135">The key to add.</span></span> <span data-ttu-id="43891-136"><paramref name="key" /> stellt das Objekt dar, an das die Eigenschaft angefügt ist.</span><span class="sxs-lookup"><span data-stu-id="43891-136"><paramref name="key" /> represents the object to which the property is attached.</span></span></param>
        <param name="value"><span data-ttu-id="43891-137">Der Eigenschaftswert des Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="43891-137">The key's property value.</span></span></param>
        <summary><span data-ttu-id="43891-138">Fügt der Tabelle einen Schlüssel hinzu.</span><span class="sxs-lookup"><span data-stu-id="43891-138">Adds a key to the table.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43891-139">Jeder Schlüssel im einem <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Objekt muss eindeutig sein.</span><span class="sxs-lookup"><span data-stu-id="43891-139">Every key in a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object must be unique.</span></span> <span data-ttu-id="43891-140">Schlüssel sind nicht eindeutig, wenn sie auf das gleiche Objekt verweisen (d. h., wenn diese übergeben als Argumente an die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Methodenrückgabe `true`).</span><span class="sxs-lookup"><span data-stu-id="43891-140">Keys are not unique if they refer to the same object (that is, if passing them as arguments to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`).</span></span>  
  
 <span data-ttu-id="43891-141">Wenn der Schlüssel Garbage collection während des Vorgangs hinzufügen, vorhandene Schlüssel/Wert-Paar entfernt wird und neue Schlüssel/Wert-Paar wird hinzugefügt, ohne eine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="43891-141">If the key is garbage-collected during the addition operation, the existing key/value pair is removed and the new key/value pair is added without an exception being thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43891-142">Das folgende Beispiel definiert eine `MainClass` Klasse und ein `MainInfo` -Klasse, die Informationen zu den `MainClass` Instanz.</span><span class="sxs-lookup"><span data-stu-id="43891-142">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="43891-143">Das Beispiel ruft dann die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> -Methode zum Hinzufügen einer `MainClass` Objekt und seine angefügten `MainInfo` -Objekt an eine <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Tabelle.</span><span class="sxs-lookup"><span data-stu-id="43891-143">The example then calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="43891-144">Das Beispiel veranschaulicht auch Aufrufe an die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> und <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> Methoden zum Hinzufügen von Schlüssel/Wert-Paare in der Tabelle, und klicken Sie auf die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> Methode zum Abrufen des Werts eines vorhandenen Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="43891-144">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43891-145"><paramref name="key" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="43891-145"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="43891-146"><paramref name="key" /> ist bereits vorhanden.</span><span class="sxs-lookup"><span data-stu-id="43891-146"><paramref name="key" /> already exists.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="43891-147">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="43891-147">requires full trust for the immediate caller.</span></span> <span data-ttu-id="43891-148">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="43891-148">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate">
      <MemberSignature Language="C#" Value="public void AddOrUpdate (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOrUpdate(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.AddOrUpdate(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOrUpdate (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOrUpdate(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.AddOrUpdate : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.AddOrUpdate (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="conditionalWeakTable.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ConditionalWeakTable`2 ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="conditionalWeakTable.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="43891-149">Stellt das Freigeben von Ressourcen und das Ausführen anderer Garbage Collector-Vorgänge sicher, wenn der Garbage Collector das <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />-Objekt verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="43891-149">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43891-150">Der Garbage Collector ruft <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A> Wenn das aktuelle Objekt wird finalisiert werden.</span><span class="sxs-lookup"><span data-stu-id="43891-150">The garbage collector calls <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A> when the current object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateValue">
      <MemberSignature Language="C#" Value="public TValue GetOrCreateValue (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrCreateValue(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrCreateValue (key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetOrCreateValue(TKey key);" />
      <MemberSignature Language="F#" Value="member this.GetOrCreateValue : 'Key -&gt; 'Value" Usage="conditionalWeakTable.GetOrCreateValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="43891-151">Der zu suchende Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="43891-151">The key to search for.</span></span> <span data-ttu-id="43891-152"><paramref name="key" /> stellt das Objekt dar, an das die Eigenschaft angefügt ist.</span><span class="sxs-lookup"><span data-stu-id="43891-152"><paramref name="key" /> represents the object to which the property is attached.</span></span></param>
        <summary><span data-ttu-id="43891-153">Sucht atomar nach einem angegebenen Schlüssel in der Tabelle und gibt den entsprechenden Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="43891-153">Atomically searches for a specified key in the table and returns the corresponding value.</span></span> <span data-ttu-id="43891-154">Wenn der Schlüssel in der Tabelle nicht vorhanden ist, ruft die Methode den Standardkonstruktor der Klasse auf, die den Wert der Tabelle darstellt, um einen Wert zu erstellen, der an den angegebenen Schlüssel gebunden wird.</span><span class="sxs-lookup"><span data-stu-id="43891-154">If the key does not exist in the table, the method invokes the default constructor of the class that represents the table's value to create a value that is bound to the specified key.</span></span></summary>
        <returns><span data-ttu-id="43891-155">Der Wert, der <paramref name="key" /> entspricht, wenn <paramref name="key" /> bereits in der Tabelle vorhanden ist, andernfalls ein von dem vom generischen <paramref name="TValue" />-Typparameter definierten Standardkonstruktor der Klasse erstellter neuer Wert.</span><span class="sxs-lookup"><span data-stu-id="43891-155">The value that corresponds to <paramref name="key" />, if <paramref name="key" /> already exists in the table; otherwise, a new value created by the default constructor of the class defined by the <paramref name="TValue" /> generic type parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43891-156">Wenn `key` existiert nicht in der Tabelle der Methode hinzugefügt, zusammen mit dem Objekt, die instanziiert wird, durch den Aufruf der Standardkonstruktor der Klasse definiert werden, indem die `TValue` generischen Typparameter.</span><span class="sxs-lookup"><span data-stu-id="43891-156">If `key` does not exist in the table, the method adds it, along with the object that is instantiated by calling the default constructor of the class defined by the `TValue` generic type parameter.</span></span> <span data-ttu-id="43891-157">Wenn die `TValue` -Klasse verfügt über keinen Standardkonstruktor eine <xref:System.MissingMethodException> ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="43891-157">If the `TValue` class has no default constructor, a <xref:System.MissingMethodException> is thrown.</span></span>  
  
 <span data-ttu-id="43891-158">Dies ist die empfohlene Methode zum Abrufen eines vorhandenen Werts oder Hinzufügen eines neuen Werts, der <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Tabelle, wenn die Klasse den Wert der Tabelle einen standardmäßigen Konstruktor definiert.</span><span class="sxs-lookup"><span data-stu-id="43891-158">This is the recommended method of retrieving an existing value or adding a new value to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table if the class of the table's value defines a default constructor.</span></span> <span data-ttu-id="43891-159">Wenn sie einen Standardkonstruktor nicht definiert, können Sie stattdessen Aufrufen der <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> -Methode, die basiert auf eine Methode bereitgestellten Rückruf zum Instanziieren des Objekts, das den Wert der Tabelle darstellt.</span><span class="sxs-lookup"><span data-stu-id="43891-159">If it does not define a default constructor, you can instead call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method, which relies on a callback-provided method to instantiate the object representing the table's value</span></span>  
  
 <span data-ttu-id="43891-160">Den Wert eines vorhandenen Schlüssels abrufen, ohne Hinzufügen von Schlüssel/Wert-Paar aufrufen, wenn der Schlüssel nicht, in der Tabelle gefunden wird die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="43891-160">To retrieve the value of an existing key without adding the key/value pair if the key is not found in the table, call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43891-161">Das folgende Beispiel definiert eine `MainClass` Klasse und ein `MainInfo` -Klasse, die Informationen zu den `MainClass` Instanz.</span><span class="sxs-lookup"><span data-stu-id="43891-161">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="43891-162">Im Beispiel wird die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> -Methode zum Hinzufügen einer `MainClass` Objekt und seine angefügten `MainInfo` -Objekt an eine <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Tabelle.</span><span class="sxs-lookup"><span data-stu-id="43891-162">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="43891-163">Das Beispiel veranschaulicht auch Aufrufe an die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> und <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> Methoden zum Hinzufügen von Schlüssel/Wert-Paare in der Tabelle, und klicken Sie auf die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> Methode zum Abrufen des Werts eines vorhandenen Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="43891-163">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43891-164"><paramref name="key" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="43891-164"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="43891-165">Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.MissingMemberException" /> ab.</span><span class="sxs-lookup"><span data-stu-id="43891-165">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.MissingMemberException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="43891-166">Die Klasse, die den Wert der Tabelle darstellt, definiert keinen Standardkonstruktor.</span><span class="sxs-lookup"><span data-stu-id="43891-166">The class that represents the table's value does not define a default constructor.</span></span></exception>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public TValue GetValue (TKey key, System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;.CreateValueCallback createValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetValue(!TKey key, class System.Runtime.CompilerServices.ConditionalWeakTable`2/CreateValueCallback&lt;!TKey, !TValue&gt; createValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetValue(TKey key, System::Runtime::CompilerServices::ConditionalWeakTable&lt;TKey, TValue&gt;::CreateValueCallback ^ createValueCallback);" />
      <MemberSignature Language="F#" Value="member this.GetValue : 'Key * System.Runtime.CompilerServices.ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt;.CreateValueCallback -&gt; 'Value" Usage="conditionalWeakTable.GetValue (key, createValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="createValueCallback" Type="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;+CreateValueCallback" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="43891-167">Der zu suchende Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="43891-167">The key to search for.</span></span> <span data-ttu-id="43891-168"><paramref name="key" /> stellt das Objekt dar, an das die Eigenschaft angefügt ist.</span><span class="sxs-lookup"><span data-stu-id="43891-168"><paramref name="key" /> represents the object to which the property is attached.</span></span></param>
        <param name="createValueCallback"><span data-ttu-id="43891-169">Ein Delegat zu einer Methode, die einen Wert für den angegebenen <paramref name="key" /> erstellen kann.</span><span class="sxs-lookup"><span data-stu-id="43891-169">A delegate to a method that can create a value for the given <paramref name="key" />.</span></span> <span data-ttu-id="43891-170">Er verfügt über einen einzelnen Parameter vom Typ <c>TKey</c> und gibt einen Wert vom Typ <c>TValue</c> zurück.</span><span class="sxs-lookup"><span data-stu-id="43891-170">It has a single parameter of type <c>TKey</c>, and returns a value of type <c>TValue</c>.</span></span></param>
        <summary><span data-ttu-id="43891-171">Sucht atomar nach einem angegebenen Schlüssel in der Tabelle und gibt den entsprechenden Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="43891-171">Atomically searches for a specified key in the table and returns the corresponding value.</span></span> <span data-ttu-id="43891-172">Wenn der Schlüssel in der Tabelle nicht vorhanden ist, ruft die Methode eine Rückrufmethode auf, um einen Wert zu erstellen, der an den angegebenen Schlüssel gebunden ist.</span><span class="sxs-lookup"><span data-stu-id="43891-172">If the key does not exist in the table, the method invokes a callback method to create a value that is bound to the specified key.</span></span></summary>
        <returns><span data-ttu-id="43891-173">Der an <paramref name="key" /> angefügte Wert, wenn <paramref name="key" /> bereits in der Tabelle vorhanden ist, andernfalls der vom <paramref name="createValueCallback" />-Delegaten zurückgegebene neue Wert.</span><span class="sxs-lookup"><span data-stu-id="43891-173">The value attached to <paramref name="key" />, if <paramref name="key" /> already exists in the table; otherwise, the new value returned by the <paramref name="createValueCallback" /> delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43891-174">Wenn `key` existiert nicht in der Tabelle <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> Ruft die Methode, die von definiert ist die `createValueCallback` Parameter und übergibt sie den Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="43891-174">If `key` does not exist in the table, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> invokes the method that is defined by the `createValueCallback` parameter and passes it the key.</span></span> <span data-ttu-id="43891-175">Ein neuer Wert wurde an den Schlüssel in der Tabelle gebunden und als Ergebnis zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="43891-175">A new value is bound to the key in the table and returned as a result.</span></span>  
  
 <span data-ttu-id="43891-176">Verwenden Sie diese Methode nur, wenn die Klasse, die den Wert der Tabelle stellt einen standardmäßigen Konstruktor nicht definiert ist.</span><span class="sxs-lookup"><span data-stu-id="43891-176">Use this method only when the class that represents the table's value does not define a default constructor.</span></span> <span data-ttu-id="43891-177">Wenn sie einen standardmäßigen Konstruktor definiert, verwendet der <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> Methode stattdessen.</span><span class="sxs-lookup"><span data-stu-id="43891-177">If it does define a default constructor, use the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method instead.</span></span> <span data-ttu-id="43891-178">Den Wert eines vorhandenen Schlüssels abrufen, ohne Hinzufügen von Schlüssel/Wert-Paar aufrufen, wenn der Schlüssel nicht, in der Tabelle gefunden wird die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="43891-178">To retrieve the value of an existing key without adding the key/value pair if the key is not found in the table, call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method.</span></span>  
  
 <span data-ttu-id="43891-179">Wenn mehrere Threads versuchen, den gleichen Schlüssel erstellen `createValueCallback` kann mehrere Male aufgerufen werden, mit dem gleichen Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="43891-179">If multiple threads try to create the same key, `createValueCallback` may be invoked multiple times with the same key.</span></span> <span data-ttu-id="43891-180">Nur eine dieser Aufrufe ist erfolgreich, und der zurückgegebene Wert wird in der Tabelle hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="43891-180">Only one of these calls will succeed, and its returned value will be added to the table.</span></span> <span data-ttu-id="43891-181">Der Thread ist erfolgreich, bei der Erstellung des Werts ist unbestimmt.</span><span class="sxs-lookup"><span data-stu-id="43891-181">Which thread succeeds in creating the value is indeterminate.</span></span> <span data-ttu-id="43891-182">Diese Regel erlaubt, in der Tabelle aufrufen `createValueCallback` außerhalb der internen Tabellensperre, um Deadlocks zu verhindern.</span><span class="sxs-lookup"><span data-stu-id="43891-182">This rule permits the table to invoke `createValueCallback` outside the internal table lock to prevent deadlocks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43891-183">Das folgende Beispiel definiert eine `MainClass` Klasse und ein `MainInfo` -Klasse, die Informationen zu den `MainClass` Instanz.</span><span class="sxs-lookup"><span data-stu-id="43891-183">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="43891-184">Sie definiert außerdem eine statische (`Shared` in Visual Basic) `CreateAttachedValue` -Methode, die zugewiesen werden kann die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> delegieren und an die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="43891-184">It also defines a static (`Shared` in Visual Basic) `CreateAttachedValue` method that can be assigned to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> delegate and passed to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method.</span></span> <span data-ttu-id="43891-185">Im Beispiel wird die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> -Methode zum Hinzufügen einer `MainClass` Objekt und seine angefügten `MainInfo` -Objekt an eine <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Tabelle.</span><span class="sxs-lookup"><span data-stu-id="43891-185">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="43891-186">Das Beispiel veranschaulicht auch Aufrufe an die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> und <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> Methoden zum Hinzufügen von Schlüssel/Wert-Paare in der Tabelle, und klicken Sie auf die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> Methode zum Abrufen des Werts eines vorhandenen Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="43891-186">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43891-187"><paramref name="key" /> oder <paramref name="createValueCallback" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="43891-187"><paramref name="key" /> or <paramref name="createValueCallback" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="43891-188">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="43891-188">requires full trust for the immediate caller.</span></span> <span data-ttu-id="43891-189">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="43891-189">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
        <altmember cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="member this.Remove : 'Key -&gt; bool" Usage="conditionalWeakTable.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="43891-190">Der zu entfernende Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="43891-190">The key to remove.</span></span></param>
        <summary><span data-ttu-id="43891-191">Entfernt einen Schlüssel und seinen Wert aus der Tabelle.</span><span class="sxs-lookup"><span data-stu-id="43891-191">Removes a key and its value from the table.</span></span></summary>
        <returns><span data-ttu-id="43891-192"><see langword="true" />, wenn der Schlüssel gefunden und entfernt wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="43891-192"><see langword="true" /> if the key is found and removed; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43891-193">Wenn der Schlüssel Garbage collection während dieses Vorgangs ist, die Methode löst keine Ausnahme aus, und der Rückgabewert nicht definiert ist.</span><span class="sxs-lookup"><span data-stu-id="43891-193">If the key is garbage-collected during this operation, the method does not raise an exception and the return value is undefined.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43891-194"><paramref name="key" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="43891-194"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="43891-195">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="43891-195">requires full trust for the immediate caller.</span></span> <span data-ttu-id="43891-196">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="43891-196">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key *  -&gt; bool" Usage="conditionalWeakTable.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="43891-197">Der Schlüssel, der ein Objekt mit einer angefügten Eigenschaft darstellt.</span><span class="sxs-lookup"><span data-stu-id="43891-197">The key that represents an object with an attached property.</span></span></param>
        <param name="value"><span data-ttu-id="43891-198">Enthält nach dem Beenden dieser Methode den angefügten Eigenschaftswert.</span><span class="sxs-lookup"><span data-stu-id="43891-198">When this method returns, contains the attached property value.</span></span> <span data-ttu-id="43891-199"><paramref name="key" /> enthält den Standardwert, wenn <paramref name="value" /> nicht gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="43891-199">If <paramref name="key" /> is not found, <paramref name="value" /> contains the default value.</span></span></param>
        <summary><span data-ttu-id="43891-200">Ruft den Wert des angegebenen Schlüssels ab.</span><span class="sxs-lookup"><span data-stu-id="43891-200">Gets the value of the specified key.</span></span></summary>
        <returns><span data-ttu-id="43891-201"><see langword="true" />, wenn <paramref name="key" /> gefunden wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="43891-201"><see langword="true" /> if <paramref name="key" /> is found; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="43891-202">Wenn der Schlüssel Garbage collection während dieses Vorgangs ist, kann die Methode zurückgeben `false` und `value` auf den Standardwert Wert (als ob der Schlüssel nicht vorhanden waren).</span><span class="sxs-lookup"><span data-stu-id="43891-202">If the key is garbage-collected during this operation, the method may return `false` and set `value` to the default value (as if the key were not present).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="43891-203">Das folgende Beispiel definiert eine `MainClass` Klasse und ein `MainInfo` -Klasse, die Informationen zu den `MainClass` Instanz.</span><span class="sxs-lookup"><span data-stu-id="43891-203">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="43891-204">Im Beispiel wird die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>, und <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> Methoden zum Hinzufügen von Schlüssel/Wert-Paare, um eine <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Tabelle.</span><span class="sxs-lookup"><span data-stu-id="43891-204">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>, and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="43891-205">In jedem Fall im Beispiel wird die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> Methode, um sicherzustellen, dass die Schlüssel/Wert-Paar in der Tabelle hinzugefügt wurde.</span><span class="sxs-lookup"><span data-stu-id="43891-205">In each case, the example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to confirm that the key/value pair has been added to the table.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="43891-206"><paramref name="key" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="43891-206"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="43891-207">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="43891-207">requires full trust for the immediate caller.</span></span> <span data-ttu-id="43891-208">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="43891-208">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
      </Docs>
    </Member>
  </Members>
</Type>