<Type Name="ConditionalWeakTable&lt;TKey,TValue&gt;" FullName="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b1a77597b1732d693bde5a84d6db7a706b6010e8" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69066187" /></Metadata><TypeSignature Language="C#" Value="public sealed class ConditionalWeakTable&lt;TKey,TValue&gt; where TKey : class where TValue : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ConditionalWeakTable`2&lt;class TKey, class TValue&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ConditionalWeakTable(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA; where TKey : class where TValue : classpublic ref class ConditionalWeakTable sealed" />
  <TypeSignature Language="F#" Value="type ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="TValue">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey"><span data-ttu-id="04605-101">Der Verweistyp, an den das Feld angefügt ist.</span><span class="sxs-lookup"><span data-stu-id="04605-101">The reference type to which the field is attached.</span></span></typeparam>
    <typeparam name="TValue"><span data-ttu-id="04605-102">Der Typ des Felds.</span><span class="sxs-lookup"><span data-stu-id="04605-102">The field's type.</span></span> <span data-ttu-id="04605-103">Dieser Typ muss ein Referenztyp sein.</span><span class="sxs-lookup"><span data-stu-id="04605-103">This must be a reference type.</span></span></typeparam>
    <summary><span data-ttu-id="04605-104">Ermöglicht, dass Compiler dynamisch Objektfelder an verwaltete Objekte anfügen können.</span><span class="sxs-lookup"><span data-stu-id="04605-104">Enables compilers to dynamically attach object fields to managed objects.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04605-105">Mit <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> der-Klasse können sprach Compiler beliebige Eigenschaften zur Laufzeit an verwaltete Objekte anfügen.</span><span class="sxs-lookup"><span data-stu-id="04605-105">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class enables language compilers to attach arbitrary properties to managed objects at run time.</span></span> <span data-ttu-id="04605-106">Ein <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> -Objekt ist ein Wörterbuch, das ein verwaltetes Objekt, das durch einen Schlüssel dargestellt wird, an die angefügte-Eigenschaft bindet, die durch einen-Wert dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="04605-106">A <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object is a dictionary that binds a managed object, which is represented by a key, to its attached property, which is represented by a value.</span></span> <span data-ttu-id="04605-107">Die Schlüssel des Objekts sind die einzelnen Instanzen der `TKey` Klasse, an die die Eigenschaft angefügt ist, und ihre Werte sind die Eigenschaftswerte, die den entsprechenden-Objekten zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="04605-107">The object's keys are the individual instances of the `TKey` class to which the property is attached, and its values are the property values that are assigned to the corresponding objects.</span></span>  
  
 <span data-ttu-id="04605-108">Schlüssel müssen eindeutig sein. Das heißt, die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> -Klasse unterstützt einen angefügten Wert pro verwaltetem Objekt.</span><span class="sxs-lookup"><span data-stu-id="04605-108">Keys must be unique; in other words, the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class supports one attached value per managed object.</span></span> <span data-ttu-id="04605-109">Zwei Schlüssel sind gleich, wenn Sie an die <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> `true`Methode übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="04605-109">Two keys are equal if passing them to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04605-110">Sie können keine Gleichheits Vergleiche Steuern <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> , indem Sie überschreiben, um den Hashcode für einen Schlüssel explizit festzulegen.</span><span class="sxs-lookup"><span data-stu-id="04605-110">You cannot control equality comparisons by overriding <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> to explicitly set the hash code for a key.</span></span> <span data-ttu-id="04605-111">Die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> -Klasse<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> verwendet nicht die-Methode, um Hashcodes zu berechnen, weshalb keine außerKraftsetzungenaufgerufenwerden.<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="04605-111">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class does not use the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method to compute hash codes, and therefore does not invoke <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> overrides.</span></span>  
  
 <span data-ttu-id="04605-112">Obwohl die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> -Klasse eine Auflistung von Schlüssel-Wert-Paaren enthält, ist Sie am besten als eine Tabelle und nicht als Wörterbuch Objekt gedacht.</span><span class="sxs-lookup"><span data-stu-id="04605-112">Although the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class holds a collection of key/value pairs, it is best thought of as a table rather than a dictionary object.</span></span> <span data-ttu-id="04605-113">Die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Klasse unterscheidet sich auf verschiedene Arten von einem Wörterbuch:</span><span class="sxs-lookup"><span data-stu-id="04605-113">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class differs from a dictionary in several ways:</span></span>  
  
-   <span data-ttu-id="04605-114">Schlüssel werden nicht persistent gespeichert.</span><span class="sxs-lookup"><span data-stu-id="04605-114">It does not persist keys.</span></span> <span data-ttu-id="04605-115">Das heißt, dass ein Schlüssel nicht nur aktiv bleibt, da er ein Member der Auflistung ist.</span><span class="sxs-lookup"><span data-stu-id="04605-115">That is, a key is not kept alive only because it is a member of the collection.</span></span>  
  
-   <span data-ttu-id="04605-116">Sie enthält nicht alle Methoden (z `GetEnumerator` . b. oder `Contains`), die in einem Wörterbuch normalerweise vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="04605-116">It does not include all the methods (such as `GetEnumerator` or `Contains`) that a dictionary typically has.</span></span>  
  
-   <span data-ttu-id="04605-117">Die <xref:System.Collections.Generic.IDictionary%602> -Schnittstelle wird nicht implementiert.</span><span class="sxs-lookup"><span data-stu-id="04605-117">It does not implement the <xref:System.Collections.Generic.IDictionary%602> interface.</span></span>  
  
 <span data-ttu-id="04605-118">Die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> -Klasse unterscheidet sich von anderen Auflistungs Objekten bei der Verwaltung der Objekt Lebensdauer von Schlüsseln, die in der Auflistung gespeichert sind.</span><span class="sxs-lookup"><span data-stu-id="04605-118">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class differs from other collection objects in its management of the object lifetime of keys stored in the collection.</span></span> <span data-ttu-id="04605-119">Wenn ein Objekt in einer Auflistung gespeichert wird, dauert es normalerweise so lange, bis es entfernt wird (und keine weiteren Verweise auf das Objekt vorhanden sind) oder bis das Sammlungsobjekt selbst zerstört wird.</span><span class="sxs-lookup"><span data-stu-id="04605-119">Ordinarily, when an object is stored in a collection, its lifetime lasts until it is removed (and there are no additional references to the object) or until the collection object itself is destroyed.</span></span> <span data-ttu-id="04605-120">Allerdings wird in <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> der-Klasse durch das Hinzufügen eines Schlüssel-Wert-Paars zur Tabelle nicht sichergestellt, dass der Schlüssel beibehalten wird, auch wenn er direkt von einem in der Tabelle gespeicherten Wert erreicht werden kann (z. b. wenn die Tabelle einen Schlüssel, einen mit einem Wert V1 enthält). und einen zweiten Schlüssel, B, mit einem Wert P2, der einen Verweis auf einen enthält.</span><span class="sxs-lookup"><span data-stu-id="04605-120">However, in the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class, adding a key/value pair to the table does not ensure that the key will persist, even if it can be reached directly from a value stored in the table (for example, if the table contains one key, A, with a value V1, and a second key, B, with a value P2 that contains a reference to A).</span></span> <span data-ttu-id="04605-121">Stattdessen wird <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> der Schlüssel-Wert-Eintrag automatisch entfernt, sobald keine anderen Verweise auf einen Schlüssel außerhalb der Tabelle vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="04605-121">Instead, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> automatically removes the key/value entry as soon as no other references to a key exist outside the table.</span></span> <span data-ttu-id="04605-122">Dies wird im Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="04605-122">The example provides an illustration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04605-123">Im folgenden Beispiel wird veranschaulicht, dass ein in der <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Tabelle gespeicherter Schlüssel nicht beibehalten wird, nachdem Verweise darauf außerhalb der Tabelle zerstört wurden.</span><span class="sxs-lookup"><span data-stu-id="04605-123">The following example illustrates that a key stored in the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table does not persist after references to it outside the table are destroyed.</span></span> <span data-ttu-id="04605-124">Im Beispiel werden zwei Klassen definiert `ManagedClass`:, die den Schlüssel in der Tabelle darstellt, `ClassData`und, der den Wert des Schlüssels darstellt.</span><span class="sxs-lookup"><span data-stu-id="04605-124">The example defines two classes: `ManagedClass`, which represents the key in the table, and `ClassData`, which represents the key's value.</span></span> <span data-ttu-id="04605-125">Im Beispiel werden drei-Objekte jedes Typs instanziiert.</span><span class="sxs-lookup"><span data-stu-id="04605-125">The example instantiates three objects of each type.</span></span> <span data-ttu-id="04605-126">Außerdem wird ein <xref:System.WeakReference> -Objekt instanziiert, das das `ManagedClass`zweite darstellt, und dann die `ManagedClass` zweite-Instanz zerstört.</span><span class="sxs-lookup"><span data-stu-id="04605-126">It also instantiates a <xref:System.WeakReference> object that represents the second `ManagedClass`, and then destroys the second `ManagedClass` instance.</span></span> <span data-ttu-id="04605-127">Der Versuch, das zweite `ManagedClass` Objekt aus der <xref:System.WeakReference.Target%2A> -Eigenschaft abzurufen, weist darauf hin, dass keine Verweise auf das Objekt übrig bleiben.</span><span class="sxs-lookup"><span data-stu-id="04605-127">The attempt to retrieve the second `ManagedClass` object from the <xref:System.WeakReference.Target%2A> property indicates that no references to the object remain.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/cs/example1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/vb/example1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="04605-128">Instanzen der <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> -Klasse sind Thread sicher.</span><span class="sxs-lookup"><span data-stu-id="04605-128">Instances of the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> class are thread safe.</span></span> <span data-ttu-id="04605-129">Es ist nicht erforderlich, dass Aufrufer zusätzliche Sperren durchführen.</span><span class="sxs-lookup"><span data-stu-id="04605-129">They do not require callers to do any additional locking.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConditionalWeakTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04605-130">Initialisiert eine neue Instanz der <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="04605-130">Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04605-131">Der <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> -Konstruktor instanziiert eine <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> leere Tabelle, d. h. die Tabelle enthält keine Schlüssel-Wert-Paare.</span><span class="sxs-lookup"><span data-stu-id="04605-131">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> constructor instantiates an empty <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table; that is, the table contains no key/value pairs.</span></span> <span data-ttu-id="04605-132">Sie können Schlüssel-Wert-Paare hinzufügen, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>indem <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>Sie die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> Methode, oder aufrufen.</span><span class="sxs-lookup"><span data-stu-id="04605-132">You can add key/value pairs by calling the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>, or <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method.</span></span>  
  
 <span data-ttu-id="04605-133">Jeder Schlüssel in einem <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> -Objekt muss eindeutig sein.</span><span class="sxs-lookup"><span data-stu-id="04605-133">Every key in a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object must be unique.</span></span> <span data-ttu-id="04605-134">Schlüssel sind nicht eindeutig, wenn Sie auf dasselbe Objekt verweisen (d. h., wenn Sie als Argumente an <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> die `true`Methode übergeben werden).</span><span class="sxs-lookup"><span data-stu-id="04605-134">Keys are not unique if they refer to the same object (that is, if passing them as arguments to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.Add : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.Add (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="04605-135">Der hinzuzufügende Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="04605-135">The key to add.</span></span> <span data-ttu-id="04605-136"><paramref name="key" /> stellt das Objekt dar, an das die Eigenschaft angefügt ist.</span><span class="sxs-lookup"><span data-stu-id="04605-136"><paramref name="key" /> represents the object to which the property is attached.</span></span></param>
        <param name="value"><span data-ttu-id="04605-137">Der Eigenschaftswert des Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="04605-137">The key's property value.</span></span></param>
        <summary><span data-ttu-id="04605-138">Fügt der Tabelle einen Schlüssel hinzu.</span><span class="sxs-lookup"><span data-stu-id="04605-138">Adds a key to the table.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04605-139">Jeder Schlüssel in einem <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> -Objekt muss eindeutig sein.</span><span class="sxs-lookup"><span data-stu-id="04605-139">Every key in a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object must be unique.</span></span> <span data-ttu-id="04605-140">Schlüssel sind nicht eindeutig, wenn Sie auf dasselbe Objekt verweisen (d. h., wenn Sie als Argumente an <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> die `true`Methode übergeben werden).</span><span class="sxs-lookup"><span data-stu-id="04605-140">Keys are not unique if they refer to the same object (that is, if passing them as arguments to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`).</span></span>  
  
 <span data-ttu-id="04605-141">Wenn der Schlüssel während der Addition freigegeben wird, wird das vorhandene Schlüssel-Wert-Paar entfernt und das neue Schlüssel-Wert-Paar hinzugefügt, ohne dass eine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="04605-141">If the key is garbage-collected during the addition operation, the existing key/value pair is removed and the new key/value pair is added without an exception being thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04605-142">Im folgenden Beispiel werden eine `MainClass` -Klasse und `MainInfo` eine-Klasse definiert, die Informationen `MainClass` über die-Instanz bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="04605-142">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="04605-143">Im Beispiel wird dann die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> -Methode aufgerufen, `MainClass` um ein-Objekt `MainInfo` und sein angefügtes-Objekt einer <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Tabelle hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="04605-143">The example then calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="04605-144">Das Beispiel veranschaulicht auch Aufrufe der <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> -und- <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> Methoden, um der Tabelle Schlüssel/Wert-Paare hinzuzufügen, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> und der-Methode, um den Wert eines vorhandenen Schlüssels abzurufen.</span><span class="sxs-lookup"><span data-stu-id="04605-144">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04605-145"><paramref name="key" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04605-145"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04605-146"><paramref name="key" /> ist bereits vorhanden.</span><span class="sxs-lookup"><span data-stu-id="04605-146"><paramref name="key" /> already exists.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="04605-147">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="04605-147">requires full trust for the immediate caller.</span></span> <span data-ttu-id="04605-148">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="04605-148">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate">
      <MemberSignature Language="C#" Value="public void AddOrUpdate (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOrUpdate(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.AddOrUpdate(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOrUpdate (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOrUpdate(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.AddOrUpdate : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.AddOrUpdate (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="TValue" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="04605-149">Der hinzuzufügende oder zu aktualisierende Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="04605-149">The key to add or update.</span></span> <span data-ttu-id="04605-150">Darf nicht <see langword="null" /> sein.</span><span class="sxs-lookup"><span data-stu-id="04605-150">May not be <see langword="null" />.</span></span></param>
        <param name="value"><span data-ttu-id="04605-151">Der <paramref name="key" /> zuzuordnende Wert.</span><span class="sxs-lookup"><span data-stu-id="04605-151">The value to associate with <paramref name="key" />.</span></span></param>
        <summary><span data-ttu-id="04605-152">Fügt den Schlüssel und Wert hinzu, wenn der Schlüssel nicht vorhanden ist, oder aktualisiert den Wert des vorhandenen Schlüssels, wenn er vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="04605-152">Adds the key and value if the key doesn't exist, or updates the existing key's value if it does exist.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04605-153"><paramref name="key" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04605-153"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="conditionalWeakTable.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04605-154">Löscht alle Schlüssel-Wert-Paare.</span><span class="sxs-lookup"><span data-stu-id="04605-154">Clears all the key/value pairs.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ConditionalWeakTable`2 ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="conditionalWeakTable.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04605-155">Stellt das Freigeben von Ressourcen und das Ausführen anderer Garbage Collector-Vorgänge sicher, wenn der Garbage Collector das <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />-Objekt verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="04605-155">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04605-156">Der Garbage Collector der <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A> aufruft, wenn das aktuelle-Objekt für die Fertigstellung bereit ist.</span><span class="sxs-lookup"><span data-stu-id="04605-156">The garbage collector calls <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A> when the current object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateValue">
      <MemberSignature Language="C#" Value="public TValue GetOrCreateValue (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrCreateValue(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrCreateValue (key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetOrCreateValue(TKey key);" />
      <MemberSignature Language="F#" Value="member this.GetOrCreateValue : 'Key -&gt; 'Value" Usage="conditionalWeakTable.GetOrCreateValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="04605-157">Der zu suchende Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="04605-157">The key to search for.</span></span> <span data-ttu-id="04605-158"><paramref name="key" /> stellt das Objekt dar, an das die Eigenschaft angefügt ist.</span><span class="sxs-lookup"><span data-stu-id="04605-158"><paramref name="key" /> represents the object to which the property is attached.</span></span></param>
        <summary><span data-ttu-id="04605-159">Sucht atomar nach einem angegebenen Schlüssel in der Tabelle und gibt den entsprechenden Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="04605-159">Atomically searches for a specified key in the table and returns the corresponding value.</span></span> <span data-ttu-id="04605-160">Wenn der Schlüssel in der Tabelle nicht vorhanden ist, ruft die Methode den parameterlosen Konstruktor der Klasse auf, die den Wert der Tabelle darstellt, um einen Wert zu erstellen, der an den angegebenen Schlüssel gebunden wird.</span><span class="sxs-lookup"><span data-stu-id="04605-160">If the key does not exist in the table, the method invokes the parameterless constructor of the class that represents the table's value to create a value that is bound to the specified key.</span></span></summary>
        <returns><span data-ttu-id="04605-161">Der Wert, der <paramref name="key" /> entspricht, wenn <paramref name="key" /> bereits in der Tabelle vorhanden ist. Andernfalls ein neuer vom parameterlosen Konstruktor der vom generischen Typparameter <paramref name="TValue" /> erstellter Wert.</span><span class="sxs-lookup"><span data-stu-id="04605-161">The value that corresponds to <paramref name="key" />, if <paramref name="key" /> already exists in the table; otherwise, a new value created by the parameterless constructor of the class defined by the <paramref name="TValue" /> generic type parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04605-162">Wenn `key` in der Tabelle nicht vorhanden ist, fügt die Methode diese zusammen mit dem Objekt hinzu, das durch Aufrufen des Parameter losen Konstruktors der durch den `TValue` generischen Typparameter definierten Klasse instanziiert wird.</span><span class="sxs-lookup"><span data-stu-id="04605-162">If `key` does not exist in the table, the method adds it, along with the object that is instantiated by calling the parameterless constructor of the class defined by the `TValue` generic type parameter.</span></span> <span data-ttu-id="04605-163">Wenn die `TValue` Klasse über keinen Parameter losen Konstruktor verfügt, wird <xref:System.MissingMethodException> eine ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="04605-163">If the `TValue` class has no parameterless constructor, a <xref:System.MissingMethodException> is thrown.</span></span>  
  
 <span data-ttu-id="04605-164">Dies ist die empfohlene Methode zum Abrufen eines vorhandenen Werts oder zum Hinzufügen eines neuen Werts zur <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Tabelle, wenn die Klasse des Tabellen Werts einen Parameter losen Konstruktor definiert.</span><span class="sxs-lookup"><span data-stu-id="04605-164">This is the recommended method of retrieving an existing value or adding a new value to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table if the class of the table's value defines a parameterless constructor.</span></span> <span data-ttu-id="04605-165">Wenn kein Parameter loser Konstruktor definiert wird, können Sie stattdessen die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> -Methode aufzurufen, die auf einer vom Rückruf bereitgestellten Methode basiert, um das Objekt zu instanziieren, das den Tabellenwert darstellt.</span><span class="sxs-lookup"><span data-stu-id="04605-165">If it does not define a parameterless constructor, you can instead call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method, which relies on a callback-provided method to instantiate the object representing the table's value</span></span>  
  
 <span data-ttu-id="04605-166">Um den Wert eines vorhandenen Schlüssels abzurufen, ohne das Schlüssel/Wert-Paar hinzuzufügen, wenn der Schlüssel nicht in der Tabelle gefunden wird <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> , rufen Sie die-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="04605-166">To retrieve the value of an existing key without adding the key/value pair if the key is not found in the table, call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04605-167">Im folgenden Beispiel werden eine `MainClass` -Klasse und `MainInfo` eine-Klasse definiert, die Informationen `MainClass` über die-Instanz bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="04605-167">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="04605-168">Im Beispiel wird die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> -Methode aufgerufen, `MainClass` um ein-Objekt `MainInfo` und sein angefügtes-Objekt einer <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Tabelle hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="04605-168">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="04605-169">Das Beispiel veranschaulicht auch Aufrufe der <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> -und- <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> Methoden, um der Tabelle Schlüssel/Wert-Paare hinzuzufügen, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> und der-Methode, um den Wert eines vorhandenen Schlüssels abzurufen.</span><span class="sxs-lookup"><span data-stu-id="04605-169">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04605-170"><paramref name="key" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04605-170"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="04605-171">Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.MissingMemberException" /> ab.</span><span class="sxs-lookup"><span data-stu-id="04605-171">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.MissingMemberException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="04605-172">Die Klasse, die den Wert der Tabelle darstellt, definiert keinen parameterlosen Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="04605-172">The class that represents the table's value does not define a parameterless constructor.</span></span></exception>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public TValue GetValue (TKey key, System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;.CreateValueCallback createValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetValue(!TKey key, class System.Runtime.CompilerServices.ConditionalWeakTable`2/CreateValueCallback&lt;!TKey, !TValue&gt; createValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetValue(TKey key, System::Runtime::CompilerServices::ConditionalWeakTable&lt;TKey, TValue&gt;::CreateValueCallback ^ createValueCallback);" />
      <MemberSignature Language="F#" Value="member this.GetValue : 'Key * System.Runtime.CompilerServices.ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt;.CreateValueCallback -&gt; 'Value" Usage="conditionalWeakTable.GetValue (key, createValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="createValueCallback" Type="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;+CreateValueCallback" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="04605-173">Der zu suchende Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="04605-173">The key to search for.</span></span> <span data-ttu-id="04605-174"><paramref name="key" /> stellt das Objekt dar, an das die Eigenschaft angefügt ist.</span><span class="sxs-lookup"><span data-stu-id="04605-174"><paramref name="key" /> represents the object to which the property is attached.</span></span></param>
        <param name="createValueCallback"><span data-ttu-id="04605-175">Ein Delegat zu einer Methode, die einen Wert für den angegebenen <paramref name="key" /> erstellen kann.</span><span class="sxs-lookup"><span data-stu-id="04605-175">A delegate to a method that can create a value for the given <paramref name="key" />.</span></span> <span data-ttu-id="04605-176">Er verfügt über einen einzelnen Parameter vom Typ <c>TKey</c> und gibt einen Wert vom Typ <c>TValue</c> zurück.</span><span class="sxs-lookup"><span data-stu-id="04605-176">It has a single parameter of type <c>TKey</c>, and returns a value of type <c>TValue</c>.</span></span></param>
        <summary><span data-ttu-id="04605-177">Sucht atomar nach einem angegebenen Schlüssel in der Tabelle und gibt den entsprechenden Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="04605-177">Atomically searches for a specified key in the table and returns the corresponding value.</span></span> <span data-ttu-id="04605-178">Wenn der Schlüssel in der Tabelle nicht vorhanden ist, ruft die Methode eine Rückrufmethode auf, um einen Wert zu erstellen, der an den angegebenen Schlüssel gebunden ist.</span><span class="sxs-lookup"><span data-stu-id="04605-178">If the key does not exist in the table, the method invokes a callback method to create a value that is bound to the specified key.</span></span></summary>
        <returns><span data-ttu-id="04605-179">Der an <paramref name="key" /> angefügte Wert, wenn <paramref name="key" /> bereits in der Tabelle vorhanden ist, andernfalls der vom <paramref name="createValueCallback" />-Delegaten zurückgegebene neue Wert.</span><span class="sxs-lookup"><span data-stu-id="04605-179">The value attached to <paramref name="key" />, if <paramref name="key" /> already exists in the table; otherwise, the new value returned by the <paramref name="createValueCallback" /> delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04605-180">Wenn `key` in der Tabelle nicht vorhanden ist, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> Ruft die Methode auf, die durch den `createValueCallback` -Parameter definiert wird, und übergibt sie an den Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="04605-180">If `key` does not exist in the table, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> invokes the method that is defined by the `createValueCallback` parameter and passes it the key.</span></span> <span data-ttu-id="04605-181">Ein neuer Wert wird an den Schlüssel in der Tabelle gebunden und als Ergebnis zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="04605-181">A new value is bound to the key in the table and returned as a result.</span></span>  
  
 <span data-ttu-id="04605-182">Verwenden Sie diese Methode nur, wenn die Klasse, die den Wert der Tabelle darstellt, keinen Parameter losen Konstruktor definiert.</span><span class="sxs-lookup"><span data-stu-id="04605-182">Use this method only when the class that represents the table's value does not define a parameterless constructor.</span></span> <span data-ttu-id="04605-183">Wenn ein Parameter loser Konstruktor definiert wird, verwenden Sie stattdessen die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> -Methode.</span><span class="sxs-lookup"><span data-stu-id="04605-183">If it does define a parameterless constructor, use the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method instead.</span></span> <span data-ttu-id="04605-184">Um den Wert eines vorhandenen Schlüssels abzurufen, ohne das Schlüssel/Wert-Paar hinzuzufügen, wenn der Schlüssel nicht in der Tabelle gefunden wird <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> , rufen Sie die-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="04605-184">To retrieve the value of an existing key without adding the key/value pair if the key is not found in the table, call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method.</span></span>  
  
 <span data-ttu-id="04605-185">Wenn mehrere Threads versuchen, denselben Schlüssel zu erstellen, `createValueCallback` kann mehrmals mit demselben Schlüssel aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="04605-185">If multiple threads try to create the same key, `createValueCallback` may be invoked multiple times with the same key.</span></span> <span data-ttu-id="04605-186">Nur einer dieser Aufrufe ist erfolgreich, und der zurückgegebene Wert wird der Tabelle hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="04605-186">Only one of these calls will succeed, and its returned value will be added to the table.</span></span> <span data-ttu-id="04605-187">Der Thread, der die Erstellung des Werts erfolgreich durchführt, ist unbestimmt.</span><span class="sxs-lookup"><span data-stu-id="04605-187">Which thread succeeds in creating the value is indeterminate.</span></span> <span data-ttu-id="04605-188">Diese Regel ermöglicht die Aufruf `createValueCallback` Ende Tabelle außerhalb der internen Tabellensperre, um Deadlocks zu verhindern.</span><span class="sxs-lookup"><span data-stu-id="04605-188">This rule permits the table to invoke `createValueCallback` outside the internal table lock to prevent deadlocks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04605-189">Im folgenden Beispiel werden eine `MainClass` -Klasse und `MainInfo` eine-Klasse definiert, die Informationen `MainClass` über die-Instanz bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="04605-189">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="04605-190">Außerdem`Shared` wird eine statische (in Visual Basic) `CreateAttachedValue` Methode definiert, die dem <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> Delegaten zugewiesen und an die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> -Methode übermittelt werden kann.</span><span class="sxs-lookup"><span data-stu-id="04605-190">It also defines a static (`Shared` in Visual Basic) `CreateAttachedValue` method that can be assigned to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> delegate and passed to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method.</span></span> <span data-ttu-id="04605-191">Im Beispiel wird die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> -Methode aufgerufen, `MainClass` um ein-Objekt `MainInfo` und sein angefügtes-Objekt einer <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Tabelle hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="04605-191">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="04605-192">Das Beispiel veranschaulicht auch Aufrufe der <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> -und- <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> Methoden, um der Tabelle Schlüssel/Wert-Paare hinzuzufügen, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> und der-Methode, um den Wert eines vorhandenen Schlüssels abzurufen.</span><span class="sxs-lookup"><span data-stu-id="04605-192">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04605-193"><paramref name="key" /> oder <paramref name="createValueCallback" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04605-193"><paramref name="key" /> or <paramref name="createValueCallback" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="04605-194">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="04605-194">requires full trust for the immediate caller.</span></span> <span data-ttu-id="04605-195">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="04605-195">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
        <altmember cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="member this.Remove : 'Key -&gt; bool" Usage="conditionalWeakTable.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="04605-196">Der zu entfernende Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="04605-196">The key to remove.</span></span></param>
        <summary><span data-ttu-id="04605-197">Entfernt einen Schlüssel und seinen Wert aus der Tabelle.</span><span class="sxs-lookup"><span data-stu-id="04605-197">Removes a key and its value from the table.</span></span></summary>
        <returns><span data-ttu-id="04605-198"><see langword="true" />, wenn der Schlüssel gefunden und entfernt wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04605-198"><see langword="true" /> if the key is found and removed; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04605-199">Wenn während dieses Vorgangs eine Garbage Collection durchgeführt wird, wird von der-Methode keine Ausnahme ausgelöst, und der Rückgabewert ist nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="04605-199">If the key is garbage-collected during this operation, the method does not raise an exception and the return value is undefined.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04605-200"><paramref name="key" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04605-200"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="04605-201">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="04605-201">requires full trust for the immediate caller.</span></span> <span data-ttu-id="04605-202">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="04605-202">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key *  -&gt; bool" Usage="conditionalWeakTable.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="04605-203">Der Schlüssel, der ein Objekt mit einer angefügten Eigenschaft darstellt.</span><span class="sxs-lookup"><span data-stu-id="04605-203">The key that represents an object with an attached property.</span></span></param>
        <param name="value"><span data-ttu-id="04605-204">Enthält nach dem Beenden dieser Methode den angefügten Eigenschaftswert.</span><span class="sxs-lookup"><span data-stu-id="04605-204">When this method returns, contains the attached property value.</span></span> <span data-ttu-id="04605-205"><paramref name="key" /> enthält den Standardwert, wenn <paramref name="value" /> nicht gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="04605-205">If <paramref name="key" /> is not found, <paramref name="value" /> contains the default value.</span></span></param>
        <summary><span data-ttu-id="04605-206">Ruft den Wert des angegebenen Schlüssels ab.</span><span class="sxs-lookup"><span data-stu-id="04605-206">Gets the value of the specified key.</span></span></summary>
        <returns><span data-ttu-id="04605-207"><see langword="true" />, wenn <paramref name="key" /> gefunden wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04605-207"><see langword="true" /> if <paramref name="key" /> is found; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04605-208">Wenn während dieses Vorgangs eine Garbage Collection durchgeführt wird, kann die Methode zurück `false` geben und `value` auf den Standardwert festgelegt werden (als wäre der Schlüssel nicht vorhanden).</span><span class="sxs-lookup"><span data-stu-id="04605-208">If the key is garbage-collected during this operation, the method may return `false` and set `value` to the default value (as if the key were not present).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04605-209">Im folgenden Beispiel werden eine `MainClass` -Klasse und `MainInfo` eine-Klasse definiert, die Informationen `MainClass` über die-Instanz bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="04605-209">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="04605-210">Im Beispiel werden die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>Methoden <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>, und <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> aufgerufen, um einer <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Tabelle Schlüssel-Wert-Paare hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="04605-210">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>, and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="04605-211">In jedem Fall ruft das Beispiel die <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> -Methode auf, um zu bestätigen, dass das Schlüssel-Wert-Paar der Tabelle hinzugefügt wurde.</span><span class="sxs-lookup"><span data-stu-id="04605-211">In each case, the example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to confirm that the key/value pair has been added to the table.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04605-212"><paramref name="key" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04605-212"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="04605-213">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span><span class="sxs-lookup"><span data-stu-id="04605-213">requires full trust for the immediate caller.</span></span> <span data-ttu-id="04605-214">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="04605-214">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
      </Docs>
    </Member>
  </Members>
</Type>
