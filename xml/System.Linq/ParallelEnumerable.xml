<Type Name="ParallelEnumerable" FullName="System.Linq.ParallelEnumerable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="615271b5f7e16d9aa4151966369bc946b4fa52f2" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56367766" /></Metadata><TypeSignature Language="C#" Value="public static class ParallelEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ParallelEnumerable extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.ParallelEnumerable" />
  <TypeSignature Language="VB.NET" Value="Public Module ParallelEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ParallelEnumerable abstract sealed" />
  <TypeSignature Language="F#" Value="type ParallelEnumerable = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen Satz von Methoden zum Abfragen von Objekten bereit, die ParallelQuery{TSource} implementieren. Dies ist die parallele Entsprechung von <see cref="T:System.Linq.Enumerable" />.</summary>
    <remarks>To be added.</remarks>
    <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Aggregate&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wendet parallel eine Akkumulatorfunktion auf eine Sequenz an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Aggregate&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Aggregate&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TSource,TSource&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Aggregate&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, !!TSource, !!TSource&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Aggregate``1(System.Linq.ParallelQuery{``0},System.Func{``0,``0,``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource) (source As ParallelQuery(Of TSource), func As Func(Of TSource, TSource, TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Aggregate(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TSource, TSource&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Source, 'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Aggregate (source, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Func&lt;TSource,TSource,TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, die aggregiert werden soll.</param>
        <param name="func">Eine Akkumulatorfunktion, die für jedes Element aufgerufen werden soll.</param>
        <summary>Wendet parallel eine Akkumulatorfunktion auf eine Sequenz an.</summary>
        <returns>Der letzte Akkumulatorwert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="func" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate&gt;">
      <MemberSignature Language="C#" Value="public static TAccumulate Aggregate&lt;TSource,TAccumulate&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TAccumulate Aggregate&lt;TSource, TAccumulate&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Aggregate``2(System.Linq.ParallelQuery{``0},``1,System.Func{``1,``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate) (source As ParallelQuery(Of TSource), seed As TAccumulate, func As Func(Of TAccumulate, TSource, TAccumulate)) As TAccumulate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TAccumulate Aggregate(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, TAccumulate seed, Func&lt;TAccumulate, TSource, TAccumulate&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.ParallelQuery&lt;'Source&gt; * 'Accumulate * Func&lt;'Accumulate, 'Source, 'Accumulate&gt; -&gt; 'Accumulate" Usage="System.Linq.ParallelEnumerable.Aggregate (source, seed, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TAccumulate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TAccumulate">Der Typ des Akkumulatorwerts.</typeparam>
        <param name="source">Eine Sequenz, die aggregiert werden soll.</param>
        <param name="seed">Der erste Akkumulatorwert.</param>
        <param name="func">Eine Akkumulatorfunktion, die für jedes Element aufgerufen werden soll.</param>
        <summary>Wendet parallel eine Akkumulatorfunktion auf eine Sequenz an. Der angegebene Startwert wird als erster Akkumulatorwert verwendet.</summary>
        <returns>Der letzte Akkumulatorwert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="func" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func, class System.Func`2&lt;!!TAccumulate, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Aggregate``3(System.Linq.ParallelQuery{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate, TResult) (source As ParallelQuery(Of TSource), seed As TAccumulate, func As Func(Of TAccumulate, TSource, TAccumulate), resultSelector As Func(Of TAccumulate, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Aggregate(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, TAccumulate seed, Func&lt;TAccumulate, TSource, TAccumulate&gt; ^ func, Func&lt;TAccumulate, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.ParallelQuery&lt;'Source&gt; * 'Accumulate * Func&lt;'Accumulate, 'Source, 'Accumulate&gt; * Func&lt;'Accumulate, 'Result&gt; -&gt; 'Result" Usage="System.Linq.ParallelEnumerable.Aggregate (source, seed, func, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TAccumulate">Der Typ des Akkumulatorwerts.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts.</typeparam>
        <param name="source">Eine Sequenz, die aggregiert werden soll.</param>
        <param name="seed">Der erste Akkumulatorwert.</param>
        <param name="func">Eine Akkumulatorfunktion, die für jedes Element aufgerufen werden soll.</param>
        <param name="resultSelector">Eine Funktion zum Transformieren des letzten Akkumulatorwerts in den Ergebniswert.</param>
        <summary>Wendet parallel eine Akkumulatorfunktion auf eine Sequenz an. Der angegebene Startwert wird als erster Akkumulatorwert verwendet, und der Ergebniswert wird mit der angegebenen Funktion ausgewählt.</summary>
        <returns>Der transformierte letzte Akkumulatorwert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="func" /> oder <paramref name="resultSelector" /> ist ein NULL-Verweis (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TAccumulate&gt; seedFactory, Func&lt;TAccumulate,TSource,TAccumulate&gt; updateAccumulatorFunc, Func&lt;TAccumulate,TAccumulate,TAccumulate&gt; combineAccumulatorsFunc, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TAccumulate&gt; seedFactory, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; updateAccumulatorFunc, class System.Func`3&lt;!!TAccumulate, !!TAccumulate, !!TAccumulate&gt; combineAccumulatorsFunc, class System.Func`2&lt;!!TAccumulate, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Aggregate``3(System.Linq.ParallelQuery{``0},System.Func{``1},System.Func{``1,``0,``1},System.Func{``1,``1,``1},System.Func{``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate, TResult) (source As ParallelQuery(Of TSource), seedFactory As Func(Of TAccumulate), updateAccumulatorFunc As Func(Of TAccumulate, TSource, TAccumulate), combineAccumulatorsFunc As Func(Of TAccumulate, TAccumulate, TAccumulate), resultSelector As Func(Of TAccumulate, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Aggregate(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TAccumulate&gt; ^ seedFactory, Func&lt;TAccumulate, TSource, TAccumulate&gt; ^ updateAccumulatorFunc, Func&lt;TAccumulate, TAccumulate, TAccumulate&gt; ^ combineAccumulatorsFunc, Func&lt;TAccumulate, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Accumulate&gt; * Func&lt;'Accumulate, 'Source, 'Accumulate&gt; * Func&lt;'Accumulate, 'Accumulate, 'Accumulate&gt; * Func&lt;'Accumulate, 'Result&gt; -&gt; 'Result" Usage="System.Linq.ParallelEnumerable.Aggregate (source, seedFactory, updateAccumulatorFunc, combineAccumulatorsFunc, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seedFactory" Type="System.Func&lt;TAccumulate&gt;" />
        <Parameter Name="updateAccumulatorFunc" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="combineAccumulatorsFunc" Type="System.Func&lt;TAccumulate,TAccumulate,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TAccumulate">Der Typ des Akkumulatorwerts.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts.</typeparam>
        <param name="source">Eine Sequenz, die aggregiert werden soll.</param>
        <param name="seedFactory">Eine Funktion, die den Anfangsakkumulatorwert zurückgibt.</param>
        <param name="updateAccumulatorFunc">Eine Akkumulatorfunktion, die für jedes Element in einer Partition aufgerufen werden soll.</param>
        <param name="combineAccumulatorsFunc">Eine Akkumulatorfunktion, die für das zurückgegebene Akkumulatorergebnis jeder Partition aufgerufen werden soll.</param>
        <param name="resultSelector">Eine Funktion zum Transformieren des letzten Akkumulatorwerts in den Ergebniswert.</param>
        <summary>Wendet parallel eine Akkumulatorfunktion auf eine Sequenz an. Diese Überladung ist in der sequenziellen Implementierung nicht verfügbar.</summary>
        <returns>Der transformierte letzte Akkumulatorwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ist spezifisch für parallele Abfragen. Eine parallele Abfrage kann die Daten Quellsequenz in mehrere Untersequenzen (Partitionen) partitionieren. Die `updateAccumulatorFunc` für jedes Element innerhalb von Partitionen aufgerufen wird. Jede Partition führt dann ein einzelnes akkumulierte Ergebnis. Die `combineAccumulatorsFunc` wird dann aufgerufen, auf die Ergebnisse der einzelnen Partitionen, um ein einzelnes Element zu erhalten. Dieses Element wird dann transformiert, indem die `resultSelector` Funktion.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="seedFactory" />, <paramref name="updateAccumulatorFunc" />, <paramref name="combineAccumulatorsFunc" /> oder <paramref name="resultSelector" /> ist ein NULL-Verweis (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; updateAccumulatorFunc, Func&lt;TAccumulate,TAccumulate,TAccumulate&gt; combineAccumulatorsFunc, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; updateAccumulatorFunc, class System.Func`3&lt;!!TAccumulate, !!TAccumulate, !!TAccumulate&gt; combineAccumulatorsFunc, class System.Func`2&lt;!!TAccumulate, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Aggregate``3(System.Linq.ParallelQuery{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``1,``1},System.Func{``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate, TResult) (source As ParallelQuery(Of TSource), seed As TAccumulate, updateAccumulatorFunc As Func(Of TAccumulate, TSource, TAccumulate), combineAccumulatorsFunc As Func(Of TAccumulate, TAccumulate, TAccumulate), resultSelector As Func(Of TAccumulate, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Aggregate(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, TAccumulate seed, Func&lt;TAccumulate, TSource, TAccumulate&gt; ^ updateAccumulatorFunc, Func&lt;TAccumulate, TAccumulate, TAccumulate&gt; ^ combineAccumulatorsFunc, Func&lt;TAccumulate, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.ParallelQuery&lt;'Source&gt; * 'Accumulate * Func&lt;'Accumulate, 'Source, 'Accumulate&gt; * Func&lt;'Accumulate, 'Accumulate, 'Accumulate&gt; * Func&lt;'Accumulate, 'Result&gt; -&gt; 'Result" Usage="System.Linq.ParallelEnumerable.Aggregate (source, seed, updateAccumulatorFunc, combineAccumulatorsFunc, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="updateAccumulatorFunc" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="combineAccumulatorsFunc" Type="System.Func&lt;TAccumulate,TAccumulate,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TAccumulate">Der Typ des Akkumulatorwerts.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts.</typeparam>
        <param name="source">Eine Sequenz, die aggregiert werden soll.</param>
        <param name="seed">Der erste Akkumulatorwert.</param>
        <param name="updateAccumulatorFunc">Eine Akkumulatorfunktion, die für jedes Element in einer Partition aufgerufen werden soll.</param>
        <param name="combineAccumulatorsFunc">Eine Akkumulatorfunktion, die für das zurückgegebene Akkumulatorergebnis jeder Partition aufgerufen werden soll.</param>
        <param name="resultSelector">Eine Funktion zum Transformieren des letzten Akkumulatorwerts in den Ergebniswert.</param>
        <summary>Wendet parallel eine Akkumulatorfunktion auf eine Sequenz an. Diese Überladung ist in der sequenziellen Implementierung nicht verfügbar.</summary>
        <returns>Der transformierte letzte Akkumulatorwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung ist spezifisch für eine parallele Abfrage verarbeiten. Eine parallele Abfrage kann die Daten Quellsequenz in mehrere Untersequenzen (Partitionen) partitionieren. Die `updateAccumulatorFunc` für jedes Element innerhalb von Partitionen aufgerufen wird. Jede Partition führt dann ein einzelnes akkumulierte Ergebnis. Die `combineAccumulatorsFunc` wird dann aufgerufen, auf die Ergebnisse der einzelnen Partitionen, um ein einzelnes Element zu erhalten. Dieses Element wird dann transformiert, indem die `resultSelector` Funktion.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="updateAccumulatorFunc" /> oder <paramref name="combineAccumulatorsFunc" /> oder <paramref name="resultSelector" /> ist ein NULL-Verweis (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="All&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool All&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool All&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.All``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function All(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool All(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member All : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.All (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, auf deren Elemente das Prädikat angewendet werden soll.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Bestimmt parallel, ob alle Elemente einer Sequenz eine Bedingung erfüllen.</summary>
        <returns>TRUE, wenn jedes Element der Quellsequenz im angegebenen Prädikat erfolgreich überprüft wird oder wenn die Sequenz leer ist, andernfalls FALSE.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Any&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob eine parallele Sequenz Elemente enthält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Any``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As ParallelQuery(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Any : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.Any source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, für die überprüft werden soll, ob sie leer ist.</param>
        <summary>Bestimmt, ob eine parallele Sequenz Elemente enthält.</summary>
        <returns>True, wenn die Quellsequenz Elemente enthält, andernfalls false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung der Methode alle bewirkt, dass eine vollständig gepufferte Zusammenführung ausgeführt werden, bevor das Ergebnis zurückgegeben wird. Das mergeverhalten kann die Leistung beeinträchtigt oder dazu führen, dass eine Ausnahme wegen unzureichenden Arbeitsspeichers in großen aufzählbare Elemente bereit. Um den mergeverhalten zu vermeiden, verwenden Sie die Überladung der, die einen Func-Parameter akzeptiert, andernfalls verwenden Sie eine alternative Methode wie z. B. "FirstOrDefault".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Any``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Any : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.Any (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, auf deren Elemente das Prädikat angewendet werden soll.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Bestimmt parallel, ob ein Element einer Sequenz eine Bedingung erfüllt.</summary>
        <returns>TRUE, wenn Elemente der Quellsequenz im angegebenen Prädikat erfolgreich überprüft werden, andernfalls FALSE.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsEnumerable&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; AsEnumerable&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; AsEnumerable&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsEnumerable``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsEnumerable(Of TSource) (source As ParallelQuery(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ AsEnumerable(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsEnumerable : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.AsEnumerable source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, die in <see cref="T:System.Collections.Generic.IEnumerable`1" /> umgewandelt werden soll.</param>
        <summary>Konvertiert ein <see cref="T:System.Linq.ParallelQuery`1" /> in ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, um die sequenzielle Auswertung der Abfrage zu erzwingen.</summary>
        <returns>Die als <see cref="T:System.Collections.Generic.IEnumerable`1" /> typisierte Eingabesequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsOrdered">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery AsOrdered (this System.Linq.ParallelQuery source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery AsOrdered(class System.Linq.ParallelQuery source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsOrdered(System.Linq.ParallelQuery)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsOrdered (source As ParallelQuery) As ParallelQuery" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery ^ AsOrdered(System::Linq::ParallelQuery ^ source);" />
      <MemberSignature Language="F#" Value="static member AsOrdered : System.Linq.ParallelQuery -&gt; System.Linq.ParallelQuery" Usage="System.Linq.ParallelEnumerable.AsOrdered source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Die Eingabesequenz.</param>
        <summary>Ermöglicht die Behandlung einer Datenquelle als sortierte Datenquelle, indem die Standardeinstellung "unsortiert" überschrieben wird. AsOrdered kann nur für nicht generische Sequenzen aufgerufen werden, die von AsParallel, ParallelEnumerable.Range und ParallelEnumerable.Repeat zurückgegeben werden.</summary>
        <returns>Die Quellsequenz, die die ursprüngliche Reihenfolge in den nachfolgenden Abfrageoperatoren beibehält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine natürliche Spannung besteht zwischen Leistung und die Beibehaltung der Reihenfolge, in parallelen Verarbeitung. Standardmäßig verhält sich eine parallele Abfrage wie die Reihenfolge der Ergebnisse ist beliebig, es sei denn, AsOrdered übernommen wird, oder es ein explizite OrderBy-Operator in der Abfrage ist. Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.InvalidOperationException">ausgelöst, wenn <paramref name="source" /> keine Elemente enthält 
- oder - 
wenn AsOrdered im Laufe einer Abfrage aufgerufen wird. Der Aufruf kann direkt nach <see cref="M:System.Linq.ParallelEnumerable.AsParallel(System.Collections.IEnumerable)" />, <see cref="M:System.Linq.ParallelEnumerable.Range(System.Int32,System.Int32)" /> oder <see cref="M:System.Linq.ParallelEnumerable.Repeat``1(``0,System.Int32)" /> ausgeführt werden.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsOrdered&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; AsOrdered&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; AsOrdered&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsOrdered``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsOrdered(Of TSource) (source As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ AsOrdered(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsOrdered : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.AsOrdered source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Eingabesequenz.</param>
        <summary>Ermöglicht die Behandlung einer Datenquelle als sortierte Datenquelle, indem die Standardeinstellung "unsortiert" überschrieben wird. AsOrdered kann nur für generische Sequenzen aufgerufen werden, die von AsParallel, ParallelEnumerable.Range und ParallelEnumerable.Repeat zurückgegeben werden.</summary>
        <returns>Die Quellsequenz, die die ursprüngliche Reihenfolge in den nachfolgenden Abfrageoperatoren beibehält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine natürliche Spannung besteht zwischen Leistung und die Beibehaltung der Reihenfolge, in parallelen Verarbeitung. Standardmäßig verhält sich eine parallele Abfrage wie die Reihenfolge der Ergebnisse ist beliebig, es sei denn, AsOrdered übernommen wird, oder es ein explizite OrderBy-Operator in der Abfrage ist. Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.InvalidOperationException">Ausgelöst, wenn <paramref name="source" /> keine Elemente enthält 
- oder - 
wenn <paramref name="source" /> nicht AsParallel, ParallelEnumerable.Range oder ParallelEnumerable.Repeat ist.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AsParallel">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ermöglicht die Parallelisierung einer Abfrage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bindet die Abfrage für PLINQ. Weitere Informationen finden Sie unter [Parallel LINQ (PLINQ) (Paralleles LINQ (PLINQ))](~/docs/standard/parallel-programming/parallel-linq-plinq.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AsParallel">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery AsParallel (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery AsParallel(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsParallel(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsParallel (source As IEnumerable) As ParallelQuery" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery ^ AsParallel(System::Collections::IEnumerable ^ source);" />
      <MemberSignature Language="F#" Value="static member AsParallel : System.Collections.IEnumerable -&gt; System.Linq.ParallelQuery" Usage="System.Linq.ParallelEnumerable.AsParallel source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das in ein <see cref="T:System.Linq.ParallelQuery" /> konvertiert werden soll.</param>
        <summary>Ermöglicht die Parallelisierung einer Abfrage.</summary>
        <returns>Die Quelle als ParallelQuery, die an ParallelEnumerable-Erweiterungsmethoden gebunden werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.ParallelEnumerable.Cast%2A> Operator kann verwendet werden, eine ParallelQuery in einem ParallelQuery(T) konvertiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsParallel&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; AsParallel&lt;TSource&gt; (this System.Collections.Concurrent.Partitioner&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; AsParallel&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsParallel``1(System.Collections.Concurrent.Partitioner{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsParallel(Of TSource) (source As Partitioner(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ AsParallel(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsParallel : System.Collections.Concurrent.Partitioner&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.AsParallel source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein Partitionierer für die Eingabesequenz.</param>
        <summary>Ermöglicht die Parallelisierung einer Abfrage mit einem benutzerdefinierten Partitionierer, der für die Aufteilung der Eingabesequenz in Partitionen zuständig ist, als Quelle.</summary>
        <returns>Die <paramref name="source" /> als ParallelQuery, die an ParallelEnumerable-Erweiterungsmethoden gebunden werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Source-Partitionierer GetOrderedPartitions, die Methode verwendet wird, wenn aktiviert ist, während des Partitionierers GetPartitions verwendet wird, wenn Sortierung nicht aktiviert ist (Standardeinstellung). Des Source-Partitionierers GetDynamicPartitions und GetDynamicOrderedPartitions des werden nicht verwendet. Weitere Informationen und Beispiele finden Sie unter [benutzerdefinierte Partitionierer für PLINQ und TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsParallel&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; AsParallel&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; AsParallel&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsParallel``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsParallel(Of TSource) (source As IEnumerable(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ AsParallel(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsParallel : seq&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.AsParallel source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das in ein <see cref="T:System.Linq.ParallelQuery`1" /> konvertiert werden soll.</param>
        <summary>Ermöglicht die Parallelisierung einer Abfrage.</summary>
        <returns>Die Quelle als <see cref="T:System.Linq.ParallelQuery`1" />, das an ParallelEnumerable-Erweiterungsmethoden gebunden werden soll.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsSequential&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; AsSequential&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; AsSequential&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsSequential``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsSequential(Of TSource) (source As ParallelQuery(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ AsSequential(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsSequential : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.AsSequential source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.ParallelQuery`1" />, das in ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> konvertiert werden soll.</param>
        <summary>Konvertiert ein <see cref="T:System.Linq.ParallelQuery`1" /> in ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, um die sequenzielle Auswertung der Abfrage zu erzwingen.</summary>
        <returns>Die Quelle als <see cref="T:System.Collections.Generic.IEnumerable`1" />, das an sequenzielle Erweiterungsmethoden gebunden werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Beibehaltung der Reihenfolge in PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md) und [Vorgehensweise: Sortierung in einer PLINQ-Abfrage Steuerelement](~/docs/standard/parallel-programming/how-to-control-ordering-in-a-plinq-query.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="AsUnordered&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; AsUnordered&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; AsUnordered&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.AsUnordered``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsUnordered(Of TSource) (source As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ AsUnordered(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsUnordered : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.AsUnordered source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Eingabesequenz.</param>
        <summary>Ermöglicht es, eine Zwischenabfrage so zu behandeln, als würde keine Reihenfolge zwischen den Elementen vorausgesetzt.</summary>
        <returns>Die Quellsequenz mit beliebiger Reihenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 AsUnordered kann Leistungsvorteile bieten, wenn die Reihenfolge in einem Teil einer Abfrage nicht erforderlich ist. Standardmäßig behandelt PLINQ eine Eingabesequenz als ungeordnete, es sei denn, OrderBy oder AsOrdered angegeben ist. Wenn Sortierung aktiviert wurde und wird nicht mehr benötigt, allerdings dann AsUnordered deaktivieren in der Mitte der Abfrage verwendet werden kann, und kann dies zu Leistungsvorteile. Der AsUnordered-Operator selbst wird nicht die Quellsequenz shuffle; entfällt einfach Sortierung für die nachfolgenden Operatoren. Wenn die Quelle sortiert ist, ggf. nachfolgende Operatoren diese Sortierung ist dies sehr viel effizienter, dafür sein. AsUnordered kann eine beliebige Stelle in der Abfrage aufgerufen werden. Es muss nicht sofort nach der AsParallel aufgerufen werden. Weitere Informationen finden Sie unter [Grundlagen zur Beschleunigung in PLINQ](~/docs/standard/parallel-programming/understanding-speedup-in-plinq.md) und [Beibehaltung der Reihenfolge in PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Average">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static decimal Average (this System.Linq.ParallelQuery&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Linq::ParallelQuery&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.ParallelQuery&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.ParallelQuery`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::ParallelQuery&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.ParallelQuery&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.ParallelQuery`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Integer)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::ParallelQuery&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;int&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe oder Anzahl der Elemente in der Sequenz ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.ParallelQuery&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.ParallelQuery`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Long)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::ParallelQuery&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;int64&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe oder Anzahl der Elemente in der Sequenz ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average (this System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Linq::ParallelQuery&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::ParallelQuery&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Die Quellsequenz.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException">Eine Sequenz von Werten, die verwendet werden, um einen Durchschnitt zu berechnen. Der Durchschnitt der Sequenz von Werten.<paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Nullable(Of Integer))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::ParallelQuery&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe oder Anzahl der Elemente in der Sequenz ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.ParallelQuery&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Nullable(Of Long))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::ParallelQuery&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe oder Anzahl der Elemente in der Sequenz ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average (this System.Linq.ParallelQuery&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Linq::ParallelQuery&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static float Average (this System.Linq.ParallelQuery&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average(class System.Linq.ParallelQuery`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average(System.Linq.ParallelQuery{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As ParallelQuery(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Linq::ParallelQuery&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <exception cref="T:System.OverflowException">(Ausgelöst als interne Ausnahme von einer <see cref="T:System.AggregateException" />). Die <paramref name="selector" />-Funktion gibt einen Wert größer als MaxValue für den Elementtyp zurück.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <exception cref="T:System.OverflowException">(Ausgelöst als interne Ausnahme von einer <see cref="T:System.AggregateException" />). Die <paramref name="selector" />-Funktion gibt einen Wert größer als MaxValue für den Elementtyp zurück.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Integer)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe oder Anzahl der Elemente in der Sequenz ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <exception cref="T:System.OverflowException">(Ausgelöst als interne Ausnahme von einer <see cref="T:System.AggregateException" />). Die <paramref name="selector" />-Funktion gibt einen Wert größer als MaxValue für den Elementtyp zurück.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Long)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe oder Anzahl der Elemente in der Sequenz ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <exception cref="T:System.OverflowException">(Ausgelöst als interne Ausnahme von einer <see cref="T:System.AggregateException" />). Die <paramref name="selector" />-Funktion gibt einen Wert größer als MaxValue für den Elementtyp zurück.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <exception cref="T:System.OverflowException">(Ausgelöst als interne Ausnahme von einer <see cref="T:System.AggregateException" />). Die <paramref name="selector" />-Funktion gibt einen Wert größer als MaxValue für den Elementtyp zurück.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <exception cref="T:System.OverflowException">(Ausgelöst als interne Ausnahme von einer <see cref="T:System.AggregateException" />). Die <paramref name="selector" />-Funktion gibt einen Wert größer als MaxValue für den Elementtyp zurück.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe oder Anzahl der Elemente in der Sequenz ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <exception cref="T:System.OverflowException">(Ausgelöst als interne Ausnahme von einer <see cref="T:System.AggregateException" />). Die <paramref name="selector" />-Funktion gibt einen Wert größer als MaxValue für den Elementtyp zurück.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe oder Anzahl der Elemente in der Sequenz ist größer als <see cref="F:System.Int64.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <exception cref="T:System.OverflowException">(Ausgelöst als interne Ausnahme von einer <see cref="T:System.AggregateException" />). Die <paramref name="selector" />-Funktion gibt einen Wert größer als MaxValue für den Elementtyp zurück.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <exception cref="T:System.OverflowException">(Ausgelöst als interne Ausnahme von einer <see cref="T:System.AggregateException" />). Die <paramref name="selector" />-Funktion gibt einen Wert größer als MaxValue für den Elementtyp zurück.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Average&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Average``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel den Durchschnitt einer Sequenz von Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <exception cref="T:System.OverflowException">(Ausgelöst als interne Ausnahme von einer <see cref="T:System.AggregateException" />). Die <paramref name="selector" />-Funktion gibt einen Wert größer als MaxValue für den Elementtyp zurück.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Cast&lt;TResult&gt; (this System.Linq.ParallelQuery source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Cast&lt;TResult&gt;(class System.Linq.ParallelQuery source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Cast``1(System.Linq.ParallelQuery)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Cast(Of TResult) (source As ParallelQuery) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Cast(System::Linq::ParallelQuery ^ source);" />
      <MemberSignature Language="F#" Value="static member Cast : System.Linq.ParallelQuery -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Cast source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ, in den die Elemente von <paramref name="source" /> konvertiert werden sollen.</typeparam>
        <param name="source">Die Sequenz, die die zu konvertierenden Elemente enthält.</param>
        <summary>Konvertiert die Elemente einer ParallelQuery in den angegebenen Typ.</summary>
        <returns>Eine Sequenz, die jedes in den angegebenen Typ konvertierte Element der Quellsequenz enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.InvalidCastException">Der Typ der Quellsequenz konnte nicht in <paramref name="TResult" /> konvertiert werden.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verkettet zwei parallele Sequenzen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Concat``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Concat(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Concat(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Concat : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Concat (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="first">Dieser Parameter wird nicht verwendet.</param>
        <param name="second">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese Concat-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung vorhanden ist, um die Verwendung von "concat" mit einer linken Datenquelle des Typs nicht zuzulassen <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle vom Typ <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde der Concat-Operator scheint in dem die Bindung an die parallele Implementierung, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Ausnahme, die auftritt, wenn die Methode aufgerufen wird.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Concat``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Concat(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Concat(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Concat : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Concat (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Die erste zu verkettende Sequenz.</param>
        <param name="second">Die Sequenz, die mit der ersten Sequenz verkettet werden soll.</param>
        <summary>Verkettet zwei parallele Sequenzen.</summary>
        <returns>Eine Sequenz, die die verketteten Elemente der zwei Eingabesequenzen enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> oder <paramref name="second" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Contains&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt parallel, ob eine Sequenz ein angegebenes Element enthält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TSource value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TSource value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Contains``1(System.Linq.ParallelQuery{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As ParallelQuery(Of TSource), value As TSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, TSource value);" />
      <MemberSignature Language="F#" Value="static member Contains : System.Linq.ParallelQuery&lt;'Source&gt; * 'Source -&gt; bool" Usage="System.Linq.ParallelEnumerable.Contains (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, in der ein Wert gesucht werden soll.</param>
        <param name="value">Der Wert, der in der Sequenz gesucht werden soll.</param>
        <summary>Bestimmt parallel mithilfe des Standardgleichheitsvergleichs, ob eine Sequenz ein angegebenes Element enthält.</summary>
        <returns>True, wenn die Quellsequenz ein Element mit dem angegebenen Wert enthält, andernfalls false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TSource value, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TSource value, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Contains``1(System.Linq.ParallelQuery{``0},``0,System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As ParallelQuery(Of TSource), value As TSource, comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, TSource value, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Contains : System.Linq.ParallelQuery&lt;'Source&gt; * 'Source * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.Contains (source, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, in der ein Wert gesucht werden soll.</param>
        <param name="value">Der Wert, der in der Sequenz gesucht werden soll.</param>
        <param name="comparer">Ein Gleichheitsvergleich zum Vergleichen von Werten.</param>
        <summary>Bestimmt parallel mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, ob eine Sequenz ein angegebenes Element enthält.</summary>
        <returns>True, wenn die Quellsequenz ein Element mit dem angegebenen Wert enthält, andernfalls false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Count&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die Anzahl von Elementen in einer parallelen Sequenz zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Count``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As ParallelQuery(Of TSource)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Count : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Count source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, die zu zählende Elemente enthält.</param>
        <summary>Gibt die Anzahl von Elementen in einer parallelen Sequenz zurück.</summary>
        <returns>Die Anzahl der Elemente in der Eingabesequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Anzahl der Elemente in der Quelle ist größer als <see cref="F:System.Int32.MaxValue" />. (In diesem Fall ist der InnerException <see cref="T:System.OverflowException" />) - oder - Eine oder mehrere Ausnahmen sind während der Auswertung für die Abfrage aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Count``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Count : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Count (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, die zu zählende Elemente enthält.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt eine Zahl zurück, die die Anzahl von Elementen in der angegebenen parallelen Sequenz angibt, die eine Bedingung erfüllen.</summary>
        <returns>Eine Zahl, die die Anzahl der Elemente in der Sequenz darstellt, die die Bedingung in der Prädikatfunktion erfüllen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Anzahl der Elemente in der Quelle ist größer als <see cref="F:System.Int32.MaxValue" />. (In diesem Fall ist der InnerException <see cref="T:System.OverflowException" />) - oder - Eine oder mehrere Ausnahmen sind während der Auswertung für die Abfrage aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die Elemente der angegebenen parallelen Sequenz zurück, oder den angegebenen Wert in einer Singletonauflistung, wenn die Sequenz leer ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.DefaultIfEmpty``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ DefaultIfEmpty(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.DefaultIfEmpty source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, für die ein Standardwert zurückgegeben werden soll, wenn sie leer ist.</param>
        <summary>Gibt die Elemente der angegebenen parallelen Sequenz oder den Standardwert des Typparameters in einer Singletonauflistung zurück, wenn die Sequenz leer ist.</summary>
        <returns>Eine Sequenz, die default(TSource) enthält, wenn <paramref name="source" /> leer ist, andernfalls <paramref name="source" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, TSource defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, !!TSource defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.DefaultIfEmpty``1(System.Linq.ParallelQuery{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As ParallelQuery(Of TSource), defaultValue As TSource) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ DefaultIfEmpty(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, TSource defaultValue);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : System.Linq.ParallelQuery&lt;'Source&gt; * 'Source -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.DefaultIfEmpty (source, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="defaultValue" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, für die der angegebene Wert zurückgegeben werden soll, wenn sie leer ist.</param>
        <param name="defaultValue">Der Wert, der zurückgegeben werden soll, wenn die Sequenz leer ist.</param>
        <summary>Gibt die Elemente der angegebenen parallelen Sequenz zurück, oder den angegebenen Wert in einer Singletonauflistung, wenn die Sequenz leer ist.</summary>
        <returns>Eine Sequenz, die defaultValue enthält, wenn <paramref name="source" /> leer ist, andernfalls <paramref name="source" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Distinct&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Werten unterschiedliche Elemente aus einer parallelen Sequenz zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Distinct``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Distinct(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Distinct : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Distinct source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der doppelte Elemente entfernt werden sollen.</param>
        <summary>Gibt mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Werten unterschiedliche Elemente aus einer parallelen Sequenz zurück.</summary>
        <returns>Eine Sequenz, die unterschiedliche Elemente aus der Quellsequenz enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Distinct``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As ParallelQuery(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Distinct(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Distinct : System.Linq.ParallelQuery&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Distinct (source, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der doppelte Elemente entfernt werden sollen.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Gibt mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten unterschiedliche Elemente aus einer parallelen Sequenz zurück.</summary>
        <returns>Eine Sequenz, die unterschiedliche Elemente aus der Quellsequenz enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ElementAt&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAt&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAt&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ElementAt``1(System.Linq.ParallelQuery{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAt(Of TSource) (source As ParallelQuery(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAt(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAt : System.Linq.ParallelQuery&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.ElementAt (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, aus der ein Element zurückgegeben werden soll.</param>
        <param name="index">Der auf 0 (null) basierende Index des abzurufenden Elements.</param>
        <summary>Gibt das Element an einem angegebenen Index in einer parallelen Sequenz zurück.</summary>
        <returns>Das Element an der angegebenen Position in der Quellsequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 bzw. größer oder gleich der Anzahl der Elemente in <paramref name="source" />.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ElementAtOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAtOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAtOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ElementAtOrDefault``1(System.Linq.ParallelQuery{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAtOrDefault(Of TSource) (source As ParallelQuery(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAtOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAtOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.ElementAtOrDefault (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, aus der ein Element zurückgegeben werden soll.</param>
        <param name="index">Der auf 0 (null) basierende Index des abzurufenden Elements.</param>
        <summary>Gibt das Element an einem angegebenen Index in einer parallelen Sequenz oder einen Standardwert zurück, wenn der Index außerhalb des gültigen Bereichs liegt.</summary>
        <returns>default(TSource), wenn der Index außerhalb der Begrenzungen der Quellsequenz liegt, andernfalls das Element an der angegebenen Position in der Quellsequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Empty&lt;TResult&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Empty&lt;TResult&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Function Empty(Of TResult) () As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TResult">Der Typ, der dem Typparameter der zurückgegebenen generischen Sequenz zugewiesen werden soll.</typeparam>
        <summary>Gibt ein leeres ParallelQuery{TResult} mit dem angegebenen Typargument zurück.</summary>
        <returns>Eine leere Sequenz, deren Typargument <paramref name="TResult" /> ist.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Except&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erzeugt die Differenzmenge von zwei parallelen Sequenzen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Except(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Except : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Except (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="first">Dieser Parameter wird nicht verwendet.</param>
        <param name="second">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese Except-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung vorhanden ist, um die Verwendung von nicht zuzulassen jedoch mit einer linken Datenquelle vom Typ <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle vom Typ <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde Except-Operator scheint in dem die Bindung an die parallele Implementierung, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Ausnahme, die auftritt, wenn die Methode aufgerufen wird.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Except(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Except : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Except (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Eine Sequenz, deren nicht auch in <paramref name="second" /> enthaltenen Elemente zurückgegeben werden.</param>
        <param name="second">Eine Sequenz, deren auch in der ersten Sequenz enthaltenen Elemente aus der zurückgegebenen Sequenz entfernt werden.</param>
        <summary>Erzeugt die Differenz zweier paralleler Sequenzen mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Werten.</summary>
        <returns>Eine Sequenz, die die Differenzmenge der Elemente von zwei Sequenzen enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> oder <paramref name="second" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Except(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Except : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Except (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="first">Dieser Parameter wird nicht verwendet.</param>
        <param name="second">Dieser Parameter wird nicht verwendet.</param>
        <param name="comparer">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese Except-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung vorhanden ist, um die Verwendung von nicht zuzulassen jedoch mit einer linken Datenquelle vom Typ <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle vom Typ <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde Except-Operator scheint in dem die Bindung an die parallele Implementierung, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Ausnahme, die auftritt, wenn die Methode aufgerufen wird.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Except``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Except(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Except : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Except (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Eine Sequenz, deren nicht auch in <paramref name="second" /> enthaltenen Elemente zurückgegeben werden.</param>
        <param name="second">Eine Sequenz, deren auch in der ersten Sequenz enthaltenen Elemente aus der zurückgegebenen Sequenz entfernt werden.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Erzeugt mithilfe des angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten die Differenzmenge zweier paralleler Sequenzen.</summary>
        <returns>Eine Sequenz, die die Differenzmenge der Elemente von zwei Sequenzen enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> oder <paramref name="second" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="First&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt das erste Element einer parallelen Sequenz zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.First``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member First : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.First source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, deren erstes Element zurückgegeben werden soll.</param>
        <summary>Gibt das erste Element einer parallelen Sequenz zurück.</summary>
        <returns>Das erste Element in der angegebenen Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Abfrage nicht sortiert ist, ist das erste Element nicht deterministisch. Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.First``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member First : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.First (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der ein Element zurückgegeben werden soll.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das erste Element in einer parallelen Sequenz zurück, das eine angegebene Bedingung erfüllt.</summary>
        <returns>Das erste Element in der Sequenz, das mit der angegebenen Prädikatfunktion erfolgreich überprüft wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Abfrage nicht sortiert ist, ist das erste Element nicht deterministisch. Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element in <paramref name="source" /> erfüllt die Bedingung in <paramref name="predicate" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FirstOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt das erste Element einer parallelen Sequenz zurück oder einen Standardwert, wenn die Sequenz keine Elemente enthält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.FirstOrDefault``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.FirstOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, deren erstes Element zurückgegeben werden soll.</param>
        <summary>Gibt das erste Element einer parallelen Sequenz zurück oder einen Standardwert, wenn die Sequenz keine Elemente enthält.</summary>
        <returns>default(TSource), wenn <paramref name="source" /> leer ist, andernfalls das erste Element in <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Abfrage nicht sortiert ist, ist das erste Element nicht deterministisch. Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.FirstOrDefault``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.FirstOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der ein Element zurückgegeben werden soll.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das erste Element der parallelen Sequenz zurück, das eine Bedingung erfüllt, oder einen Standardwert, wenn ein solches Element nicht gefunden wird.</summary>
        <returns>default(TSource), wenn <paramref name="source" /> leer ist oder die vom Prädikat angegebene Überprüfung für kein Element erfolgreich ausgeführt wird, andernfalls das erste Element in <paramref name="source" />, für das die vom Prädikat angegebene Überprüfung erfolgreich ausgeführt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Abfrage nicht sortiert ist, ist das erste Element nicht deterministisch. Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ForAll&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static void ForAll&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Action&lt;TSource&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForAll&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ForAll``1(System.Linq.ParallelQuery{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub ForAll(Of TSource) (source As ParallelQuery(Of TSource), action As Action(Of TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void ForAll(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForAll : System.Linq.ParallelQuery&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; unit" Usage="System.Linq.ParallelEnumerable.ForAll (source, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="action" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Das <see cref="T:System.Linq.ParallelQuery`1" />, dessen Elemente von <paramref name="action" /> verarbeitet werden.</param>
        <param name="action">Eine Aktion, die für jedes Element aufgerufen werden soll.</param>
        <summary>Ruft parallel die angegebene Aktion für jedes Element in der <paramref name="source" /> auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine effiziente Möglichkeit, die die Ausgabe eine parallele Abfrage verarbeitet werden, da keine Zusammenführungsschritt am Ende erforderlich ist. Weitere Informationen finden Sie unter [Mergeoptionen in PLINQ](~/docs/standard/parallel-programming/merge-options-in-plinq.md) oder [Beibehaltung der Reihenfolge in PLINQ](~/docs/standard/parallel-programming/order-preservation-in-plinq.md). Da diese Methode einen Nebeneffekt erzeugt, können sie beobachten Sie die tatsächliche Reihenfolge der Ausführung in einer parallelen Abfrage verwendet werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gruppiert parallel die Elemente einer Sequenz entsprechend einer Schlüsselauswahlfunktion.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As ParallelQuery(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Ein OrderedParallelQuery{TSource}, das zu sortierende Elemente enthält.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <summary>Gruppiert parallel die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion.</summary>
        <returns>Eine Sequenz von Gruppen, die entsprechend ihrem <paramref name="TKey" /> absteigend sortiert werden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels vom <paramref name="keySelector" /> &gt;.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.OrderedParallelQuery`1" /> mit den zu sortierenden Elementen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert parallel die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und vergleicht die Schlüssel mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <returns>Eine Sequenz von Gruppen, die entsprechend ihrem <paramref name="TKey" /> absteigend sortiert werden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As ParallelQuery(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente im <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.OrderedParallelQuery`1" /> mit den zu sortierenden Elementen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einem <see cref="T:System.Linq.IGrouping`2" /> zugeordnet wird.</param>
        <summary>Gruppiert parallel die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und projiziert die Elemente für jede Gruppe mithilfe einer angegebenen Funktion.</summary>
        <returns>Eine Sequenz von Gruppen, die entsprechend ihrem <paramref name="TKey" /> absteigend sortiert werden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente in der IGrouping.</typeparam>
        <param name="source">Ein OrderedParallelQuery{TSource}, das zu sortierende Elemente enthält.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einer IGrouping zugeordnet wird.</param>
        <param name="comparer">Ein IComparer{TSource} zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert parallel die Elemente einer Sequenz entsprechend einer Schlüsselauswahlfunktion. Die Schlüssel werden mithilfe eines Vergleichs verglichen, und die Elemente jeder Gruppe werden mithilfe einer angegebenen Funktion projiziert.</summary>
        <returns>Eine Sequenz von Gruppen, die entsprechend ihrem <paramref name="TKey" /> absteigend sortiert werden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), resultSelector As Func(Of TKey, IEnumerable(Of TSource), TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <typeparam name="TResult">Der Typ des von <paramref name="resultSelector" /> zurückgegebenen Ergebniswerts.</typeparam>
        <param name="source">Eine Sequenz, deren Elemente gruppiert werden sollen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <summary>Gruppiert parallel die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert.</summary>
        <returns>Eine Sequenz von Elementen vom Typ <paramref name="TResult" />, wobei jedes Element eine Projektion über eine Gruppe und ihren Schlüssel darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), resultSelector As Func(Of TKey, IEnumerable(Of TSource), TResult), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <typeparam name="TResult">Der Typ des von <paramref name="resultSelector" /> zurückgegebenen Ergebniswerts.</typeparam>
        <param name="source">Eine Sequenz, deren Elemente gruppiert werden sollen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert parallel die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert. Die Schlüssel werden mithilfe eines angegebenen Vergleichs verglichen.</summary>
        <returns>Eine Folge von Gruppen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``4(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), resultSelector As Func(Of TKey, IEnumerable(Of TElement), TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, elementSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente in jedem IGrouping{TKey, TElement}.</typeparam>
        <typeparam name="TResult">Der Typ des von <paramref name="resultSelector" /> zurückgegebenen Ergebniswerts.</typeparam>
        <param name="source">Eine Sequenz, deren Elemente gruppiert werden sollen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einem IGrouping&lt;Key, TElement&gt; zugeordnet wird.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <summary>Gruppiert parallel die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert. Die Elemente jeder Gruppe werden mithilfe einer angegebenen Funktion projiziert.</summary>
        <returns>Eine Sequenz von Elementen vom Typ <paramref name="TResult" />, wobei jedes Element eine Projektion über eine Gruppe und ihren Schlüssel darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupBy``4(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), resultSelector As Func(Of TKey, IEnumerable(Of TElement), TResult), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupBy (source, keySelector, elementSelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente in jedem IGrouping{TKey, TElement}.</typeparam>
        <typeparam name="TResult">Der Typ des von <paramref name="resultSelector" /> zurückgegebenen Ergebniswerts.</typeparam>
        <param name="source">Eine Sequenz, deren Elemente gruppiert werden sollen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einem IGrouping{Key, TElement} zugeordnet wird.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert. Schlüsselwerte werden mithilfe eines angegebenen Vergleichs verglichen, und die Elemente jeder Gruppe werden mithilfe einer angegebenen Funktion projiziert.</summary>
        <returns>Eine Sequenz von Elementen vom Typ <paramref name="TResult" />, wobei jedes Element eine Projektion über eine Gruppe und ihren Schlüssel darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Korreliert parallel die Elemente zweier Sequenzen basierend auf der Gleichheit der Schlüssel und gruppiert die Ergebnisse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, IEnumerable(Of TInner), TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupJoin(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : System.Linq.ParallelQuery&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TInner">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TKey">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TResult">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="outer">Dieser Parameter wird nicht verwendet.</param>
        <param name="inner">Dieser Parameter wird nicht verwendet.</param>
        <param name="outerKeySelector">Dieser Parameter wird nicht verwendet.</param>
        <param name="innerKeySelector">Dieser Parameter wird nicht verwendet.</param>
        <param name="resultSelector">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese GroupJoin-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung vorhanden ist, um die Verwendung von GroupJoin mit einer linken Datenquelle des Typs nicht zulassen <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle vom Typ <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde der GroupJoin-Operator scheint in dem die Bindung an die parallele Implementierung, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Linq.ParallelQuery&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Linq.ParallelQuery`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As ParallelQuery(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, IEnumerable(Of TInner), TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupJoin(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Linq::ParallelQuery&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : System.Linq.ParallelQuery&lt;'Outer&gt; * System.Linq.ParallelQuery&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Linq.ParallelQuery&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements anhand eines Elements aus der ersten Sequenz und einer Auflistung von übereinstimmenden Elementen aus der zweiten Sequenz.</param>
        <summary>Korreliert parallel die Elemente zweier Sequenzen basierend auf der Gleichheit der Schlüssel und gruppiert die Ergebnisse. Schlüssel werden mithilfe des Standardgleichheitsvergleichs verglichen.</summary>
        <returns>Eine Sequenz, die Elemente des Typs <paramref name="TResult" /> enthält, die durch Ausführen eines Group Joins von zwei Sequenzen ermittelt werden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, IEnumerable(Of TInner), TResult), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupJoin(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : System.Linq.ParallelQuery&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TInner">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TKey">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TResult">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="outer">Dieser Parameter wird nicht verwendet.</param>
        <param name="inner">Dieser Parameter wird nicht verwendet.</param>
        <param name="outerKeySelector">Dieser Parameter wird nicht verwendet.</param>
        <param name="innerKeySelector">Dieser Parameter wird nicht verwendet.</param>
        <param name="resultSelector">Dieser Parameter wird nicht verwendet.</param>
        <param name="comparer">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese GroupJoin-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung vorhanden ist, um die Verwendung von GroupJoin mit einer linken Datenquelle des Typs nicht zulassen <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle vom Typ <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde der GroupJoin-Operator scheint in dem die Bindung an die parallele Implementierung, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Ausnahme, die auftritt, wenn die Methode aufgerufen wird.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Linq.ParallelQuery&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Linq.ParallelQuery`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.GroupJoin``4(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As ParallelQuery(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, IEnumerable(Of TInner), TResult), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ GroupJoin(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Linq::ParallelQuery&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : System.Linq.ParallelQuery&lt;'Outer&gt; * System.Linq.ParallelQuery&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Linq.ParallelQuery&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements anhand eines Elements aus der ersten Sequenz und einer Auflistung von übereinstimmenden Elementen aus der zweiten Sequenz.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Hashen und Vergleichen von Schlüsseln.</param>
        <summary>Korreliert parallel die Elemente zweier Sequenzen basierend auf der Gleichheit der Schlüssel und gruppiert die Ergebnisse. Schlüssel werden mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> verglichen.</summary>
        <returns>Eine Sequenz, die Elemente des Typs <paramref name="TResult" /> enthält, die durch Ausführen eines Group Joins von zwei Sequenzen ermittelt werden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Intersect&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erzeugt die Schnittmenge zweier paralleler Sequenzen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Intersect(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Intersect (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="first">Dieser Parameter wird nicht verwendet.</param>
        <param name="second">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese Intersect-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung vorhanden ist, um die Verwendung von Intersect mit einer linken Datenquelle des Typs nicht zuzulassen <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle vom Typ <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde der Intersect-Operator scheint in dem die Bindung an die parallele Implementierung, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Ausnahme, die auftritt, wenn die Methode aufgerufen wird.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Intersect(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Intersect (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Eine Sequenz, deren unterschiedliche Elemente, die auch in <paramref name="second" /> vorhanden sind, zurückgegeben werden.</param>
        <param name="second">Eine Sequenz, deren unterschiedliche Elemente, die auch in der ersten Sequenz vorhanden sind, zurückgegeben werden.</param>
        <summary>Erzeugt die Schnittmenge zweier paralleler Sequenzen mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Werten.</summary>
        <returns>Eine Sequenz, die die Elemente enthält, die die Schnittmenge von zwei Sequenzen bilden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Intersect(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Intersect (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="first">Dieser Parameter wird nicht verwendet.</param>
        <param name="second">Dieser Parameter wird nicht verwendet.</param>
        <param name="comparer">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese Intersect-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung vorhanden ist, um die Verwendung von Intersect mit einer linken Datenquelle des Typs nicht zuzulassen <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle vom Typ <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde der Intersect-Operator scheint in dem die Bindung an die parallele Implementierung, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Ausnahme, die auftritt, wenn die Methode aufgerufen wird.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Intersect``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Intersect(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Intersect (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Eine Sequenz, deren unterschiedliche Elemente, die auch in <paramref name="second" /> vorhanden sind, zurückgegeben werden.</param>
        <param name="second">Eine Sequenz, deren unterschiedliche Elemente, die auch in der ersten Sequenz vorhanden sind, zurückgegeben werden.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Erzeugt mithilfe des angegebenen IEqualityComparer{T} zum Vergleichen von Werten die Schnittmenge zweier paralleler Sequenzen.</summary>
        <returns>Eine Sequenz, die die Elemente enthält, die die Schnittmenge von zwei Sequenzen bilden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Korreliert parallel die Elemente zweier Sequenzen auf der Grundlage von übereinstimmenden Schlüsseln.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, TInner, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Join(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Join : System.Linq.ParallelQuery&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, 'Inner, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TInner">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TKey">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TResult">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="outer">Dieser Parameter wird nicht verwendet.</param>
        <param name="inner">Dieser Parameter wird nicht verwendet.</param>
        <param name="outerKeySelector">Dieser Parameter wird nicht verwendet.</param>
        <param name="innerKeySelector">Dieser Parameter wird nicht verwendet.</param>
        <param name="resultSelector">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese Join-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer eine <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung vorhanden ist, um die Verwendung von Join mit einer linken Datenquelle des Typs nicht zulassen <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle vom Typ <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde der Join-Operator scheint in dem die Bindung an die parallele Implementierung, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Linq.ParallelQuery&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Linq.ParallelQuery`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As ParallelQuery(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, TInner, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Join(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Linq::ParallelQuery&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Join : System.Linq.ParallelQuery&lt;'Outer&gt; * System.Linq.ParallelQuery&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, 'Inner, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Linq.ParallelQuery&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements aus zwei übereinstimmenden Elementen.</param>
        <summary>Korreliert parallel die Elemente zweier Sequenzen auf der Grundlage von übereinstimmenden Schlüsseln. Schlüssel werden mithilfe des Standardgleichheitsvergleichs verglichen.</summary>
        <returns>Eine Sequenz, die Elemente des Typs <paramref name="TResult" /> enthält, die durch Ausführen eines Inner Joins von zwei Sequenzen ermittelt werden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, TInner, TResult), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Join(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Join : System.Linq.ParallelQuery&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, 'Inner, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TInner">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TKey">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TResult">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="outer">Dieser Parameter wird nicht verwendet.</param>
        <param name="inner">Dieser Parameter wird nicht verwendet.</param>
        <param name="outerKeySelector">Dieser Parameter wird nicht verwendet.</param>
        <param name="innerKeySelector">Dieser Parameter wird nicht verwendet.</param>
        <param name="resultSelector">Dieser Parameter wird nicht verwendet.</param>
        <param name="comparer">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese Join-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer eine <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung vorhanden ist, um die Verwendung eines Joins mit einer linken Datenquelle vom Typ nicht zuzulassen <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle vom Typ <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde der Join-Operator scheint in dem die Bindung an die parallele Implementierung, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Ausnahme, die auftritt, wenn die Methode aufgerufen wird.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.ParallelQuery&lt;TOuter&gt; outer, System.Linq.ParallelQuery&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TOuter&gt; outer, class System.Linq.ParallelQuery`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Join``4(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As ParallelQuery(Of TOuter), inner As ParallelQuery(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, TInner, TResult), comparer As IEqualityComparer(Of TKey)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Join(System::Linq::ParallelQuery&lt;TOuter&gt; ^ outer, System::Linq::ParallelQuery&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Join : System.Linq.ParallelQuery&lt;'Outer&gt; * System.Linq.ParallelQuery&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, 'Inner, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.ParallelQuery&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Linq.ParallelQuery&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements aus zwei übereinstimmenden Elementen.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Hashen und Vergleichen von Schlüsseln.</param>
        <summary>Korreliert parallel die Elemente zweier Sequenzen auf der Grundlage von übereinstimmenden Schlüsseln. Schlüssel werden mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> verglichen.</summary>
        <returns>Eine Sequenz, die Elemente des Typs <paramref name="TResult" /> enthält, die durch Ausführen eines Inner Joins von zwei Sequenzen ermittelt werden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="action" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Last&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt das letzte Element einer parallelen Sequenz zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Last``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Last : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Last source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der das letzte Element zurückgegeben werden soll.</param>
        <summary>Gibt das letzte Element einer parallelen Sequenz zurück.</summary>
        <returns>Der Wert an der letzten Position in der Quellsequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Abfrage nicht sortiert ist, ist das letzte Element nicht deterministisch. Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Last``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Last : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Last (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der ein Element zurückgegeben werden soll.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das letzte Element einer parallelen Sequenz zurück, das eine angegebene Bedingung erfüllt.</summary>
        <returns>Das letzte Element in der Sequenz, das mit der angegebenen Prädikatfunktion erfolgreich überprüft wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Abfrage nicht sortiert ist, ist das letzte Element nicht deterministisch. Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element in <paramref name="source" /> erfüllt die Bedingung in <paramref name="predicate" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt das letzte Element einer parallelen Sequenz zurück oder einen Standardwert, wenn die Sequenz keine Elemente enthält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.LastOrDefault``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.LastOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der ein Element zurückgegeben werden soll.</param>
        <summary>Gibt das letzte Element einer parallelen Sequenz zurück oder einen Standardwert, wenn die Sequenz keine Elemente enthält.</summary>
        <returns>default(), wenn die Quellsequenz leer ist, andernfalls das letzte Element in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Abfrage nicht sortiert ist, ist das letzte Element nicht deterministisch. Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.LastOrDefault``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.LastOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der ein Element zurückgegeben werden soll.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das letzte Element einer parallelen Sequenz zurück, das eine Bedingung erfüllt, oder einen Standardwert, wenn ein solches Element nicht gefunden wird.</summary>
        <returns>default(), wenn die Sequenz leer ist oder keine Elemente von der Prädikatfunktion erfolgreich überprüft werden, andernfalls das letzte Element, das von der Prädikatfunktion erfolgreich überprüft wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Abfrage nicht sortiert ist, ist das letzte Element nicht deterministisch. Weitere Informationen finden Sie unter [Order Preservation in PLINQ (Beibehaltung der Reihenfolge in PLINQ)](~/docs/standard/parallel-programming/order-preservation-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="LongCount&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Int64 zurück, die die Gesamtanzahl von Elementen in einer parallelen Sequenz darstellt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.LongCount``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As ParallelQuery(Of TSource)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LongCount : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.LongCount source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, die zu zählende Elemente enthält.</param>
        <summary>Gibt eine Int64 zurück, die die Gesamtanzahl von Elementen in einer parallelen Sequenz darstellt.</summary>
        <returns>Die Anzahl der Elemente in der Eingabesequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Anzahl der Elemente in der Quelle ist größer als <see cref="F:System.Int64.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.OverflowException">Das berechnete Ergebnis ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.LongCount``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LongCount : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.LongCount (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, die zu zählende Elemente enthält.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt eine Int64 zurück, die die Anzahl von Elementen in einer parallelen Sequenz darstellt, die eine Bedingung erfüllen.</summary>
        <returns>Eine Zahl, die die Anzahl der Elemente in der Sequenz darstellt, die die Bedingung in der Prädikatfunktion erfüllen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Anzahl der Elemente in der Quelle ist größer als <see cref="F:System.Int64.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.OverflowException">Das berechnete Ergebnis ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Max">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (this System.Linq.ParallelQuery&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Max(System::Linq::ParallelQuery&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (this System.Linq.ParallelQuery&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(class System.Linq.ParallelQuery`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Max(System::Linq::ParallelQuery&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (this System.Linq.ParallelQuery&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(class System.Linq.ParallelQuery`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Max(System::Linq::ParallelQuery&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;int&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (this System.Linq.ParallelQuery&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(class System.Linq.ParallelQuery`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Max(System::Linq::ParallelQuery&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;int64&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max (this System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Max(System::Linq::ParallelQuery&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max (this System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Max(System::Linq::ParallelQuery&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max (this System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Max(System::Linq::ParallelQuery&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max (this System.Linq.ParallelQuery&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Max(System::Linq::ParallelQuery&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max (this System.Linq.ParallelQuery&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Max(System::Linq::ParallelQuery&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (this System.Linq.ParallelQuery&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(class System.Linq.ParallelQuery`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max(System.Linq.ParallelQuery{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As ParallelQuery(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Max(System::Linq::ParallelQuery&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in der Quellsequenz.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente und <paramref name="TSource" /> ist ein nicht auf 0 (null) festlegbarer Werttyp.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente und <paramref name="TSource" /> ist ein nicht auf 0 (null) festlegbarer Werttyp.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente und <paramref name="TSource" /> ist ein nicht auf 0 (null) festlegbarer Werttyp.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente und <paramref name="TSource" /> ist ein nicht auf 0 (null) festlegbarer Werttyp.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente und <paramref name="TSource" /> ist ein nicht auf 0 (null) festlegbarer Werttyp.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Max&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente und <paramref name="TSource" /> ist ein nicht auf 0 (null) festlegbarer Werttyp.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Max&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Max&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Max``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource, TResult) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Max(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; 'Result" Usage="System.Linq.ParallelEnumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Der Typ des von <paramref name="selector" /> zurückgegebenen Werts.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformierenfunktion auf und gibt den Höchstwert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente und <paramref name="TSource" /> ist ein nicht auf 0 (null) festlegbarer Werttyp.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Min">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (this System.Linq.ParallelQuery&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Min(System::Linq::ParallelQuery&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente und <paramref name="TSource" /> ist ein nicht auf 0 (null) festlegbarer Werttyp.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (this System.Linq.ParallelQuery&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(class System.Linq.ParallelQuery`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Min(System::Linq::ParallelQuery&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente und <paramref name="TSource" /> ist ein nicht auf 0 (null) festlegbarer Werttyp.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (this System.Linq.ParallelQuery&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(class System.Linq.ParallelQuery`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Min(System::Linq::ParallelQuery&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;int&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente und <paramref name="TSource" /> ist ein nicht auf 0 (null) festlegbarer Werttyp.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (this System.Linq.ParallelQuery&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(class System.Linq.ParallelQuery`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Min(System::Linq::ParallelQuery&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;int64&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente und <paramref name="TSource" /> ist ein nicht auf 0 (null) festlegbarer Werttyp.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min (this System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Min(System::Linq::ParallelQuery&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min (this System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Min(System::Linq::ParallelQuery&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min (this System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Min(System::Linq::ParallelQuery&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min (this System.Linq.ParallelQuery&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Min(System::Linq::ParallelQuery&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min (this System.Linq.ParallelQuery&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Min(System::Linq::ParallelQuery&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (this System.Linq.ParallelQuery&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(class System.Linq.ParallelQuery`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min(System.Linq.ParallelQuery{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As ParallelQuery(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Min(System::Linq::ParallelQuery&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente und <paramref name="TSource" /> ist ein nicht auf 0 (null) festlegbarer Werttyp.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer parallelen Sequenz von Werten zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente und <paramref name="TSource" /> ist ein nicht auf 0 (null) festlegbarer Werttyp.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente und <paramref name="TSource" /> ist ein nicht auf 0 (null) festlegbarer Werttyp.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente und <paramref name="TSource" /> ist ein nicht auf 0 (null) festlegbarer Werttyp.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente und <paramref name="TSource" /> ist ein nicht auf 0 (null) festlegbarer Werttyp.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente und <paramref name="TSource" /> ist ein nicht auf 0 (null) festlegbarer Werttyp.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Min&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente und <paramref name="TSource" /> ist ein nicht auf 0 (null) festlegbarer Werttyp.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Min&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Min&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Min``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource, TResult) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Min(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; 'Result" Usage="System.Linq.ParallelEnumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Der Typ des von <paramref name="selector" /> zurückgegebenen Werts.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft parallel für jedes Element einer Sequenz eine Transformationsfunktion auf und gibt den Mindestwert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente und <paramref name="TSource" /> ist ein nicht auf 0 (null) festlegbarer Werttyp.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="OfType&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; OfType&lt;TResult&gt; (this System.Linq.ParallelQuery source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; OfType&lt;TResult&gt;(class System.Linq.ParallelQuery source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.OfType``1(System.Linq.ParallelQuery)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OfType(Of TResult) (source As ParallelQuery) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ OfType(System::Linq::ParallelQuery ^ source);" />
      <MemberSignature Language="F#" Value="static member OfType : System.Linq.ParallelQuery -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.OfType source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ, nach dem die Elemente der Sequenz gefiltert werden sollen.</typeparam>
        <param name="source">Die Sequenz, deren Elemente gefiltert werden sollen.</param>
        <summary>Filtert die Elemente einer ParallelQuery anhand eines angegebenen Typs.</summary>
        <returns>Eine Sequenz, die Elemente der Eingabesequenz enthält, die nach Typ gefiltert sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortiert parallel die Elemente einer Sequenz in aufsteigender Reihenfolge.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.OrderBy``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ OrderBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.OrderBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <summary>Sortiert parallel die Elemente einer Sequenz in aufsteigender Reihenfolge nach einem Schlüssel.</summary>
        <returns>Ein OrderedParallelQuery{TSource}, dessen Elemente nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu sequenziellen Implementierung ist dies keine stabile Sortierung. Um eine stabile Sortierung zu erreichen, ändern Sie eine Abfrage der Form: sortiert Var = Quelle. Select((e,i) = > new {E = e, I = i}). OrderBy((v) = > v.e). ThenBy (V = > v.i entstanden ist). Select((v) = > v.e);  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.OrderBy``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ OrderBy(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderBy : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.OrderBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="comparer">Ein IComparer{TKey} zum Vergleichen von Schlüsseln.</param>
        <summary>Sortiert parallel die Elemente einer Sequenz mithilfe eines angegebenen Vergleichs in aufsteigender Reihenfolge.</summary>
        <returns>Ein OrderedParallelQuery{TSource}, dessen Elemente nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu sequenziellen Implementierung ist dies keine stabile Sortierung. Finden Sie unter den Hinweisen zu <xref:System.Linq.ParallelEnumerable.OrderBy%2A> für einen Ansatz zum Implementieren einer stabilen Sortierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortiert die Elemente einer Sequenz in absteigender Reihenfolge.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.OrderByDescending``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ OrderByDescending(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.OrderByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <summary>Sortiert parallel die Elemente einer Sequenz in absteigender Reihenfolge nach einem Schlüssel.</summary>
        <returns>Ein OrderedParallelQuery{TSource}, dessen Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu sequenziellen Implementierung ist dies keine stabile Sortierung. Finden Sie unter den Hinweisen zu <xref:System.Linq.ParallelEnumerable.OrderBy%2A> für einen Ansatz zum Implementieren einer stabilen Sortierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.OrderByDescending``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ OrderByDescending(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.OrderByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="comparer">Ein IComparer{TKey} zum Vergleichen von Schlüsseln.</param>
        <summary>Sortiert die Elemente einer Sequenz mithilfe eines angegebenen Vergleichs in absteigender Reihenfolge.</summary>
        <returns>Ein OrderedParallelQuery{TSource}, dessen Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu sequenziellen Implementierung ist dies keine stabile Sortierung. Finden Sie unter den Hinweisen zu <xref:System.Linq.ParallelEnumerable.OrderBy%2A> für einen Ansatz zum Implementieren einer stabilen Sortierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="KeySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Range">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;int&gt; Range (int start, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;int32&gt; Range(int32 start, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Range(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Range (start As Integer, count As Integer) As ParallelQuery(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Linq::ParallelQuery&lt;int&gt; ^ Range(int start, int count);" />
      <MemberSignature Language="F#" Value="static member Range : int * int -&gt; System.Linq.ParallelQuery&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Range (start, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Der Wert der ersten ganzen Zahl in der Sequenz.</param>
        <param name="count">Die Anzahl der aufeinander folgenden ganzen Zahlen, die generiert werden sollen.</param>
        <summary>Generiert eine parallele Sequenz von ganzen Zahlen in einem angegebenen Bereich.</summary>
        <returns>Eine IEnumerable&lt;Int32&gt;-Schnittstelle in C# oder IEnumerable(Of Int32) in Visual Basic, die einen Bereich sequenzieller ganzer Zahlen enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist kleiner als 0 oder <paramref name="start" /> + <paramref name="count" /> –1 ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Repeat&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Repeat&lt;TResult&gt; (TResult element, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Repeat&lt;TResult&gt;(!!TResult element, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Repeat``1(``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Repeat(Of TResult) (element As TResult, count As Integer) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Repeat(TResult element, int count);" />
      <MemberSignature Language="F#" Value="static member Repeat : 'Result * int -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Repeat (element, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="element" Type="TResult" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Werts, der in der Ergebnissequenz wiederholt werden soll.</typeparam>
        <param name="element">Der zu wiederholende Wert.</param>
        <param name="count">Die gewünschte Anzahl der Wiederholungen des Werts in der generierten Sequenz.</param>
        <summary>Generiert eine parallele Sequenz, die einen wiederholten Wert enthält.</summary>
        <returns>Eine Sequenz, die einen wiederholten Wert enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist kleiner als 0.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Reverse&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Reverse&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Reverse``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reverse(Of TSource) (source As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Reverse(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Reverse : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Reverse source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine umzukehrende Sequenz von Werten.</param>
        <summary>Kehrt die Reihenfolge der Elemente in einer parallelen Sequenz um.</summary>
        <returns>Eine Sequenz , deren Elemente den Elementen der Eingabesequenz in umgekehrter Reihenfolge entsprechen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Projiziert parallel jedes Element einer Sequenz in ein neues Format.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Select``2(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Integer, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Select(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Der von der Auswahl zurückgegebene Typ der Elemente.</typeparam>
        <param name="source">Eine Sequenz von Werten, für die eine Transformationsfunktion aufgerufen werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Projiziert parallel jedes Element einer Sequenz in ein neues Format, indem der Index des Elements integriert wird.</summary>
        <returns>Eine Sequenz, deren Elemente das Ergebnis eines Aufrufs der Transformationsfunktion für jedes Element von <paramref name="source" /> ist, basierend auf dem für <paramref name="selector" /> bereitgestellten Index.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.OverflowException">Mehr als <see cref="F:System.Int32.MaxValue" /> Elemente werden von der Abfrage aufgezählt. Diese Bedingung könnte im Streamingmodus auftreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Select``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Select(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Der von der Auswahl zurückgegebene Typ der Elemente.</typeparam>
        <param name="source">Eine Sequenz von Werten, für die eine Transformationsfunktion aufgerufen werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Projiziert parallel jedes Element einer Sequenz in ein neues Format.</summary>
        <returns>Eine Sequenz, deren Elemente das Ergebnis des Aufrufs einer Transformationsfunktion für jedes Element von <paramref name="source" /> sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SelectMany&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Projiziert jedes Element einer Sequenz parallel in ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> und fasst die resultierenden Sequenzen in einer einzelnen Sequenz zusammen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SelectMany``2(System.Linq.ParallelQuery{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, IEnumerable(Of TResult))) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ SelectMany(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, seq&lt;'Result&gt;&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Der von der Auswahl zurückgegebene Typ der Elemente der Sequenz.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Projiziert jedes Element einer Sequenz parallel in ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> und fasst die resultierenden Sequenzen in einer einzelnen Sequenz zusammen.</summary>
        <returns>Eine Sequenz, deren Elemente das Ergebnis eines Aufrufs der 1:n-Transformierenfunktion für jedes Element der Eingabesequenz sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SelectMany``2(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Integer, IEnumerable(Of TResult))) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ SelectMany(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int, seq&lt;'Result&gt;&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Der von der Auswahl zurückgegebene Typ der Elemente der Sequenz.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Projiziert jedes Element einer Sequenz parallel in ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> und fasst die resultierenden Sequenzen in einer einzelnen Sequenz zusammen. Der Index jedes Quellelements wird im projizierten Format des jeweiligen Elements verwendet.</summary>
        <returns>Eine Sequenz, deren Elemente das Ergebnis eines Aufrufs der 1:n-Transformierenfunktion für jedes Element der Eingabesequenz sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.OverflowException">Mehr als <see cref="F:System.Int32.MaxValue" /> Elemente werden von der Abfrage aufgezählt.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SelectMany``3(System.Linq.ParallelQuery{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As ParallelQuery(Of TSource), collectionSelector As Func(Of TSource, IEnumerable(Of TCollection)), resultSelector As Func(Of TSource, TCollection, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ SelectMany(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^ collectionSelector, Func&lt;TSource, TCollection, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, seq&lt;'Collection&gt;&gt; * Func&lt;'Source, 'Collection, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Zwischenelemente, die von <paramref name="collectionSelector" /> erfasst werden.</typeparam>
        <typeparam name="TCollection">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Der Typ der Elemente in der Ergebnissequenz.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="collectionSelector">Eine Transformierenfunktion, die auf jedes Quellelement angewendet werden soll. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements anhand eines Elements aus der ersten Sequenz und einer Auflistung von übereinstimmenden Elementen aus der zweiten Sequenz.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, fasst die resultierenden Sequenzen zu einer einzigen Sequenz zusammen und ruft für jedes Element in dieser Sequenz eine Ergebnisauswahlfunktion auf.</summary>
        <returns>Eine Sequenz, deren Elemente das Ergebnis eines Aufrufs der 1:n-Transform-Funktion <paramref name="collectionSelector" /> für jedes Element von <paramref name="source" /> auf der Basis des für <paramref name="collectionSelector" /> angegebenen Indexes und die anschließende Zuordnung jedes dieser Sequenzelemente und ihrer entsprechenden Quellelemente zu einem Ergebniselement sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.OverflowException">Mehr als <see cref="F:System.Int32.MaxValue" /> Elemente werden von der Abfrage aufgezählt.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SelectMany``3(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As ParallelQuery(Of TSource), collectionSelector As Func(Of TSource, Integer, IEnumerable(Of TCollection)), resultSelector As Func(Of TSource, TCollection, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ SelectMany(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^ collectionSelector, Func&lt;TSource, TCollection, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int, seq&lt;'Collection&gt;&gt; * Func&lt;'Source, 'Collection, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Zwischenelemente, die von <paramref name="collectionSelector" /> erfasst werden.</typeparam>
        <typeparam name="TCollection">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Der zurückzugebende Elementtyp.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="collectionSelector">Eine Transformierenfunktion, die auf jedes Quellelement angewendet werden soll. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements anhand eines Elements aus der ersten Sequenz und einer Auflistung von übereinstimmenden Elementen aus der zweiten Sequenz.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, fasst die resultierenden Sequenzen zu einer einzigen Sequenz zusammen und ruft für jedes Element in dieser Sequenz eine Ergebnisauswahlfunktion auf. Der Index jedes Quellelements wird im projizierten Zwischenformat des jeweiligen Elements verwendet.</summary>
        <returns>Eine Sequenz, deren Elemente das Ergebnis eines Aufrufs der 1:n-Transform-Funktion <paramref name="collectionSelector" /> für jedes Element von <paramref name="source" /> auf der Basis des für <paramref name="collectionSelector" /> angegebenen Indexes und die anschließende Zuordnung jedes dieser Sequenzelemente und ihrer entsprechenden Quellelemente zu einem Ergebniselement sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.OverflowException">Mehr als <see cref="F:System.Int32.MaxValue" /> Elemente werden von der Abfrage aufgezählt.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SequenceEqual&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob zwei parallele Sequenzen gleich sind, indem die Elemente mithilfe eines Gleichheitsvergleichs für ihren Typ verglichen werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.SequenceEqual (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="first">Dieser Parameter wird nicht verwendet.</param>
        <param name="second">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese SequenceEqual-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung vorhanden ist, um die Verwendung von SequenceEqual mit einer linken Datenquelle des Typs nicht zulassen <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle vom Typ <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde der SequenceEqual-Operator scheint in dem die Bindung an die parallele Implementierung, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wird jedes Mal ausgelöst, wenn diese Methode aufgerufen wird.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.SequenceEqual (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Eine Sequenz, die mit einer zweiten Sequenz verglichen werden soll.</param>
        <param name="second">Eine Sequenz, die mit der ersten Eingabesequenz verglichen werden soll.</param>
        <summary>Bestimmt, ob zwei parallele Sequenzen gleich sind, indem die Elemente mithilfe des Standardgleichheitsvergleichs für ihren Typ verglichen werden.</summary>
        <returns>True, wenn die zwei Quellsequenzen von gleicher Länge sind und ihre entsprechenden Elemente durch den Standardgleichheitsvergleich für ihren Typ als gleich bestimmt werden, andernfalls false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> oder <paramref name="second" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.SequenceEqual (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="first">Dieser Parameter wird nicht verwendet.</param>
        <param name="second">Dieser Parameter wird nicht verwendet.</param>
        <param name="comparer">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese SequenceEqual-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung vorhanden ist, um die Verwendung von SequenceEqual mit einer linken Datenquelle des Typs nicht zulassen <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle vom Typ <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde der SequenceEqual-Operator scheint in dem die Bindung an die parallele Implementierung, aber in Wirklichkeit binden, sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Wird jedes Mal ausgelöst, wenn diese Methode aufgerufen wird.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SequenceEqual``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource), comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.ParallelEnumerable.SequenceEqual (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Eine Sequenz, die mit <paramref name="second" /> verglichen werden soll.</param>
        <param name="second">Eine Sequenz, die mit der ersten Eingabesequenz verglichen werden soll.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, der zum Vergleichen von Elementen verwendet werden soll.</param>
        <summary>Bestimmt, ob zwei parallele Sequenzen gleich sind, indem ihre Elemente mithilfe eines angegebenen IEqualityComparer{T} verglichen werden.</summary>
        <returns>True, wenn die zwei Quellsequenzen von gleicher Länge sind und ihre entsprechenden Elemente durch den Standardgleichheitsvergleich für ihren Typ als gleich bestimmt werden, andernfalls false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> oder <paramref name="second" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Single&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt das einzige Element einer parallelen Sequenz zurück und löst eine Ausnahme aus, wenn nicht genau ein Element in der Sequenz vorhanden ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Single``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Single : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Single source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, deren einziges Element zurückgegeben werden soll.</param>
        <summary>Gibt das einzige Element einer parallelen Sequenz zurück und löst eine Ausnahme aus, wenn nicht genau ein Element in der Sequenz vorhanden ist.</summary>
        <returns>Das einzige Element der Eingabesequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Die Eingabesequenz enthält mehr als ein Element. -oder- Die Eingabesequenz ist leer.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Single``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Single : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.Single (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, deren einziges Element zurückgegeben werden soll.</param>
        <param name="predicate">Eine Funktion zum Überprüfen eines Elements auf eine Bedingung.</param>
        <summary>Gibt das einzige Element einer parallelen Sequenz zurück, das eine angegebene Bedingung erfüllt, und löst eine Ausnahme aus, wenn mehrere solche Elemente vorhanden sind.</summary>
        <returns>Das einzige Element der Eingabesequenz, das eine Bedingung erfüllt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Eine oder mehrere Ausnahmen sind während der Auswertung der Abfrage aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element erfüllt die Bedingung in <paramref name="predicate" />. -oder- Mehrere Elemente erfüllen die Bedingung in <paramref name="predicate" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SingleOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt das einzige Element einer parallelen Sequenz zurück oder einen Standardwert, wenn die Sequenz leer ist. Diese Methode löst eine Ausnahme aus, wenn mehrere Elemente in der Sequenz vorhanden sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SingleOrDefault``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As ParallelQuery(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.SingleOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, deren einziges Element zurückgegeben werden soll.</param>
        <summary>Gibt das einzige Element einer parallelen Sequenz zurück oder einen Standardwert, wenn die Sequenz leer ist. Diese Methode löst eine Ausnahme aus, wenn mehrere Elemente in der Sequenz vorhanden sind.</summary>
        <returns>Das einzige Element der Eingabesequenz oder default(), wenn die Sequenz keine Elemente enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> hat mehr als ein Element.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SingleOrDefault``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.ParallelEnumerable.SingleOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, deren einziges Element zurückgegeben werden soll.</param>
        <param name="predicate">Eine Funktion zum Überprüfen eines Elements auf eine Bedingung.</param>
        <summary>Gibt das einzige Element einer parallelen Sequenz zurück, das eine angegebene Bedingung erfüllt, oder einen Standardwert, wenn kein solches Element vorhanden ist. Diese Methode löst eine Ausnahme aus, wenn mehrere Elemente die Bedingung erfüllen.</summary>
        <returns>Gibt das einzige Element der Eingabesequenz zurück, das die Bedingung erfüllt, oder default(), wenn ein solches Element nicht gefunden wird.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> ist leer oder mehrere Elemente werden zurückgegeben.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Skip&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Skip&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Skip``1(System.Linq.ParallelQuery{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Skip(Of TSource) (source As ParallelQuery(Of TSource), count As Integer) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Skip(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Skip : System.Linq.ParallelQuery&lt;'Source&gt; * int -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Skip (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="count">Die Anzahl der Elemente, die übersprungen werden sollen, bevor die übrigen Elemente zurückgegeben werden.</param>
        <summary>Umgeht eine festgelegte Anzahl von Elementen in einer parallelen Sequenz und gibt dann die übrigen Elemente zurück.</summary>
        <returns>Eine Sequenz, die die Elemente enthält, die nach dem angegebenen Index in der Eingabesequenz auftreten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Anzahl > Quelle. Count(), werden keine Elemente zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.OverflowException">Anzahl ist größer als <see cref="F:System.Int32.MaxValue" /></exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Umgeht Elemente in einer parallelen Sequenz, solange eine angegebene Bedingung true ist, und gibt dann die übrigen Elemente zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SkipWhile``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ SkipWhile(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Umgeht Elemente in einer parallelen Sequenz, solange eine angegebene Bedingung true ist, und gibt dann die übrigen Elemente zurück.</summary>
        <returns>Eine Sequenz, die die Elemente aus der Eingabesequenz ab dem ersten Element in der linearen Reihe enthält, für das die vom Prädikat angegebene Überprüfung nicht erfolgreich ausgeführt wird.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.SkipWhile``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ SkipWhile(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="predicate">Eine Funktion zum Überprüfen jedes Quellelements auf eine Bedingung. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <summary>Umgeht Elemente in einer parallelen Sequenz, solange eine angegebene Bedingung true ist, und gibt dann die übrigen Elemente zurück. In der Logik der Prädikatfunktion wird der Index des Elements verwendet.</summary>
        <returns>Eine Sequenz, die die Elemente aus der Eingabesequenz ab dem ersten Element in der linearen Reihe enthält, für das die vom Prädikat angegebene Überprüfung nicht erfolgreich ausgeführt wird.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.OverflowException">Mehr als <see cref="F:System.Int32.MaxValue" /> Elemente werden von der Abfrage aufgezählt.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sum">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static decimal Sum (this System.Linq.ParallelQuery&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Linq::ParallelQuery&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static double Sum (this System.Linq.ParallelQuery&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum(class System.Linq.ParallelQuery`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Linq::ParallelQuery&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Double.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static int Sum (this System.Linq.ParallelQuery&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum(class System.Linq.ParallelQuery`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Linq::ParallelQuery&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;int&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static long Sum (this System.Linq.ParallelQuery&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum(class System.Linq.ParallelQuery`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Linq::ParallelQuery&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;int64&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum (this System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Linq::ParallelQuery&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum (this System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Linq::ParallelQuery&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Double.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum (this System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Linq::ParallelQuery&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum (this System.Linq.ParallelQuery&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Linq::ParallelQuery&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum (this System.Linq.ParallelQuery&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum(class System.Linq.ParallelQuery`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Linq::ParallelQuery&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Single.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static float Sum (this System.Linq.ParallelQuery&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum(class System.Linq.ParallelQuery`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum(System.Linq.ParallelQuery{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As ParallelQuery(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Linq::ParallelQuery&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Single.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten, die durch den Aufruf einer Transformierenfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten, die durch den Aufruf einer Transformierenfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Double.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente in der Quellsequenz.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten, die durch den Aufruf einer Transformierenfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten, die durch den Aufruf einer Transformierenfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten, die durch den Aufruf einer Transformierenfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten, die durch den Aufruf einer Transformierenfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Double.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten, die durch den Aufruf einer Transformierenfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten, die durch den Aufruf einer Transformierenfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten, die durch den Aufruf einer Transformierenfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Single.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Sum&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Sum``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As ParallelQuery(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.ParallelEnumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Summe berechnet werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet parallel die Summe einer Sequenz von Werten, die durch den Aufruf einer Transformierenfunktion für jedes Element der Eingabesequenz ermittelt werden.</summary>
        <returns>Die Summe der projizierten Werte in der Sequenz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Die Summe ist größer als <see cref="F:System.Single.MaxValue" />. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Take&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Take&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Take``1(System.Linq.ParallelQuery{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Take(Of TSource) (source As ParallelQuery(Of TSource), count As Integer) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Take(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Take : System.Linq.ParallelQuery&lt;'Source&gt; * int -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Take (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="count">Die Anzahl der zurückzugebenden Elemente.</param>
        <summary>Gibt eine angegebene Anzahl von zusammenhängenden Elementen ab dem Anfang einer parallelen Sequenz zurück.</summary>
        <returns>Eine Sequenz, die die festgelegte Anzahl von Elementen ab dem Anfang der Eingabesequenz enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TakeWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt Elemente aus einer parallelen Sequenz zurück, solange eine angegebene Bedingung true ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.TakeWhile``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ TakeWhile(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt Elemente aus einer parallelen Sequenz zurück, solange eine angegebene Bedingung true ist.</summary>
        <returns>Eine Sequenz, die die Elemente aus der Eingabesequenz enthält, die vor dem Element auftreten, bei dem die Überprüfung nicht mehr erfolgreich ist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.TakeWhile``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ TakeWhile(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="predicate">Eine Funktion zum Überprüfen jedes Quellelements auf eine Bedingung. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <summary>Gibt Elemente aus einer parallelen Sequenz zurück, solange eine angegebene Bedingung true ist. In der Logik der Prädikatfunktion wird der Index des Elements verwendet.</summary>
        <returns>Eine Sequenz, die Elemente aus der Eingabesequenz enthält, die vor dem Element auftreten, bei dem die Überprüfung nicht mehr erfolgreich ist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.OverflowException">Mehr als <see cref="F:System.Int32.MaxValue" /> Elemente werden von dieser Abfrage aufgelistet.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt parallel eine nachfolgende Sortierung der Elemente in einer Sequenz in aufsteigender Reihenfolge durch.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.OrderedParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ThenBy``2(System.Linq.OrderedParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As OrderedParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ ThenBy(System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.OrderedParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.ThenBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.OrderedParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Ein OrderedParallelQuery{TSource}, das zu sortierende Elemente enthält.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <summary>Führt parallel eine nachfolgende Sortierung der Elemente in einer Sequenz in aufsteigender Reihenfolge nach einem Schlüssel durch.</summary>
        <returns>Ein OrderedParallelQuery{TSource}, dessen Elemente nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu sequenziellen Implementierung ist dies keine stabile Sortierung. Finden Sie unter den Hinweisen zu <xref:System.Linq.ParallelEnumerable.OrderBy%2A> für einen Ansatz zum Implementieren einer stabilen Sortierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.OrderedParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ThenBy``2(System.Linq.OrderedParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As OrderedParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ ThenBy(System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.OrderedParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.ThenBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.OrderedParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Ein OrderedParallelQuery{TSource}, das zu sortierende Elemente enthält.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="comparer">Ein IComparer{TKey} zum Vergleichen von Schlüsseln.</param>
        <summary>Führt parallel mithilfe eines angegebenen Vergleichs eine nachfolgende Sortierung der Elemente in einer Sequenz in aufsteigender Reihenfolge durch.</summary>
        <returns>Ein OrderedParallelQuery{TSource}, dessen Elemente nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu sequenziellen Implementierung ist dies keine stabile Sortierung. Finden Sie unter den Hinweisen zu <xref:System.Linq.ParallelEnumerable.OrderBy%2A> für einen Ansatz zum Implementieren einer stabilen Sortierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt parallel eine nachfolgende Sortierung der Elemente in einer Sequenz in absteigender Reihenfolge durch.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.OrderedParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ThenByDescending``2(System.Linq.OrderedParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As OrderedParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ ThenByDescending(System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.OrderedParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.ThenByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.OrderedParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Ein OrderedParallelQuery{TSource}, das zu sortierende Elemente enthält.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <summary>Führt parallel eine nachfolgende Sortierung der Elemente in einer Sequenz in absteigender Reihenfolge nach einem Schlüssel durch.</summary>
        <returns>Eine Sequenz, deren Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu sequenziellen Implementierung ist dies keine stabile Sortierung. Finden Sie unter den Hinweisen zu <xref:System.Linq.ParallelEnumerable.OrderBy%2A> für einen Ansatz zum Implementieren einer stabilen Sortierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.OrderedParallelQuery&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.OrderedParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.OrderedParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ThenByDescending``2(System.Linq.OrderedParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As OrderedParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As OrderedParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ ThenByDescending(System::Linq::OrderedParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.OrderedParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.OrderedParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.ThenByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.OrderedParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.OrderedParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Ein OrderedParallelQuery{TSource}, das zu sortierende Elemente enthält.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="comparer">Ein IComparer{TKey} zum Vergleichen von Schlüsseln.</param>
        <summary>Führt parallel mithilfe eines angegebenen Vergleichs eine nachfolgende Sortierung der Elemente in einer Sequenz in absteigender Reihenfolge durch.</summary>
        <returns>Eine Sequenz, deren Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu sequenziellen Implementierung ist dies keine stabile Sortierung. Finden Sie unter den Hinweisen zu <xref:System.Linq.ParallelEnumerable.OrderBy%2A> für einen Ansatz zum Implementieren einer stabilen Sortierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToArray&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource[] ToArray&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource[] ToArray&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToArray``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToArray(Of TSource) (source As ParallelQuery(Of TSource)) As TSource()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static cli::array &lt;TSource&gt; ^ ToArray(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ToArray : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; 'Source[]" Usage="System.Linq.ParallelEnumerable.ToArray source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, aus der ein Array erstellt werden soll.</param>
        <summary>Erstellt ein Array aus einem <see cref="T:System.Linq.ParallelQuery`1" />.</summary>
        <returns>Ein Array, das die Elemente aus der Eingabesequenz enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein <see cref="T:System.Collections.Generic.Dictionary`2" /> aus einem <see cref="T:System.Linq.ParallelQuery`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToDictionary``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As Dictionary(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TSource&gt; ^ ToDictionary(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Source&gt;" Usage="System.Linq.ParallelEnumerable.ToDictionary (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Eine Sequenz, aus der ein <see cref="T:System.Collections.Generic.Dictionary`2" /> erstellt werden soll.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <summary>Erstellt ein <see cref="T:System.Collections.Generic.Dictionary`2" /> aus einem <see cref="T:System.Linq.ParallelQuery`1" /> gemäß einer angegebenen Schlüsselauswahlfunktion.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.Dictionary`2" />, das Schlüssel und Werte enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException"><paramref name="keySelector" /> generiert einen Schlüssel, der ein NULL-Verweis ist (Nothing in Visual Basic). -oder- <paramref name="keySelector" /> erzeugt für zwei Elemente doppelte Schlüssel. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToDictionary``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As Dictionary(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TSource&gt; ^ ToDictionary(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Source&gt;" Usage="System.Linq.ParallelEnumerable.ToDictionary (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Eine Sequenz, aus der ein <see cref="T:System.Collections.Generic.Dictionary`2" /> erstellt werden soll.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Erstellt ein <see cref="T:System.Collections.Generic.Dictionary`2" /> aus einer <see cref="T:System.Linq.ParallelQuery`1" /> gemäß einer angegebenen Schlüsselauswahlfunktion und eines angegebenen Schlüsselvergleichs.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.Dictionary`2" />, das Schlüssel und Werte enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException"><paramref name="keySelector" /> generiert einen Schlüssel, der ein NULL-Verweis ist (Nothing in Visual Basic). -oder- <paramref name="keySelector" /> erzeugt für zwei Elemente doppelte Schlüssel. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToDictionary``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey, TElement) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As Dictionary(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TElement&gt; ^ ToDictionary(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Element&gt;" Usage="System.Linq.ParallelEnumerable.ToDictionary (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <typeparam name="TElement">Der Typ des von <paramref name="elementSelector" /> zurückgegebenen Werts.</typeparam>
        <param name="source">Eine Sequenz, aus der ein <see cref="T:System.Collections.Generic.Dictionary`2" /> erstellt werden soll.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="elementSelector">Eine Transformationsfunktion, mit der aus jedem Element ein Ergebniselementwert erzeugt wird.</param>
        <summary>Erstellt ein <see cref="T:System.Collections.Generic.Dictionary`2" /> aus einem <see cref="T:System.Linq.ParallelQuery`1" /> entsprechend der angegebenen Schlüsselauswahlfunktion und Elementauswahlfunktion.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.Dictionary`2" />, das Werte vom Typ <paramref name="TElement" /> enthält, die aus der Eingabesequenz ausgewählt werden</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist ein NULL-Verweis (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException"><paramref name="keySelector" /> generiert einen Schlüssel, der ein NULL-Verweis ist (Nothing in Visual Basic). -oder- <paramref name="keySelector" /> erzeugt für zwei Elemente doppelte Schlüssel. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToDictionary``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey, TElement) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As Dictionary(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TElement&gt; ^ ToDictionary(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Element&gt;" Usage="System.Linq.ParallelEnumerable.ToDictionary (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <typeparam name="TElement">Der Typ des von <paramref name="elementSelector" /> zurückgegebenen Werts.</typeparam>
        <param name="source">Eine Sequenz, aus der ein <see cref="T:System.Collections.Generic.Dictionary`2" /> erstellt werden soll.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="elementSelector">Eine Transformationsfunktion, mit der aus jedem Element ein Ergebniselementwert erzeugt wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Erstellt ein <see cref="T:System.Collections.Generic.Dictionary`2" /> aus einem <see cref="T:System.Linq.ParallelQuery`1" /> entsprechend einer angegebenen Schlüsselauswahlfunktion, einem Vergleich und einer Elementauswahlfunktion.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.Dictionary`2" />, das Werte vom Typ <paramref name="TElement" /> enthält, die aus der Eingabesequenz ausgewählt werden</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist ein NULL-Verweis (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException"><paramref name="keySelector" /> generiert einen Schlüssel, der ein NULL-Verweis ist (Nothing in Visual Basic). -oder- <paramref name="keySelector" /> erzeugt für zwei Elemente doppelte Schlüssel. Oder: Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToList&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.List&lt;TSource&gt; ToList&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.List`1&lt;!!TSource&gt; ToList&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToList``1(System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToList(Of TSource) (source As ParallelQuery(Of TSource)) As List(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::List&lt;TSource&gt; ^ ToList(System::Linq::ParallelQuery&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ToList : System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Collections.Generic.List&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.ToList source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, aus der ein <see cref="T:System.Collections.Generic.List`1" /> erstellt werden soll.</param>
        <summary>Erstellt ein <see cref="T:System.Collections.Generic.List`1" /> aus einem <see cref="T:System.Linq.ParallelQuery`1" />.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.List`1" />, die Elemente aus der Eingabesequenz enthält</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLookup&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine <see cref="T:System.Linq.ILookup`2" /> aus einer <see cref="T:System.Linq.ParallelQuery`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToLookup``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey)) As ILookup(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TSource&gt; ^ ToLookup(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ToLookup : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Source&gt;" Usage="System.Linq.ParallelEnumerable.ToLookup (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Die Sequenz, aus der ein <see cref="T:System.Linq.ILookup`2" /> erstellt werden soll.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.ILookup`2" /> aus einem <see cref="T:System.Linq.ParallelQuery`1" /> gemäß einer angegebenen Schlüsselauswahlfunktion.</summary>
        <returns>Ein <see cref="T:System.Linq.ILookup`2" />, das Schlüssel und Werte enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToLookup``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As ILookup(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TSource&gt; ^ ToLookup(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToLookup : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Source&gt;" Usage="System.Linq.ParallelEnumerable.ToLookup (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Die Sequenz, aus der ein <see cref="T:System.Linq.ILookup`2" /> erstellt werden soll.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.ILookup`2" /> aus einem <see cref="T:System.Linq.ParallelQuery`1" /> gemäß einer angegebenen Schlüsselauswahlfunktion und eines angegebenen Schlüsselvergleichs.</summary>
        <returns>Ein <see cref="T:System.Linq.ILookup`2" />, das Schlüssel und Werte enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist ein NULL-Verweis (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToLookup``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey, TElement) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As ILookup(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TElement&gt; ^ ToLookup(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member ToLookup : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Element&gt;" Usage="System.Linq.ParallelEnumerable.ToLookup (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <typeparam name="TElement">Der Typ des von <paramref name="elementSelector" /> zurückgegebenen Werts.</typeparam>
        <param name="source">Die Sequenz, aus der ein <see cref="T:System.Linq.ILookup`2" /> erstellt werden soll.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="elementSelector">Eine Transformationsfunktion, mit der aus jedem Element ein Ergebniselementwert erzeugt wird.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.ILookup`2" /> aus einem <see cref="T:System.Linq.ParallelQuery`1" /> entsprechend der angegebenen Schlüsselauswahlfunktion und Elementauswahlfunktion.</summary>
        <returns>Ein <see cref="T:System.Linq.ILookup`2" />, das Werte vom Typ <paramref name="TElement" /> enthält, die aus der Eingabesequenz ausgewählt werden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist ein NULL-Verweis (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.ToLookup``3(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey, TElement) (source As ParallelQuery(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As ILookup(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TElement&gt; ^ ToLookup(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToLookup : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Element&gt;" Usage="System.Linq.ParallelEnumerable.ToLookup (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <typeparam name="TElement">Der Typ des von <paramref name="elementSelector" /> zurückgegebenen Werts.</typeparam>
        <param name="source">Die Sequenz, aus der ein <see cref="T:System.Linq.ILookup`2" /> erstellt werden soll.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="elementSelector">Eine Transformationsfunktion, mit der aus jedem Element ein Ergebniselementwert erzeugt wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.ILookup`2" /> aus einem <see cref="T:System.Linq.ParallelQuery`1" /> entsprechend einer angegebenen Schlüsselauswahlfunktion, einem Vergleich und einer Elementauswahlfunktion.</summary>
        <returns>Ein Lookup&lt;(Of &lt;(TKey, TElement&gt;)&gt;), das aus der Eingabesequenz ausgewählte Werte des Typs „TElement“ enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist ein NULL-Verweis (Nothing in Visual Basic).</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Union&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erzeugt die Vereinigungsmenge von zwei parallelen Sequenzen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Union(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Union : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Union (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="first">Dieser Parameter wird nicht verwendet.</param>
        <param name="second">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese Union-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung vorhanden ist, um die Verwendung von Union mit einer linken Datenquelle des Typs nicht zulassen <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle vom Typ <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde der Union-Operator scheint in dem die Bindung an die parallele Implementierung, aber in Wirklichkeit binden, sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Ausnahme, die auftritt, wenn die Methode aufgerufen wird.</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Union(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Union : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Union (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Eine Sequenz, deren unterschiedliche Elemente den ersten Satz für die Vereinigungsmengenbildung darstellen.</param>
        <param name="second">Eine Sequenz, deren unterschiedliche Elemente den zweiten Satz für die Vereinigungsmengenbildung darstellen.</param>
        <summary>Erzeugt die Vereinigungsmenge zweier paralleler Sequenzen mithilfe des Standardgleichheitsvergleichs.</summary>
        <returns>Eine Sequenz, die die Elemente aus beiden Eingabesequenzen ohne Duplikate enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> oder <paramref name="second" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (first As ParallelQuery(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Union(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Union : System.Linq.ParallelQuery&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Union (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="first">Dieser Parameter wird nicht verwendet.</param>
        <param name="second">Dieser Parameter wird nicht verwendet.</param>
        <param name="comparer">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese Union-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung vorhanden ist, um die Verwendung von Union mit einer linken Datenquelle des Typs nicht zulassen <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle vom Typ <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde der Union-Operator scheint in dem die Bindung an die parallele Implementierung, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Ausnahme, die auftritt, wenn die Methode aufgerufen wird.</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; first, System.Linq.ParallelQuery&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Union``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (first As ParallelQuery(Of TSource), second As ParallelQuery(Of TSource), comparer As IEqualityComparer(Of TSource)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Union(System::Linq::ParallelQuery&lt;TSource&gt; ^ first, System::Linq::ParallelQuery&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Union : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelQuery&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Union (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Eine Sequenz, deren unterschiedliche Elemente den ersten Satz für die Vereinigungsmengenbildung darstellen.</param>
        <param name="second">Eine Sequenz, deren unterschiedliche Elemente den zweiten Satz für die Vereinigungsmengenbildung darstellen.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Erzeugt mithilfe eines angegebenen IEqualityComparer{T} die Vereinigungsmenge zweier paralleler Sequenzen.</summary>
        <returns>Eine Sequenz, die die Elemente aus beiden Eingabesequenzen ohne Duplikate enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> oder <paramref name="second" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Where&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Filtert parallel eine Sequenz von Werten nach einem Prädikat.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Where&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Where``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Boolean)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Where(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Quelle.</typeparam>
        <param name="source">Eine zu filternde Sequenz.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Filtert parallel eine Sequenz von Werten nach einem Prädikat.</summary>
        <returns>Eine Sequenz, die Elemente aus der Eingabesequenz enthält, die die Bedingung erfüllen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; Where&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Where``1(System.Linq.ParallelQuery{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As ParallelQuery(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ Where(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : System.Linq.ParallelQuery&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Quelle.</typeparam>
        <param name="source">Eine zu filternde Sequenz.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Filtert parallel eine Sequenz von Werten nach einem Prädikat. In der Logik der Prädikatfunktion wird der Index der einzelnen Elemente verwendet.</summary>
        <returns>Eine Sequenz, die Elemente aus der Eingabesequenz enthält, die die Bedingung erfüllen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist ein NULL-Verweis („Nothing“ in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.OverflowException">Mehr als <see cref="F:System.Int32.MaxValue" /> Elemente werden von der Abfrage aufgezählt.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="WithCancellation&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; WithCancellation&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; WithCancellation&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.WithCancellation``1(System.Linq.ParallelQuery{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ WithCancellation(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WithCancellation : System.Linq.ParallelQuery&lt;'Source&gt; * System.Threading.CancellationToken -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.WithCancellation (source, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine ParallelQuery, für die die Option festgelegt werden soll.</param>
        <param name="cancellationToken">Ein Abbruchtoken.</param>
        <summary>Legt das <see cref="T:System.Threading.CancellationToken" /> fest, das der Abfrage zugeordnet werden soll.</summary>
        <returns>Eine ParallelQuery, die die gleiche Abfrage wie die Quelle darstellt, jedoch entsprechend dem registrierten Abbruchtoken.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Die <see cref="T:System.Threading.CancellationTokenSource" />, die dem freigegebenen <paramref name="cancellationToken" /> zugeordnet ist.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="WithCancellation" /> wird mehrmals in der Abfrage verwendet.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/80b14640-edfa-4153-be1b-3e003d3e9c1a">Gewusst wie: Abbrechen einer PLINQ-Abfrage</related>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Abbruch</related>
      </Docs>
    </Member>
    <Member MemberName="WithDegreeOfParallelism&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; WithDegreeOfParallelism&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, int degreeOfParallelism);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; WithDegreeOfParallelism&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, int32 degreeOfParallelism) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.WithDegreeOfParallelism``1(System.Linq.ParallelQuery{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithDegreeOfParallelism(Of TSource) (source As ParallelQuery(Of TSource), degreeOfParallelism As Integer) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ WithDegreeOfParallelism(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, int degreeOfParallelism);" />
      <MemberSignature Language="F#" Value="static member WithDegreeOfParallelism : System.Linq.ParallelQuery&lt;'Source&gt; * int -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.WithDegreeOfParallelism (source, degreeOfParallelism)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="degreeOfParallelism" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine ParallelQuery, für die der Grenzwert für den Grad der Parallelität festgelegt werden soll.</param>
        <param name="degreeOfParallelism">Der Grad der Parallelität für die Abfrage. Der Standardwert ist Math.Min(<see cref="P:System.Environment.ProcessorCount" />, <see langword="MAX_SUPPORTED_DOP" />), wobei <see langword="MAX_SUPPORTED_DOP" /> gleich 512 ist.</param>
        <summary>Legt den Grad der Parallelität für eine Abfrage fest. Der Grad der Parallelität ist die maximale Anzahl gleichzeitig ausgeführter Aufgaben, die zum Verarbeiten der Abfrage verwendet werden.</summary>
        <returns>Eine ParallelQuery, die die gleiche Abfrage wie die Quelle mit festgelegtem Grenzwert für den Grad der Parallelität darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="degreeOfParallelism" /> ist kleiner als 1 oder größer als 511.</exception>
        <exception cref="T:System.InvalidOperationException">WithDegreeOfParallelism wird mehrmals in der Abfrage verwendet.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="WithExecutionMode&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; WithExecutionMode&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, System.Linq.ParallelExecutionMode executionMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; WithExecutionMode&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, valuetype System.Linq.ParallelExecutionMode executionMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.WithExecutionMode``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelExecutionMode)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithExecutionMode(Of TSource) (source As ParallelQuery(Of TSource), executionMode As ParallelExecutionMode) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ WithExecutionMode(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, System::Linq::ParallelExecutionMode executionMode);" />
      <MemberSignature Language="F#" Value="static member WithExecutionMode : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelExecutionMode -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.WithExecutionMode (source, executionMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="executionMode" Type="System.Linq.ParallelExecutionMode" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine ParallelQuery, für die die Option festgelegt werden soll.</param>
        <param name="executionMode">Der Modus, in dem die Abfrage ausgeführt werden soll.</param>
        <summary>Legt den Ausführungsmodus der Abfrage fest.</summary>
        <returns>Eine ParallelQuery, die die gleiche Abfrage wie die Quelle darstellt, jedoch entsprechend dem registrierten Ausführungsmodus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Den Ausführungsmodus angibt, ob PLINQ versucht, auf die sequenzielle Ausführung zurückgreift, wenn bestimmte Abfrageformen erkannt. Weitere Informationen und Beispiele finden Sie unter [Vorgehensweise: Angeben des Ausführungsmodus in PLINQ](~/docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="executionMode" /> ist kein gültiger <see cref="T:System.Linq.ParallelExecutionMode" />-Wert.</exception>
        <exception cref="T:System.InvalidOperationException">WithExecutionMode wird mehrmals in der Abfrage verwendet.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="WithMergeOptions&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TSource&gt; WithMergeOptions&lt;TSource&gt; (this System.Linq.ParallelQuery&lt;TSource&gt; source, System.Linq.ParallelMergeOptions mergeOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TSource&gt; WithMergeOptions&lt;TSource&gt;(class System.Linq.ParallelQuery`1&lt;!!TSource&gt; source, valuetype System.Linq.ParallelMergeOptions mergeOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.WithMergeOptions``1(System.Linq.ParallelQuery{``0},System.Linq.ParallelMergeOptions)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function WithMergeOptions(Of TSource) (source As ParallelQuery(Of TSource), mergeOptions As ParallelMergeOptions) As ParallelQuery(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TSource&gt; ^ WithMergeOptions(System::Linq::ParallelQuery&lt;TSource&gt; ^ source, System::Linq::ParallelMergeOptions mergeOptions);" />
      <MemberSignature Language="F#" Value="static member WithMergeOptions : System.Linq.ParallelQuery&lt;'Source&gt; * System.Linq.ParallelMergeOptions -&gt; System.Linq.ParallelQuery&lt;'Source&gt;" Usage="System.Linq.ParallelEnumerable.WithMergeOptions (source, mergeOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.ParallelQuery&lt;TSource&gt;" RefType="this" />
        <Parameter Name="mergeOptions" Type="System.Linq.ParallelMergeOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine ParallelQuery, für die die Option festgelegt werden soll.</param>
        <param name="mergeOptions">Die Mergeoptionen, die für diese Abfrage festgelegt werden sollen.</param>
        <summary>Legt die Zusammenführungsoptionen für diese Abfrage fest. Diese Optionen geben an, wie die Abfrage die Ausgabe puffert.</summary>
        <returns>Eine ParallelQuery, die die gleiche Abfrage wie die Quelle darstellt, jedoch entsprechend den registrierten Mergeoptionen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist ein NULL-Verweis (Nothing in Visual&amp;#160;Basic).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mergeOptions" /> ist kein gültiger <see cref="T:System.Linq.ParallelMergeOptions" />-Wert.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="WithMergeOptions" /> wird mehrmals in der Abfrage verwendet.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/e8f7be3b-88de-4f33-ab14-dc008e76c1ba">Mergeoptionen in PLINQ</related>
        <related type="Article" href="https://msdn.microsoft.com/library/0f33b527-e91a-4550-a39a-e63e396fd831">Gewusst wie: Angeben von Zusammenführungsoptionen in PLINQ</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt parallel zwei Sequenzen unter Verwendung der angegebenen Prädikatfunktion zusammen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Linq.ParallelQuery&lt;TFirst&gt; first, System.Collections.Generic.IEnumerable&lt;TSecond&gt; second, Func&lt;TFirst,TSecond,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TFirst&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; second, class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Zip``3(System.Linq.ParallelQuery{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Zip(Of TFirst, TSecond, TResult) (first As ParallelQuery(Of TFirst), second As IEnumerable(Of TSecond), resultSelector As Func(Of TFirst, TSecond, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFirst, typename TSecond, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Zip(System::Linq::ParallelQuery&lt;TFirst&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSecond&gt; ^ second, Func&lt;TFirst, TSecond, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Zip : System.Linq.ParallelQuery&lt;'First&gt; * seq&lt;'Second&gt; * Func&lt;'First, 'Second, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Zip (first, second, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery&lt;T&gt; rather than System.Collections.Generic.IEnumerable&lt;T&gt;. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery&lt;T&gt;.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TFirst&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TFirst,TSecond,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TSecond">Dieser Typparameter wird nicht verwendet.</typeparam>
        <typeparam name="TResult">Dieser Typparameter wird nicht verwendet.</typeparam>
        <param name="first">Dieser Parameter wird nicht verwendet.</param>
        <param name="second">Dieser Parameter wird nicht verwendet.</param>
        <param name="resultSelector">Dieser Parameter wird nicht verwendet.</param>
        <summary>Diese Zip-Überladung sollte nie aufgerufen werden. Diese Methode wird als veraltet markiert und löst beim Aufrufen immer eine <see cref="T:System.NotSupportedException" /> aus.</summary>
        <returns>Diese Überladung löst immer eine <see cref="T:System.NotSupportedException" /> aus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung vorhanden ist, um die Verwendung der ZIP-Datei mit einer linken Datenquelle des Typs nicht zuzulassen <xref:System.Linq.ParallelQuery%601> und einer rechten Datenquelle vom Typ <xref:System.Collections.Generic.IEnumerable%601>. Andernfalls würde der Zip-Operator an die parallele Implementierung gebunden zu sein scheint, aber in Wirklichkeit Binden der sequenziellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Ausnahme, die auftritt, wenn die Methode aufgerufen wird.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/parallel-linq-plinq.md">Paralleles LINQ (PLINQ)</related>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ParallelQuery&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Linq.ParallelQuery&lt;TFirst&gt; first, System.Linq.ParallelQuery&lt;TSecond&gt; second, Func&lt;TFirst,TSecond,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ParallelQuery`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Linq.ParallelQuery`1&lt;!!TFirst&gt; first, class System.Linq.ParallelQuery`1&lt;!!TSecond&gt; second, class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.ParallelEnumerable.Zip``3(System.Linq.ParallelQuery{``0},System.Linq.ParallelQuery{``1},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Zip(Of TFirst, TSecond, TResult) (first As ParallelQuery(Of TFirst), second As ParallelQuery(Of TSecond), resultSelector As Func(Of TFirst, TSecond, TResult)) As ParallelQuery(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFirst, typename TSecond, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ParallelQuery&lt;TResult&gt; ^ Zip(System::Linq::ParallelQuery&lt;TFirst&gt; ^ first, System::Linq::ParallelQuery&lt;TSecond&gt; ^ second, Func&lt;TFirst, TSecond, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Zip : System.Linq.ParallelQuery&lt;'First&gt; * System.Linq.ParallelQuery&lt;'Second&gt; * Func&lt;'First, 'Second, 'Result&gt; -&gt; System.Linq.ParallelQuery&lt;'Result&gt;" Usage="System.Linq.ParallelEnumerable.Zip (first, second, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ParallelQuery&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Linq.ParallelQuery&lt;TFirst&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Linq.ParallelQuery&lt;TSecond&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TFirst,TSecond,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TSecond">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TResult">Der Typ der Rückgabeelemente.</typeparam>
        <param name="first">Die erste Sequenz, die gezippt werden soll.</param>
        <param name="second">Die zweite Sequenz, die gezippt werden soll.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements aus zwei übereinstimmenden Elementen.</param>
        <summary>Führt parallel zwei Sequenzen unter Verwendung der angegebenen Prädikatfunktion zusammen.</summary>
        <returns>Eine Sequenz, die Elemente des Typs <paramref name="TResult" /> enthält, die durch paarweises Ausführen von <paramref name="resultSelector" /> für zwei Sequenzen ermittelt werden. Wenn die Sequenzlängen ungleich sind, wird auf die Länge der kürzeren Sequenz gekürzt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> oder <paramref name="second" /> oder <paramref name="resultSelector" /> ist ein NULL-Verweis (Nothing in Visual Basic).</exception>
        <exception cref="T:System.OperationCanceledException">Die Abfrage wurde abgebrochen, wobei das Token über <paramref name="WithCancellation" /> übergeben wurde.</exception>
        <exception cref="T:System.AggregateException">Während der Auswertung der Abfrage ist mindestens eine Ausnahme aufgetreten.</exception>
      </Docs>
    </Member>
  </Members>
</Type>