<Type Name="Queryable" FullName="System.Linq.Queryable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5e5df19a63b2a4db7c91917642f62b22f895d342" /><Meta Name="ms.sourcegitcommit" Value="634678f7ccd2928c6b2cf792a301b079b63639af" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/26/2019" /><Meta Name="ms.locfileid" Value="68540571" /></Metadata><TypeSignature Language="C#" Value="public static class Queryable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Queryable extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Queryable" />
  <TypeSignature Language="VB.NET" Value="Public Module Queryable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Queryable abstract sealed" />
  <TypeSignature Language="F#" Value="type Queryable = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Queryable</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen Satz von <see langword="static" />-Methoden (<see langword="Shared" />-Methoden in Visual Basic) zum Abfragen von Datenstrukturen bereit, die <see cref="T:System.Linq.IQueryable`1" /> implementieren.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der in der <xref:System.Linq.Queryable> -Klasse deklarierte Satz von Methoden stellt eine Implementierung der Standard Abfrage Operatoren zum Abfragen von Datenquellen <xref:System.Linq.IQueryable%601>bereit, die implementieren. Die Standard Abfrage Operatoren sind allgemeine Methoden, die dem [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] -Muster folgen und es Ihnen ermöglichen, traversierungs-, Filter-und Projektions Vorgänge für Daten in beliebigen auszudrücken. NET-basierte Programmiersprache.  
  
 Die Mehrzahl der Methoden in dieser Klasse werden als Erweiterungs Methoden definiert, die den <xref:System.Linq.IQueryable%601> Typ erweitern. Dies bedeutet, dass Sie für jedes Objekt, das implementiert <xref:System.Linq.IQueryable%601>, wie eine Instanzmethode aufgerufen werden kann. Diese Methoden, die <xref:System.Linq.IQueryable%601> erweitern, führen keine direkte Abfrage durch. Stattdessen besteht die Funktion darin, ein <xref:System.Linq.Expressions.Expression> Objekt zu erstellen, bei dem es sich um eine Ausdrucks Baumstruktur handelt, die die kumulative Abfrage darstellt. Die-Methoden übergeben dann die neue Ausdrucks Baumstruktur entweder <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> an die- <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Methode oder an die <xref:System.Linq.IQueryable%601>-Methode der Eingabe. Die Methode, die aufgerufen wird, hängt davon <xref:System.Linq.Queryable> ab, ob die Methode einen Singleton-Wert <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> zurückgibt. in diesem Fall wird aufgerufen, oder es sind Aufzähl Bare Ergebnisse aufgetreten. in diesem Fall <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> wird aufgerufen.  
  
 Die tatsächliche Abfrage Ausführung für die Zieldaten erfolgt durch eine Klasse, die implementiert <xref:System.Linq.IQueryable%601>. Die Annahme einer <xref:System.Linq.Queryable> <xref:System.Linq.Enumerable> Implementierung besteht darin, dass das Ergebnis der Ausführung einer Ausdrucks Baumstruktur, die von einer Standard Abfrage Operator-Methode erstellt wurde, dem Ergebnis des Aufrufs der entsprechenden Methode im <xref:System.Linq.IQueryable%601> , wenn es sich bei der Datenquelle <xref:System.Collections.Generic.IEnumerable%601>um eine handelt.  
  
 Zusätzlich zu den Methoden des Standard Abfrage Operators, die auf <xref:System.Linq.IQueryable%601> -Objekte angewendet werden, enthält diese Klasse auch <xref:System.Linq.Queryable.AsQueryable%2A>eine-Methode <xref:System.Collections.IEnumerable> ,, <xref:System.Linq.IQueryable> die-Objekte als-Objekte eingibt.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/a73c4aec-5d15-4e98-b962-1274021ea93d">Language-Integrated Query (LINQ)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/24cda21e-8af8-4632-b519-c404a839b9b2">Übersicht über Standardabfrageoperatoren</related>
    <related type="Article" href="https://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b">Ausdrucksbaumstrukturen</related>
    <related type="Article" href="https://msdn.microsoft.com/library/73d13345-eece-471a-af40-4cc7a2f11655">LINQ to SQL</related>
  </Docs>
  <Members>
    <Member MemberName="Aggregate&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Aggregate&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TSource,TSource&gt;&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Aggregate&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, !!TSource, !!TSource&gt;&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Aggregate``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``0,``0}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource) (source As IQueryable(Of TSource), func As Expression(Of Func(Of TSource, TSource, TSource))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Aggregate(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TSource, TSource&gt; ^&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Source, 'Source&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Aggregate (source, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TSource,TSource&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, die aggregiert werden soll.</param>
        <param name="func">Eine Akkumulatorfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Wendet eine Akkumulatorfunktion auf eine Sequenz an</summary>
        <returns>Der letzte Akkumulatorwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Aggregate%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Aggregate%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Aggregate%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass die angegebene Funktion `func`,, auf jeden Wert in der Quell Sequenz angewendet wird und der akkumulierte Wert zurückgegeben wird. Der erste Wert in `source` wird als Ausgangswert für den akkumulierten Wert verwendet, der dem ersten Parameter in `func`entspricht.  
  
 Zum vereinfachen allgemeiner Aggregations Vorgänge umfasst der Satz von Standard Abfrage Operatoren auch zwei Zählmethoden <xref:System.Linq.Queryable.Count%2A> , <xref:System.Linq.Queryable.LongCount%2A>und, sowie vier <xref:System.Linq.Queryable.Max%2A>numerische <xref:System.Linq.Queryable.Min%2A>Aggregations <xref:System.Linq.Queryable.Sum%2A>Methoden,,, und. <xref:System.Linq.Queryable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Aggregate%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%7D%29> verwendet wird, um einen Satz aus einem Zeichen folgen Array zu erstellen.  
  
 [!code-csharp[System.Linq.Queryable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#1)]
 [!code-vb[System.Linq.Queryable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="func" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate&gt;">
      <MemberSignature Language="C#" Value="public static TAccumulate Aggregate&lt;TSource,TAccumulate&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TAccumulate seed, System.Linq.Expressions.Expression&lt;Func&lt;TAccumulate,TSource,TAccumulate&gt;&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TAccumulate Aggregate&lt;TSource, TAccumulate&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt;&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Aggregate``2(System.Linq.IQueryable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate) (source As IQueryable(Of TSource), seed As TAccumulate, func As Expression(Of Func(Of TAccumulate, TSource, TAccumulate))) As TAccumulate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TAccumulate Aggregate(System::Linq::IQueryable&lt;TSource&gt; ^ source, TAccumulate seed, System::Linq::Expressions::Expression&lt;Func&lt;TAccumulate, TSource, TAccumulate&gt; ^&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.IQueryable&lt;'Source&gt; * 'Accumulate * System.Linq.Expressions.Expression&lt;Func&lt;'Accumulate, 'Source, 'Accumulate&gt;&gt; -&gt; 'Accumulate" Usage="System.Linq.Queryable.Aggregate (source, seed, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TAccumulate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TAccumulate,TSource,TAccumulate&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TAccumulate">Der Typ des Akkumulatorwerts.</typeparam>
        <param name="source">Eine Sequenz, die aggregiert werden soll.</param>
        <param name="seed">Der erste Akkumulatorwert.</param>
        <param name="func">Eine Akkumulatorfunktion, die für jedes Element aufgerufen werden soll.</param>
        <summary>Wendet eine Akkumulatorfunktion auf eine Sequenz an Der angegebene Startwert wird als erster Akkumulatorwert verwendet.</summary>
        <returns>Der letzte Akkumulatorwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Aggregate%60%602%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Aggregate%60%602%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Aggregate%60%602%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass die angegebene Funktion `func`,, auf jeden Wert in der Quell Sequenz angewendet wird und der akkumulierte Wert zurückgegeben wird. Der `seed` -Parameter wird als Ausgangswert für den akkumulierten Wert verwendet, der dem ersten Parameter in `func`entspricht.  
  
 Zum vereinfachen allgemeiner Aggregations Vorgänge umfasst der Satz von Standard Abfrage Operatoren auch zwei Zählmethoden <xref:System.Linq.Queryable.Count%2A> , <xref:System.Linq.Queryable.LongCount%2A>und, sowie vier <xref:System.Linq.Queryable.Max%2A>numerische <xref:System.Linq.Queryable.Min%2A>Aggregations <xref:System.Linq.Queryable.Sum%2A>Methoden,,, und. <xref:System.Linq.Queryable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Aggregate%60%602%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%29> verwendet wird, um eine Akkumulatorfunktion anzuwenden, wenn ein Ausgangswert für die Funktion bereitgestellt wird.  
  
 [!code-csharp[System.Linq.Queryable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#2)]
 [!code-vb[System.Linq.Queryable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="func" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TAccumulate seed, System.Linq.Expressions.Expression&lt;Func&lt;TAccumulate,TSource,TAccumulate&gt;&gt; func, System.Linq.Expressions.Expression&lt;Func&lt;TAccumulate,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt;&gt; func, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TAccumulate, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Aggregate``3(System.Linq.IQueryable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate, TResult) (source As IQueryable(Of TSource), seed As TAccumulate, func As Expression(Of Func(Of TAccumulate, TSource, TAccumulate)), selector As Expression(Of Func(Of TAccumulate, TResult))) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Aggregate(System::Linq::IQueryable&lt;TSource&gt; ^ source, TAccumulate seed, System::Linq::Expressions::Expression&lt;Func&lt;TAccumulate, TSource, TAccumulate&gt; ^&gt; ^ func, System::Linq::Expressions::Expression&lt;Func&lt;TAccumulate, TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Aggregate : System.Linq.IQueryable&lt;'Source&gt; * 'Accumulate * System.Linq.Expressions.Expression&lt;Func&lt;'Accumulate, 'Source, 'Accumulate&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Accumulate, 'Result&gt;&gt; -&gt; 'Result" Usage="System.Linq.Queryable.Aggregate (source, seed, func, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TAccumulate,TSource,TAccumulate&gt;&gt;" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TAccumulate,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TAccumulate">Der Typ des Akkumulatorwerts.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts.</typeparam>
        <param name="source">Eine Sequenz, die aggregiert werden soll.</param>
        <param name="seed">Der erste Akkumulatorwert.</param>
        <param name="func">Eine Akkumulatorfunktion, die für jedes Element aufgerufen werden soll.</param>
        <param name="selector">Eine Funktion zum Transformieren des letzten Akkumulatorwerts in den Ergebniswert.</param>
        <summary>Wendet eine Akkumulatorfunktion auf eine Sequenz an Der angegebene Startwert wird als erster Akkumulatorwert verwendet, und der Ergebniswert wird mit der angegebenen Funktion ausgewählt.</summary>
        <returns>Der transformierte letzte Akkumulatorwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Aggregate%60%603%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Aggregate%60%603%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Aggregate%60%603%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass die angegebene Funktion `func`,, auf jeden Wert in der Quell Sequenz angewendet wird und der akkumulierte Wert zurückgegeben wird. Der `seed` -Parameter wird als Ausgangswert für den akkumulierten Wert verwendet, der dem ersten Parameter in `func`entspricht. Der letzte akkumulierte Wert wird `selector` an das-Ergebnis übermittelt, um den Ergebniswert abzurufen  
  
 Zum vereinfachen allgemeiner Aggregations Vorgänge umfasst der Satz von Standard Abfrage Operatoren auch zwei Zählmethoden <xref:System.Linq.Queryable.Count%2A> , <xref:System.Linq.Queryable.LongCount%2A>und, sowie vier <xref:System.Linq.Queryable.Max%2A>numerische <xref:System.Linq.Queryable.Min%2A>Aggregations <xref:System.Linq.Queryable.Sum%2A>Methoden,,, und. <xref:System.Linq.Queryable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, <xref:System.Linq.Queryable.Aggregate%60%603%28System.Linq.IQueryable%7B%60%600%7D%2C%60%601%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%29> wie mit eine Akkumulatorfunktion und eine Ergebnis Auswahl angewendet werden.  
  
 [!code-csharp[System.Linq.Queryable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#3)]
 [!code-vb[System.Linq.Queryable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="func" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="All&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool All&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool All&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.All``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function All(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool All(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member All : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; bool" Usage="System.Linq.Queryable.All (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, deren Elemente auf eine Bedingung überprüft werden sollen.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Bestimmt, ob alle Elemente einer Sequenz eine Bedingung erfüllen.</summary>
        <returns><see langword="true" />, wenn jedes Element der Quellsequenz im angegebenen Prädikat erfolgreich überprüft wird oder wenn die Sequenz leer ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von darstellt, hängt `source` von der Implementierung des Parameter Typs ab. Das erwartete Verhalten ist, dass es bestimmt, ob alle Elemente `source` in die Bedingung in `predicate`erfüllen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> verwendet wird, um zu bestimmen, ob alle Elemente in einer Sequenz eine Bedingung erfüllen.  
  
 [!code-csharp[System.Linq.Queryable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#4)]
 [!code-vb[System.Linq.Queryable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#4)]  
  
 Der boolesche Wert, der <xref:System.Linq.Queryable.All%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> von der-Methode zurückgegeben wird, wird in der `where` Regel im`Where` Prädikat einer-Klausel (-Klausel in Visual Basic <xref:System.Linq.Queryable.Where%2A> ) oder einem direkten Aufrufder-Methode verwendet. Im folgenden Beispiel wird die Verwendung `All` der-Methode veranschaulicht.  
  
 [!code-csharp[System.Linq.Queryable#134](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#134)]
 [!code-vb[System.Linq.Queryable#134](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#134)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Any&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob ein Element einer <see cref="T:System.Linq.IQueryable`1" />-Sequenz vorhanden ist oder eine Bedingung erfüllt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Any``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As IQueryable(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Any : System.Linq.IQueryable&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Queryable.Any source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, für die überprüft werden soll, ob sie leer ist.</param>
        <summary>Bestimmt, ob eine Sequenz Elemente enthält.</summary>
        <returns><see langword="true" />, wenn die Quellsequenz Elemente enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es bestimmt `source` , ob Elemente enthält.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> verwendet wird, um zu bestimmen, ob eine Sequenz Elemente enthält.  
  
 [!code-csharp[System.Linq.Queryable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#5)]
 [!code-vb[System.Linq.Queryable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#5)]  
  
 Der boolesche Wert, der <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> von der-Methode zurückgegeben wird, wird in der `where` Regel im`Where` Prädikat einer-Klausel (-Klausel in Visual Basic <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> ) oder einem direkten Aufrufder-Methode verwendet. Im folgenden Beispiel wird die Verwendung `Any` der-Methode veranschaulicht.  
  
 [!code-csharp[System.Linq.Queryable#135](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#135)]
 [!code-vb[System.Linq.Queryable#135](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#135)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Any``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Any : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; bool" Usage="System.Linq.Queryable.Any (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, deren Elemente auf eine Bedingung überprüft werden sollen.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Bestimmt, ob ein Element einer Sequenz eine Bedingung erfüllt.</summary>
        <returns><see langword="true" />, wenn Elemente der Quellsequenz im angegebenen Prädikat erfolgreich überprüft werden, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es bestimmt, ob eines der Elemente `source` von die durch `predicate`angegebene Bedingung erfüllt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Any%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> verwendet wird, um zu bestimmen, ob ein beliebiges Element in einer Sequenz eine Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Queryable#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#6)]
 [!code-vb[System.Linq.Queryable#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Append&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Append&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Append``1(System.Linq.IQueryable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TSource) (source As IQueryable(Of TSource), element As TSource) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Append(System::Linq::IQueryable&lt;TSource&gt; ^ source, TSource element);" />
      <MemberSignature Language="F#" Value="static member Append : System.Linq.IQueryable&lt;'Source&gt; * 'Source -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Append (source, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="element" Type="TSource" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsQueryable">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable AsQueryable (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable AsQueryable(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.AsQueryable(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsQueryable (source As IEnumerable) As IQueryable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable ^ AsQueryable(System::Collections::IEnumerable ^ source);" />
      <MemberSignature Language="F#" Value="static member AsQueryable : System.Collections.IEnumerable -&gt; System.Linq.IQueryable" Usage="System.Linq.Queryable.AsQueryable source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine zu konvertierende Sequenz.</param>
        <summary>Konvertiert einen <see cref="T:System.Collections.IEnumerable" /> in einen <see cref="T:System.Linq.IQueryable" />.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable" />, das die Eingabesequenz darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Typ von `source` implementiert <xref:System.Linq.IQueryable%601>, <xref:System.Linq.Queryable.AsQueryable%28System.Collections.IEnumerable%29> wird er direkt zurückgegeben. Andernfalls wird ein <xref:System.Linq.IQueryable%601> -Wert zurückgegeben, der Abfragen ausführt, indem in <xref:System.Linq.Enumerable> anstelle der in <xref:System.Linq.Queryable>die entsprechenden Abfrage Operator Methoden aufgerufen werden.  
  
 Bei dieser Methode wird `source` davon <xref:System.Collections.Generic.IEnumerable%601> ausgegangen, `T`dass für einige implementiert. Zur Laufzeit ist das Ergebnis vom Typ <xref:System.Linq.IQueryable%601> für das gleiche. `T` Diese Methode ist in dynamischen Szenarios nützlich, wenn Sie den Typ von `T`nicht statisch kennen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Für einige <paramref name="source" /> wird <see cref="T:System.Collections.Generic.IEnumerable`1" /> von <paramref name="T" /> nicht implementiert.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsQueryable&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TElement&gt; AsQueryable&lt;TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TElement&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TElement&gt; AsQueryable&lt;TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.AsQueryable``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsQueryable(Of TElement) (source As IEnumerable(Of TElement)) As IQueryable(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TElement&gt; ^ AsQueryable(System::Collections::Generic::IEnumerable&lt;TElement&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsQueryable : seq&lt;'Element&gt; -&gt; System.Linq.IQueryable&lt;'Element&gt;" Usage="System.Linq.Queryable.AsQueryable source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TElement&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TElement">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine zu konvertierende Sequenz.</param>
        <summary>Konvertiert ein generisches <see cref="T:System.Collections.Generic.IEnumerable`1" /> in ein generisches <see cref="T:System.Linq.IQueryable`1" />.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, das die Eingabesequenz darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Typ von `source` implementiert <xref:System.Linq.IQueryable%601>, <xref:System.Linq.Queryable.AsQueryable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> wird er direkt zurückgegeben. Andernfalls wird ein <xref:System.Linq.IQueryable%601> -Wert zurückgegeben, der Abfragen ausführt, indem in <xref:System.Linq.Enumerable> anstelle der in <xref:System.Linq.Queryable>die entsprechenden Abfrage Operator Methoden aufgerufen werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.AsQueryable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> verwendet wird, <xref:System.Collections.Generic.IEnumerable%601> um eine <xref:System.Linq.IQueryable%601>in eine zu konvertieren.  
  
 [!code-csharp[System.Linq.Queryable#125](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#125)]
 [!code-vb[System.Linq.Queryable#125](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#125)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Average">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet den Durchschnitt einer Sequenz von numerischen Werten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static decimal Average (this System.Linq.IQueryable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average(class System.Linq.IQueryable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Linq::IQueryable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Decimal" />-Werten, deren Durchschnitt berechnet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Decimal" />-Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> das Aufrufen von sich selbst darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass der Durchschnitt der Werte in `source`berechnet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> verwendet wird, um den Durchschnitt einer Sequenz von-Werten zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.IQueryable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.IQueryable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;double&gt; -&gt; double" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Double" />-Werten, deren Durchschnitt berechnet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Double" />-Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Double%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Double%7D%29> das Aufrufen von sich selbst darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Double%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass der Durchschnitt der Werte in `source`berechnet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> verwendet wird, um den Durchschnitt einer Sequenz von-Werten zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.IQueryable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.IQueryable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Integer)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;int&gt; -&gt; double" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int32" />-Werten, deren Durchschnitt berechnet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int32" />-Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> das Aufrufen von sich selbst darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass der Durchschnitt der Werte in `source`berechnet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> verwendet wird, um den Durchschnitt einer Sequenz von-Werten zu berechnen.  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Linq.IQueryable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Linq.IQueryable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Long)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;int64&gt; -&gt; double" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int64" />-Werten, deren Durchschnitt berechnet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int64" />-Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int64%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int64%7D%29> das Aufrufen von sich selbst darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int64%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass der Durchschnitt der Werte in `source`berechnet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> verwendet wird, um den Durchschnitt einer Sequenz von-Werten zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Linq::IQueryable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Decimal" />-Werten, die NULL sein können, zum Berechnen des Durchschnitts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Decimal" />-Werten, die NULL sein können.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur <see langword="null" />-Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> das Aufrufen von sich selbst darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass der Durchschnitt der Werte in `source`berechnet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> verwendet wird, um den Durchschnitt einer Sequenz von-Werten zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Double" />-Werten, die NULL sein können, zum Berechnen des Durchschnitts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Double" />-Werten, die NULL sein können.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur <see langword="null" />-Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> das Aufrufen von sich selbst darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass der Durchschnitt der Werte in `source`berechnet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> verwendet wird, um den Durchschnitt einer Sequenz von-Werten zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Nullable(Of Integer))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int32" />-Werten, die NULL sein können, zum Berechnen des Durchschnitts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int32" />-Werten, die NULL sein können.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur <see langword="null" />-Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> das Aufrufen von sich selbst darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass der Durchschnitt der Werte in `source`berechnet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> verwendet wird, um den Durchschnitt einer Sequenz von-Werten zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Nullable(Of Long))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int64" />-Werten, die NULL sein können, zum Berechnen des Durchschnitts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int64" />-Werten, die NULL sein können.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur <see langword="null" />-Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> das Aufrufen von sich selbst darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass der Durchschnitt der Werte in `source`berechnet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> verwendet wird, um den Durchschnitt einer Sequenz von-Werten zu berechnen.  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average (this System.Linq.IQueryable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Linq::IQueryable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Single" />-Werten, die NULL sein können, zum Berechnen des Durchschnitts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Single" />-Werten, die NULL sein können.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur <see langword="null" />-Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> das Aufrufen von sich selbst darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass der Durchschnitt der Werte in `source`berechnet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> verwendet wird, um den Durchschnitt einer Sequenz von-Werten zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#12)]
 [!code-vb[System.Linq.Queryable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static float Average (this System.Linq.IQueryable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average(class System.Linq.IQueryable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average(System.Linq.IQueryable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IQueryable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Linq::IQueryable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;single&gt; -&gt; single" Usage="System.Linq.Queryable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Single" />-Werten, deren Durchschnitt berechnet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Single" />-Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Single%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Single%7D%29> das Aufrufen von sich selbst darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Single%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass der Durchschnitt der Werte in `source`berechnet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%28System.Linq.IQueryable%7BSystem.Int32%7D%29> verwendet wird, um den Durchschnitt einer Sequenz von-Werten zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#8)]
 [!code-vb[System.Linq.Queryable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Decimal))) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, System::Decimal&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, decimal&gt;&gt; -&gt; decimal" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Decimal" />-Werten, die durch den Aufruf einer Projektionsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass der Durchschnitt der Werte in `source` berechnet wird, nachdem für die einzelnen Werte aufgerufen `selector` wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> verwendet wird, um <xref:System.String> die durchschnittliche Länge in einer Sequenz von Werten <xref:System.String>des Typs zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Double))) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, double&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, double&gt;&gt; -&gt; double" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Durchschnitt berechnet werden soll</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Double" />-Werten, die durch den Aufruf einer Projektionsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass der Durchschnitt der Werte in `source` berechnet wird, nachdem für die einzelnen Werte aufgerufen `selector` wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> verwendet wird, um <xref:System.String> die durchschnittliche Länge in einer Sequenz von Werten <xref:System.String>des Typs zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Integer))) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int&gt;&gt; -&gt; double" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Durchschnitt berechnet werden soll</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int32" />-Werten, die durch den Aufruf einer Projektionsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass der Durchschnitt der Werte in `source` berechnet wird, nachdem für die einzelnen Werte aufgerufen `selector` wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> verwendet wird, um <xref:System.String> die durchschnittliche Länge in einer Sequenz von Werten <xref:System.String>des Typs zu berechnen.  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Long))) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, long&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int64&gt;&gt; -&gt; double" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Durchschnitt berechnet werden soll</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int64" />-Werten, die durch den Aufruf einer Projektionsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass der Durchschnitt der Werte in `source` berechnet wird, nachdem für die einzelnen Werte aufgerufen `selector` wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> verwendet wird, um <xref:System.String> die durchschnittliche Länge in einer Sequenz von Werten <xref:System.String>des Typs zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;decimal&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Decimal)))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;decimal&gt;&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Durchschnitt berechnet werden soll</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Decimal" />-Werten, die NULL zulassen, die durch den Aufruf einer Projektionsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten oder <see langword="null" />, wenn die <paramref name="source" />-Sequenz leer ist oder nur <see langword="null" />-Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass der Durchschnitt der Werte in `source` berechnet wird, nachdem für die einzelnen Werte aufgerufen `selector` wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> verwendet wird, um <xref:System.String> die durchschnittliche Länge in einer Sequenz von Werten <xref:System.String>des Typs zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;double&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Double)))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;double&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;double&gt;&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Durchschnitt berechnet werden soll</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Double" />-Werten, die NULL zulassen, die durch den Aufruf einer Projektionsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten oder <see langword="null" />, wenn die <paramref name="source" />-Sequenz leer ist oder nur <see langword="null" />-Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass der Durchschnitt der Werte in `source` berechnet wird, nachdem für die einzelnen Werte aufgerufen `selector` wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> verwendet wird, um <xref:System.String> die durchschnittliche Länge in einer Sequenz von Werten <xref:System.String>des Typs zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;int&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Integer)))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;int&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;int&gt;&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Durchschnitt berechnet werden soll</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int32" />-Werten, die NULL zulassen, die durch den Aufruf einer Projektionsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten oder <see langword="null" />, wenn die <paramref name="source" />-Sequenz leer ist oder nur <see langword="null" />-Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend übergibt er die <xref:System.Linq.Expressions.MethodCallExpression> an die <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode <xref:System.Linq.IQueryProvider> der von <xref:System.Linq.IQueryable.Provider%2A> dargestellten Eigenschaft des `source` -Parameters.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass der Durchschnitt der Werte in `source` berechnet wird, nachdem für die einzelnen Werte aufgerufen `selector` wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> verwendet wird, um <xref:System.String> die durchschnittliche Länge in einer Sequenz von Werten <xref:System.String>des Typs zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;long&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Long)))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;long&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;int64&gt;&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Durchschnitt berechnet werden soll</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int64" />-Werten, die NULL zulassen, die durch den Aufruf einer Projektionsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten oder <see langword="null" />, wenn die <paramref name="source" />-Sequenz leer ist oder nur <see langword="null" />-Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass der Durchschnitt der Werte in `source` berechnet wird, nachdem für die einzelnen Werte aufgerufen `selector` wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> verwendet wird, um <xref:System.String> die durchschnittliche Länge in einer Sequenz von Werten <xref:System.String>des Typs zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;float&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Single)))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;float&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;single&gt;&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Durchschnitt berechnet werden soll</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Single" />-Werten, die NULL zulassen, die durch den Aufruf einer Projektionsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten oder <see langword="null" />, wenn die <paramref name="source" />-Sequenz leer ist oder nur <see langword="null" />-Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend übergibt er die <xref:System.Linq.Expressions.MethodCallExpression> an die <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode <xref:System.Linq.IQueryProvider> der von <xref:System.Linq.IQueryable.Provider%2A> dargestellten Eigenschaft des `source` -Parameters.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass der Durchschnitt der Werte in `source` berechnet wird, nachdem für die einzelnen Werte aufgerufen `selector` wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> verwendet wird, um <xref:System.String> die durchschnittliche Länge in einer Sequenz von Werten <xref:System.String>des Typs zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Average&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Average``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Single))) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, float&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, single&gt;&gt; -&gt; single" Usage="System.Linq.Queryable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Durchschnitt berechnet werden soll</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Single" />-Werten, die durch den Aufruf einer Projektionsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass der Durchschnitt der Werte in `source` berechnet wird, nachdem für die einzelnen Werte aufgerufen `selector` wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Average%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> verwendet wird, um <xref:System.String> die durchschnittliche Länge in einer Sequenz von Werten <xref:System.String>des Typs zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#18)]
 [!code-vb[System.Linq.Queryable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Cast&lt;TResult&gt; (this System.Linq.IQueryable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Cast&lt;TResult&gt;(class System.Linq.IQueryable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Cast``1(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Cast(Of TResult) (source As IQueryable) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Cast(System::Linq::IQueryable ^ source);" />
      <MemberSignature Language="F#" Value="static member Cast : System.Linq.IQueryable -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Cast source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ, in den die Elemente von <paramref name="source" /> konvertiert werden sollen.</typeparam>
        <param name="source">Das <see cref="T:System.Linq.IQueryable" />, das die zu konvertierenden Elemente enthält.</param>
        <summary>Konvertiert die Elemente einer <see cref="T:System.Linq.IQueryable" /> in den angegebenen Typ.</summary>
        <returns>Eine <see cref="T:System.Linq.IQueryable`1" />, die jedes in den angegebenen Typ konvertierte Element der Quellsequenz enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Cast%60%601%28System.Linq.IQueryable%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Cast%60%601%28System.Linq.IQueryable%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Cast%60%601%28System.Linq.IQueryable%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass die Werte in in `source` den- `TResult`Typ konvertiert werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Cast%60%601%28System.Linq.IQueryable%29> verwendet wird, um-Objekte in einer <xref:System.String>Sequenz in den-Typ zu konvertieren.  
  
 [!code-csharp[System.Linq.Queryable#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#19)]
 [!code-vb[System.Linq.Queryable#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Ein Element in der Sequenz kann nicht in den Typ <paramref name="TResult" /> umgewandelt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Concat``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Concat(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Concat(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member Concat : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Concat (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="source1">Die erste zu verkettende Sequenz.</param>
        <param name="source2">Die Sequenz, die mit der ersten Sequenz verkettet werden soll.</param>
        <summary>Verkettet zwei Sequenzen</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, das die verketteten Elemente der beiden Eingabesequenzen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Concat%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Concat%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source1` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Concat%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source1` des Typs des Parameters ab. Das erwartete Verhalten ist, dass die Elemente `source2` in mit denen von `source1` verkettet werden, um eine neue Sequenz zu erstellen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Concat%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> verwendet wird, um zwei Sequenzen zu verketten.  
  
 [!code-csharp[System.Linq.Queryable#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#20)]
 [!code-vb[System.Linq.Queryable#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> oder <paramref name="source2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Contains&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob ein <see cref="T:System.Linq.IQueryable`1" /> ein angegebenes Element enthält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Contains``1(System.Linq.IQueryable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As IQueryable(Of TSource), item As TSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Linq::IQueryable&lt;TSource&gt; ^ source, TSource item);" />
      <MemberSignature Language="F#" Value="static member Contains : System.Linq.IQueryable&lt;'Source&gt; * 'Source -&gt; bool" Usage="System.Linq.Queryable.Contains (source, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="item" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, in dem <paramref name="item" /> gesucht werden soll.</param>
        <param name="item">Das Objekt, das in der Sequenz gesucht werden soll.</param>
        <summary>Bestimmt mithilfe des Standardgleichheitsvergleichs, ob eine Sequenz ein angegebenes Element enthält</summary>
        <returns><see langword="true" />, wenn die Eingabesequenz ein Element mit dem angegebenen Wert enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es bestimmt `source` , `item`ob enthält.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> verwendet wird, um zu bestimmen, ob eine Sequenz ein bestimmtes Element enthält.  
  
 [!code-csharp[System.Linq.Queryable#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#21)]
 [!code-vb[System.Linq.Queryable#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource item, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource item, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Contains``1(System.Linq.IQueryable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As IQueryable(Of TSource), item As TSource, comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Linq::IQueryable&lt;TSource&gt; ^ source, TSource item, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Contains : System.Linq.IQueryable&lt;'Source&gt; * 'Source * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Queryable.Contains (source, item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="item" Type="TSource" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, in dem <paramref name="item" /> gesucht werden soll.</param>
        <param name="item">Das Objekt, das in der Sequenz gesucht werden soll.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Bestimmt mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, ob eine Sequenz ein angegebenes Element enthält</summary>
        <returns><see langword="true" />, wenn die Eingabesequenz ein Element mit dem angegebenen Wert enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Contains%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es mithilfe `source` `comparer` von `item` zum Vergleichen von Werten bestimmt, ob enthält.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Count&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die Anzahl der Elemente in einer Sequenz zurück</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Count``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As IQueryable(Of TSource)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Count : System.Linq.IQueryable&lt;'Source&gt; -&gt; int" Usage="System.Linq.Queryable.Count source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Das <see cref="T:System.Linq.IQueryable`1" />, das die zu zählenden Elemente enthält.</param>
        <summary>Gibt die Anzahl der Elemente in einer Sequenz zurück</summary>
        <returns>Die Anzahl der Elemente in der Eingabesequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass die Anzahl der Elemente in `source`gezählt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> verwendet wird, um die Elemente in einer Sequenz zu zählen.  
  
 [!code-csharp[System.Linq.Queryable#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#22)]
 [!code-vb[System.Linq.Queryable#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Anzahl der Elemente in <paramref name="source" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Count``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Count : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; int" Usage="System.Linq.Queryable.Count (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, das die zu zählenden Elemente enthält</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt die Anzahl der Elemente in der angegebenen Sequenz zurück, die eine Bedingung erfüllen.</summary>
        <returns>Die Anzahl von Elementen in der Sequenz, die die Bedingung in der Prädikatfunktion erfüllen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass die Anzahl der Elemente in `source` gezählt wird, die die von `predicate`angegebene Bedingung erfüllen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Count%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> verwendet wird, um die Elemente in einer Sequenz zu zählen, die eine Bedingung erfüllen.  
  
 [!code-csharp[System.Linq.Queryable#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#23)]
 [!code-vb[System.Linq.Queryable#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Anzahl der Elemente in <paramref name="source" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die Elemente in einer Sequenz zurück, oder eine Standardwert-Singletonauflistung, wenn die Sequenz leer ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.DefaultIfEmpty``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As IQueryable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ DefaultIfEmpty(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : System.Linq.IQueryable&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.DefaultIfEmpty source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Das <see cref="T:System.Linq.IQueryable`1" />, für das ein Standardwert zurückgegeben soll, wenn die Sequenz leer ist.</param>
        <summary>Gibt die Elemente der angegebenen Sequenz oder den Standardwert des Typparameters in einer Singletonauflistung zurück, wenn die Sequenz leer ist</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, das <see langword="default" />(<paramref name="TSource" />) enthält, wenn <paramref name="source" /> leer ist, andernfalls <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `source` zurückgibt, wenn es nicht leer ist. Andernfalls wird ein <xref:System.Linq.IQueryable%601> -Wert zurückgegeben `default(TSource)`, der enthält.  
  
   
  
## Examples  
 In den folgenden Codebeispielen wird veranschaulicht, <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> wie verwendet wird, um einen Standardwert für den Fall anzugeben, dass die Quell Sequenz leer ist.  
  
 [!code-csharp[System.Linq.Queryable#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#24)]
 [!code-vb[System.Linq.Queryable#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.DefaultIfEmpty``1(System.Linq.IQueryable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As IQueryable(Of TSource), defaultValue As TSource) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ DefaultIfEmpty(System::Linq::IQueryable&lt;TSource&gt; ^ source, TSource defaultValue);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : System.Linq.IQueryable&lt;'Source&gt; * 'Source -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.DefaultIfEmpty (source, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="defaultValue" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Das <see cref="T:System.Linq.IQueryable`1" />, für das der angegebene Wert zurückgegeben soll, wenn die Sequenz leer ist.</param>
        <param name="defaultValue">Der Wert, der zurückgegeben werden soll, wenn die Sequenz leer ist.</param>
        <summary>Gibt die Elemente der angegebenen Sequenz oder den angegebenen Wert in einer Singletonauflistung zurück, wenn die Sequenz leer ist.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, das <paramref name="defaultValue" /> enthält, wenn <paramref name="source" /> leer ist, andernfalls <paramref name="source" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `source` zurückgibt, wenn es nicht leer ist. Andernfalls wird ein <xref:System.Linq.IQueryable%601> -Wert zurückgegeben `defaultValue`, der enthält.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt eine Situation, in der es nützlich ist, <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> in einer [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] Abfrage aufzurufen. Ein Standardwert wird in diesem <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> Beispiel an den Wert übermittelt.  
  
 [!code-csharp[System.Linq.Queryable#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#25)]
 [!code-vb[System.Linq.Queryable#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Distinct&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt unterschiedliche Elemente aus einer Sequenz zurück</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Distinct``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As IQueryable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Distinct(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Distinct : System.Linq.IQueryable&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Distinct source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Das <see cref="T:System.Linq.IQueryable`1" />, aus dem Duplikate entfernt werden sollen.</param>
        <summary>Gibt mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Werten unterschiedliche Elemente aus einer Sequenz zurück</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, das unterschiedliche Elemente aus <paramref name="source" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es eine ungeordnete Sequenz der eindeutigen Elemente in `source`zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> verwendet wird, um unterschiedliche Elemente aus einer Sequenz zurückzugeben.  
  
 [!code-csharp[System.Linq.Queryable#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#27)]
 [!code-vb[System.Linq.Queryable#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Distinct``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As IQueryable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Distinct(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Distinct : System.Linq.IQueryable&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Distinct (source, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Das <see cref="T:System.Linq.IQueryable`1" />, aus dem Duplikate entfernt werden sollen.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Gibt mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten unterschiedliche Elemente aus einer Sequenz zurück</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, das unterschiedliche Elemente aus <paramref name="source" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Distinct%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es eine unsortierter Sequenz der eindeutigen Elemente in `source` zurückgibt `comparer` , indem verwendet wird, um Werte zu vergleichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="comparer" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAt&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAt&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAt&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ElementAt``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAt(Of TSource) (source As IQueryable(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAt(System::Linq::IQueryable&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAt : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.Queryable.ElementAt (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, aus dem ein Element zurückgegeben werden soll</param>
        <param name="index">Der auf 0 (null) basierende Index des abzurufenden Elements.</param>
        <summary>Gibt das Element an einem angegebenen Index in einer Sequenz zurück</summary>
        <returns>Das Element an der angegebenen Position in <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.ElementAt%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.ElementAt%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.ElementAt%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es das Element an der `index` Position `source`in zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.ElementAt%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> verwendet wird, um ein Element an einer bestimmten Position in einer Sequenz zurückzugeben.  
  
 [!code-csharp[System.Linq.Queryable#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#28)]
 [!code-vb[System.Linq.Queryable#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAtOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAtOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAtOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ElementAtOrDefault``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAtOrDefault(Of TSource) (source As IQueryable(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAtOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAtOrDefault : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.Queryable.ElementAtOrDefault (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, aus dem ein Element zurückgegeben werden soll</param>
        <param name="index">Der auf 0 (null) basierende Index des abzurufenden Elements.</param>
        <summary>Gibt das Element an einem angegebenen Index in einer Sequenz oder einen Standardwert zurück, wenn der Index außerhalb des gültigen Bereichs liegt.</summary>
        <returns><c>default</c>(<paramref name="TSource" />), wenn <paramref name="index" /> außerhalb der Begrenzungen von <paramref name="source" /> liegt, andernfalls das Element an der angegebenen Position in <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.ElementAtOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.ElementAtOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.ElementAtOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es das Element an der `index` Position `source`in zurück `default(TSource)` gibt `index` oder wenn außerhalb der Begrenzungen `source`von liegt.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Verwendung von <xref:System.Linq.Queryable.ElementAtOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29>. In diesem Beispiel wird ein Wert `index` für verwendet, der außerhalb der Begrenzungen der Quell Sequenz liegt.  
  
 [!code-csharp[System.Linq.Queryable#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#29)]
 [!code-vb[System.Linq.Queryable#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Except&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erzeugt die Differenzmenge von zwei Sequenzen</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Except``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Except(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member Except : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Except (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="source1">Es wird ein <see cref="T:System.Linq.IQueryable`1" /> zurückgegeben, dessen Elemente nicht auch in <paramref name="source2" /> enthalten sind.</param>
        <param name="source2">Die Rückgabesequenz enthält kein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen Elemente auch in der ersten Sequenz vorhanden sind.</param>
        <summary>Erzeugt die Differenzmenge zweier Sequenzen mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Werten</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, das die Differenzmenge der beiden Sequenzen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des`source1` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source1` des Typs des Parameters ab. Das erwartete Verhalten ist, dass alle Elemente in `source1` zurückgegeben werden, mit Ausnahme derjenigen, die `source2`auch in sind.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> verwendet wird, um die Elemente zurückzugeben, die nur in der ersten Quell Sequenz angezeigt werden.  
  
 [!code-csharp[System.Linq.Queryable#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#34)]
 [!code-vb[System.Linq.Queryable#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> oder <paramref name="source2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Except``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Except(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Except : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Except (source1, source2, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="source1">Es wird ein <see cref="T:System.Linq.IQueryable`1" /> zurückgegeben, dessen Elemente nicht auch in <paramref name="source2" /> enthalten sind.</param>
        <param name="source2">Die Rückgabesequenz enthält kein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen Elemente auch in der ersten Sequenz vorhanden sind.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Erzeugt mithilfe des angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> die Differenzmenge zweier Sequenzen zum Vergleichen von Werten</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, das die Differenzmenge der beiden Sequenzen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des`source1` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Except%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source1` des Typs des Parameters ab. Das erwartete Verhalten ist, dass alle Elemente in `source1` zurückgegeben werden, mit Ausnahme derjenigen, die `source2`auch in `comparer` und zum Vergleichen von Werten verwendet werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> oder <paramref name="source2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="First&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt das erste Element einer Sequenz zurück</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.First``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member First : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.First source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Das <see cref="T:System.Linq.IQueryable`1" />, dessen erstes Element zurückgegeben werden soll</param>
        <summary>Gibt das erste Element einer Sequenz zurück</summary>
        <returns>Das erste Element in <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es das erste Element in `source`zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> verwendet wird, um das erste Element in einer Sequenz zurückzugeben.  
  
 [!code-csharp[System.Linq.Queryable#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#35)]
 [!code-vb[System.Linq.Queryable#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Quellsequenz ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.First``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member First : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.First (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, aus dem ein Element zurückgegeben werden soll</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das erste Element einer Sequenz zurück, das eine angegebene Bedingung erfüllt.</summary>
        <returns>Das erste Element in <paramref name="source" />, das in <paramref name="predicate" /> erfolgreich überprüft wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es das erste Element in `source` zurückgibt, das die von `predicate`angegebene Bedingung erfüllt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> verwendet wird, um das erste Element einer Sequenz zurückzugeben, das eine Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Queryable#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#36)]
 [!code-vb[System.Linq.Queryable#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#36)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element erfüllt die Bedingung in <paramref name="predicate" />.  
  
- oder - 
Die Quellsequenz ist leer.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FirstOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt das erste Element einer Sequenz oder einen Standardwert zurück, wenn kein Element gefunden wird</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.FirstOrDefault``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.FirstOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Das <see cref="T:System.Linq.IQueryable`1" />, dessen erstes Element zurückgegeben werden soll</param>
        <summary>Gibt das erste Element einer Sequenz oder einen Standardwert zurück, wenn die Sequenz keine Elemente enthält.</summary>
        <returns><c>default</c>(<paramref name="TSource" />), wenn <paramref name="source" /> leer ist, andernfalls das erste Element in <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es das erste Element in `source`oder einen Standardwert zurückgibt `source` , wenn leer ist.  
  
 Die <xref:System.Linq.Queryable.FirstOrDefault%2A> -Methode bietet keine Möglichkeit, den Standardwert anzugeben, der zurückgegeben `source` werden soll, wenn leer ist. Wenn Sie einen anderen Standardwert als `default(TSource)`angeben möchten, verwenden Sie die <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> -Methode, wie im Beispiel Abschnitt beschrieben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> von für eine leere Sequenz veranschaulicht.  
  
 [!code-csharp[System.Linq.Queryable#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#37)]
 [!code-vb[System.Linq.Queryable#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#37)]  
  
 Manchmal ist der Wert `default(TSource)` von nicht der Standardwert, den Sie verwenden möchten, wenn die Auflistung keine Elemente enthält. Anstatt das Ergebnis für den unerwünschten Standardwert zu überprüfen und ggf. zu ändern, können Sie die <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> -Methode verwenden, um den Standardwert anzugeben, den Sie verwenden möchten, wenn die Auflistung leer ist. Rufen Sie dann <xref:System.Linq.Queryable.First%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> auf, um das erste Element abzurufen. Im folgenden Codebeispiel werden beide Techniken verwendet, um den Standardwert 1 zu erhalten, wenn eine Auflistung von numerischen Monaten leer ist. Da der Standardwert für eine Ganzzahl 0 ist, was keinem Monat entspricht, muss der Standardwert stattdessen auf 1 festgelegt werden. Die erste Ergebnisvariable wird nach Abschluss der Abfrage auf den unerwünschten Standardwert geprüft. Die zweite Ergebnisvariable wird abgerufen, indem <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> aufgerufen wird, um den Standardwert 1 anzugeben.  
  
 [!code-csharp[System.Linq.Queryable#131](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#131)]
 [!code-vb[System.Linq.Queryable#131](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#131)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.FirstOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.FirstOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, aus dem ein Element zurückgegeben werden soll</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das erste Element einer Sequenz zurück, das eine angegebene Bedingung erfüllt, oder einen Standardwert, wenn ein solches Element nicht gefunden wird.</summary>
        <returns><c>default</c>(<paramref name="TSource" />), wenn <paramref name="source" /> leer ist oder wenn kein Element die von <paramref name="predicate" /> angegebene Überprüfung besteht. Andernfalls das erste Element in <paramref name="source" />, das die von <paramref name="predicate" /> angegebene Überprüfung besteht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es das erste Element in `source` zurückgibt, das die `predicate`Bedingung in erfüllt, oder einen Standardwert, wenn kein Element die Bedingung erfüllt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.FirstOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> verwendet wird, indem ein Prädikat übergeben wird. In der zweiten Abfrage gibt es kein Element in der Sequenz, das die Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Queryable#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#38)]
 [!code-vb[System.Linq.Queryable#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gruppiert die Elemente einer Sequenz</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey))) As IQueryable(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; -&gt; System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der in <paramref name="keySelector" /> dargestellten Funktion zurückgegeben wird.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, dessen Elemente gruppiert werden sollen</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion</summary>
        <returns>Eine <c>IQueryable&lt;IGrouping&lt;TKey, TSource&gt;&gt;</c> in C# oder eine <c>IQueryable(Of IGrouping(Of TKey, TSource))</c> in Visual Basic, wobei jede <see cref="T:System.Linq.IGrouping`2" />-Schnittstelle eine Sequenz von Objekten und einen Schlüssel enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten besteht darin, dass die Elemente von `source` anhand eines Schlüssel Werts gruppiert werden, der durch `keySelector` Aufrufen von für jedes Element abgerufen wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> verwendet wird, um die Elemente einer Sequenz zu gruppieren.  
  
 [!code-csharp[System.Linq.Queryable#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#14)]
 [!code-vb[System.Linq.Queryable#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der in <paramref name="keySelector" /> dargestellten Funktion zurückgegeben wird.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, dessen Elemente gruppiert werden sollen</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und vergleicht die Schlüssel mithilfe eines angegebenen Vergleichs</summary>
        <returns>Eine <c>IQueryable&lt;IGrouping&lt;TKey, TSource&gt;&gt;</c> in C# oder eine <c>IQueryable(Of IGrouping(Of TKey, TSource))</c> in Visual Basic, wobei jede <see cref="T:System.Linq.IGrouping`2" /> eine Sequenz von Objekten und einen Schlüssel enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.GroupBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass die Elemente von `source` nach einem Schlüsselwert gruppiert werden. Der Schlüsselwert wird durch Aufrufen `keySelector` von für jedes Element abgerufen, und Schlüsselwerte werden mithilfe `comparer`von verglichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="comparer" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TElement&gt;&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TElement&gt;&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), elementSelector As Expression(Of Func(Of TSource, TElement))) As IQueryable(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TElement&gt; ^&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Element&gt;&gt; -&gt; System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="elementSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TElement&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der in <paramref name="keySelector" /> dargestellten Funktion zurückgegeben wird.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente in jedem <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, dessen Elemente gruppiert werden sollen</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einem <see cref="T:System.Linq.IGrouping`2" /> zugeordnet wird.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und projiziert die Elemente für jede Gruppe mithilfe einer angegebenen Funktion</summary>
        <returns>Eine <c>IQueryable&lt;IGrouping&lt;TKey, TElement&gt;&gt;</c> in C# oder eine <c>IQueryable(Of IGrouping(Of TKey, TElement))</c> in Visual Basic, wobei jede <see cref="T:System.Linq.IGrouping`2" />-Schnittstelle eine Sequenz von Objekten vom Typ <paramref name="TElement" /> und einen Schlüssel enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten besteht darin, dass die Elemente von `source` anhand eines Schlüssel Werts gruppiert werden, der durch `keySelector` Aufrufen von für jedes Element abgerufen wird. Ruft `elementSelector` für jedes Element auf, um ein Ergebnis Element abzurufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%29> verwendet wird, um die Elemente einer Sequenz zu gruppieren.  
  
 [!code-csharp[System.Linq.Queryable#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#39)]
 [!code-vb[System.Linq.Queryable#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TElement&gt;&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TElement&gt;&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), elementSelector As Expression(Of Func(Of TSource, TElement)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TElement&gt; ^&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Element&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="elementSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TElement&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der in <paramref name="keySelector" /> dargestellten Funktion zurückgegeben wird.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente in jedem <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, dessen Elemente gruppiert werden sollen</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einem <see cref="T:System.Linq.IGrouping`2" /> zugeordnet wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert die Elemente einer Sequenz und projiziert die Elemente jeder Gruppe mithilfe einer angegebenen Funktion. Schlüsselwerte werden mithilfe eines angegebenen Vergleichs verglichen.</summary>
        <returns>Eine <c>IQueryable&lt;IGrouping&lt;TKey, TElement&gt;&gt;</c> in C# oder eine <c>IQueryable(Of IGrouping(Of TKey, TElement))</c> in Visual Basic, wobei jede <see cref="T:System.Linq.IGrouping`2" />-Schnittstelle eine Sequenz von Objekten vom Typ <paramref name="TElement" /> und einen Schlüssel enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten besteht darin, dass die Elemente von `source` anhand eines Schlüssel Werts gruppiert werden, der durch `keySelector` Aufrufen von für jedes Element abgerufen wird. Schlüsselwerte werden mithilfe `comparer`von verglichen. Der `elementSelector` -Parameter wird für jedes Element aufgerufen, um ein Ergebnis Element abzurufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="keySelector" />, <paramref name="elementSelector" /> oder <paramref name="comparer" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), resultSelector As Expression(Of Func(Of TKey, IEnumerable(Of TSource), TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der in <paramref name="keySelector" /> dargestellten Funktion zurückgegeben wird.</typeparam>
        <typeparam name="TResult">Der Typ des von <paramref name="resultSelector" /> zurückgegebenen Ergebniswerts.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, dessen Elemente gruppiert werden sollen</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert.</summary>
        <returns>Eine <c>T:System.Linq.IQueryable`1</c>-Schnittstelle, die über das Typargument <paramref name="TResult" /> verfügt und in der jedes Element eine Projektion über einer Gruppe und ihrem Schlüssel darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten besteht darin, dass die Elemente von `source` anhand eines Schlüssel Werts gruppiert werden, der durch `keySelector` Aufrufen von für jedes Element abgerufen wird. Der `resultSelector` -Parameter wird zum Abrufen eines Ergebnis Werts aus jeder Gruppe und Ihrem Schlüssel verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%29> verwendet wird, um die Elemente einer Sequenz zu gruppieren und eine Sequenz von Ergebnissen `TResult`vom Typ zu projizieren.  
  
 [!code-csharp[System.Linq.Queryable#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#15)]
 [!code-vb[System.Linq.Queryable#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt;&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2}},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), resultSelector As Expression(Of Func(Of TKey, IEnumerable(Of TSource), TResult)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der in <paramref name="keySelector" /> dargestellten Funktion zurückgegeben wird.</typeparam>
        <typeparam name="TResult">Der Typ des von <paramref name="resultSelector" /> zurückgegebenen Ergebniswerts.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, dessen Elemente gruppiert werden sollen</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert. Schlüssel werden mithilfe eines angegebenen Vergleichs verglichen.</summary>
        <returns>Eine <c>T:System.Linq.IQueryable`1</c>-Schnittstelle, die über das Typargument <paramref name="TResult" /> verfügt und in der jedes Element eine Projektion über einer Gruppe und ihrem Schlüssel darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.GroupBy%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten besteht darin, dass die Elemente von `source` nach Schlüsselwerten gruppiert werden, die durch `keySelector` Aufrufen von für jedes Element abgerufen werden. Der `comparer` -Parameter wird zum Vergleichen von Schlüsseln verwendet `resultSelector` , und der-Parameter wird zum Abrufen eines Ergebnis Werts aus jeder Gruppe und Ihrem Schlüssel verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="keySelector" />, <paramref name="resultSelector" /> oder <paramref name="comparer" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TElement&gt;&gt; elementSelector, System.Linq.Expressions.Expression&lt;Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TElement&gt;&gt; elementSelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``4(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), elementSelector As Expression(Of Func(Of TSource, TElement)), resultSelector As Expression(Of Func(Of TKey, IEnumerable(Of TElement), TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TElement&gt; ^&gt; ^ elementSelector, System::Linq::Expressions::Expression&lt;Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Element&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, elementSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="elementSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TElement&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der in <paramref name="keySelector" /> dargestellten Funktion zurückgegeben wird.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente in jedem <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <typeparam name="TResult">Der Typ des von <paramref name="resultSelector" /> zurückgegebenen Ergebniswerts.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, dessen Elemente gruppiert werden sollen</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einem <see cref="T:System.Linq.IGrouping`2" /> zugeordnet wird.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert. Die Elemente jeder Gruppe werden mithilfe einer angegebenen Funktion projiziert.</summary>
        <returns>Eine <c>T:System.Linq.IQueryable`1</c>-Schnittstelle, die über das Typargument <paramref name="TResult" /> verfügt und in der jedes Element eine Projektion über einer Gruppe und ihrem Schlüssel darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten besteht darin, dass die Elemente von `source` nach Schlüsselwerten gruppiert werden, die durch `keySelector` Aufrufen von für jedes Element abgerufen werden. Der `elementSelector` -Parameter wird verwendet, um die Elemente jeder Gruppe zu projizieren, `resultSelector` und der-Parameter wird verwendet, um aus jeder Gruppe und Ihrem Schlüssel einen Ergebniswert zu erhalten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%29> verwendet wird, um die Elemente einer Sequenz zu gruppieren und eine Sequenz von Ergebnissen `TResult`vom Typ zu projizieren.  
  
 [!code-csharp[System.Linq.Queryable#130](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#130)]
 [!code-vb[System.Linq.Queryable#130](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#130)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="keySelector" />, <paramref name="elementSelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TElement&gt;&gt; elementSelector, System.Linq.Expressions.Expression&lt;Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TElement&gt;&gt; elementSelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt;&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupBy``4(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3}},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), elementSelector As Expression(Of Func(Of TSource, TElement)), resultSelector As Expression(Of Func(Of TKey, IEnumerable(Of TElement), TResult)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TElement&gt; ^&gt; ^ elementSelector, System::Linq::Expressions::Expression&lt;Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Element&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupBy (source, keySelector, elementSelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="elementSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TElement&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der in <paramref name="keySelector" /> dargestellten Funktion zurückgegeben wird.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente in jedem <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <typeparam name="TResult">Der Typ des von <paramref name="resultSelector" /> zurückgegebenen Ergebniswerts.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, dessen Elemente gruppiert werden sollen</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einem <see cref="T:System.Linq.IGrouping`2" /> zugeordnet wird.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert. Schlüssel werden mithilfe eines angegebenen Vergleichs verglichen, und die Elemente jeder Gruppe werden mithilfe einer angegebenen Funktion projiziert.</summary>
        <returns>Eine <c>T:System.Linq.IQueryable`1</c>-Schnittstelle, die über das Typargument <paramref name="TResult" /> verfügt und in der jedes Element eine Projektion über einer Gruppe und ihrem Schlüssel darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.GroupBy%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten besteht darin, dass die Elemente von `source` nach Schlüsselwerten gruppiert werden, die durch `keySelector` Aufrufen von für jedes Element abgerufen werden. Der `comparer` -Parameter wird verwendet, um Schlüsselwerte zu vergleichen. Der `elementSelector` -Parameter wird verwendet, um die Elemente jeder Gruppe zu projizieren, `resultSelector` und der-Parameter wird verwendet, um aus jeder Gruppe und Ihrem Schlüssel einen Ergebniswert zu erhalten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" />, <paramref name="keySelector" />, <paramref name="elementSelector" />, <paramref name="resultSelector" /> oder <paramref name="comparer" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Korreliert die Elemente von zwei Sequenzen anhand der Gleichheit der Schlüssel und gruppiert die Ergebnisse</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TKey&gt;&gt; outerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TInner,TKey&gt;&gt; innerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TOuter, !!TKey&gt;&gt; outerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TInner, !!TKey&gt;&gt; innerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupJoin``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As IQueryable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Expression(Of Func(Of TOuter, TKey)), innerKeySelector As Expression(Of Func(Of TInner, TKey)), resultSelector As Expression(Of Func(Of TOuter, IEnumerable(Of TInner), TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupJoin(System::Linq::IQueryable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TKey&gt; ^&gt; ^ outerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TInner, TKey&gt; ^&gt; ^ innerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : System.Linq.IQueryable&lt;'Outer&gt; * seq&lt;'Inner&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Inner, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.IQueryable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TKey&gt;&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TInner,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements anhand eines Elements aus der ersten Sequenz und einer Auflistung von übereinstimmenden Elementen aus der zweiten Sequenz.</param>
        <summary>Korreliert die Elemente von zwei Sequenzen anhand der Gleichheit der Schlüssel und gruppiert die Ergebnisse Schlüssel werden mithilfe des Standardgleichheitsvergleichs verglichen.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, das Elemente vom Typ <paramref name="TResult" /> enthält, die durch Ausführen eines Gruppenjoins von zwei Sequenzen ermittelt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `outer` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `outer` des Typs des Parameters ab. Das erwartete Verhalten ist, die die `outerKeySelector` und `innerKeySelector` Funktionen werden verwendet, um Schlüssel zu extrahieren `outer` und `inner`bzw. Diese Schlüssel werden auf Gleichheit verglichen, um jedes Element in `outer` mit 0 (null) oder `inner`mehr Elementen aus abzugleichen. Anschließend wird `resultSelector` die Funktion aufgerufen, um ein Ergebnis Objekt aus jeder Gruppe korrelierter Elemente zu projizieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%29> verwendet wird, um einen gruppierten Join für zwei Sequenzen auszuführen.  
  
 [!code-csharp[System.Linq.Queryable#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#40)]
 [!code-vb[System.Linq.Queryable#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" />, <paramref name="inner" />, <paramref name="outerKeySelector" />, <paramref name="innerKeySelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TKey&gt;&gt; outerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TInner,TKey&gt;&gt; innerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TOuter, !!TKey&gt;&gt; outerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TInner, !!TKey&gt;&gt; innerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt;&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.GroupJoin``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3}},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As IQueryable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Expression(Of Func(Of TOuter, TKey)), innerKeySelector As Expression(Of Func(Of TInner, TKey)), resultSelector As Expression(Of Func(Of TOuter, IEnumerable(Of TInner), TResult)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ GroupJoin(System::Linq::IQueryable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TKey&gt; ^&gt; ^ outerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TInner, TKey&gt; ^&gt; ^ innerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : System.Linq.IQueryable&lt;'Outer&gt; * seq&lt;'Inner&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Inner, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.IQueryable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TKey&gt;&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TInner,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements anhand eines Elements aus der ersten Sequenz und einer Auflistung von übereinstimmenden Elementen aus der zweiten Sequenz.</param>
        <param name="comparer">Ein Vergleich zum Hashen und Vergleichen von Schlüsseln.</param>
        <summary>Korreliert die Elemente von zwei Sequenzen anhand der Gleichheit der Schlüssel und gruppiert die Ergebnisse Schlüssel werden mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> verglichen.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, das Elemente vom Typ <paramref name="TResult" /> enthält, die durch Ausführen eines Gruppenjoins von zwei Sequenzen ermittelt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `outer` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.GroupJoin%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> den Aufruf von darstellt, hängt von der Implementierung `outer` des Typs des Parameters ab. Das erwartete Verhalten ist, die die `outerKeySelector` und `innerKeySelector` Funktionen werden verwendet, um Schlüssel zu extrahieren `outer` und `inner`bzw. Diese Schlüssel werden mithilfe `comparer`von auf Gleichheit verglichen. Das Ergebnis der Vergleiche wird verwendet, um jedes Element in `outer` mit 0 (null) oder mehr Elementen aus `inner`abzugleichen. Anschließend wird `resultSelector` die Funktion aufgerufen, um ein Ergebnis Objekt aus jeder Gruppe korrelierter Elemente zu projizieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" />, <paramref name="inner" />, <paramref name="outerKeySelector" />, <paramref name="innerKeySelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Intersect&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erzeugt die Schnittmenge zweier Sequenzen</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Intersect``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Intersect(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Intersect (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="source1">Eine Sequenz, deren unterschiedliche Elemente, die auch in <paramref name="source2" /> vorhanden sind, zurückgegeben werden.</param>
        <param name="source2">Eine Sequenz, deren unterschiedliche Elemente, die auch in der ersten Sequenz vorhanden sind, zurückgegeben werden.</param>
        <summary>Erzeugt die Schnittmenge zweier Sequenzen mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Werten</summary>
        <returns>Eine Sequenz, die die Schnittmenge der beiden Sequenzen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source1` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source1` des Typs des Parameters ab. Das erwartete Verhalten ist, dass alle Elemente in `source1` , die ebenfalls in `source2` sind, zurückgegeben werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> verwendet wird, um die Elemente zurückzugeben, die in jeder der beiden Sequenzen angezeigt werden.  
  
 [!code-csharp[System.Linq.Queryable#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#41)]
 [!code-vb[System.Linq.Queryable#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> oder <paramref name="source2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Intersect``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Intersect(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Intersect : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Intersect (source1, source2, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="source1">Ein <see cref="T:System.Linq.IQueryable`1" />, dessen unterschiedliche Elemente, die auch in <paramref name="source2" /> vorhanden sind, zurückgegeben werden.</param>
        <param name="source2">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen unterschiedliche Elemente, die auch in der ersten Sequenz vorhanden sind, zurückgegeben werden.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Erzeugt mithilfe des angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten die Schnittmenge von zwei Sequenzen</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, das die Schnittmenge der beiden Sequenzen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source1` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Intersect%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source1` des Typs des Parameters ab. Das erwartete Verhalten ist, dass alle Elemente in `source1` , die ebenfalls in `source2` sind, zurückgegeben werden. Der `comparer` -Parameter wird zum Vergleichen von Elementen verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> oder <paramref name="source2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Korreliert die Elemente von zwei Sequenzen auf der Grundlage von übereinstimmenden Schlüsseln</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TKey&gt;&gt; outerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TInner,TKey&gt;&gt; innerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TInner,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TOuter, !!TKey&gt;&gt; outerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TInner, !!TKey&gt;&gt; innerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Join``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As IQueryable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Expression(Of Func(Of TOuter, TKey)), innerKeySelector As Expression(Of Func(Of TInner, TKey)), resultSelector As Expression(Of Func(Of TOuter, TInner, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Join(System::Linq::IQueryable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TKey&gt; ^&gt; ^ outerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TInner, TKey&gt; ^&gt; ^ innerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TInner, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Join : System.Linq.IQueryable&lt;'Outer&gt; * seq&lt;'Inner&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Inner, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Inner, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.IQueryable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TKey&gt;&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TInner,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TInner,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements aus zwei übereinstimmenden Elementen.</param>
        <summary>Korreliert die Elemente von zwei Sequenzen auf der Grundlage von übereinstimmenden Schlüsseln Schlüssel werden mithilfe des Standardgleichheitsvergleichs verglichen.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, für das Elemente vom Typ <paramref name="TResult" /> durch Ausführen eines inneren Joins von zwei Sequenzen ermittelt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `outer` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `outer` des Typs des Parameters ab. Das erwartete Verhalten ist die eines inneren Joins. Die `outerKeySelector` und `innerKeySelector` Funktionen werden verwendet, um Schlüssel zu extrahieren `outer` und `inner`bzw. Diese Schlüssel werden auf Gleichheit abgestimmt, um Elemente aus jeder Sequenz abzugleichen. Ein paar von Elementen wird für jedes Element in `inner` gespeichert, das mit einem Element in `outer`übereinstimmt. Anschließend wird `resultSelector` die-Funktion aufgerufen, um ein Ergebnis Objekt aus jedem Paar von übereinstimmenden Elementen zu projizieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%29> verwendet wird, um eine innere Verknüpfung von zwei Sequenzen auf Grundlage eines gemeinsamen Schlüssels auszuführen.  
  
 [!code-csharp[System.Linq.Queryable#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#42)]
 [!code-vb[System.Linq.Queryable#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" />, <paramref name="inner" />, <paramref name="outerKeySelector" />, <paramref name="innerKeySelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Linq.IQueryable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TKey&gt;&gt; outerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TInner,TKey&gt;&gt; innerKeySelector, System.Linq.Expressions.Expression&lt;Func&lt;TOuter,TInner,TResult&gt;&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TOuter, !!TKey&gt;&gt; outerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TInner, !!TKey&gt;&gt; innerKeySelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt;&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Join``4(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As IQueryable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Expression(Of Func(Of TOuter, TKey)), innerKeySelector As Expression(Of Func(Of TInner, TKey)), resultSelector As Expression(Of Func(Of TOuter, TInner, TResult)), comparer As IEqualityComparer(Of TKey)) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Join(System::Linq::IQueryable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TKey&gt; ^&gt; ^ outerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TInner, TKey&gt; ^&gt; ^ innerKeySelector, System::Linq::Expressions::Expression&lt;Func&lt;TOuter, TInner, TResult&gt; ^&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Join : System.Linq.IQueryable&lt;'Outer&gt; * seq&lt;'Inner&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Inner, 'Key&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Outer, 'Inner, 'Result&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Linq.IQueryable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TKey&gt;&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TInner,TKey&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TOuter,TInner,TResult&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements aus zwei übereinstimmenden Elementen.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Hashen und Vergleichen von Schlüsseln.</param>
        <summary>Korreliert die Elemente von zwei Sequenzen auf der Grundlage von übereinstimmenden Schlüsseln Schlüssel werden mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> verglichen.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, für das Elemente vom Typ <paramref name="TResult" /> durch Ausführen eines inneren Joins von zwei Sequenzen ermittelt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `outer` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Join%60%604%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%601%2C%60%602%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%602%7D%29> den Aufruf von darstellt, hängt von der Implementierung `outer` des Typs des Parameters ab. Das erwartete Verhalten ist die eines inneren Joins. Die `outerKeySelector` und `innerKeySelector` Funktionen werden verwendet, um Schlüssel zu extrahieren `outer` und `inner`bzw. Diese Schlüssel werden mithilfe `comparer`von auf Gleichheit verglichen. Das Ergebnis der Vergleiche wird zum Erstellen eines passenden Paars für jedes Element in `inner` verwendet, das mit einem Element in `outer`übereinstimmt. Anschließend wird `resultSelector` die-Funktion aufgerufen, um ein Ergebnis Objekt aus jedem Paar von übereinstimmenden Elementen zu projizieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" />, <paramref name="inner" />, <paramref name="outerKeySelector" />, <paramref name="innerKeySelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Last&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt das letzte Element in einer Sequenz zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Last``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Last : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Last source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, dessen letztes Element zurückgegeben werden soll</param>
        <summary>Gibt das letzte Element in einer Sequenz zurück.</summary>
        <returns>Der Wert an der letzten Position <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es das letzte Element in `source`zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> verwendet wird, um das letzte Element eines Arrays zurückzugeben.  
  
 [!code-csharp[System.Linq.Queryable#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#43)]
 [!code-vb[System.Linq.Queryable#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#43)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Quellsequenz ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Last``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Last : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Last (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, aus dem ein Element zurückgegeben werden soll</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das letzte Element einer Sequenz zurück, das eine angegebene Bedingung erfüllt.</summary>
        <returns>Das letzte Element in <paramref name="source" />, das die von <paramref name="predicate" /> angegebene Überprüfung besteht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es das letzte Element in `source` zurückgibt, das die von `predicate`angegebene Bedingung erfüllt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> verwendet wird, um das letzte Element eines Arrays zurückzugeben, das eine Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Queryable#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#44)]
 [!code-vb[System.Linq.Queryable#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#44)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element erfüllt die Bedingung in <paramref name="predicate" />.  
  
- oder - 
Die Quellsequenz ist leer.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt das letzte Element einer Sequenz oder einen Standardwert zurück, wenn kein Element gefunden wird</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.LastOrDefault``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.LastOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, dessen letztes Element zurückgegeben werden soll</param>
        <summary>Gibt das letzte Element in einer Sequenz zurück, oder einen Standardwert, wenn die Sequenz keine Elemente enthält.</summary>
        <returns><c>default</c>(<paramref name="TSource" />), wenn <paramref name="source" /> leer ist, andernfalls das letzte Element in <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es das letzte Element in `source`zurückgibt, oder einen Standard `source` Wert, wenn leer ist.  
  
 Die <xref:System.Linq.Queryable.LastOrDefault%2A> -Methode bietet keine Möglichkeit, einen Standardwert anzugeben. Wenn Sie einen anderen Standardwert als `default(TSource)`angeben möchten, verwenden Sie die <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> -Methode, wie im Beispiel Abschnitt beschrieben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> von in einem leeren Array veranschaulicht.  
  
 [!code-csharp[System.Linq.Queryable#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#45)]
 [!code-vb[System.Linq.Queryable#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#45)]  
  
 Manchmal ist der Wert `default(TSource)` von nicht der Standardwert, den Sie verwenden möchten, wenn die Auflistung keine Elemente enthält. Anstatt das Ergebnis für den unerwünschten Standardwert zu überprüfen und ggf. zu ändern, können Sie die <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> -Methode verwenden, um den Standardwert anzugeben, den Sie verwenden möchten, wenn die Auflistung leer ist. Rufen Sie dann <xref:System.Linq.Queryable.Last%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> auf, um das letzte Element abzurufen. Im folgenden Codebeispiel werden beide Techniken verwendet, um den Standardwert 1 zu erhalten, wenn eine Auflistung numerischer Tage des Monats leer ist. Da der Standardwert für eine Ganzzahl 0 ist, was keinem Tag des Monats entspricht, muss der Standardwert stattdessen auf 1 festgelegt werden. Die erste Ergebnisvariable wird nach Abschluss der Abfrage auf den unerwünschten Standardwert geprüft. Die zweite Ergebnisvariable wird abgerufen, indem <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> aufgerufen wird, um den Standardwert 1 anzugeben.  
  
 [!code-csharp[System.Linq.Queryable#132](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#132)]
 [!code-vb[System.Linq.Queryable#132](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#132)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.LastOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.LastOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, aus dem ein Element zurückgegeben werden soll</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das letzte Element einer Sequenz, das eine Bedingung erfüllt, oder einen Standardwert zurück, wenn ein solches Element nicht gefunden wird.</summary>
        <returns><c>default</c>(<paramref name="TSource" />), wenn <paramref name="source" /> leer ist oder wenn keine Elemente von der Prädikatfunktion erfolgreich überprüft werden. Andernfalls das letzte Element von <paramref name="source" />, das von der Prädikatfunktion erfolgreich überprüft wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es das letzte Element in `source` zurückgibt, das die von `predicate`angegebene Bedingung erfüllt. Wenn kein solches Element in `source`vorhanden ist, wird ein Standardwert zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.LastOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> verwendet wird, indem ein Prädikat übergeben wird. Beim zweiten Aufrufe der-Methode gibt es kein Element in der Sequenz, das die Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Queryable#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#46)]
 [!code-vb[System.Linq.Queryable#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#46)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LongCount&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt ein <see cref="T:System.Int64" /> zurück, das die Anzahl der Elemente in einer Sequenz darstellt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.LongCount``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As IQueryable(Of TSource)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LongCount : System.Linq.IQueryable&lt;'Source&gt; -&gt; int64" Usage="System.Linq.Queryable.LongCount source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, das die zu zählenden Elemente enthält</param>
        <summary>Gibt ein <see cref="T:System.Int64" /> zurück, das die Gesamtanzahl der Elemente in einer Sequenz darstellt</summary>
        <returns>Die Anzahl von Elementen in <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass die Anzahl der Elemente in `source` gezählt wird und ein <xref:System.Int64>zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> verwendet wird, um die Elemente in einem Array zu zählen.  
  
 [!code-csharp[System.Linq.Queryable#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#47)]
 [!code-vb[System.Linq.Queryable#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Anzahl der Elemente überschreitet <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.LongCount``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LongCount : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; int64" Usage="System.Linq.Queryable.LongCount (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, das die zu zählenden Elemente enthält</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt ein <see cref="T:System.Int64" /> zurück, das die Anzahl der Elemente in einer Sequenz darstellt, die eine Bedingung erfüllen.</summary>
        <returns>Die Anzahl der Elemente in <paramref name="source" />, die die Bedingung in der Prädikatfunktion erfüllen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass die Anzahl der Elemente in `source` gezählt wird, die die von `predicate` angegebene Bedingung erfüllen, <xref:System.Int64>und eine zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.LongCount%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> verwendet wird, um die Elemente in einem Array zu zählen, die eine Bedingung erfüllen.  
  
 [!code-csharp[System.Linq.Queryable#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#48)]
 [!code-vb[System.Linq.Queryable#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#48)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Anzahl der übereinstimmenden Elemente überschreitet <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Max&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Max&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Max``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Max(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einem generischen <see cref="T:System.Linq.IQueryable`1" /> zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Max%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Max%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Max%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es den maximalen Wert in `source`zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Max%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz zu ermitteln.  
  
 [!code-csharp[System.Linq.Queryable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#52)]
 [!code-vb[System.Linq.Queryable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Max&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Max&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Max``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, TResult))) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Max(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Result&gt;&gt; -&gt; 'Result" Usage="System.Linq.Queryable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Der Typ des Werts, der von der durch <paramref name="selector" /> dargestellten Funktion zurückgegeben wird.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element eines generischen <see cref="T:System.Linq.IQueryable`1" /> eine Projektionsfunktion auf und gibt den höchsten Ergebniswert zurück.</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Max%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Max%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Max%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `selector` für jedes Element in `source` aufruft und den maximalen Wert zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Max%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!code-csharp[System.Linq.Queryable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#58)]
 [!code-vb[System.Linq.Queryable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Min&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Min&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Min``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Min(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert eines generischen <see cref="T:System.Linq.IQueryable`1" /> zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Min%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Min%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Min%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es den minimalen Wert in `source`zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Min%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> verwendet wird, um den Mindestwert in einer Sequenz zu bestimmen.  
  
 [!code-csharp[System.Linq.Queryable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#60)]
 [!code-vb[System.Linq.Queryable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Min&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Min&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Min``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, TResult))) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Min(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Result&gt;&gt; -&gt; 'Result" Usage="System.Linq.Queryable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Der Typ des Werts, der von der durch <paramref name="selector" /> dargestellten Funktion zurückgegeben wird.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element eines generischen <see cref="T:System.Linq.IQueryable`1" /> eine Projektionsfunktion auf und gibt den niedrigsten Ergebniswert zurück.</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Min%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Min%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Min%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `selector` für jedes Element in `source` aufruft und den minimalen Wert zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Min%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> verwendet wird, um den Mindestwert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!code-csharp[System.Linq.Queryable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#68)]
 [!code-vb[System.Linq.Queryable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfType&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; OfType&lt;TResult&gt; (this System.Linq.IQueryable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; OfType&lt;TResult&gt;(class System.Linq.IQueryable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OfType``1(System.Linq.IQueryable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OfType(Of TResult) (source As IQueryable) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ OfType(System::Linq::IQueryable ^ source);" />
      <MemberSignature Language="F#" Value="static member OfType : System.Linq.IQueryable -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.OfType source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ, nach dem die Elemente der Sequenz gefiltert werden sollen.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable" />, dessen Elemente gefiltert werden sollen.</param>
        <summary>Filtert die Elemente eines <see cref="T:System.Linq.IQueryable" /> anhand eines angegebenen Typs</summary>
        <returns>Eine Auflistung, die die Elemente aus <paramref name="source" /> mit dem Typ <paramref name="TResult" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `OfType` -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der `OfType` den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die `OfType` den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass alle Elemente in `source` herausgefiltert werden, die nicht vom Typ `TResult`sind.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie `OfType` zum Filtern von Elementen verwendet wird, die nicht <xref:System.Reflection.PropertyInfo> vom Typ aus einer Liste von Elementen <xref:System.Reflection.MemberInfo>des Typs sind.  
  
 [!code-csharp[System.Linq.Queryable#69](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#69)]
 [!code-vb[System.Linq.Queryable#69](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortiert die Elemente einer Sequenz in aufsteigender Reihenfolge</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OrderBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey))) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ OrderBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.OrderBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der durch <paramref name="keySelector" /> dargestellten Funktion zurückgegeben wird.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <summary>Sortiert die Elemente einer Sequenz in aufsteigender Reihenfolge nach einem Schlüssel</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedQueryable`1" />, dessen Elemente nach einem Schlüssel sortiert werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird. Das Ergebnis des- <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Aufruf von wird in <xref:System.Linq.IOrderedQueryable%601> den-Typ umgewandelt und zurückgegeben.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass die Elemente von `source` basierend auf dem Schlüssel sortiert werden, der durch Aufrufen `keySelector` von für `source`jedes Element von abgerufen wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> verwendet wird, um die Elemente einer Sequenz zu sortieren.  
  
 [!code-csharp[System.Linq.Queryable#70](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#70)]
 [!code-vb[System.Linq.Queryable#70](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#70)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OrderBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), comparer As IComparer(Of TKey)) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ OrderBy(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderBy : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.OrderBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der durch <paramref name="keySelector" /> dargestellten Funktion zurückgegeben wird.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Sortiert die Elemente einer Sequenz mithilfe eines angegebenen Vergleichs in aufsteigender Reihenfolge</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedQueryable`1" />, dessen Elemente nach einem Schlüssel sortiert werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird. Das Ergebnis des- <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Aufruf von wird in <xref:System.Linq.IOrderedQueryable%601> den-Typ umgewandelt und zurückgegeben.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.OrderBy%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass die Elemente von `source` basierend auf dem Schlüssel sortiert werden, der durch Aufrufen `keySelector` von für `source`jedes Element von abgerufen wird. Der `comparer` -Parameter wird verwendet, um Schlüssel zu vergleichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="comparer" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortiert die Elemente einer Sequenz in absteigender Reihenfolge.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OrderByDescending``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey))) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ OrderByDescending(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.OrderByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der durch <paramref name="keySelector" /> dargestellten Funktion zurückgegeben wird.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <summary>Sortiert die Elemente einer Sequenz in absteigender Reihenfolge nach einem Schlüssel</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedQueryable`1" />, dessen Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird. Das Ergebnis des- <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Aufruf von wird in <xref:System.Linq.IOrderedQueryable%601> den-Typ umgewandelt und zurückgegeben.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass die Elemente von `source` in absteigender Reihenfolge sortiert werden, basierend auf dem Schlüssel, der durch Aufrufen `source` `keySelector` von für jedes Element von abgerufen wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.OrderByDescending``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As IQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), comparer As IComparer(Of TKey)) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ OrderByDescending(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.OrderByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der durch <paramref name="keySelector" /> dargestellten Funktion zurückgegeben wird.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Sortiert die Elemente einer Sequenz mithilfe eines angegebenen Vergleichs in absteigender Reihenfolge.</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedQueryable`1" />, dessen Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird. Das Ergebnis des- <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Aufruf von wird in <xref:System.Linq.IOrderedQueryable%601> den-Typ umgewandelt und zurückgegeben.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass die Elemente von `source` in absteigender Reihenfolge sortiert werden, basierend auf dem Schlüssel, der durch Aufrufen `source` `keySelector` von für jedes Element von abgerufen wird. Der `comparer` -Parameter wird verwendet, um Schlüssel zu vergleichen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.OrderByDescending%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> verwendet wird, um die Elemente einer Sequenz in absteigender Reihenfolge mithilfe eines benutzerdefinierten Comparers zu sortieren.  
  
 [!code-csharp[System.Linq.Queryable#71](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#71)]
 [!code-vb[System.Linq.Queryable#71](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#71)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="comparer" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Prepend&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Prepend&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Prepend&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Prepend``1(System.Linq.IQueryable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Prepend(Of TSource) (source As IQueryable(Of TSource), element As TSource) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Prepend(System::Linq::IQueryable&lt;TSource&gt; ^ source, TSource element);" />
      <MemberSignature Language="F#" Value="static member Prepend : System.Linq.IQueryable&lt;'Source&gt; * 'Source -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Prepend (source, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="element" Type="TSource" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="element">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Reverse&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Reverse&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Reverse``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reverse(Of TSource) (source As IQueryable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Reverse(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Reverse : System.Linq.IQueryable&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Reverse source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine umzukehrende Sequenz von Werten.</param>
        <summary>Kehrt die Reihenfolge der Elemente in einer Sequenz um</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, dessen Elemente den Elementen der Eingabesequenz in umgekehrter Reihenfolge entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Reverse%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Reverse%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Reverse%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass die Reihenfolge der Elemente in `source`umgekehrt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Reverse%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> verwendet wird, um die Reihenfolge der Elemente in einem Array umzukehren.  
  
 [!code-csharp[System.Linq.Queryable#74](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#74)]
 [!code-vb[System.Linq.Queryable#74](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#74)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Projiziert jedes Element einer Sequenz in ein neues Format.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Select``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Integer, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Select(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Der Typ des Werts, der von der durch <paramref name="selector" /> dargestellten Funktion zurückgegeben wird.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein neues Format, indem der Index des Elements integriert wird</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, dessen Elemente das Ergebnis des Aufrufs einer Projektionsfunktion für jedes Element von <paramref name="source" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `selector` für jedes Element von `source` aufruft, um es in eine andere Form zu projizieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%7D%29> verwendet wird, um eine Sequenz von-Werten zu projizieren und den Index der einzelnen Elemente im projizierten Formular zu verwenden.  
  
 [!code-csharp[System.Linq.Queryable#76](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#76)]
 [!code-vb[System.Linq.Queryable#76](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#76)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Select``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Select(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Der Typ des Werts, der von der durch <paramref name="selector" /> dargestellten Funktion zurückgegeben wird.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein neues Format.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, dessen Elemente das Ergebnis des Aufrufs einer Projektionsfunktion für jedes Element von <paramref name="source" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `selector` für jedes Element von `source` aufruft, um es in eine andere Form zu projizieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Select%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> verwendet wird, um eine Sequenz von-Werten zu projizieren.  
  
 [!code-csharp[System.Linq.Queryable#75](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#75)]
 [!code-vb[System.Linq.Queryable#75](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#75)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SelectMany&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> und fasst die resultierenden Sequenzen in einer einzigen Sequenz vom Typ <see cref="T:System.Linq.IQueryable`1" /> zusammen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SelectMany``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, IEnumerable(Of TResult)))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ SelectMany(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, seq&lt;'Result&gt;&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Der Typ der Elemente der Sequenz, die von der durch <paramref name="selector" /> dargestellten Funktion zurückgegeben werden.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> und fasst die resultierenden Sequenzen in einer einzigen Sequenz zusammen.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, dessen Elemente das Ergebnis des Aufrufs einer 1:n-Projektionsfunktion für jedes Element der Eingabesequenz sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `selector` für jedes Element von `source` aufruft, um es in ein Aufzähl bares Formular zu projizieren. Anschließend werden die Aufzähl baren Ergebnisse in eine einzelne, eindimensionale Sequenz verkettet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> verwendet wird, um eine 1: n-Projektion über ein Array auszuführen.  
  
 [!code-csharp[System.Linq.Queryable#77](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#77)]
 [!code-vb[System.Linq.Queryable#77](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#77)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SelectMany``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Integer, IEnumerable(Of TResult)))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ SelectMany(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, seq&lt;'Result&gt;&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Der Typ der Elemente der Sequenz, die von der durch <paramref name="selector" /> dargestellten Funktion zurückgegeben werden.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> und fasst die resultierenden Sequenzen in einer einzigen Sequenz zusammen. Der Index jedes Quellelements wird im projizierten Format des jeweiligen Elements verwendet.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, dessen Elemente das Ergebnis des Aufrufs einer 1:n-Projektionsfunktion für jedes Element der Eingabesequenz sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `selector` für jedes Element von `source` aufruft, um es in ein Aufzähl bares Formular zu projizieren. Jedes Aufzähl Bare Ergebnis enthält den Index des Quell Elements. Anschließend werden die Aufzähl baren Ergebnisse in eine einzelne, eindimensionale Sequenz verkettet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.SelectMany%60%602%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%29> verwendet wird, um eine 1: n-Projektion über ein Array auszuführen und den Index der einzelnen Quell Elemente zu verwenden.  
  
 [!code-csharp[System.Linq.Queryable#78](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#78)]
 [!code-vb[System.Linq.Queryable#78](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#78)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;&gt; collectionSelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TCollection,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt;&gt; collectionSelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SelectMany``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As IQueryable(Of TSource), collectionSelector As Expression(Of Func(Of TSource, IEnumerable(Of TCollection))), resultSelector As Expression(Of Func(Of TSource, TCollection, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ SelectMany(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^&gt; ^ collectionSelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TCollection, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, seq&lt;'Collection&gt;&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Collection, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TCollection,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TCollection">Der Typ der Zwischenelemente, die von der durch <paramref name="collectionSelector" /> dargestellten Funktion erfasst werden.</typeparam>
        <typeparam name="TResult">Der Typ der Elemente in der resultierenden Sequenz.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="collectionSelector">Eine Projektionsfunktion, die auf jedes Element der Eingabesequenz angewendet werden soll.</param>
        <param name="resultSelector">Eine Projektionsfunktion, die auf jedes Element jeder Zwischensequenz angewendet werden soll.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> und ruft für jedes Element darin eine Ergebnisauswahlfunktion auf. Die Ergebniswerte aus jeder Zwischensequenz werden zu einer einzigen eindimensionalen Sequenz zusammengefasst und zurückgegeben.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, dessen Elemente erzeugt werden, indem für jedes Element von <paramref name="collectionSelector" /> die 1:n-Projektionsfunktion <paramref name="source" /> aufgerufen wird und dann jedes so erzeugte Element der Sequenz und sein entsprechendes <paramref name="source" />-Element einem Ergebniselement zugeordnet werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `collectionSelector` für jedes Element von `source` aufruft, um es in ein Aufzähl bares Formular zu projizieren. Anschließend wird die Funktion, `resultSelector` die durch dargestellt wird, für jedes Element in jeder Zwischensequenz aufgerufen. Die resultierenden Werte werden in einer einzelnen eindimensionalen Sequenz verkettet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> verwendet wird, um eine 1: n-Projektion über ein Array auszuführen. In diesem Beispiel wird eine Ergebnis Auswahlfunktion verwendet, um das Quell Element beizubehalten, das jeder Zwischensequenz im Gültigkeitsbereich des `Select`letzten Aufrufens entspricht.  
  
 [!code-csharp[System.Linq.Queryable#124](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#124)]
 [!code-vb[System.Linq.Queryable#124](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#124)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="collectionSelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;&gt; collectionSelector, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TCollection,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt;&gt; collectionSelector, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SelectMany``3(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}}},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As IQueryable(Of TSource), collectionSelector As Expression(Of Func(Of TSource, Integer, IEnumerable(Of TCollection))), resultSelector As Expression(Of Func(Of TSource, TCollection, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ SelectMany(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^&gt; ^ collectionSelector, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TCollection, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, seq&lt;'Collection&gt;&gt;&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Collection, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TCollection,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TCollection">Der Typ der Zwischenelemente, die von der durch <paramref name="collectionSelector" /> dargestellten Funktion erfasst werden.</typeparam>
        <typeparam name="TResult">Der Typ der Elemente in der resultierenden Sequenz.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="collectionSelector">Eine Projektionsfunktion, die auf jedes Element der Eingabesequenz angewendet werden soll. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <param name="resultSelector">Eine Projektionsfunktion, die auf jedes Element jeder Zwischensequenz angewendet werden soll.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das den Index des Quellelements enthält, von dem es erzeugt wurde. Für jedes Element jeder Zwischensequenz wird eine Ergebnisauswahlfunktion aufgerufen, und die Ergebniswerte werden zu einer einzigen eindimensionale Sequenz zusammengefasst und zurückgegeben.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, dessen Elemente erzeugt werden, indem für jedes Element von <paramref name="collectionSelector" /> die 1:n-Projektionsfunktion <paramref name="source" /> aufgerufen wird und dann jedes so erzeugte Element der Sequenz und sein entsprechendes <paramref name="source" />-Element einem Ergebniselement zugeordnet werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.SelectMany%60%603%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `collectionSelector` für jedes Element von `source` aufruft, um es in ein Aufzähl bares Formular zu projizieren. Jedes Aufzähl Bare Ergebnis enthält den Index des Quell Elements. Anschließend wird die Funktion, `resultSelector` die durch dargestellt wird, für jedes Element in jeder Zwischensequenz aufgerufen. Die resultierenden Werte werden in einer einzelnen eindimensionalen Sequenz verkettet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="collectionSelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SequenceEqual&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob zwei Sequenzen gleich sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SequenceEqual``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Queryable.SequenceEqual (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="source1">Ein <see cref="T:System.Linq.IQueryable`1" /> dessen Elemente mit den Elementen von <paramref name="source2" /> verglichen werden sollen.</param>
        <param name="source2">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen Elemente mit den Elementen der ersten Sequenz verglichen werden sollen.</param>
        <summary>Bestimmt mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Elementen, ob zwei Sequenzen gleich sind.</summary>
        <returns><see langword="true" />, wenn die zwei Quellsequenzen von gleicher Länge sind und ihre entsprechenden Elemente als gleich gelten, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source1` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source1` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es bestimmt, ob die beiden Quell Sequenzen gleich sind.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> verwendet wird, um zu bestimmen, ob zwei Sequenzen gleich sind. In diesem Beispiel sind die Sequenzen gleich.  
  
 [!code-csharp[System.Linq.Queryable#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#32)]
 [!code-vb[System.Linq.Queryable#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#32)]  
  
 Im folgenden Codebeispiel werden zwei Sequenzen verglichen, die nicht gleich sind.  
  
 [!code-csharp[System.Linq.Queryable#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#33)]
 [!code-vb[System.Linq.Queryable#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> oder <paramref name="source2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SequenceEqual``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Queryable.SequenceEqual (source1, source2, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="source1">Ein <see cref="T:System.Linq.IQueryable`1" /> dessen Elemente mit den Elementen von <paramref name="source2" /> verglichen werden sollen.</param>
        <param name="source2">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen Elemente mit den Elementen der ersten Sequenz verglichen werden sollen.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, der zum Vergleichen von Elementen verwendet werden soll.</param>
        <summary>Bestimmt mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Elementen, ob zwei Sequenzen gleich sind.</summary>
        <returns><see langword="true" />, wenn die zwei Quellsequenzen von gleicher Länge sind und ihre entsprechenden Elemente als gleich gelten, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source1` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.SequenceEqual%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source1` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es bestimmt, ob die beiden Quell Sequenzen gleich sind `comparer` , indem zum Vergleichen von Elementen verwendet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> oder <paramref name="source2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Single&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt ein einzelnes spezifisches Element einer Sequenz zurück</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Single``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Single : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Single source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, dessen einziges Element zurückgegeben werden soll</param>
        <summary>Gibt das einzige Element einer Sequenz zurück und löst eine Ausnahme aus, wenn nicht genau ein Element in der Sequenz vorhanden ist.</summary>
        <returns>Das einzige Element der Eingabesequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es das einzige Element in `source`zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> verwendet wird, um das einzige Element eines Arrays auszuwählen.  
  
 [!code-csharp[System.Linq.Queryable#79](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#79)]
 [!code-vb[System.Linq.Queryable#79](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#79)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> hat mehr als ein Element.</exception>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Single``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Single : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.Single (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, aus dem ein einzelnes Element zurückgegeben werden soll</param>
        <param name="predicate">Eine Funktion zum Überprüfen eines Elements auf eine Bedingung.</param>
        <summary>Gibt das einzige Element einer Sequenz zurück, das eine angegebene Bedingung erfüllt, und löst eine Ausnahme aus, wenn mehrere solche Elemente vorhanden sind.</summary>
        <returns>Das einzige Element der Eingabesequenz, das die Bedingung in <paramref name="predicate" /> erfüllt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es das einzige Element in `source` zurückgibt, das die von `predicate`angegebene Bedingung erfüllt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> verwendet wird, um das einzige Element eines Arrays auszuwählen, das eine Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Queryable#81](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#81)]
 [!code-vb[System.Linq.Queryable#81](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#81)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element erfüllt die Bedingung in <paramref name="predicate" />.  
  
- oder - 
Die Bedingung in <paramref name="predicate" /> wird von mehreren Elementen erfüllt.  
  
- oder - 
Die Quellsequenz ist leer.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SingleOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt ein einzelnes spezifisches Element einer Sequenz zurück, oder einen Standardwert, wenn ein solches Element nicht gefunden wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SingleOrDefault``1(System.Linq.IQueryable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As IQueryable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : System.Linq.IQueryable&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Queryable.SingleOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, dessen einziges Element zurückgegeben werden soll</param>
        <summary>Gibt das einzige Element einer Sequenz oder einen Standardwert zurück, wenn die Sequenz leer ist. Diese Methode löst eine Ausnahme aus, wenn mehrere Elemente in der Sequenz vorhanden sind.</summary>
        <returns>Das einzige Element der Eingabesequenz oder <c>default</c>(<paramref name="TSource" />), wenn die Sequenz keine Elemente enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es das einzige Element in `source`zurückgibt, oder einen Standard `source` Wert, wenn leer ist.  
  
 Die <xref:System.Linq.Queryable.SingleOrDefault%2A> -Methode bietet keine Möglichkeit, einen Standardwert anzugeben. Wenn Sie einen anderen Standardwert als `default(TSource)`angeben möchten, verwenden Sie die <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> -Methode, wie im Beispiel Abschnitt beschrieben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> verwendet wird, um das einzige Element eines Arrays auszuwählen. Die zweite Abfrage veranschaulicht, <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> dass einen Standardwert zurückgibt, wenn die Sequenz nicht genau ein Element enthält.  
  
 [!code-csharp[System.Linq.Queryable#83](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#83)]
 [!code-vb[System.Linq.Queryable#83](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#83)]  
  
 Manchmal ist der Wert `default(TSource)` von nicht der Standardwert, den Sie verwenden möchten, wenn die Auflistung keine Elemente enthält. Anstatt das Ergebnis für den unerwünschten Standardwert zu überprüfen und ggf. zu ändern, können Sie die <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> -Methode verwenden, um den Standardwert anzugeben, den Sie verwenden möchten, wenn die Auflistung leer ist. Rufen Sie dann <xref:System.Linq.Queryable.Single%60%601%28System.Linq.IQueryable%7B%60%600%7D%29> auf, um das Element abzurufen. Im folgenden Codebeispiel werden beide Techniken verwendet, um den Standardwert 1 zu erhalten, wenn eine Auflistung von Seitenzahlen leer ist. Da der Standardwert für eine Ganzzahl 0 ist, was normalerweise keine gültige Seitenzahl ist, muss der Standardwert stattdessen als 1 angegeben werden. Die erste Ergebnisvariable wird nach Abschluss der Abfrage auf den unerwünschten Standardwert geprüft. Die zweite Ergebnisvariable wird abgerufen, indem <xref:System.Linq.Queryable.DefaultIfEmpty%60%601%28System.Linq.IQueryable%7B%60%600%7D%2C%60%600%29> aufgerufen wird, um den Standardwert 1 anzugeben.  
  
 [!code-csharp[System.Linq.Queryable#133](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#133)]
 [!code-vb[System.Linq.Queryable#133](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#133)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> hat mehr als ein Element.</exception>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SingleOrDefault``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; 'Source" Usage="System.Linq.Queryable.SingleOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, aus dem ein einzelnes Element zurückgegeben werden soll</param>
        <param name="predicate">Eine Funktion zum Überprüfen eines Elements auf eine Bedingung.</param>
        <summary>Gibt das einzige Element einer Sequenz, das eine angegebene Bedingung erfüllt, oder einen Standardwert zurück, wenn kein solches Element vorhanden ist. Diese Methode löst eine Ausnahme aus, wenn mehrere Elemente die Bedingung erfüllen.</summary>
        <returns>Gibt das einzige Element der Eingabesequenz zurück, das die Bedingung in <paramref name="predicate" /> erfüllt, oder <c>default</c>(<paramref name="TSource" />), wenn ein solches Element nicht gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es das einzige Element in `source` zurückgibt, das die durch `predicate`angegebene Bedingung erfüllt, oder einen Standardwert, wenn kein solches Element vorhanden ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> verwendet wird, um das einzige Element eines Arrays auszuwählen, das eine Bedingung erfüllt. Die zweite Abfrage veranschaulicht, <xref:System.Linq.Queryable.SingleOrDefault%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> dass einen Standardwert zurückgibt, wenn die Sequenz nicht genau ein Element enthält, das die Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Queryable#85](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#85)]
 [!code-vb[System.Linq.Queryable#85](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#85)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Bedingung in <paramref name="predicate" /> wird von mehreren Elementen erfüllt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Skip&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Skip&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Skip``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Skip(Of TSource) (source As IQueryable(Of TSource), count As Integer) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Skip(System::Linq::IQueryable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Skip : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Skip (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, aus dem Elemente zurückgegeben werden sollen</param>
        <param name="count">Die Anzahl der Elemente, die übersprungen werden sollen, bevor die übrigen Elemente zurückgegeben werden.</param>
        <summary>Umgeht eine festgelegte Anzahl von Elementen in einer Sequenz und gibt dann die übrigen Elemente zurück</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, das Elemente enthält, die nach dem angegebenen Index in der Eingabesequenz auftreten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Skip%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Skip%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Skip%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es die ersten `count` Elemente in `source` überspringt und die restlichen Elemente zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Skip%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> verwendet wird, um eine angegebene Anzahl von Elementen in einem sortierten Array zu überspringen und die restlichen Elemente zurückzugeben.  
  
 [!code-csharp[System.Linq.Queryable#87](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#87)]
 [!code-vb[System.Linq.Queryable#87](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; SkipLast&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; SkipLast&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SkipLast``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipLast(Of TSource) (source As IQueryable(Of TSource), count As Integer) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ SkipLast(System::Linq::IQueryable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member SkipLast : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.SkipLast (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Umgeht Elemente in einer Sequenz, solange eine angegebene Bedingung true ist, und gibt dann die übrigen Elemente zurück</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SkipWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ SkipWhile(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, aus dem Elemente zurückgegeben werden sollen</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Umgeht Elemente in einer Sequenz, solange eine angegebene Bedingung true ist, und gibt dann die übrigen Elemente zurück</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, das Elemente aus <paramref name="source" /> ab dem ersten Element in der linearen Reihe enthält, das die in <paramref name="predicate" /> angegebene Überprüfung nicht besteht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `predicate` für jedes Element in `source` gilt, bis ein Element gefunden wird `predicate` , für das false zurückgibt. Dieses Element und alle restlichen Elemente werden zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> verwendet wird, um Elemente eines Arrays zu überspringen, solange eine Bedingung true ist.  
  
 [!code-csharp[System.Linq.Queryable#88](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#88)]
 [!code-vb[System.Linq.Queryable#88](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#88)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.SkipWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Integer, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ SkipWhile(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IQueryable`1" />, aus dem Elemente zurückgegeben werden sollen</param>
        <param name="predicate">Eine Funktion zum Überprüfen jedes Elements auf eine Bedingung. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <summary>Umgeht Elemente in einer Sequenz, solange eine angegebene Bedingung true ist, und gibt dann die übrigen Elemente zurück In der Logik der Prädikatfunktion wird der Index des Elements verwendet.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, das Elemente aus <paramref name="source" /> ab dem ersten Element in der linearen Reihe enthält, das die in <paramref name="predicate" /> angegebene Überprüfung nicht besteht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `predicate` für jedes Element in `source` gilt, bis ein Element gefunden wird `predicate` , für das false zurückgibt. Dieses Element und alle restlichen Elemente werden zurückgegeben. Der Index jedes Quell Elements wird als zweites Argument für `predicate`bereitgestellt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.SkipWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> verwendet wird, um Elemente eines Arrays zu überspringen, solange eine Bedingung, die vom Index des Elements abhängt, true ist.  
  
 [!code-csharp[System.Linq.Queryable#89](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#89)]
 [!code-vb[System.Linq.Queryable#89](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sum">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet die Summe einer Sequenz von numerischen Werten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static decimal Sum (this System.Linq.IQueryable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum(class System.Linq.IQueryable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Linq::IQueryable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Decimal" />-Werten, deren Summe berechnet werden soll</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Decimal" />-Werten</summary>
        <returns>Die Summe der Werte in der Sequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Decimal%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es die Summe der Werte in `source`zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> verwendet wird, um die Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static double Sum (this System.Linq.IQueryable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum(class System.Linq.IQueryable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Linq::IQueryable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;double&gt; -&gt; double" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Double" />-Werten, deren Summe berechnet werden soll</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Double" />-Werten</summary>
        <returns>Die Summe der Werte in der Sequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Double%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Double%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Double%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es die Summe der Werte in `source`zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> verwendet wird, um die Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static int Sum (this System.Linq.IQueryable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum(class System.Linq.IQueryable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Linq::IQueryable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;int&gt; -&gt; int" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int32" />-Werten, deren Summe berechnet werden soll</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int32" />-Werten</summary>
        <returns>Die Summe der Werte in der Sequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int32%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int32%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int32%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es die Summe der Werte in `source`zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> verwendet wird, um die Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static long Sum (this System.Linq.IQueryable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum(class System.Linq.IQueryable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Linq::IQueryable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;int64&gt; -&gt; int64" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int64" />-Werten, deren Summe berechnet werden soll</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int64" />-Werten</summary>
        <returns>Die Summe der Werte in der Sequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int64%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int64%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Int64%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es die Summe der Werte in `source`zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> verwendet wird, um die Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Linq::IQueryable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Decimal" />-Werten, die NULL zulassen, und deren Summe berechnet werden soll</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Decimal" />-Werten, die NULL zulassen</summary>
        <returns>Die Summe der Werte in der Sequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es die Summe der Werte in `source`zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> verwendet wird, um die Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Linq::IQueryable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Double" />-Werten, die NULL zulassen, und deren Summe berechnet werden soll</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Double" />-Werten, die NULL zulassen</summary>
        <returns>Die Summe der Werte in der Sequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es die Summe der Werte in `source`zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> verwendet wird, um die Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Linq::IQueryable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int32" />-Werten, die NULL zulassen, und deren Summe berechnet werden soll</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int32" />-Werten, die NULL zulassen</summary>
        <returns>Die Summe der Werte in der Sequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es die Summe der Werte in `source`zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> verwendet wird, um die Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Linq::IQueryable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int64" />-Werten, die NULL zulassen, und deren Summe berechnet werden soll</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int64" />-Werten, die NULL zulassen</summary>
        <returns>Die Summe der Werte in der Sequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es die Summe der Werte in `source`zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> verwendet wird, um die Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum (this System.Linq.IQueryable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum(class System.Linq.IQueryable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Linq::IQueryable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Single" />-Werten, die NULL zulassen, und deren Summe berechnet werden soll</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Single" />-Werten, die NULL zulassen</summary>
        <returns>Die Summe der Werte in der Sequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es die Summe der Werte in `source`zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> verwendet wird, um die Werte einer Sequenz zusammenzufassen.  
  
 [!code-csharp[System.Linq.Queryable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#121)]
 [!code-vb[System.Linq.Queryable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static float Sum (this System.Linq.IQueryable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum(class System.Linq.IQueryable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum(System.Linq.IQueryable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IQueryable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Linq::IQueryable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;single&gt; -&gt; single" Usage="System.Linq.Queryable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Single" />-Werten, deren Summe berechnet werden soll</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Single" />-Werten</summary>
        <returns>Die Summe der Werte in der Sequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es die Summe der Werte in `source`zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Sum%28System.Linq.IQueryable%7BSystem.Single%7D%29> verwendet wird, um die Werte einer Sequenz zusammenzufassen.  
  
 [!code-csharp[System.Linq.Queryable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#120)]
 [!code-vb[System.Linq.Queryable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Decimal))) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, System::Decimal&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, decimal&gt;&gt; -&gt; decimal" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten des Typs <paramref name="TSource" />.</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Decimal" />-Werten, die durch den Aufruf einer Projektionsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Die Summe der projizierten Werte</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Decimal%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `selector` für jedes Element von `source` aufruft und die Summe der resultierenden Werte zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> verwendet wird, um die projizierten Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Double))) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, double&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, double&gt;&gt; -&gt; double" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten des Typs <paramref name="TSource" />.</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Double" />-Werten, die durch den Aufruf einer Projektionsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Die Summe der projizierten Werte</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `selector` für jedes Element von `source` aufruft und die Summe der resultierenden Werte zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> verwendet wird, um die projizierten Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Integer))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int&gt;&gt; -&gt; int" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten des Typs <paramref name="TSource" />.</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int32" />-Werten, die durch den Aufruf einer Projektionsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Die Summe der projizierten Werte</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `selector` für jedes Element von `source` aufruft und die Summe der resultierenden Werte zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> verwendet wird, um die projizierten Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Long))) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, long&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int64&gt;&gt; -&gt; int64" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten des Typs <paramref name="TSource" />.</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int64" />-Werten, die durch den Aufruf einer Projektionsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Die Summe der projizierten Werte</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int64%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `selector` für jedes Element von `source` aufruft und die Summe der resultierenden Werte zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> verwendet wird, um die projizierten Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;decimal&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Decimal}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Decimal)))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;decimal&gt;&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten des Typs <paramref name="TSource" />.</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Decimal" />-Werten, die NULL zulassen, die durch den Aufruf einer Projektionsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Die Summe der projizierten Werte</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `selector` für jedes Element von `source` aufruft und die Summe der resultierenden Werte zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> verwendet wird, um die projizierten Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;double&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Double}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Double)))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;double&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;double&gt;&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten des Typs <paramref name="TSource" />.</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Double" />-Werten, die NULL zulassen, die durch den Aufruf einer Projektionsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Die Summe der projizierten Werte</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `selector` für jedes Element von `source` aufruft und die Summe der resultierenden Werte zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> verwendet wird, um die projizierten Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;int&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int32}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Integer)))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;int&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;int&gt;&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten des Typs <paramref name="TSource" />.</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int32" />-Werten, die NULL zulassen, die durch den Aufruf einer Projektionsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Die Summe der projizierten Werte</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `selector` für jedes Element von `source` aufruft und die Summe der resultierenden Werte zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> verwendet wird, um die projizierten Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;long&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Int64}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Long)))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;long&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;int64&gt;&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten des Typs <paramref name="TSource" />.</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int64" />-Werten, die NULL zulassen, die durch den Aufruf einer Projektionsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Die Summe der projizierten Werte</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `selector` für jedes Element von `source` aufruft und die Summe der resultierenden Werte zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> verwendet wird, um die projizierten Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,Nullable&lt;float&gt;&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Nullable{System.Single}}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Nullable(Of Single)))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, Nullable&lt;float&gt;&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, Nullable&lt;single&gt;&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten des Typs <paramref name="TSource" />.</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Single" />-Werten, die NULL zulassen, die durch den Aufruf einer Projektionsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Die Summe der projizierten Werte</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `selector` für jedes Element von `source` aufruft und die Summe der resultierenden Werte zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> verwendet wird, um die projizierten Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Sum&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Sum``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IQueryable(Of TSource), selector As Expression(Of Func(Of TSource, Single))) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, float&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, single&gt;&gt; -&gt; single" Usage="System.Linq.Queryable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten des Typs <paramref name="TSource" />.</param>
        <param name="selector">Eine Projektionsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Single" />-Werten, die durch den Aufruf einer Projektionsfunktion für jedes Element der Eingabesequenz ermittelt wird.</summary>
        <returns>Die Summe der projizierten Werte</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.Execute%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Single%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `selector` für jedes Element von `source` aufruft und die Summe der resultierenden Werte zurückgibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Sum%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Double%7D%7D%29> verwendet wird, um die projizierten Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Queryable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#98)]
 [!code-vb[System.Linq.Queryable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Take&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Take&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Take``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Take(Of TSource) (source As IQueryable(Of TSource), count As Integer) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Take(System::Linq::IQueryable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Take : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Take (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="count">Die Anzahl der zurückzugebenden Elemente.</param>
        <summary>Gibt eine angegebene Anzahl von zusammenhängenden Elementen ab dem Anfang einer Sequenz zurück</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, das die angegebene Anzahl von Elementen ab dem Anfang von <paramref name="source" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Take%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Take%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Take%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es die ersten `count` Elemente vom Anfang von `source`annimmt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Take%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Int32%29> verwendet wird, um Elemente ab dem Anfang einer Sequenz zurückzugeben.  
  
 [!code-csharp[System.Linq.Queryable#99](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#99)]
 [!code-vb[System.Linq.Queryable#99](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#99)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; TakeLast&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; TakeLast&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.TakeLast``1(System.Linq.IQueryable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeLast(Of TSource) (source As IQueryable(Of TSource), count As Integer) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ TakeLast(System::Linq::IQueryable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member TakeLast : System.Linq.IQueryable&lt;'Source&gt; * int -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.TakeLast (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TakeWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt Elemente aus einer Sequenz zurück, solange eine angegebene Bedingung TRUE ist, und überspringt dann die übrigen Elemente</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.TakeWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ TakeWhile(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt Elemente aus einer Sequenz zurück, solange eine angegebene Bedingung TRUE ist</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, das Elemente aus der Eingabesequenz enthält, die vor dem Element auftreten, bei dem die von <paramref name="predicate" /> angegebene Überprüfung nicht mehr erfolgreich ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `predicate` für jedes Element in `source` gilt, bis ein Element gefunden wird `predicate` , `false`das zurückgibt. Bis zu diesem Punkt werden alle Elemente zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> verwendet wird, um Elemente ab dem Anfang einer Sequenz zurückzugeben, solange eine Bedingung true ist.  
  
 [!code-csharp[System.Linq.Queryable#100](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#100)]
 [!code-vb[System.Linq.Queryable#100](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#100)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.TakeWhile``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Integer, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ TakeWhile(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="predicate">Eine Funktion zum Überprüfen jedes Elements auf eine Bedingung. Der zweite Parameter der Funktion stellt den Index des Elements in der Quellsequenz dar.</param>
        <summary>Gibt Elemente aus einer Sequenz zurück, solange eine angegebene Bedingung TRUE ist In der Logik der Prädikatfunktion wird der Index des Elements verwendet.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, das Elemente aus der Eingabesequenz enthält, die vor dem Element auftreten, bei dem die von <paramref name="predicate" /> angegebene Überprüfung nicht mehr erfolgreich ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es `predicate` für jedes Element in `source` gilt, bis ein Element gefunden wird `predicate` , `false`das zurückgibt. Bis zu diesem Punkt werden alle Elemente zurückgegeben. Der Index jedes Quell Elements wird als zweites Argument für `predicate`bereitgestellt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.TakeWhile%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> verwendet wird, um Elemente vom Anfang einer Sequenz zurückzugeben, solange eine Bedingung, die den Index des-Elements verwendet, true ist.  
  
 [!code-csharp[System.Linq.Queryable#101](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#101)]
 [!code-vb[System.Linq.Queryable#101](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#101)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt eine nachfolgende Sortierung der Elemente in einer Sequenz in aufsteigender Reihenfolge durch</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ThenBy``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As IOrderedQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey))) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ ThenBy(System::Linq::IOrderedQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.IOrderedQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.ThenBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der von <paramref name="keySelector" /> dargestellten Funktion zurückgegeben wird.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IOrderedQueryable`1" /> mit den zu sortierenden Elementen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <summary>Führt eine nachfolgende Sortierung der Elemente in einer Sequenz in aufsteigender Reihenfolge nach einem Schlüssel durch</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedQueryable`1" />, dessen Elemente nach einem Schlüssel sortiert werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird. Das Ergebnis des- <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Aufruf von wird in <xref:System.Linq.IOrderedQueryable%601> den-Typ umgewandelt und zurückgegeben.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es eine sekundäre Sortierung der Elemente von `source` basierend auf dem Schlüssel ausführt, der durch Aufrufen `keySelector` von für jedes `source`Element von abgerufen wird. Alle zuvor eingerichteten Sortier Reihenfolgen werden beibehalten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> verwendet wird, um eine sekundäre Reihenfolge der Elemente in einer Sequenz auszuführen.  
  
 [!code-csharp[System.Linq.Queryable#102](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#102)]
 [!code-vb[System.Linq.Queryable#102](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#102)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ThenBy``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As IOrderedQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), comparer As IComparer(Of TKey)) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ ThenBy(System::Linq::IOrderedQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.IOrderedQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.ThenBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der von <paramref name="keySelector" /> dargestellten Funktion zurückgegeben wird.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IOrderedQueryable`1" /> mit den zu sortierenden Elementen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Führt mithilfe eines angegebenen Vergleichs eine nachfolgende Sortierung der Elemente in einer Sequenz in aufsteigender Reihenfolge durch</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedQueryable`1" />, dessen Elemente nach einem Schlüssel sortiert werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird. Das Ergebnis des- <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Aufruf von wird in <xref:System.Linq.IOrderedQueryable%601> den-Typ umgewandelt und zurückgegeben.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es eine sekundäre Sortierung der Elemente von `source` basierend auf dem Schlüssel ausführt, der durch Aufrufen `keySelector` von für jedes `source`Element von abgerufen wird. Alle zuvor eingerichteten Sortier Reihenfolgen werden beibehalten. Der `comparer` -Parameter wird verwendet, um Schlüsselwerte zu vergleichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="comparer" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt eine nachfolgende Sortierung der Elemente in einer Sequenz in absteigender Reihenfolge durch</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ThenByDescending``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As IOrderedQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey))) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ ThenByDescending(System::Linq::IOrderedQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.IOrderedQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.ThenByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der von <paramref name="keySelector" /> dargestellten Funktion zurückgegeben wird.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IOrderedQueryable`1" /> mit den zu sortierenden Elementen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <summary>Führt eine nachfolgende Sortierung der Elemente in einer Sequenz in absteigender Reihenfolge nach einem Schlüssel durch</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedQueryable`1" />, dessen Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.ThenByDescending%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.ThenByDescending%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird. Das Ergebnis des- <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Aufruf von wird in <xref:System.Linq.IOrderedQueryable%601> den-Typ umgewandelt und zurückgegeben.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.ThenByDescending%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es eine sekundäre Sortierung der Elemente von `source` in absteigender Reihenfolge ausführt, basierend auf dem Schlüssel, der durch Aufrufen `keySelector` von `source`für jedes Element von abgerufen wird. Alle zuvor eingerichteten Sortier Reihenfolgen werden beibehalten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedQueryable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,TKey&gt;&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, !!TKey&gt;&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.ThenByDescending``2(System.Linq.IOrderedQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As IOrderedQueryable(Of TSource), keySelector As Expression(Of Func(Of TSource, TKey)), comparer As IComparer(Of TKey)) As IOrderedQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedQueryable&lt;TSource&gt; ^ ThenByDescending(System::Linq::IOrderedQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, TKey&gt; ^&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.IOrderedQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, 'Key&gt;&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.ThenByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,TKey&gt;&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des Schlüssels, der von der <paramref name="keySelector" />-Funktion zurückgegeben wird.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IOrderedQueryable`1" /> mit den zu sortierenden Elementen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Führt mithilfe eines angegebenen Vergleichs eine nachfolgende Sortierung der Elemente in einer Sequenz in absteigender Reihenfolge durch</summary>
        <returns>Eine Auflistung, deren Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird. Das Ergebnis des- <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> Aufruf von wird in <xref:System.Linq.IOrderedQueryable%601> den-Typ umgewandelt und zurückgegeben.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.ThenBy%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten ist, dass es eine sekundäre Sortierung der Elemente von `source` in absteigender Reihenfolge ausführt, basierend auf dem Schlüssel, der durch Aufrufen `keySelector` von `source`für jedes Element von abgerufen wird. Alle zuvor eingerichteten Sortier Reihenfolgen werden beibehalten. Der `comparer` -Parameter wird verwendet, um Schlüsselwerte zu vergleichen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.ThenByDescending%60%602%28System.Linq.IOrderedQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2C%60%601%7D%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> verwendet wird, um eine sekundäre Sortierung der Elemente in einer Sequenz in absteigender Reihenfolge mithilfe eines benutzerdefinierten Vergleichs auszuführen.  
  
 [!code-csharp[System.Linq.Queryable#103](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#103)]
 [!code-vb[System.Linq.Queryable#103](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#103)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="comparer" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Union&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erzeugt die Vereinigungsmenge von zwei Sequenzen</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Union``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Union(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member Union : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Union (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="source1">Eine Sequenz, deren unterschiedliche Elemente den ersten Satz für die Gesamtmengenbildung darstellen.</param>
        <param name="source2">Eine Sequenz, deren unterschiedliche Elemente den zweiten Satz für die Gesamtmengenbildung darstellen.</param>
        <summary>Erzeugt die Vereinigungsmenge von zwei Sequenzen mithilfe des Standardgleichheitsvergleichs</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, das die Elemente aus beiden Eingabesequenzen ohne Duplikate enthält</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source1` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source1` des Typs des Parameters ab. Das erwartete Verhalten ist, dass die Menge der Elemente in `source1` und `source2` zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> verwendet wird, um die Mengen Union von zwei Sequenzen zu erhalten.  
  
 [!code-csharp[System.Linq.Queryable#109](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#109)]
 [!code-vb[System.Linq.Queryable#109](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#109)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> oder <paramref name="source2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source1, System.Collections.Generic.IEnumerable&lt;TSource&gt; source2, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source2, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Union``1(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (source1 As IQueryable(Of TSource), source2 As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Union(System::Linq::IQueryable&lt;TSource&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source2, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Union : System.Linq.IQueryable&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Union (source1, source2, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="source1">Eine Sequenz, deren unterschiedliche Elemente den ersten Satz für die Gesamtmengenbildung darstellen.</param>
        <param name="source2">Eine Sequenz, deren unterschiedliche Elemente den zweiten Satz für die Gesamtmengenbildung darstellen.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Erzeugt mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> die Vereinigungsmenge von zwei Sequenzen</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, das die Elemente aus beiden Eingabesequenzen ohne Duplikate enthält</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source1` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Union%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source1` des Typs des Parameters ab. Das erwartete Verhalten ist, dass die Menge der Elemente in `source1` und `source2` zurückgegeben wird. Der `comparer` -Parameter wird verwendet, um Werte zu vergleichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> oder <paramref name="source2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Where&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Filtert eine Sequenz von Werten basierend auf einem Prädikat.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TSource, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Where``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Where(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein zu filterndes <see cref="T:System.Linq.IQueryable`1" /></param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Filtert eine Sequenz von Werten basierend auf einem Prädikat.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> mit Elementen aus der Eingabesequenz, die die von <paramref name="predicate" /> angegebene Bedingung erfüllen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten besteht darin, dass die Elemente aus `source` zurückgegeben werden, die die `predicate`von angegebene Bedingung erfüllen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Boolean%7D%7D%29> verwendet wird, um eine Sequenz zu filtern.  
  
 [!code-csharp[System.Linq.Queryable#110](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#110)]
 [!code-vb[System.Linq.Queryable#110](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#110)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Linq.IQueryable&lt;TSource&gt; source, System.Linq.Expressions.Expression&lt;Func&lt;TSource,int,bool&gt;&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Linq.IQueryable`1&lt;!!TSource&gt; source, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TSource, int32, bool&gt;&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Where``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Int32,System.Boolean}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As IQueryable(Of TSource), predicate As Expression(Of Func(Of TSource, Integer, Boolean))) As IQueryable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TSource&gt; ^ Where(System::Linq::IQueryable&lt;TSource&gt; ^ source, System::Linq::Expressions::Expression&lt;Func&lt;TSource, int, bool&gt; ^&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : System.Linq.IQueryable&lt;'Source&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'Source, int, bool&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Source&gt;" Usage="System.Linq.Queryable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IQueryable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TSource,System.Int32,System.Boolean&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein zu filterndes <see cref="T:System.Linq.IQueryable`1" /></param>
        <param name="predicate">Eine Funktion zum Überprüfen jedes Elements auf eine Bedingung. Der zweite Parameter der Funktion stellt den Index des Elements in der Quellsequenz dar.</param>
        <summary>Filtert eine Sequenz von Werten basierend auf einem Prädikat. In der Logik der Prädikatfunktion wird der Index der einzelnen Elemente verwendet.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" /> mit Elementen aus der Eingabesequenz, die die von <paramref name="predicate" /> angegebene Bedingung erfüllen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verfügt über mindestens einen Parameter des Typs <xref:System.Linq.Expressions.Expression%601> , dessen Typargument einer <xref:System.Func%602> der-Typen ist. Für diese Parameter können Sie einen Lambda-Ausdruck übergeben und in einen <xref:System.Linq.Expressions.Expression%601>kompiliert werden.  
  
 Die <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source` -Parameters dargestellt wird.  
  
 Das Abfrage Verhalten, das auftritt, wenn eine Ausdrucks Baumstruktur ausgeführt wird, die <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> den Aufruf von darstellt, hängt von der Implementierung `source` des Typs des Parameters ab. Das erwartete Verhalten besteht darin, dass die Elemente aus `source` zurückgegeben werden, die die `predicate`von angegebene Bedingung erfüllen. Der Index jedes Quell Elements wird als zweites Argument für `predicate`bereitgestellt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Queryable.Where%60%601%28System.Linq.IQueryable%7B%60%600%7D%2CSystem.Linq.Expressions.Expression%7BSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%7D%29> verwendet wird, um eine Sequenz auf der Grundlage eines Prädikats zu filtern, das den Index der einzelnen Elemente enthält.  
  
 [!code-csharp[System.Linq.Queryable#111](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#111)]
 [!code-vb[System.Linq.Queryable#111](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#111)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;ValueTuple&lt;TFirst,TSecond&gt;&gt; Zip&lt;TFirst,TSecond&gt; (this System.Linq.IQueryable&lt;TFirst&gt; source1, System.Collections.Generic.IEnumerable&lt;TSecond&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;valuetype System.ValueTuple`2&lt;!!TFirst, !!TSecond&gt;&gt; Zip&lt;TFirst, TSecond&gt;(class System.Linq.IQueryable`1&lt;!!TFirst&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Zip``2(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Zip(Of TFirst, TSecond) (source1 As IQueryable(Of TFirst), source2 As IEnumerable(Of TSecond)) As IQueryable(Of ValueTuple(Of TFirst, TSecond))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFirst, typename TSecond&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;ValueTuple&lt;TFirst, TSecond&gt;&gt; ^ Zip(System::Linq::IQueryable&lt;TFirst&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSecond&gt; ^ source2);" />
      <MemberSignature Language="F#" Value="static member Zip : System.Linq.IQueryable&lt;'First&gt; * seq&lt;'Second&gt; -&gt; System.Linq.IQueryable&lt;ValueTuple&lt;'First, 'Second&gt;&gt;" Usage="System.Linq.Queryable.Zip (source1, source2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;System.ValueTuple&lt;TFirst,TSecond&gt;&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="netcore-3.0">
            <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "First", "Second" })</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TFirst&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">Der Typ der Elemente der ersten Eingabesequenz.</typeparam>
        <typeparam name="TSecond">Der Typ der Elemente der zweiten Eingabesequenz.</typeparam>
        <param name="source1">Die erste Sequenz, die zusammengeführt werden soll</param>
        <param name="source2">Die zweite Sequenz, die zusammengeführt werden soll</param>
        <summary>Erzeugt eine Tupelsequenz mit Elementen aus den beiden angegebenen Sequenzen.</summary>
        <returns>Eine Tupelsequenz mit Elementen, die der ersten und zweiten Sequenz in dieser Reihenfolge entnommen wurden.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IQueryable&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Linq.IQueryable&lt;TFirst&gt; source1, System.Collections.Generic.IEnumerable&lt;TSecond&gt; source2, System.Linq.Expressions.Expression&lt;Func&lt;TFirst,TSecond,TResult&gt;&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IQueryable`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Linq.IQueryable`1&lt;!!TFirst&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; source2, class System.Linq.Expressions.Expression`1&lt;class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt;&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Queryable.Zip``3(System.Linq.IQueryable{``0},System.Collections.Generic.IEnumerable{``1},System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Zip(Of TFirst, TSecond, TResult) (source1 As IQueryable(Of TFirst), source2 As IEnumerable(Of TSecond), resultSelector As Expression(Of Func(Of TFirst, TSecond, TResult))) As IQueryable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFirst, typename TSecond, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IQueryable&lt;TResult&gt; ^ Zip(System::Linq::IQueryable&lt;TFirst&gt; ^ source1, System::Collections::Generic::IEnumerable&lt;TSecond&gt; ^ source2, System::Linq::Expressions::Expression&lt;Func&lt;TFirst, TSecond, TResult&gt; ^&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Zip : System.Linq.IQueryable&lt;'First&gt; * seq&lt;'Second&gt; * System.Linq.Expressions.Expression&lt;Func&lt;'First, 'Second, 'Result&gt;&gt; -&gt; System.Linq.IQueryable&lt;'Result&gt;" Usage="System.Linq.Queryable.Zip (source1, source2, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Queryable</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Linq.IQueryable&lt;TFirst&gt;" RefType="this" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="resultSelector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TFirst,TSecond,TResult&gt;&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">Der Typ der Elemente der ersten Eingabesequenz.</typeparam>
        <typeparam name="TSecond">Der Typ der Elemente der zweiten Eingabesequenz.</typeparam>
        <typeparam name="TResult">Der Typ der Elemente in der Ergebnissequenz.</typeparam>
        <param name="source1">Die erste Sequenz, die zusammengeführt werden soll</param>
        <param name="source2">Die zweite Sequenz, die zusammengeführt werden soll</param>
        <param name="resultSelector">Eine Funktion, die angibt, wie die Elemente der zwei Sequenzen zusammengeführt werden sollen</param>
        <summary>Führt zwei Sequenzen mit der angegebenen Prädikatfunktion zusammen.</summary>
        <returns>Ein <see cref="T:System.Linq.IQueryable`1" />, das die zusammengeführten Elemente der beiden Eingabesequenzen enthält</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Queryable.Zip%2A> -Methode generiert <xref:System.Linq.Expressions.MethodCallExpression> einen, der <xref:System.Linq.Queryable.Zip%2A> den Aufruf von sich selbst als konstruierte generische Methode darstellt. Anschließend <xref:System.Linq.Expressions.MethodCallExpression> übergibt sie an die <xref:System.Linq.IQueryProvider> <xref:System.Linq.IQueryProvider.CreateQuery%60%601%28System.Linq.Expressions.Expression%29> -Methode des, das durch die <xref:System.Linq.IQueryable.Provider%2A> -Eigenschaft des `source1` -Parameters dargestellt wird.  
  
 Die-Methode führt jedes Element der ersten Sequenz mit einem Element zusammen, das in der zweiten Sequenz denselben Index aufweist. Wenn die Sequenzen nicht die gleiche Anzahl von Elementen aufweisen, führt die Methode Sequenzen zusammen, bis Sie das Ende eines von Ihnen erreicht. Wenn eine Sequenz z. b. über drei Elemente und die andere eine Sequenz über vier Elemente verfügt, enthält die resultierende Sequenz nur drei Elemente.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Linq.Queryable.Zip%2A> -Methode verwendet wird, um zwei Sequenzen zusammenzuführen.  
  
 [!code-csharp[System.Linq.Queryable#200](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Queryable/CS/queryable.cs#200)]
 [!code-vb[System.Linq.Queryable#200](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Queryable/VB/queryable.vb#200)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source1" /> oder <paramref name="source2" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>