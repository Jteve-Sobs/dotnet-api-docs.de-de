<Type Name="Enumerable" FullName="System.Linq.Enumerable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f84f562f20c4cf15be58de804c7d822d7e6d9ad0" /><Meta Name="ms.sourcegitcommit" Value="367e1eae0725e6da7136cd073aaa856ded5d5c29" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/13/2019" /><Meta Name="ms.locfileid" Value="75026767" /></Metadata><TypeSignature Language="C#" Value="public static class Enumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Enumerable extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Enumerable" />
  <TypeSignature Language="VB.NET" Value="Public Module Enumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Enumerable abstract sealed" />
  <TypeSignature Language="F#" Value="type Enumerable = class" />
  <AssemblyInfo>
    <AssemblyName>System.Linq</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt eine Reihe von <see langword="static" />-Methoden (<see langword="Shared" />-Methoden in Visual Basic) zum Abfragen von Objekten bereit, die <see cref="T:System.Collections.Generic.IEnumerable`1" /> implementieren</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methoden in dieser Klasse stellen eine Implementierung der Standard Abfrage Operatoren zum Abfragen von Datenquellen bereit, die <xref:System.Collections.Generic.IEnumerable%601>implementieren. Die Standard Abfrage Operatoren sind allgemeine Methoden, die dem-[!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] Muster folgen und es Ihnen ermöglichen, traversierungs-, Filter-und Projektions Vorgänge für Daten in beliebigen auszudrücken. NET-basierte Programmiersprache.  
  
 Die Mehrzahl der Methoden in dieser Klasse werden als Erweiterungs Methoden definiert, mit denen <xref:System.Collections.Generic.IEnumerable%601>erweitert wird. Dies bedeutet, dass Sie für jedes Objekt, das <xref:System.Collections.Generic.IEnumerable%601>implementiert, wie eine Instanzmethode aufgerufen werden kann.  
  
 Methoden, die in einer Abfrage verwendet werden, die eine Sequenz von Werten zurückgibt, verbrauchen die Zieldaten erst, wenn das Abfrageobjekt aufgezählt wird. Dies wird als verzögerte Ausführung bezeichnet. Methoden, die in einer Abfrage verwendet werden, die einen Singleton-Wert zurückgibt, werden die Zieldaten sofort ausführen und verarbeiten.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/24cda21e-8af8-4632-b519-c404a839b9b2">Übersicht über Standardabfrageoperatoren</related>
    <related type="Article" href="~/docs/csharp/programming-guide/classes-and-structs/extension-methods.md">Erweiterungsmethoden (C#-Programmierhandbuch)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/extension-methods.md">Erweiterungsmethoden (Visual Basic)</related>
  </Docs>
  <Members>
    <Member MemberName="Aggregate&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Aggregate&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TSource,TSource&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Aggregate&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, !!TSource, !!TSource&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource) (source As IEnumerable(Of TSource), func As Func(Of TSource, TSource, TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Aggregate(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TSource, TSource&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : seq&lt;'Source&gt; * Func&lt;'Source, 'Source, 'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Aggregate (source, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Func&lt;TSource,TSource,TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das aggregiert werden soll</param>
        <param name="func">Eine Akkumulatorfunktion, die für jedes Element aufgerufen werden soll.</param>
        <summary>Wendet eine Akkumulatorfunktion auf eine Sequenz an</summary>
        <returns>Der letzte Akkumulatorwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29>-Methode vereinfacht das Ausführen einer Berechnung für eine Sequenz von Werten. Diese Methode funktioniert durch Aufrufen von `func` einmal für jedes Element in `source` mit Ausnahme des ersten. Jedes Mal, wenn `func` aufgerufen wird, übergibt <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29> sowohl das-Element aus der Sequenz als auch einen aggregierten Wert (als erstes Argument an `func`). Das erste Element von `source` wird als ursprünglicher Aggregatwert verwendet. Das Ergebnis `func` ersetzt den vorherigen aggregierten Wert. <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29> gibt das Endergebnis `func`zurück.  
  
 Diese Überladung der <xref:System.Linq.Enumerable.Aggregate%2A> Methode ist nicht für alle Fälle geeignet, da Sie das erste Element `source` als anfänglichen Aggregatwert verwendet. Sie sollten eine andere Überladung auswählen, wenn der Rückgabewert nur die Elemente `source` einschließen soll, die eine bestimmte Bedingung erfüllen. Diese Überladung ist beispielsweise nicht zuverlässig, wenn Sie die Summe der geraden Zahlen in `source`berechnen möchten. Das Ergebnis ist falsch, wenn das erste Element ungerade ist, anstatt es selbst zu verwenden.  
  
 Um allgemeine Aggregations Vorgänge zu vereinfachen, beinhalten die Standard Abfrage Operatoren auch eine allgemeine Count-Methode, <xref:System.Linq.Enumerable.Count%2A>und vier numerische Aggregations Methoden, nämlich <xref:System.Linq.Enumerable.Min%2A>, <xref:System.Linq.Enumerable.Max%2A>, <xref:System.Linq.Enumerable.Sum%2A>und <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Reihenfolge der Wörter in einer Zeichenfolge mithilfe von <xref:System.Linq.Enumerable.Aggregate%2A>umgekehrt wird.  
  
 [!code-csharp[System.Linq.Enumerable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#1)]
 [!code-vb[System.Linq.Enumerable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="func" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate&gt;">
      <MemberSignature Language="C#" Value="public static TAccumulate Aggregate&lt;TSource,TAccumulate&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TAccumulate Aggregate&lt;TSource, TAccumulate&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate) (source As IEnumerable(Of TSource), seed As TAccumulate, func As Func(Of TAccumulate, TSource, TAccumulate)) As TAccumulate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TAccumulate Aggregate(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TAccumulate seed, Func&lt;TAccumulate, TSource, TAccumulate&gt; ^ func);" />
      <MemberSignature Language="F#" Value="static member Aggregate : seq&lt;'Source&gt; * 'Accumulate * Func&lt;'Accumulate, 'Source, 'Accumulate&gt; -&gt; 'Accumulate" Usage="System.Linq.Enumerable.Aggregate (source, seed, func)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TAccumulate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TAccumulate">Der Typ des Akkumulatorwerts.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das aggregiert werden soll</param>
        <param name="seed">Der erste Akkumulatorwert.</param>
        <param name="func">Eine Akkumulatorfunktion, die für jedes Element aufgerufen werden soll.</param>
        <summary>Wendet eine Akkumulatorfunktion auf eine Sequenz an Der angegebene Startwert wird als erster Akkumulatorwert verwendet.</summary>
        <returns>Der letzte Akkumulatorwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29>-Methode vereinfacht das Ausführen einer Berechnung für eine Sequenz von Werten. Diese Methode funktioniert durch Aufrufen von `func` einmal für jedes Element in `source`. Jedes Mal, wenn `func` aufgerufen wird, übergibt <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29> sowohl das-Element aus der Sequenz als auch einen aggregierten Wert (als erstes Argument an `func`). Der Wert des `seed`-Parameters wird als ursprünglicher Aggregatwert verwendet. Das Ergebnis `func` ersetzt den vorherigen aggregierten Wert. <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29> gibt das Endergebnis `func`zurück.  
  
 Um allgemeine Aggregations Vorgänge zu vereinfachen, beinhalten die Standard Abfrage Operatoren auch eine allgemeine Count-Methode, <xref:System.Linq.Enumerable.Count%2A>und vier numerische Aggregations Methoden, nämlich <xref:System.Linq.Enumerable.Min%2A>, <xref:System.Linq.Enumerable.Max%2A>, <xref:System.Linq.Enumerable.Sum%2A>und <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Aggregate%2A> verwendet wird, um eine Akkumulatorfunktion anzuwenden und einen Ausgangswert zu verwenden.  
  
 [!code-csharp[System.Linq.Enumerable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#2)]
 [!code-vb[System.Linq.Enumerable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="func" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func, class System.Func`2&lt;!!TAccumulate, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Aggregate(Of TSource, TAccumulate, TResult) (source As IEnumerable(Of TSource), seed As TAccumulate, func As Func(Of TAccumulate, TSource, TAccumulate), resultSelector As Func(Of TAccumulate, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TAccumulate, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Aggregate(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TAccumulate seed, Func&lt;TAccumulate, TSource, TAccumulate&gt; ^ func, Func&lt;TAccumulate, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Aggregate : seq&lt;'Source&gt; * 'Accumulate * Func&lt;'Accumulate, 'Source, 'Accumulate&gt; * Func&lt;'Accumulate, 'Result&gt; -&gt; 'Result" Usage="System.Linq.Enumerable.Aggregate (source, seed, func, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TAccumulate">Der Typ des Akkumulatorwerts.</typeparam>
        <typeparam name="TResult">Der Typ des Ergebniswerts.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das aggregiert werden soll</param>
        <param name="seed">Der erste Akkumulatorwert.</param>
        <param name="func">Eine Akkumulatorfunktion, die für jedes Element aufgerufen werden soll.</param>
        <param name="resultSelector">Eine Funktion zum Transformieren des letzten Akkumulatorwerts in den Ergebniswert.</param>
        <summary>Wendet eine Akkumulatorfunktion auf eine Sequenz an Der angegebene Startwert wird als erster Akkumulatorwert verwendet, und der Ergebniswert wird mit der angegebenen Funktion ausgewählt.</summary>
        <returns>Der transformierte letzte Akkumulatorwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29>-Methode vereinfacht das Ausführen einer Berechnung für eine Sequenz von Werten. Diese Methode funktioniert durch Aufrufen von `func` einmal für jedes Element in `source`. Jedes Mal, wenn `func` aufgerufen wird, übergibt <xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29> sowohl das-Element aus der Sequenz als auch einen aggregierten Wert (als erstes Argument an `func`). Der Wert des `seed`-Parameters wird als ursprünglicher Aggregatwert verwendet. Das Ergebnis `func` ersetzt den vorherigen aggregierten Wert. Das Endergebnis von `func` wird an `resultSelector` übermittelt, um das Endergebnis <xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29>zu erhalten.  
  
 Um allgemeine Aggregations Vorgänge zu vereinfachen, beinhalten die Standard Abfrage Operatoren auch eine allgemeine Count-Methode, <xref:System.Linq.Enumerable.Count%2A>und vier numerische Aggregations Methoden, nämlich <xref:System.Linq.Enumerable.Min%2A>, <xref:System.Linq.Enumerable.Max%2A>, <xref:System.Linq.Enumerable.Sum%2A>und <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit <xref:System.Linq.Enumerable.Aggregate%2A> eine Akkumulatorfunktion und eine Ergebnis Auswahl anwenden.  
  
 [!code-csharp[System.Linq.Enumerable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#3)]
 [!code-vb[System.Linq.Enumerable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="func" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="All&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool All&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool All&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.All``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function All(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool All(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member All : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; bool" Usage="System.Linq.Enumerable.All (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das die Elemente enthält, auf die das Prädikat angewendet werden soll</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Bestimmt, ob alle Elemente einer Sequenz eine Bedingung erfüllen.</summary>
        <returns><see langword="true" />, wenn jedes Element der Quellsequenz im angegebenen Prädikat erfolgreich überprüft wird oder wenn die Sequenz leer ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode gibt nicht alle Elemente einer Auflistung zurück. Stattdessen bestimmt Sie, ob alle Elemente einer Auflistung eine Bedingung erfüllen.  
  
 Die Enumeration von `source` wird beendet, sobald das Ergebnis bestimmt werden kann.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into All()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.All%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.All%2A> verwendet wird, um zu bestimmen, ob alle Elemente in einer Sequenz eine Bedingung erfüllen. Variable `allStartWithB` ist true, wenn alle Haustier-Namen mit "B" beginnen oder wenn das `pets` Array leer ist.  
  
 [!code-csharp[System.Linq.Enumerable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#4)]
 [!code-vb[System.Linq.Enumerable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#4)]  
  
 Der boolesche Wert, der von der <xref:System.Linq.Enumerable.All%2A>-Methode zurückgegeben wird, wird in der Regel im Prädikat einer `where`-Klausel (`Where`-Klausel in Visual Basic) oder einem direkten Aufrufder <xref:System.Linq.Enumerable.Where%2A>-Methode verwendet. Im folgenden Beispiel wird die Verwendung der `All`-Methode veranschaulicht.  
  
 [!code-csharp[System.Linq.Enumerable#129](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#129)]
 [!code-vb[System.Linq.Enumerable#129](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#129)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Any&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob ein Element einer Sequenz vorhanden ist oder eine Bedingung erfüllt</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As IEnumerable(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Any : seq&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Enumerable.Any source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Das <see cref="T:System.Collections.Generic.IEnumerable`1" />, bei dem überprüft werden soll, ob es leer ist.</param>
        <summary>Bestimmt, ob eine Sequenz Elemente enthält.</summary>
        <returns><see langword="true" />, wenn die Quellsequenz Elemente enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode gibt kein Element einer Auflistung zurück. Stattdessen bestimmt er, ob die Auflistung Elemente enthält.  
  
 Die Enumeration von `source` wird beendet, sobald das Ergebnis bestimmt werden kann.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Any()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Any%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Any%2A> verwendet wird, um zu bestimmen, ob eine Sequenz Elemente enthält.  
  
 [!code-csharp[System.Linq.Enumerable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#5)]
 [!code-vb[System.Linq.Enumerable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#5)]  
  
 Der boolesche Wert, der von der <xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>-Methode zurückgegeben wird, wird in der Regel im Prädikat einer `where`-Klausel (`Where`-Klausel in Visual Basic) oder einem direkten Aufrufder <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>-Methode verwendet. Im folgenden Beispiel wird die Verwendung der `Any`-Methode veranschaulicht.  
  
 [!code-csharp[System.Linq.Enumerable#130](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#130)]
 [!code-vb[System.Linq.Enumerable#130](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#130)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Any(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Any(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Any : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; bool" Usage="System.Linq.Enumerable.Any (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, auf dessen Elemente das Prädikat angewendet werden soll.</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Bestimmt, ob ein Element einer Sequenz eine Bedingung erfüllt.</summary>
        <returns><see langword="true" />, wenn Elemente der Quellsequenz im angegebenen Prädikat erfolgreich überprüft werden, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode gibt kein Element einer Auflistung zurück. Stattdessen bestimmt Sie, ob Elemente einer Auflistung eine Bedingung erfüllen.  
  
 Die Enumeration von `source` wird beendet, sobald das Ergebnis bestimmt werden kann.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Any()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Any%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Any%2A> verwendet wird, um zu bestimmen, ob ein beliebiges Element in einer Sequenz eine Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Enumerable#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#6)]
 [!code-vb[System.Linq.Enumerable#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Append&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Append&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Append&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Append``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Append(Of TSource) (source As IEnumerable(Of TSource), element As TSource) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Append(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TSource element);" />
      <MemberSignature Language="F#" Value="static member Append : seq&lt;'Source&gt; * 'Source -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Append (source, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netstandard-2.1" />
        <Parameter Name="element" Type="TSource" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten.</param>
        <param name="element">Der an <paramref name="source" /> anzufügende Wert.</param>
        <summary>Fügt einen Wert an das Ende der Sequenz an.</summary>
        <returns>Eine neue Sequenz, die mit <paramref name="element" /> endet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Diese Methode ändert nicht die Elemente der Auflistung. Stattdessen wird eine Kopie der Auflistung mit dem neuen Element erstellt.
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Append%2A> verwendet wird, um einen Wert an das Ende der Sequenz anzufügen.  
  
 [!code-csharp[System.Linq.Enumerable#201](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#201)]
 [!code-vb[System.Linq.Enumerable#201](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#201)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsEnumerable&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; AsEnumerable&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; AsEnumerable&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.AsEnumerable``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsEnumerable(Of TSource) (source As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ AsEnumerable(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsEnumerable : seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.AsEnumerable source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, die als <see cref="T:System.Collections.Generic.IEnumerable`1" /> typisiert werden soll.</param>
        <summary>Gibt die Eingabe als <see cref="T:System.Collections.Generic.IEnumerable`1" /> typisiert zurück</summary>
        <returns>Die als <see cref="T:System.Collections.Generic.IEnumerable`1" /> typisierte Eingabesequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>-Methode hat keine Auswirkung, außer um den Kompilier Zeittyp `source` von einem Typ zu ändern, der <xref:System.Collections.Generic.IEnumerable%601> zum <xref:System.Collections.Generic.IEnumerable%601> selbst implementiert.  
  
 <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> kann verwendet werden, um zwischen Abfrage Implementierungen auszuwählen, wenn eine Sequenz <xref:System.Collections.Generic.IEnumerable%601> implementiert, aber auch einen anderen Satz von öffentlichen Abfrage Methoden zur Verfügung steht. Wenn beispielsweise eine generische Klasse `Table`, die <xref:System.Collections.Generic.IEnumerable%601> implementiert und über eigene Methoden wie `Where`, `Select`und `SelectMany`verfügt, würde ein Aufruf von `Where` die öffentliche `Where` Methode `Table`aufrufen. Ein `Table` Typ, der eine Datenbanktabelle darstellt, könnte über eine `Where` Methode verfügen, die das Prädikat Argument als Ausdrucks Baumstruktur annimmt und die Struktur für die Remote Ausführung in SQL konvertiert. Wenn die Remote Ausführung nicht gewünscht ist, z. b. weil das-Prädikat eine lokale Methode aufruft, kann die <xref:System.Linq.Enumerable.AsEnumerable%2A>-Methode verwendet werden, um die benutzerdefinierten Methoden auszublenden und stattdessen die Standard Abfrage Operatoren zur Verfügung zu stellen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> verwendet wird, um die benutzerdefinierte `Where` Methode eines Typs auszublenden, wenn die Implementierung des Standard Abfrage Operators gewünscht wird.  
  
 [!code-csharp[System.Linq.Enumerable#108](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#108)]
 [!code-vb[System.Linq.Enumerable#108](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#108)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Average">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet den Durchschnitt einer Sequenz von numerischen Werten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static decimal Average (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Collections::Generic::IEnumerable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Decimal" />-Werten, deren Durchschnitt berechnet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Decimal" />-Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Average()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> verwendet wird, um den Durchschnitt einer Sequenz von Werten zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;double&gt; -&gt; double" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Double" />-Werten, deren Durchschnitt berechnet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Double" />-Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Summe der Elemente zu groß ist, um als <xref:System.Double>darzustellen, gibt diese Methode positive oder negative unendlich zurück.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Average()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> verwendet wird, um einen Durchschnitt zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Integer)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;int&gt; -&gt; double" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int32" />-Werten, deren Durchschnitt berechnet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int32" />-Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Average()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> verwendet wird, um einen Durchschnitt zu berechnen.  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Long)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;int64&gt; -&gt; double" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int64" />-Werten, deren Durchschnitt berechnet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int64" />-Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Average()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> verwendet wird, um einen Durchschnitt zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Collections::Generic::IEnumerable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Decimal" />-Werten, die NULL sein können, zum Berechnen des Durchschnitts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Decimal" />-Werten, die NULL sein können.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur Werte enthält, die <see langword="null" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Average()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> verwendet wird, um einen Durchschnitt zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe der Elemente in der Sequenz ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Double" />-Werten, die NULL sein können, zum Berechnen des Durchschnitts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Double" />-Werten, die NULL sein können.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur Werte enthält, die <see langword="null" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Summe der Elemente zu groß ist, um als <xref:System.Double>darzustellen, gibt diese Methode positive oder negative unendlich zurück.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Average()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> verwendet wird, um einen Durchschnitt zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Nullable(Of Integer))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int32" />-Werten, die NULL sein können, zum Berechnen des Durchschnitts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int32" />-Werten, die NULL sein können.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur Werte enthält, die <see langword="null" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Average()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> verwendet wird, um einen Durchschnitt zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe der Elemente in der Sequenz ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Nullable(Of Long))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int64" />-Werten, die NULL sein können, zum Berechnen des Durchschnitts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int64" />-Werten, die NULL sein können.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur Werte enthält, die <see langword="null" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Average()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> verwendet wird, um einen Durchschnitt zu berechnen.  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe der Elemente in der Sequenz ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Collections::Generic::IEnumerable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Single" />-Werten, die NULL sein können, zum Berechnen des Durchschnitts.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Single" />-Werten, die NULL sein können.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur Werte enthält, die <see langword="null" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Average()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> verwendet wird, um einen Durchschnitt zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static float Average (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average (source As IEnumerable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Collections::Generic::IEnumerable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;single&gt; -&gt; single" Usage="System.Linq.Enumerable.Average source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Single" />-Werten, deren Durchschnitt berechnet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Single" />-Werten.</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Average()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> verwendet wird, um einen Durchschnitt zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, mit denen ein Durchschnittswert berechnet wird.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Decimal" />-Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Average()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> verwendet wird, um einen Durchschnitt zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <exception cref="T:System.OverflowException">Die Summe der Elemente in der Sequenz ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Durchschnitt berechnet werden soll</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Double" />-Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Average()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> verwendet wird, um einen Durchschnitt zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; double" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Durchschnitt berechnet werden soll</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int32" />-Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Average()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um einen Durchschnitt zu berechnen.  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <exception cref="T:System.OverflowException">Die Summe der Elemente in der Sequenz ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Long)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; double" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Quelle.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Durchschnitt berechnet werden soll</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int64" />-Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Average()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> verwendet wird, um einen Durchschnitt zu berechnen.  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <exception cref="T:System.OverflowException">Die Summe der Elemente in der Sequenz ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Durchschnitt berechnet werden soll</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Decimal" />-Werten, die NULL zulassen, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur Werte enthält, die <see langword="null" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Average()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> verwendet wird, um einen Durchschnitt zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe der Elemente in der Sequenz ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Durchschnitt berechnet werden soll</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Double" />-Werten, die NULL zulassen, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur Werte enthält, die <see langword="null" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Average()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> verwendet wird, um einen Durchschnitt zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Durchschnitt berechnet werden soll</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int32" />-Werten, die NULL zulassen, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur Werte enthält, die <see langword="null" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Average()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um einen Durchschnitt zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe der Elemente in der Sequenz ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Durchschnitt berechnet werden soll</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Int64" />-Werten, die NULL zulassen, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur Werte enthält, die <see langword="null" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Average()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> verwendet wird, um einen Durchschnitt zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Durchschnitt berechnet werden soll</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Single" />-Werten, die NULL zulassen, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden</summary>
        <returns>Der Durchschnitt der Sequenz von Werten, oder <see langword="null" />, wenn die Quellsequenz leer ist oder nur Werte enthält, die <see langword="null" /> sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Average()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um einen Durchschnitt zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Average(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Average(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Average : seq&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.Enumerable.Average (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Durchschnitt berechnet werden soll</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet den Durchschnitt einer Sequenz von <see cref="T:System.Single" />-Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden</summary>
        <returns>Der Durchschnitt der Sequenz von Werten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Average()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Average%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um einen Durchschnitt zu berechnen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Cast&lt;TResult&gt; (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Cast&lt;TResult&gt;(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Cast(Of TResult) (source As IEnumerable) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Cast(System::Collections::IEnumerable ^ source);" />
      <MemberSignature Language="F#" Value="static member Cast : System.Collections.IEnumerable -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Cast source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ, an den die Elemente von <paramref name="source" /> übergeben werden sollen.</typeparam>
        <param name="source">Das <see cref="T:System.Collections.IEnumerable" />, das die in Typ <paramref name="TResult" /> umzuwandelnden Elemente enthält.</param>
        <summary>Wandelt die Elemente eines <see cref="T:System.Collections.IEnumerable" /> in den angegebenen Typ um</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das jedes Element der Quellsequenz enthält, das in den angegebenen Typ umgewandelt wird</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Die <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>-Methode ermöglicht, dass die Standard Abfrage Operatoren für nicht generische Auflistungen aufgerufen werden, indem die erforderlichen Typinformationen bereitgestellt werden. <xref:System.Collections.ArrayList> implementiert beispielsweise <xref:System.Collections.Generic.IEnumerable%601>nicht, aber durch Aufrufen von <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29> für das <xref:System.Collections.ArrayList> Objekt können die Standard Abfrage Operatoren verwendet werden, um die Sequenz abzufragen.  
  
 Wenn ein Element nicht in den Typ `TResult`konvertiert werden kann, löst diese Methode eine <xref:System.InvalidCastException>aus.

 Die Quell Sequenz für diese Methode ist <xref:System.Collections.IEnumerable>. Dies bedeutet, dass die Elemente den statischen Typ der Kompilierzeit `object`haben. Die einzigen Typkonvertierungen, die von dieser Methode durchgeführt werden, sind Verweis Konvertierungen und Unboxing-Konvertierungen. Der Lauf Zeittyp der Elemente in der Auflistung muss mit dem Zieltyp oder im Fall von Werttypen identisch sein. der Lauf Zeittyp der Elemente muss das Ergebnis einer Boxing-Konvertierung des Zieltyps sein. Andere Konvertierungs Typen, z. b. die zwischen verschiedenen numerischen Typen, sind nicht zulässig. 
 
 Um nur die Elemente zu erhalten, die in den Typ `TResult`konvertiert werden können, verwenden Sie die <xref:System.Linq.Enumerable.OfType%2A>-Methode anstelle von <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>.  
  
 In einem Abfrage Ausdruck übersetzt eine explizit typisierte Iterations Variable in einen Aufruf von <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>. Dieses Beispiel zeigt die Syntax für eine explizit typisierte Bereichs Variable.  
  
```csharp  
from int i in objects  
```  
  
```vb  
From i As Integer In objects  
```  

Verwenden Sie die `select`-Klausel einer Abfrage, um andere Konvertierungs Typen auszuführen, wie z. b. die impliziten numerischen Konvertierungen. Im folgenden Beispiel werden die `Cast`-Methode und eine `select`-Anweisung verwendet, um eine Sequenz von geachtelten Ganzzahlen in eine Sequenz von Double-Werten zu konvertieren.

```csharp
IEnumerable sequence = Enumerable.Range(0, 10);
var doubles = from int item in sequence
                select (double)item;
``` 

```vb
Dim sequence As IEnumerable = Enumerable.Range(0, 10)
Dim doubles = From item As Integer In sequence
                Select CType(item, Double)
```

## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29> verwendet wird, um die Verwendung der Standard Abfrage Operatoren für eine <xref:System.Collections.ArrayList>zu aktivieren.  
  
 [!code-csharp[System.Linq.Enumerable#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#19)]
 [!code-vb[System.Linq.Enumerable#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Ein Element in der Sequenz kann nicht in den Typ <paramref name="TResult" /> umgewandelt werden.</exception>
        <related type="Article" href="~/docs/csharp/language-reference/keywords/from-clause.md">from-Klausel (C#-Referenz)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/from-clause.md">From-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Concat(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Concat(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Concat (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Die erste zu verkettende Sequenz.</param>
        <param name="second">Die Sequenz, die mit der ersten Sequenz verkettet werden soll.</param>
        <summary>Verkettet zwei Sequenzen</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das die verketteten Elemente der beiden Eingabesequenzen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Die <xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>-Methode unterscheidet sich von der <xref:System.Linq.Enumerable.Union%2A>-Methode, da die <xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>-Methode alle ursprünglichen Elemente in den Eingabe Sequenzen zurückgibt. Die <xref:System.Linq.Enumerable.Union%2A>-Methode gibt nur eindeutige Elemente zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> verwendet wird, um zwei Sequenzen zu verketten.  
  
 [!code-csharp[System.Linq.Enumerable#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#20)]
 [!code-vb[System.Linq.Enumerable#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#20)]  
  
 Eine alternative Möglichkeit zum Verketten von zwei Sequenzen besteht darin, eine Auflistung zu erstellen, z. b. ein Array mit Sequenzen, und dann die <xref:System.Linq.Enumerable.SelectMany%2A> Methode anzuwenden und dabei die Identitäts Auswahlfunktion zu übergeben. Im folgenden Beispiel wird die Verwendung von <xref:System.Linq.Enumerable.SelectMany%2A>veranschaulicht.  
  
 [!code-csharp[System.Linq.Enumerable#112](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#112)]
 [!code-vb[System.Linq.Enumerable#112](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#112)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> oder <paramref name="second" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Contains&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob eine Sequenz ein angegebenes Element enthält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As IEnumerable(Of TSource), value As TSource) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TSource value);" />
      <MemberSignature Language="F#" Value="static member Contains : seq&lt;'Source&gt; * 'Source -&gt; bool" Usage="System.Linq.Enumerable.Contains (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, in der ein Wert gesucht werden soll.</param>
        <param name="value">Der Wert, der in der Sequenz gesucht werden soll.</param>
        <summary>Bestimmt mithilfe des Standardgleichheitsvergleichs, ob eine Sequenz ein angegebenes Element enthält</summary>
        <returns><see langword="true" />, wenn die Quellsequenz ein Element mit dem angegebenen Wert enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Typ von `source` <xref:System.Collections.Generic.ICollection%601>implementiert, wird die `Contains`-Methode in dieser Implementierung aufgerufen, um das Ergebnis zu erhalten. Andernfalls bestimmt diese Methode, ob `source` das angegebene Element enthält.  
  
 Die Enumeration wird beendet, sobald ein entsprechendes Element gefunden wurde.  
  
 Elemente werden mithilfe des Standard Gleichheits Vergleichs (<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>) mit dem angegebenen Wert verglichen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Contains%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> verwendet wird, um zu bestimmen, ob ein Array ein bestimmtes Element enthält.  
  
 [!code-csharp[System.Linq.Enumerable#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#21)]
 [!code-vb[System.Linq.Enumerable#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource value, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource value, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Contains(Of TSource) (source As IEnumerable(Of TSource), value As TSource, comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool Contains(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TSource value, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Contains : seq&lt;'Source&gt; * 'Source * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Enumerable.Contains (source, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, in der ein Wert gesucht werden soll.</param>
        <param name="value">Der Wert, der in der Sequenz gesucht werden soll.</param>
        <param name="comparer">Ein Gleichheitsvergleich zum Vergleichen von Werten.</param>
        <summary>Bestimmt mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, ob eine Sequenz ein angegebenes Element enthält</summary>
        <returns><see langword="true" />, wenn die Quellsequenz ein Element mit dem angegebenen Wert enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Enumeration wird beendet, sobald ein entsprechendes Element gefunden wurde.  
  
 Wenn `comparer` `null`ist, wird der Standard Gleichheits Vergleich (<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>) zum Vergleichen von Elementen mit dem angegebenen Wert verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein Gleichheits Vergleich implementiert wird, der in der <xref:System.Linq.Enumerable.Contains%2A>-Methode verwendet werden kann.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Nachdem Sie diesen Vergleich implementiert haben, können Sie eine Sequenz von `Product` Objekten in der <xref:System.Linq.Enumerable.Contains%2A>-Methode verwenden, wie im folgenden Beispiel gezeigt:  
  
 [!code-csharp[CSLINQCustomComparer#6](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#6)]
 [!code-vb[CSLINQCustomComparer#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Count&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die Anzahl der Elemente in einer Sequenz zurück</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As IEnumerable(Of TSource)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Count : seq&lt;'Source&gt; -&gt; int" Usage="System.Linq.Enumerable.Count source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, die zu zählende Elemente enthält.</param>
        <summary>Gibt die Anzahl der Elemente in einer Sequenz zurück</summary>
        <returns>Die Anzahl der Elemente in der Eingabesequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Typ von `source` <xref:System.Collections.Generic.ICollection%601>implementiert, wird diese Implementierung verwendet, um die Anzahl von Elementen abzurufen. Andernfalls bestimmt diese Methode die Anzahl.  
  
 Verwenden Sie die <xref:System.Linq.Enumerable.LongCount%2A>-Methode, wenn Sie erwarten, dass das Ergebnis größer als <xref:System.Int32.MaxValue>sein soll.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Count()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Count%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> zum zählen der Elemente in einem Array verwendet wird.  
  
 [!code-csharp[System.Linq.Enumerable#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#22)]
 [!code-vb[System.Linq.Enumerable#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Anzahl der Elemente in <paramref name="source" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Count(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Count(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Count : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; int" Usage="System.Linq.Enumerable.Count (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, die Elemente enthält, die überprüft und gezählt werden sollen</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt eine Zahl zurück, die die Anzahl der Elemente in der angegebenen Sequenz angibt, die eine Bedingung erfüllen</summary>
        <returns>Eine Zahl, die die Anzahl der Elemente in der Sequenz darstellt, die die Bedingung in der Prädikatfunktion erfüllen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Typ von `source` <xref:System.Collections.Generic.ICollection%601>implementiert, wird diese Implementierung verwendet, um die Anzahl von Elementen abzurufen. Andernfalls bestimmt diese Methode die Anzahl.  
  
 Sie sollten die <xref:System.Linq.Enumerable.LongCount%2A>-Methode verwenden, wenn Sie erwarten, dass das Ergebnis größer als <xref:System.Int32.MaxValue>sein soll.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Count()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Count%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> verwendet wird, um die Elemente in einem Array zu zählen, die eine Bedingung erfüllen.  
  
 [!code-csharp[System.Linq.Enumerable#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#23)]
 [!code-vb[System.Linq.Enumerable#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Anzahl der Elemente in <paramref name="source" /> ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die Elemente eines <see cref="T:System.Collections.Generic.IEnumerable`1" /> oder eine Standardwert-Singletonauflistung zurück, wenn die Sequenz leer ist</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ DefaultIfEmpty(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.DefaultIfEmpty source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, für die ein Standardwert zurückgegeben werden soll, wenn sie leer ist.</param>
        <summary>Gibt die Elemente der angegebenen Sequenz oder den Standardwert des Typparameters in einer Singletonauflistung zurück, wenn die Sequenz leer ist</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />-Objekt, das den Standardwert für den <paramref name="TSource" />-Typ enthält, wenn <paramref name="source" /> leer ist, andernfalls <paramref name="source" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Der Standardwert für Verweis-und Werte zulässt-Typen ist `null`.  
  
 Diese Methode kann verwendet werden, um einen linken äußeren Join zu entwickeln, wenn diese mit der <xref:System.Linq.Enumerable.GroupJoin%2A>)-Methode kombiniert wird.  
  
   
  
## Examples  
 Die folgenden Codebeispiele veranschaulichen, wie Sie mit <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> einen Standardwert bereitstellen, wenn die Quell Sequenz leer ist.  
  
 In diesem Beispiel wird eine nicht leere Sequenz verwendet.  
  
 [!code-csharp[System.Linq.Enumerable#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#24)]
 [!code-vb[System.Linq.Enumerable#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#24)]  
  
 In diesem Beispiel wird eine leere Sequenz verwendet.  
  
 [!code-csharp[System.Linq.Enumerable#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#25)]
 [!code-vb[System.Linq.Enumerable#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">Verknüpfen</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function DefaultIfEmpty(Of TSource) (source As IEnumerable(Of TSource), defaultValue As TSource) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ DefaultIfEmpty(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TSource defaultValue);" />
      <MemberSignature Language="F#" Value="static member DefaultIfEmpty : seq&lt;'Source&gt; * 'Source -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.DefaultIfEmpty (source, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="defaultValue" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, für die der angegebene Wert zurückgegeben werden soll, wenn sie leer ist.</param>
        <param name="defaultValue">Der Wert, der zurückgegeben werden soll, wenn die Sequenz leer ist.</param>
        <summary>Gibt die Elemente der angegebenen Sequenz oder den angegebenen Wert in einer Singletonauflistung zurück, wenn die Sequenz leer ist.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das <paramref name="defaultValue" /> enthält, wenn <paramref name="source" /> leer ist, andernfalls <paramref name="source" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Diese Methode kann verwendet werden, um einen linken äußeren Join zu entwickeln, wenn diese mit der <xref:System.Linq.Enumerable.GroupJoin%2A>)-Methode kombiniert wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>-Methode verwendet und ein Standardwert angegeben wird. Die erste Sequenz ist nicht leer, und die zweite Sequenz ist leer.  
  
 [!code-csharp[System.Linq.Enumerable#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#26)]
 [!code-vb[System.Linq.Enumerable#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#26)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">Verknüpfen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Distinct&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt unterschiedliche Elemente aus einer Sequenz zurück</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Ergebnis Sequenz ist nicht geordnet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Distinct(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Distinct : seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Distinct source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der doppelte Elemente entfernt werden sollen.</param>
        <summary>Gibt mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Werten unterschiedliche Elemente aus einer Sequenz zurück</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das unterschiedliche Elemente aus der Quellsequenz enthält</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Die <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>-Methode gibt eine ungeordnete Sequenz zurück, die keine doppelten Werte enthält. Er verwendet den Standard Gleichheits Vergleich, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, um Werte zu vergleichen.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Distinct`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Distinct%2A>übersetzt.  
  
 Der Standard Gleichheits Vergleich, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, wird zum Vergleichen von Werten der Typen verwendet, die die <xref:System.IEquatable%601> generische Schnittstelle implementieren. Um einen benutzerdefinierten Datentyp zu vergleichen, müssen Sie diese Schnittstelle implementieren und ihre eigenen <xref:System.Object.GetHashCode%2A> und <xref:System.Object.Equals%2A> Methoden für den-Typ bereitstellen.  
  
 Ein Beispiel, in dem <xref:System.Collections.Generic.IEqualityComparer%601> zum Definieren eines benutzerdefinierten Vergleichs verwendet wird, finden Sie unter <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> verwendet wird, um unterschiedliche Elemente aus einer Sequenz von ganzen Zahlen zurückzugeben.  
  
 [!code-csharp[System.Linq.Enumerable#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#27)]
 [!code-vb[System.Linq.Enumerable#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#27)]  
  
 Wenn Sie unterschiedliche Elemente aus Sequenzen von Objekten eines benutzerdefinierten Datentyps zurückgeben möchten, müssen Sie den <xref:System.IEquatable%601> generischen Schnittstelle in der Klasse implementieren. Im folgenden Codebeispiel wird gezeigt, wie diese Schnittstelle in einem benutzerdefinierten Datentyp implementiert wird und <xref:System.Object.GetHashCode%2A>-und <xref:System.Object.Equals%2A> Methoden bereitgestellt werden.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#1)]
 [!code-vb[CSLINQEncapsulatedComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#1)]  
  
 Nachdem Sie diese Schnittstelle implementiert haben, können Sie eine Sequenz von `Product` Objekten in der <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>-Methode verwenden, wie im folgenden Beispiel gezeigt:  
  
 [!code-csharp[CSLINQEncapsulatedComparer#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#5)]
 [!code-vb[CSLINQEncapsulatedComparer#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/distinct-clause.md">Distinct-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Distinct(Of TSource) (source As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Distinct(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Distinct : seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Distinct (source, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der doppelte Elemente entfernt werden sollen.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Gibt mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten unterschiedliche Elemente aus einer Sequenz zurück</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das unterschiedliche Elemente aus der Quellsequenz enthält</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Die <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29>-Methode gibt eine ungeordnete Sequenz zurück, die keine doppelten Werte enthält. Wenn `comparer` `null`ist, wird der Standard Gleichheits Vergleich (<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>) verwendet, um Werte zu vergleichen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein Gleichheits Vergleich implementiert wird, der in der <xref:System.Linq.Enumerable.Distinct%2A>-Methode verwendet werden kann.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Nachdem Sie diesen Vergleich implementiert haben, können Sie eine Sequenz von `Product` Objekten in der <xref:System.Linq.Enumerable.Distinct%2A>-Methode verwenden, wie im folgenden Beispiel gezeigt:  
  
 [!code-csharp[CSLINQCustomComparer#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#5)]
 [!code-vb[CSLINQCustomComparer#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAt&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAt&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAt&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAt(Of TSource) (source As IEnumerable(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAt(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAt : seq&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.Enumerable.ElementAt (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem ein Element zurückgegeben werden soll</param>
        <param name="index">Der auf 0 (null) basierende Index des abzurufenden Elements.</param>
        <summary>Gibt das Element an einem angegebenen Index in einer Sequenz zurück</summary>
        <returns>Das Element an der angegebenen Position in der Quellsequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Typ von `source` <xref:System.Collections.Generic.IList%601>implementiert, wird diese Implementierung verwendet, um das Element am angegebenen Index abzurufen. Andernfalls ruft diese Methode das angegebene Element ab.  
  
 Diese Methode löst eine Ausnahme aus, wenn `index` außerhalb des gültigen Bereichs liegt. Um stattdessen einen Standardwert zurückzugeben, wenn der angegebene Index außerhalb des gültigen Bereichs liegt, verwenden Sie die <xref:System.Linq.Enumerable.ElementAtOrDefault%2A>-Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.ElementAt%2A> verwendet wird, um ein Element an einer bestimmten Position zurückzugeben.  
  
 [!code-csharp[System.Linq.Enumerable#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#28)]
 [!code-vb[System.Linq.Enumerable#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0 bzw. größer oder gleich der Anzahl der Elemente in <paramref name="source" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAtOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAtOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAtOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ElementAtOrDefault(Of TSource) (source As IEnumerable(Of TSource), index As Integer) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource ElementAtOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int index);" />
      <MemberSignature Language="F#" Value="static member ElementAtOrDefault : seq&lt;'Source&gt; * int -&gt; 'Source" Usage="System.Linq.Enumerable.ElementAtOrDefault (source, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem ein Element zurückgegeben werden soll</param>
        <param name="index">Der auf 0 (null) basierende Index des abzurufenden Elements.</param>
        <summary>Gibt das Element an einem angegebenen Index in einer Sequenz oder einen Standardwert zurück, wenn der Index außerhalb des gültigen Bereichs liegt.</summary>
        <returns><see langword="default" />(<paramref name="TSource" />), wenn der Index außerhalb der Begrenzungen der Quellsequenz liegt, andernfalls das Element an der angegebenen Position in der Quellsequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Typ von `source` <xref:System.Collections.Generic.IList%601>implementiert, wird diese Implementierung verwendet, um das Element am angegebenen Index abzurufen. Andernfalls ruft diese Methode das angegebene Element ab.  
  
 Der Standardwert für Verweis-und Werte zulässt-Typen ist `null`.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die Verwendung von <xref:System.Linq.Enumerable.ElementAtOrDefault%2A>. In diesem Beispiel wird ein Index verwendet, der sich außerhalb der Grenzen des Arrays befindet.  
  
 [!code-csharp[System.Linq.Enumerable#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#29)]
 [!code-vb[System.Linq.Enumerable#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Empty&lt;TResult&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Empty&lt;TResult&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Function Empty(Of TResult) () As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TResult">Der Typ, der dem Typparameter des zurückgegebenen generischen <see cref="T:System.Collections.Generic.IEnumerable`1" /> zugewiesen werden soll.</typeparam>
        <summary>Gibt ein leeres <see cref="T:System.Collections.Generic.IEnumerable`1" /> zurück, das über das angegebene Typargument verfügt</summary>
        <returns>Ein leeres <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen Typargument <paramref name="TResult" /> ist</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Empty%60%601>-Methode speichert eine leere Sequenz vom Typ "`TResult`" zwischen. Wenn das Objekt, das zurückgegeben wird, aufgezählt wird, werden keine Elemente zurückgegeben.  
  
 In einigen Fällen ist diese Methode nützlich, um eine leere Sequenz an eine benutzerdefinierte Methode zu übergeben, die einen <xref:System.Collections.Generic.IEnumerable%601>annimmt. Sie kann auch verwendet werden, um ein neutrales Element für Methoden zu generieren, wie z. b. <xref:System.Linq.Enumerable.Union%2A>. Ein Beispiel für diese Verwendung von <xref:System.Linq.Enumerable.Empty%60%601>finden Sie im Beispiel Abschnitt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Empty%60%601> verwendet wird, um eine leere <xref:System.Collections.Generic.IEnumerable%601>zu generieren.  
  
 [!code-csharp[System.Linq.Enumerable#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#30)]
 [!code-vb[System.Linq.Enumerable#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#30)]  
  
 Im folgenden Codebeispiel wird eine mögliche Anwendung der <xref:System.Linq.Enumerable.Empty%60%601>-Methode veranschaulicht. Die <xref:System.Linq.Enumerable.Aggregate%2A>-Methode wird auf eine Auflistung von Zeichen folgen Arrays angewendet. Die Elemente der einzelnen Arrays in der Auflistung werden dem resultierenden <xref:System.Collections.Generic.IEnumerable%601> nur dann hinzugefügt, wenn dieses Array vier oder mehr Elemente enthält. <xref:System.Linq.Enumerable.Empty%2A> wird verwendet, um den Ausgangswert für <xref:System.Linq.Enumerable.Aggregate%2A> zu generieren, denn wenn kein Array in der Auflistung über vier oder mehr Elemente verfügt, wird nur die leere Sequenz zurückgegeben.  
  
 [!code-csharp[System.Linq.Enumerable#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#31)]
 [!code-vb[System.Linq.Enumerable#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Except&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erzeugt die Differenzmenge von zwei Sequenzen</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Die festgelegte Differenz von zwei Sätzen wird als die Member der ersten Menge definiert, die nicht in der zweiten Menge angezeigt werden.  
  
Diese Methode gibt die Elemente in `first` zurück, die nicht in `second`angezeigt werden. Diese Elemente werden nicht in `second` zurückgegeben, die nicht in `first`angezeigt werden.
Nur eindeutige Elemente werden zurückgegeben.

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/dotnet/api/system.linq.enumerable.intersect">Enumerable. Intersect-Methode</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Except(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Except : seq&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Except (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Es wird ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> zurückgegeben, dessen Elemente nicht auch in <paramref name="second" /> enthalten sind.</param>
        <param name="second">Wenn ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> Elemente enthält, die auch in der ersten Sequenz vorhanden sind, werden diese Elemente aus der zurückgegebenen Sequenz entfernt.</param>
        <summary>Erzeugt die Differenzmenge zweier Sequenzen mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Werten</summary>
        <returns>Eine Sequenz, die die Differenzmenge der Elemente von zwei Sequenzen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
    
 Der Standard Gleichheits Vergleich, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, wird verwendet, um Werte der Typen zu vergleichen. Um einen benutzerdefinierten Datentyp zu vergleichen, müssen Sie die <xref:System.Object.Equals%2A> und die <xref:System.Object.GetHashCode%2A> Methoden überschreiben und optional die <xref:System.IEquatable%601> generische Schnittstelle in den benutzerdefinierten Typ implementieren. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>-Eigenschaft.
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die `Except<TSource>(IEnumerable<TSource>, IEnumerable<TSource>)`-Methode verwendet wird, um zwei Sequenzen von Zahlen zu vergleichen und um Elemente zurückzugeben, die nur in der ersten Sequenz angezeigt werden.  
  
 [!code-csharp-interactive[System.Linq.Enumerable#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#34)]
 [!code-vb[System.Linq.Enumerable#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#34)]  
  
  Wenn Sie Sequenzen von Objekten eines benutzerdefinierten Datentyps vergleichen möchten, müssen Sie den <xref:System.IEquatable%601> generischen Schnittstelle in einer Hilfsklasse implementieren. Im folgenden Codebeispiel wird veranschaulicht, wie diese Schnittstelle in einem benutzerdefinierten Datentyp implementiert wird und <xref:System.Object.GetHashCode%2A>-und <xref:System.Object.Equals%2A> Methoden überschrieben werden.
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]
 [!code-vb[CSLINQEncapsulatedComparer#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#9)]  
  
 Nachdem Sie diese Schnittstelle implementiert haben, können Sie Sequenzen von `ProductA` Objekten in der `Except<TSource>(IEnumerable<TSource>, IEnumerable<TSource>)`-Methode verwenden, wie im folgenden Beispiel gezeigt:
  
 [!code-csharp[CSLINQEncapsulatedComparer#7](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#7)]
 [!code-vb[CSLINQEncapsulatedComparer#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#7)]  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> oder <paramref name="second" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Except(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Except(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Except : seq&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Except (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Es wird ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> zurückgegeben, dessen Elemente nicht auch in <paramref name="second" /> enthalten sind.</param>
        <param name="second">Wenn ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> Elemente enthält, die auch in der ersten Sequenz vorhanden sind, werden diese Elemente aus der zurückgegebenen Sequenz entfernt.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Erzeugt mithilfe des angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> die Differenzmenge zweier Sequenzen zum Vergleichen von Werten</summary>
        <returns>Eine Sequenz, die die Differenzmenge der Elemente von zwei Sequenzen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` `null`ist, wird der Standard Gleichheits Vergleich (<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>) verwendet, um Werte zu vergleichen.
  
## Examples  
 Wenn Sie Sequenzen von Objekten eines benutzerdefinierten Datentyps vergleichen möchten, müssen Sie den <xref:System.Collections.Generic.IEqualityComparer%601> generischen Schnittstelle in einer Hilfsklasse implementieren. Im folgenden Codebeispiel wird gezeigt, wie diese Schnittstelle in einem benutzerdefinierten Datentyp implementiert wird und <xref:System.Object.GetHashCode%2A>-und <xref:System.Object.Equals%2A> Methoden bereitgestellt werden. Im folgenden Beispiel wird gezeigt, wie ein Gleichheits Vergleich implementiert wird, der in der <xref:System.Linq.Enumerable.Except%2A>-Methode verwendet werden kann.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Nachdem Sie diesen Vergleich implementiert haben, können Sie Sequenzen von `Product` Objekten in der <xref:System.Linq.Enumerable.Except%2A>-Methode verwenden, wie im folgenden Beispiel gezeigt:  
  
 [!code-csharp[CSLINQCustomComparer#7](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#7)]
 [!code-vb[CSLINQCustomComparer#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> oder <paramref name="second" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="First&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt das erste Element einer Sequenz zurück</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member First : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.First source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Das <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen erstes Element zurückgegeben werden soll</param>
        <summary>Gibt das erste Element einer Sequenz zurück</summary>
        <returns>Das erste Element in der angegebenen Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>-Methode löst eine Ausnahme aus, wenn `source` keine-Elemente enthält. Um stattdessen einen Standardwert zurückzugeben, wenn die Quell Sequenz leer ist, verwenden Sie die <xref:System.Linq.Enumerable.FirstOrDefault%2A>-Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> verwendet wird, um das erste Element eines Arrays zurückzugeben.  
  
 [!code-csharp[System.Linq.Enumerable#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#35)]
 [!code-vb[System.Linq.Enumerable#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Quellsequenz ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function First(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource First(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member First : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.First (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem ein Element zurückgegeben werden soll</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das erste Element in einer Sequenz zurück, das eine angegebene Bedingung erfüllt.</summary>
        <returns>Das erste Element in der Sequenz, das mit der angegebenen Prädikatfunktion erfolgreich überprüft wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>-Methode löst eine Ausnahme aus, wenn kein entsprechendes Element in `source`gefunden wird. Um stattdessen einen Standardwert zurückzugeben, wenn kein entsprechendes Element gefunden wird, verwenden Sie die <xref:System.Linq.Enumerable.FirstOrDefault%2A>-Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> verwendet wird, um das erste Element eines Arrays zurückzugeben, das eine Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Enumerable#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#36)]
 [!code-vb[System.Linq.Enumerable#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#36)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element erfüllt die Bedingung in <paramref name="predicate" />.  
  
- oder - 
Die Quellsequenz ist leer.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FirstOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt das erste Element einer Sequenz oder einen Standardwert zurück, wenn kein Element gefunden wird</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.FirstOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Das <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen erstes Element zurückgegeben werden soll</param>
        <summary>Gibt das erste Element einer Sequenz oder einen Standardwert zurück, wenn die Sequenz keine Elemente enthält.</summary>
        <returns><see langword="default" />(<paramref name="TSource" />), wenn <paramref name="source" /> leer ist, andernfalls das erste Element in <paramref name="source" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für Verweis-und Werte zulässt-Typen ist `null`.  
  
 Die <xref:System.Linq.Enumerable.FirstOrDefault%2A>-Methode bietet keine Möglichkeit, einen Standardwert anzugeben. Wenn Sie einen anderen Standardwert als `default(TSource)`angeben möchten, verwenden Sie die <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>-Methode, wie im Beispiel Abschnitt beschrieben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> in einem leeren Array verwendet wird.  
  
 [!code-csharp[System.Linq.Enumerable#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#37)]
 [!code-vb[System.Linq.Enumerable#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#37)]  
  
 Manchmal ist der Wert von `default(TSource)` nicht der Standardwert, den Sie verwenden möchten, wenn die Auflistung keine Elemente enthält. Anstatt das Ergebnis für den unerwünschten Standardwert zu überprüfen und ggf. zu ändern, können Sie die <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>-Methode verwenden, um den Standardwert anzugeben, den Sie verwenden möchten, wenn die Auflistung leer ist. Rufen Sie dann <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> auf, um das erste Element abzurufen. Im folgenden Codebeispiel werden beide Techniken verwendet, um den Standardwert 1 zu erhalten, wenn eine Auflistung von numerischen Monaten leer ist. Da der Standardwert für eine Ganzzahl 0 ist, was keinem Monat entspricht, muss der Standardwert stattdessen auf 1 festgelegt werden. Die erste Ergebnisvariable wird auf den unerwünschten Standardwert geprüft, nachdem die Ausführung der Abfrage abgeschlossen ist. Die zweite Ergebnisvariable wird mit <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> abgerufen, um den Standardwert 1 anzugeben.  
  
 [!code-csharp[System.Linq.Enumerable#126](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#126)]
 [!code-vb[System.Linq.Enumerable#126](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#126)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FirstOrDefault(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource FirstOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member FirstOrDefault : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.FirstOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem ein Element zurückgegeben werden soll</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das erste Element der Sequenz zurück, das eine Bedingung erfüllt, oder einen Standardwert, wenn ein solches Element nicht gefunden wird.</summary>
        <returns><see langword="default" />(<paramref name="TSource" />), wenn <paramref name="source" /> leer ist oder wenn kein Element die von <paramref name="predicate" /> angegebene Überprüfung besteht. Andernfalls das erste Element in <paramref name="source" />, das die von <paramref name="predicate" /> angegebene Überprüfung besteht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für Verweis-und Werte zulässt-Typen ist `null`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> durch Übergeben eines Prädikats verwendet werden. Beim zweiten Aufrufe der-Methode gibt es kein-Element im-Array, das die Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Enumerable#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#38)]
 [!code-vb[System.Linq.Enumerable#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gruppiert die Elemente einer Sequenz</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As IEnumerable(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; seq&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen Elemente gruppiert werden sollen</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion</summary>
        <returns>Ein <c>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt;</c> in C# oder ein <c>IEnumerable(Of IGrouping(Of TKey, TSource))</c> in Visual Basic, wobei jedes <see cref="T:System.Linq.IGrouping`2" />-Objekt eine Sequenz von Objekten und einen Schlüssel enthält</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
> [!NOTE]
>  Beispiele für `GroupBy`finden Sie in den folgenden Artikeln:
>   
> - <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> - <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> - <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 Die <xref:System.Linq.Enumerable.GroupBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29>-Methode gibt eine Auflistung von <xref:System.Linq.IGrouping%602>-Objekten zurück, eine für jeden gefundenen eindeutigen Schlüssel. Ein <xref:System.Linq.IGrouping%602> ist ein <xref:System.Collections.Generic.IEnumerable%601>, dem auch ein Schlüssel zugeordnet ist.  
  
 Die <xref:System.Linq.IGrouping%602>-Objekte werden in einer Reihenfolge basierend auf der Reihenfolge der Elemente in `source` ausgegeben, die den ersten Schlüssel der einzelnen <xref:System.Linq.IGrouping%602>erzeugt haben. Elemente in einer Gruppierung werden in der Reihenfolge zurückgegeben, in der Sie in `source`angezeigt werden.  
  
 Der standardmäßige Gleichheits Vergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> wird zum Vergleichen von Schlüsseln verwendet.  
  
 In der Abfrage Ausdruckssyntax wird eine `group by` ( C#Visual) oder `Group By Into` (Visual Basic)-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.GroupBy%2A>übersetzt. Weitere Informationen und Verwendungs Beispiele finden Sie unter [Group-Klausel](~/docs/csharp/language-reference/keywords/group-clause.md) und [Group By-Klausel](~/docs/visual-basic/language-reference/queries/group-by-clause.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/csharp/language-reference/keywords/group-clause.md">group-Klausel (C#-Referenz)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/group-by-clause.md">GROUP BY-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of IGrouping(Of TKey, TSource))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Linq::IGrouping&lt;TKey, TSource&gt; ^&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;System.Linq.IGrouping&lt;'Key, 'Source&gt;&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen Elemente gruppiert werden sollen</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und vergleicht die Schlüssel mithilfe eines angegebenen Vergleichs</summary>
        <returns>Ein <c>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt;</c> in C# oder ein <c>IEnumerable(Of IGrouping(Of TKey, TSource))</c> in Visual Basic, wobei jedes <see cref="T:System.Linq.IGrouping`2" />-Objekt eine Auflistung von Objekten und einen Schlüssel enthält</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
> [!NOTE]
>  Beispiele für `GroupBy`finden Sie in den folgenden Artikeln:
>   
> - <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> - <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> - <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 Die <xref:System.Linq.Enumerable.GroupBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29>-Methode gibt eine Auflistung von <xref:System.Linq.IGrouping%602>-Objekten zurück, eine für jeden gefundenen eindeutigen Schlüssel. Ein <xref:System.Linq.IGrouping%602> ist ein <xref:System.Collections.Generic.IEnumerable%601>, dem auch ein Schlüssel zugeordnet ist.  
  
 Die <xref:System.Linq.IGrouping%602>-Objekte werden in einer Reihenfolge basierend auf der Reihenfolge der Elemente in `source` ausgegeben, die den ersten Schlüssel der einzelnen <xref:System.Linq.IGrouping%602>erzeugt haben. Elemente in einer Gruppierung werden in der Reihenfolge zurückgegeben, in der Sie in `source`angezeigt werden.  
  
 Wenn `comparer` `null`ist, wird der standardmäßige Gleichheits Vergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet.  
  
 Wenn zwei Schlüssel gemäß `comparer`als gleich betrachtet werden, wird der erste Schlüssel als Schlüssel für diese Gruppierung ausgewählt.  
  
 In der Abfrage Ausdruckssyntax wird eine `group by` ( C#Visual) oder `Group By Into` (Visual Basic)-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.GroupBy%2A>übersetzt. Weitere Informationen und Verwendungs Beispiele finden Sie unter [Group-Klausel](~/docs/csharp/language-reference/keywords/group-clause.md) und [Group By-Klausel](~/docs/visual-basic/language-reference/queries/group-by-clause.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/csharp/language-reference/keywords/group-clause.md">group-Klausel (C#-Referenz)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/group-by-clause.md">GROUP BY-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As IEnumerable(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; seq&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente im <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen Elemente gruppiert werden sollen</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in <see cref="T:System.Linq.IGrouping`2" /> zugeordnet wird</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und projiziert die Elemente für jede Gruppe mithilfe einer angegebenen Funktion</summary>
        <returns>Ein <c>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;</c> in C# oder ein <c>IEnumerable(Of IGrouping(Of TKey, TElement))</c> in Visual Basic, wobei jedes <see cref="T:System.Linq.IGrouping`2" />-Objekt eine Auflistung von Objekten des Typs <paramref name="TElement" /> und einen Schlüssel enthält</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Die <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>-Methode gibt eine Auflistung von <xref:System.Linq.IGrouping%602>-Objekten zurück, eine für jeden gefundenen eindeutigen Schlüssel. Ein <xref:System.Linq.IGrouping%602> ist ein <xref:System.Collections.Generic.IEnumerable%601>, dem auch ein Schlüssel zugeordnet ist.  
  
 Die <xref:System.Linq.IGrouping%602>-Objekte werden in einer Reihenfolge basierend auf der Reihenfolge der Elemente in `source` ausgegeben, die den ersten Schlüssel der einzelnen <xref:System.Linq.IGrouping%602>erzeugt haben. Elemente in einer Gruppierung werden in der Reihenfolge zurückgegeben, in der die Elemente, die Sie erstellt haben, in `source`angezeigt werden.  
  
 Der standardmäßige Gleichheits Vergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> wird zum Vergleichen von Schlüsseln verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> verwendet wird, um die Elemente einer Sequenz zu gruppieren.  
  
 [!code-csharp[System.Linq.Enumerable#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#39)]
 [!code-vb[System.Linq.Enumerable#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#39)]  
  
 In der Abfrage Ausdruckssyntax wird eine `group by` ( C#Visual) oder `Group By Into` (Visual Basic)-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.GroupBy%2A>übersetzt. Die Übersetzung des Abfrage Ausdrucks im folgenden Beispiel entspricht der Abfrage im obigen Beispiel.  
  
 [!code-csharp[System.Linq.Enumerable#122](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#122)]
 [!code-vb[System.Linq.Enumerable#122](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#122)]  
  
> [!NOTE]
>  In einem visuellen C# Ausdruck oder einem Visual Basic Abfrage Ausdruck treten die Element-und Schlüsselauswahl Ausdrücke in umgekehrter Reihenfolge von ihren Argument Positionen in einem aufzurufenden <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/csharp/language-reference/keywords/group-clause.md">group-Klausel (C#-Referenz)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/group-by-clause.md">GROUP BY-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of IGrouping(Of TKey, TElement))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;System::Linq::IGrouping&lt;TKey, TElement&gt; ^&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;System.Linq.IGrouping&lt;'Key, 'Element&gt;&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente im <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen Elemente gruppiert werden sollen</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einem <see cref="T:System.Linq.IGrouping`2" /> zugeordnet wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer Schlüsselauswahlfunktion Die Schlüssel werden mithilfe eines Vergleichs verglichen, und die Elemente jeder Gruppe werden mithilfe einer angegebenen Funktion projiziert.</summary>
        <returns>Ein <c>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;</c> in C# oder ein <c>IEnumerable(Of IGrouping(Of TKey, TElement))</c> in Visual Basic, wobei jedes <see cref="T:System.Linq.IGrouping`2" />-Objekt eine Auflistung von Objekten des Typs <paramref name="TElement" /> und einen Schlüssel enthält</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
> [!NOTE]
>  Beispiele für `GroupBy`finden Sie in den folgenden Artikeln:
>   
> - <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> - <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> - <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 Die <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29>-Methode gibt eine Auflistung von <xref:System.Linq.IGrouping%602>-Objekten zurück, eine für jeden gefundenen eindeutigen Schlüssel. Ein <xref:System.Linq.IGrouping%602> ist ein <xref:System.Collections.Generic.IEnumerable%601>, dem auch ein Schlüssel zugeordnet ist.  
  
 Die <xref:System.Linq.IGrouping%602>-Objekte werden in einer Reihenfolge basierend auf der Reihenfolge der Elemente in `source` ausgegeben, die den ersten Schlüssel der einzelnen <xref:System.Linq.IGrouping%602>erzeugt haben. Elemente in einer Gruppierung werden in der Reihenfolge zurückgegeben, in der die Elemente, die Sie erstellt haben, in `source`angezeigt werden.  
  
 Wenn `comparer` `null`ist, wird der standardmäßige Gleichheits Vergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet.  
  
 Wenn zwei Schlüssel gemäß `comparer`als gleich betrachtet werden, wird der erste Schlüssel als Schlüssel für diese Gruppierung ausgewählt.  
  
 In der Abfrage Ausdruckssyntax wird eine `group by` ( C#Visual) oder `Group By Into` (Visual Basic)-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.GroupBy%2A>übersetzt. Weitere Informationen und Verwendungs Beispiele finden Sie unter [Group-Klausel](~/docs/csharp/language-reference/keywords/group-clause.md) und [Group By-Klausel](~/docs/visual-basic/language-reference/queries/group-by-clause.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/csharp/language-reference/keywords/group-clause.md">group-Klausel (C#-Referenz)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/group-by-clause.md">GROUP BY-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), resultSelector As Func(Of TKey, IEnumerable(Of TSource), TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <typeparam name="TResult">Der Typ des von <paramref name="resultSelector" /> zurückgegebenen Ergebniswerts.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen Elemente gruppiert werden sollen</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert.</summary>
        <returns>Eine Auflistung von Elementen vom Typ <paramref name="TResult" />, wobei jedes Element eine Projektion über einer Gruppe und ihrem Schlüssel darstellt</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Abfrage Ausdruckssyntax wird eine `group by` ( C#Visual) oder `Group By Into` (Visual Basic)-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.GroupBy%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29> verwendet wird, um die Elemente einer Sequenz zu gruppieren und eine Sequenz von Ergebnissen des Typs `TResult`zu projizieren.  
  
 [!code-csharp[System.Linq.Enumerable#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#15)]
 [!code-vb[System.Linq.Enumerable#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#15)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/csharp/language-reference/keywords/group-clause.md">group-Klausel (C#-Referenz)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/group-by-clause.md">GROUP BY-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TResult) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), resultSelector As Func(Of TKey, IEnumerable(Of TSource), TResult), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Key, seq&lt;'Source&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <typeparam name="TResult">Der Typ des von <paramref name="resultSelector" /> zurückgegebenen Ergebniswerts.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen Elemente gruppiert werden sollen</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert. Die Schlüssel werden mithilfe eines angegebenen Vergleichs verglichen.</summary>
        <returns>Eine Auflistung von Elementen vom Typ <paramref name="TResult" />, wobei jedes Element eine Projektion über einer Gruppe und ihrem Schlüssel darstellt</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/csharp/language-reference/keywords/group-clause.md">group-Klausel (C#-Referenz)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/group-by-clause.md">GROUP BY-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), resultSelector As Func(Of TKey, IEnumerable(Of TElement), TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, elementSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente in jedem <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <typeparam name="TResult">Der Typ des von <paramref name="resultSelector" /> zurückgegebenen Ergebniswerts.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen Elemente gruppiert werden sollen</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einem <see cref="T:System.Linq.IGrouping`2" /> zugeordnet wird.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert. Die Elemente jeder Gruppe werden mithilfe einer angegebenen Funktion projiziert.</summary>
        <returns>Eine Auflistung von Elementen vom Typ <paramref name="TResult" />, wobei jedes Element eine Projektion über einer Gruppe und ihrem Schlüssel darstellt</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Abfrage Ausdruckssyntax wird eine `group by` ( C#Visual) oder `Group By Into` (Visual Basic)-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.GroupBy%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29> verwendet wird, um die projizierten Elemente einer Sequenz zu gruppieren und anschließend eine Sequenz von Ergebnissen des Typs `TResult`zu projizieren.  
  
 [!code-csharp[System.Linq.Enumerable#125](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#125)]
 [!code-vb[System.Linq.Enumerable#125](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#125)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/csharp/language-reference/keywords/group-clause.md">group-Klausel (C#-Referenz)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/group-by-clause.md">GROUP BY-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupBy(Of TSource, TKey, TElement, TResult) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), resultSelector As Func(Of TKey, IEnumerable(Of TElement), TResult), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, Func&lt;TKey, System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * Func&lt;'Key, seq&lt;'Element&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupBy (source, keySelector, elementSelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <typeparam name="TElement">Der Typ der Elemente in jedem <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <typeparam name="TResult">Der Typ des von <paramref name="resultSelector" /> zurückgegebenen Ergebniswerts.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen Elemente gruppiert werden sollen</param>
        <param name="keySelector">Eine Funktion zum Extrahieren des Schlüssels für jedes Element.</param>
        <param name="elementSelector">Eine Funktion, mit der jedes Quellelement einem Element in einem <see cref="T:System.Linq.IGrouping`2" /> zugeordnet wird.</param>
        <param name="resultSelector">Eine Funktion, mit der aus jeder Gruppe ein Ergebniswert erstellt wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln</param>
        <summary>Gruppiert die Elemente einer Sequenz entsprechend einer angegebenen Schlüsselauswahlfunktion und erstellt aus jeder Gruppe und ihrem Schlüssel einen Ergebniswert. Schlüsselwerte werden mithilfe eines angegebenen Vergleichs verglichen, und die Elemente jeder Gruppe werden mithilfe einer angegebenen Funktion projiziert.</summary>
        <returns>Eine Auflistung von Elementen vom Typ <paramref name="TResult" />, wobei jedes Element eine Projektion über einer Gruppe und ihrem Schlüssel darstellt</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/csharp/language-reference/keywords/group-clause.md">group-Klausel (C#-Referenz)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/group-by-clause.md">GROUP BY-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Korreliert die Elemente von zwei Sequenzen anhand der Gleichheit der Schlüssel und gruppiert die Ergebnisse</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As IEnumerable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, IEnumerable(Of TInner), TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupJoin(System::Collections::Generic::IEnumerable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : seq&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements anhand eines Elements aus der ersten Sequenz und einer Auflistung von übereinstimmenden Elementen aus der zweiten Sequenz.</param>
        <summary>Korreliert die Elemente von zwei Sequenzen anhand der Gleichheit der Schlüssel und gruppiert die Ergebnisse Schlüssel werden mithilfe des Standardgleichheitsvergleichs verglichen.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das Elemente vom Typ <paramref name="TResult" /> enthält, die durch Ausführen einer Gruppenverknüpfung von zwei Sequenzen ermittelt werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Der Standard Gleichheits Vergleich, der <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, wird zum Hashen und Vergleichen von Schlüsseln verwendet.  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A> generiert hierarchische Ergebnisse, was bedeutet, dass Elemente aus `outer` mit Auflistungen übereinstimmender Elemente aus `inner`kombiniert werden. `GroupJoin` ermöglicht es Ihnen, die Ergebnisse auf einen ganzen Satz von Übereinstimmungen für jedes Element `outer`zu basieren.  
  
> [!NOTE]
>  Wenn `inner` für ein bestimmtes Element `outer`keine korrelierten Elemente enthält, ist die Reihenfolge der Übereinstimmungen für dieses Element leer, wird aber dennoch in den Ergebnissen angezeigt.  
  
 Die `resultSelector`-Funktion wird für jedes `outer`-Element mit einer Auflistung aller `inner` Elemente, die dem `outer` Element entsprechen, nur einmal aufgerufen. Dies unterscheidet sich von der <xref:System.Linq.Enumerable.Join%2A>-Methode, bei der die Ergebnis Auswahlfunktion für Paare aufgerufen wird, die ein Element aus `outer` und ein Element aus `inner`enthalten.  
  
 `GroupJoin` behält die Reihenfolge der Elemente `outer`und für jedes Element `outer`die Reihenfolge der übereinstimmenden Elemente aus `inner`.  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A> hat keine direkte Entsprechung in herkömmlichen relationalen Daten Bank Begriffen. Diese Methode implementiert jedoch eine Obermenge innerer Joins und linker äußerer Joins. Beide Vorgänge können im Hinblick auf einen gruppierten Join geschrieben werden. Siehe Verknüpfungs [Vorgänge](https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107).  
  
 In der Abfrage Ausdruckssyntax wird eine `join … into` ( C#Visual) oder `Group Join` (Visual Basic)-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.GroupJoin%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.GroupJoin%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%29> verwendet wird, um einen gruppierten Join für zwei Sequenzen auszuführen.  
  
 [!code-csharp[System.Linq.Enumerable#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#40)]
 [!code-vb[System.Linq.Enumerable#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" />, <paramref name="inner" />, <paramref name="outerKeySelector" />, <paramref name="innerKeySelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">Verknüpfungsvorgänge</related>
        <related type="Article" href="~/docs/csharp/language-reference/keywords/join-clause.md">join-Klausel (C#-Referenz)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/group-join-clause.md">Group Join-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GroupJoin(Of TOuter, TInner, TKey, TResult) (outer As IEnumerable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, IEnumerable(Of TInner), TResult), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ GroupJoin(System::Collections::Generic::IEnumerable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member GroupJoin : seq&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, seq&lt;'Inner&gt;, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.GroupJoin (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements anhand eines Elements aus der ersten Sequenz und einer Auflistung von übereinstimmenden Elementen aus der zweiten Sequenz.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Hashen und Vergleichen von Schlüsseln.</param>
        <summary>Korreliert die Elemente von zwei Sequenzen anhand der Gleichheit der Schlüssel und gruppiert die Ergebnisse Schlüssel werden mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> verglichen.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das Elemente vom Typ <paramref name="TResult" /> enthält, die durch Ausführen einer Gruppenverknüpfung von zwei Sequenzen ermittelt werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Wenn `comparer` `null`ist, wird der Standard Gleichheits Vergleich (<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>) verwendet, um Schlüssel zu hashten und zu vergleichen.  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A> generiert hierarchische Ergebnisse, was bedeutet, dass Elemente aus `outer` mit Auflistungen übereinstimmender Elemente aus `inner`kombiniert werden. `GroupJoin` ermöglicht es Ihnen, die Ergebnisse auf einen ganzen Satz von Übereinstimmungen für jedes Element `outer`zu basieren.  
  
> [!NOTE]
>  Wenn `inner` für ein bestimmtes Element `outer`keine korrelierten Elemente enthält, ist die Reihenfolge der Übereinstimmungen für dieses Element leer, wird aber dennoch in den Ergebnissen angezeigt.  
  
 Die `resultSelector`-Funktion wird für jedes `outer`-Element mit einer Auflistung aller `inner` Elemente, die dem `outer` Element entsprechen, nur einmal aufgerufen. Dies unterscheidet sich von der <xref:System.Linq.Enumerable.Join%2A> Methode, bei der die Ergebnis Auswahlfunktion für Paare aufgerufen wird, die ein Element aus `outer` und ein Element aus `inner`enthalten.  
  
 `GroupJoin` behält die Reihenfolge der Elemente `outer`und für jedes Element `outer`die Reihenfolge der übereinstimmenden Elemente aus `inner`.  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A> hat keine direkte Entsprechung in herkömmlichen relationalen Daten Bank Begriffen. Diese Methode implementiert jedoch eine Obermenge innerer Joins und linker äußerer Joins. Beide Vorgänge können im Hinblick auf einen gruppierten Join geschrieben werden. Siehe Verknüpfungs [Vorgänge](https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" />, <paramref name="inner" />, <paramref name="outerKeySelector" />, <paramref name="innerKeySelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">Ausführen von joinvorgängen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Intersect&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erzeugt die Schnittmenge zweier Sequenzen</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/dotnet/api/system.linq.enumerable.except">Enumerable. with-Methode</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Intersect(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Intersect : seq&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Intersect (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen unterschiedliche Elemente auch in <paramref name="second" /> vorhanden sind, wird zurückgegeben.</param>
        <param name="second">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen unterschiedliche Elemente auch in der ersten Sequenz vorhanden sind, wird zurückgegeben.</param>
        <summary>Erzeugt die Schnittmenge zweier Sequenzen mithilfe des Standardgleichheitsvergleichs zum Vergleichen von Werten</summary>
        <returns>Eine Sequenz, die die Elemente enthält, die die Schnittmenge von zwei Sequenzen bilden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Die Schnittmenge von zwei Sätzen a und B wird als der Satz definiert, der alle Elemente von enthält, die auch in B, aber keine anderen Elemente enthalten sind.  
  
 Wenn das Objekt, das von dieser Methode zurückgegeben wird, aufgezählt wird, führt `Intersect` unterschiedliche Elemente aus, die in beiden Sequenzen in der Reihenfolge auftreten, in der Sie in `first`vorkommen  
  
 Der Standard Gleichheits Vergleich, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, wird verwendet, um Werte der Typen zu vergleichen. Um einen benutzerdefinierten Datentyp zu vergleichen, müssen Sie die <xref:System.Object.Equals%2A> und die <xref:System.Object.GetHashCode%2A> Methoden überschreiben und optional die <xref:System.IEquatable%601> generische Schnittstelle in den benutzerdefinierten Typ implementieren. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>-Eigenschaft.
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie `Intersect<TSource>(IEnumerable<TSource>, IEnumerable<TSource>)` verwendet wird, um die Elemente zurückzugeben, die in jeder der beiden Sequenzen von ganzen Zahlen angezeigt werden.  
  
 [!code-csharp-interactive[System.Linq.Enumerable#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#41)]
 [!code-vb[System.Linq.Enumerable#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#41)]  
  
 Wenn Sie Sequenzen von Objekten eines benutzerdefinierten Datentyps vergleichen möchten, müssen Sie den <xref:System.IEquatable%601> generischen Schnittstelle in einer Hilfsklasse implementieren. Im folgenden Codebeispiel wird veranschaulicht, wie diese Schnittstelle in einem benutzerdefinierten Datentyp implementiert wird und <xref:System.Object.GetHashCode%2A>-und <xref:System.Object.Equals%2A> Methoden überschrieben werden.
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
 [!code-vb[CSLINQEncapsulatedComparer#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#9)]  

 Nachdem Sie diese Schnittstelle implementiert haben, können Sie Sequenzen von `ProductA` Objekten in der `Intersect`-Methode verwenden, wie im folgenden Beispiel gezeigt:
  
[!code-csharp[CSLINQEncapsulatedComparer#10](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#10)]  
[!code-vb[CSLINQEncapsulatedComparer#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#10)]  

[!code-csharp[CSLINQEncapsulatedComparer#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#3)]
[!code-vb[CSLINQEncapsulatedComparer#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> oder <paramref name="second" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Intersect(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Intersect(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Intersect : seq&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Intersect (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen unterschiedliche Elemente auch in <paramref name="second" /> vorhanden sind, wird zurückgegeben.</param>
        <param name="second">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen unterschiedliche Elemente auch in der ersten Sequenz vorhanden sind, wird zurückgegeben.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten.</param>
        <summary>Erzeugt mithilfe des angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten die Schnittmenge von zwei Sequenzen</summary>
        <returns>Eine Sequenz, die die Elemente enthält, die die Schnittmenge von zwei Sequenzen bilden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Die Schnittmenge von zwei Sätzen a und B wird als der Satz definiert, der alle Elemente von enthält, die auch in B, aber keine anderen Elemente enthalten sind.  
  
 Wenn das Objekt, das von dieser Methode zurückgegeben wird, aufgezählt wird, führt `Intersect` unterschiedliche Elemente aus, die in beiden Sequenzen in der Reihenfolge auftreten, in der Sie in `first`vorkommen  
  
 Wenn `comparer` `null`ist, wird der Standard Gleichheits Vergleich (<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>) verwendet, um Werte zu vergleichen.  
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein Gleichheits Vergleich implementiert wird, der in der `Intersect`-Methode verwendet werden kann.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Nachdem Sie diesen Vergleich implementiert haben, können Sie Sequenzen von `Product` Objekten in der `Intersect`-Methode verwenden, wie im folgenden Beispiel gezeigt:  
  
 [!code-csharp[CSLINQCustomComparer#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#2)]
 [!code-vb[CSLINQCustomComparer#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#2)]  
[!code-csharp[CSLINQCustomComparer#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#3)]
[!code-vb[CSLINQCustomComparer#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> oder <paramref name="second" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Korreliert die Elemente von zwei Sequenzen auf der Grundlage von übereinstimmenden Schlüsseln</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As IEnumerable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, TInner, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Join(System::Collections::Generic::IEnumerable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Join : seq&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, 'Inner, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements aus zwei übereinstimmenden Elementen.</param>
        <summary>Korreliert die Elemente von zwei Sequenzen auf der Grundlage von übereinstimmenden Schlüsseln Schlüssel werden mithilfe des Standardgleichheitsvergleichs verglichen.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das Elemente vom Typ <paramref name="TResult" /> enthält, die durch Ausführen eines inneren Joins von zwei Sequenzen ermittelt werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Der Standard Gleichheits Vergleich, der <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, wird zum Hashen und Vergleichen von Schlüsseln verwendet.  
  
 Ein Join bezieht sich auf den Vorgang, mit dem die Elemente von zwei Informationsquellen auf Grundlage eines gemeinsamen Schlüssels korreliert werden. <xref:System.Linq.Enumerable.Join%2A> werden die beiden Informationsquellen und die Schlüssel, mit denen Sie miteinander übereinstimmen, in einem Methoden aufzurufen. Dies unterscheidet sich von der Verwendung von `SelectMany`, bei der mehrere Methodenaufrufe erforderlich sind, um denselben Vorgang auszuführen.  
  
 <xref:System.Linq.Enumerable.Join%2A> behält die Reihenfolge der Elemente `outer`und für jedes dieser Elemente die Reihenfolge der übereinstimmenden Elemente `inner`.  
  
 In der Abfrage Ausdruckssyntax wird eine `join` ( C#Visual) oder `Join` (Visual Basic)-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Join%2A>übersetzt.  
  
 In relationalen Daten Bank Begriffen implementiert die <xref:System.Linq.Enumerable.Join%2A>-Methode einen inneren Gleichheitsjoin. "Inner" bedeutet, dass nur Elemente, die eine Entsprechung in der anderen Sequenz aufweisen, in den Ergebnissen enthalten sind. Ein "equijoin" ist ein Join, bei dem die Schlüssel auf Gleichheit verglichen werden. Ein linker äußerer Joinvorgang verfügt über keinen dedizierten Standard Abfrage Operator, kann jedoch mit der <xref:System.Linq.Enumerable.GroupJoin%2A>-Methode ausgeführt werden. Siehe Verknüpfungs [Vorgänge](https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Join%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%29> verwendet wird, um eine innere Verknüpfung von zwei Sequenzen auf der Grundlage eines gemeinsamen Schlüssels auszuführen.  
  
 [!code-csharp[System.Linq.Enumerable#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#42)]
 [!code-vb[System.Linq.Enumerable#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" />, <paramref name="inner" />, <paramref name="outerKeySelector" />, <paramref name="innerKeySelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">Verknüpfen</related>
        <related type="Article" href="~/docs/csharp/language-reference/keywords/join-clause.md">join-Klausel (C#-Referenz)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/join-clause.md">Join-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Join(Of TOuter, TInner, TKey, TResult) (outer As IEnumerable(Of TOuter), inner As IEnumerable(Of TInner), outerKeySelector As Func(Of TOuter, TKey), innerKeySelector As Func(Of TInner, TKey), resultSelector As Func(Of TOuter, TInner, TResult), comparer As IEqualityComparer(Of TKey)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOuter, typename TInner, typename TKey, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Join(System::Collections::Generic::IEnumerable&lt;TOuter&gt; ^ outer, System::Collections::Generic::IEnumerable&lt;TInner&gt; ^ inner, Func&lt;TOuter, TKey&gt; ^ outerKeySelector, Func&lt;TInner, TKey&gt; ^ innerKeySelector, Func&lt;TOuter, TInner, TResult&gt; ^ resultSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Join : seq&lt;'Outer&gt; * seq&lt;'Inner&gt; * Func&lt;'Outer, 'Key&gt; * Func&lt;'Inner, 'Key&gt; * Func&lt;'Outer, 'Inner, 'Result&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Join (outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">Der Typ der Elemente der ersten Sequenz.</typeparam>
        <typeparam name="TInner">Der Typ der Elemente der zweiten Sequenz.</typeparam>
        <typeparam name="TKey">Der Typ der von den Schlüsselauswahlfunktionen zurückgegebenen Schlüssel.</typeparam>
        <typeparam name="TResult">Der Typ der Ergebniselemente.</typeparam>
        <param name="outer">Die erste zu verknüpfende Sequenz.</param>
        <param name="inner">Die Sequenz, die mit der ersten Sequenz verknüpft werden soll.</param>
        <param name="outerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der ersten Sequenz.</param>
        <param name="innerKeySelector">Eine Funktion zum Extrahieren des Joinschlüssels aus jedem Element der zweiten Sequenz.</param>
        <param name="resultSelector">Eine Funktion zum Erstellen eines Ergebniselements aus zwei übereinstimmenden Elementen.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Hashen und Vergleichen von Schlüsseln.</param>
        <summary>Korreliert die Elemente von zwei Sequenzen auf der Grundlage von übereinstimmenden Schlüsseln Schlüssel werden mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> verglichen.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das Elemente vom Typ <paramref name="TResult" /> enthält, die durch Ausführen eines inneren Joins von zwei Sequenzen ermittelt werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Wenn `comparer` `null`ist, wird der Standard Gleichheits Vergleich (<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>) verwendet, um Schlüssel zu hashten und zu vergleichen.  
  
 Ein Join bezieht sich auf den Vorgang, mit dem die Elemente von zwei Informationsquellen auf Grundlage eines gemeinsamen Schlüssels korreliert werden. <xref:System.Linq.Enumerable.Join%2A> werden die beiden Informationsquellen und die Schlüssel, mit denen Sie miteinander übereinstimmen, in einem Methoden aufzurufen. Dies unterscheidet sich von der Verwendung von `SelectMany`, bei der mehrere Methodenaufrufe erforderlich sind, um denselben Vorgang auszuführen.  
  
 <xref:System.Linq.Enumerable.Join%2A> behält die Reihenfolge der Elemente `outer`und für jedes dieser Elemente die Reihenfolge der übereinstimmenden Elemente `inner`.  
  
 In relationalen Daten Bank Begriffen implementiert die <xref:System.Linq.Enumerable.Join%2A>-Methode einen inneren Gleichheitsjoin. "Inner" bedeutet, dass nur Elemente, die eine Entsprechung in der anderen Sequenz aufweisen, in den Ergebnissen enthalten sind. Ein "equijoin" ist ein Join, bei dem die Schlüssel auf Gleichheit verglichen werden. Ein linker äußerer Joinvorgang verfügt über keinen dedizierten Standard Abfrage Operator, kann jedoch mit der <xref:System.Linq.Enumerable.GroupJoin%2A>-Methode ausgeführt werden. Siehe Verknüpfungs [Vorgänge](https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="outer" />, <paramref name="inner" />, <paramref name="outerKeySelector" />, <paramref name="innerKeySelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107">Verknüpfen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Last&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt das letzte Element einer Sequenz zurück</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Last : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Last source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen letztes Element zurückgegeben werden soll</param>
        <summary>Gibt das letzte Element einer Sequenz zurück</summary>
        <returns>Der Wert an der letzten Position in der Quellsequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>-Methode löst eine Ausnahme aus, wenn `source` keine-Elemente enthält. Um stattdessen einen Standardwert zurückzugeben, wenn die Quell Sequenz leer ist, verwenden Sie die <xref:System.Linq.Enumerable.LastOrDefault%2A>-Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> verwendet wird, um das letzte Element eines Arrays zurückzugeben.  
  
 [!code-csharp[System.Linq.Enumerable#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#43)]
 [!code-vb[System.Linq.Enumerable#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#43)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Quellsequenz ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Last(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Last(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Last : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Last (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem ein Element zurückgegeben werden soll</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das letzte Element einer Sequenz zurück, das eine angegebene Bedingung erfüllt.</summary>
        <returns>Das letzte Element in der Sequenz, das mit der angegebenen Prädikatfunktion erfolgreich überprüft wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>-Methode löst eine Ausnahme aus, wenn kein entsprechendes Element in `source`gefunden wird. Um stattdessen einen Standardwert zurückzugeben, wenn kein entsprechendes Element gefunden wird, verwenden Sie die <xref:System.Linq.Enumerable.LastOrDefault%2A>-Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> verwendet wird, um das letzte Element eines Arrays zurückzugeben, das eine Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Enumerable#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#44)]
 [!code-vb[System.Linq.Enumerable#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#44)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element erfüllt die Bedingung in <paramref name="predicate" />.  
  
- oder - 
Die Quellsequenz ist leer.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt das letzte Element einer Sequenz oder einen Standardwert zurück, wenn kein Element gefunden wird</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.LastOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen letztes Element zurückgegeben werden soll</param>
        <summary>Gibt das letzte Element einer Sequenz oder einen Standardwert zurück, wenn die Sequenz keine Elemente enthält.</summary>
        <returns><see langword="default" />(<paramref name="TSource" />), wenn die Quellsequenz leer ist; andernfalls das letzte Element in <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für Verweis-und Werte zulässt-Typen ist `null`.  
  
 Die <xref:System.Linq.Enumerable.LastOrDefault%2A>-Methode bietet keine Möglichkeit, einen Standardwert anzugeben. Wenn Sie einen anderen Standardwert als `default(TSource)`angeben möchten, verwenden Sie die <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>-Methode, wie im Beispiel Abschnitt beschrieben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.LastOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> in einem leeren Array verwendet wird.  
  
 [!code-csharp[System.Linq.Enumerable#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#45)]
 [!code-vb[System.Linq.Enumerable#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#45)]  
  
 Manchmal ist der Wert von `default(TSource)` nicht der Standardwert, den Sie verwenden möchten, wenn die Auflistung keine Elemente enthält. Anstatt das Ergebnis für den unerwünschten Standardwert zu überprüfen und ggf. zu ändern, können Sie die <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>-Methode verwenden, um den Standardwert anzugeben, den Sie verwenden möchten, wenn die Auflistung leer ist. Rufen Sie dann <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> auf, um das letzte Element abzurufen. Im folgenden Codebeispiel werden beide Techniken verwendet, um den Standardwert 1 zu erhalten, wenn eine Auflistung numerischer Tage des Monats leer ist. Da der Standardwert für eine Ganzzahl 0 ist, was keinem Tag des Monats entspricht, muss der Standardwert stattdessen auf 1 festgelegt werden. Die erste Ergebnisvariable wird auf den unerwünschten Standardwert geprüft, nachdem die Ausführung der Abfrage abgeschlossen ist. Die zweite Ergebnisvariable wird mit <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> abgerufen, um den Standardwert 1 anzugeben.  
  
 [!code-csharp[System.Linq.Enumerable#127](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#127)]
 [!code-vb[System.Linq.Enumerable#127](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#127)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LastOrDefault(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource LastOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LastOrDefault : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.LastOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem ein Element zurückgegeben werden soll</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt das letzte Element einer Sequenz, das eine Bedingung erfüllt, oder einen Standardwert zurück, wenn ein solches Element nicht gefunden wird.</summary>
        <returns><see langword="default" />(<paramref name="TSource" />), wenn die Sequenz leer ist oder wenn keine Elemente von der Prädikatfunktion erfolgreich überprüft werden. Andernfalls das letzte Element, das von der Prädikatfunktion erfolgreich überprüft wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für Verweis-und Werte zulässt-Typen ist `null`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.LastOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> durch Übergeben eines Prädikats verwendet werden. Beim zweiten Aufrufe der-Methode gibt es kein Element in der Sequenz, das die Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Enumerable#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#46)]
 [!code-vb[System.Linq.Enumerable#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#46)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LongCount&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt ein <see cref="T:System.Int64" /> zurück, das die Anzahl der Elemente in einer Sequenz darstellt</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As IEnumerable(Of TSource)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member LongCount : seq&lt;'Source&gt; -&gt; int64" Usage="System.Linq.Enumerable.LongCount source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das die zu zählenden Elemente enthält</param>
        <summary>Gibt ein <see cref="T:System.Int64" /> zurück, das die Gesamtanzahl der Elemente in einer Sequenz darstellt</summary>
        <returns>Die Anzahl der Elemente in der Quellsequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode anstelle <xref:System.Linq.Enumerable.Count%2A>, wenn Sie erwarten, dass das Ergebnis größer als <xref:System.Int32.MaxValue>ist.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into LongCount()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.LongCount%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> zum zählen der Elemente in einem Array verwendet wird.  
  
 [!code-csharp[System.Linq.Enumerable#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#47)]
 [!code-vb[System.Linq.Enumerable#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Anzahl der Elemente überschreitet <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function LongCount(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long LongCount(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member LongCount : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; int64" Usage="System.Linq.Enumerable.LongCount (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das die zu zählenden Elemente enthält</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt ein <see cref="T:System.Int64" /> zurück, das die Anzahl der Elemente in einer Sequenz darstellt, die eine Bedingung erfüllen</summary>
        <returns>Eine Zahl, die die Anzahl der Elemente in der Sequenz darstellt, die die Bedingung in der Prädikatfunktion erfüllen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode anstelle <xref:System.Linq.Enumerable.Count%2A>, wenn Sie erwarten, dass das Ergebnis größer als <xref:System.Int32.MaxValue>ist.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into LongCount()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.LongCount%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> verwendet wird, um die Elemente in einem Array zu zählen, die eine Bedingung erfüllen.  
  
 [!code-csharp[System.Linq.Enumerable#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#48)]
 [!code-vb[System.Linq.Enumerable#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#48)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Anzahl der übereinstimmenden Elemente überschreitet <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Max">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Höchstwert in einer Sequenz von Werten zurück</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Max(System::Collections::Generic::IEnumerable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Decimal" />-Werten, deren Höchstwert bestimmt werden soll</param>
        <summary>Gibt den Höchstwert in einer Sequenz von <see cref="T:System.Decimal" />-Werten zurück</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29>-Methode verwendet die <xref:System.Decimal> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Max(System::Collections::Generic::IEnumerable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;double&gt; -&gt; double" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Double" />-Werten, deren Höchstwert bestimmt werden soll</param>
        <summary>Gibt den Höchstwert in einer Sequenz von <see cref="T:System.Double" />-Werten zurück</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29>-Methode verwendet die <xref:System.Double> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Max(System::Collections::Generic::IEnumerable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;int&gt; -&gt; int" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int32" />-Werten, deren Höchstwert bestimmt werden soll</param>
        <summary>Gibt den Höchstwert in einer Sequenz von <see cref="T:System.Int32" />-Werten zurück</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29>-Methode verwendet die <xref:System.Int32> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Max(System::Collections::Generic::IEnumerable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int64" />-Werten, deren Höchstwert bestimmt werden soll</param>
        <summary>Gibt den Höchstwert in einer Sequenz von <see cref="T:System.Int64" />-Werten zurück</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29>-Methode verwendet die <xref:System.Int64> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz zu ermitteln.  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Max(System::Collections::Generic::IEnumerable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Decimal" />-Werten, die NULL-Werte zulassen und deren Höchstwert bestimmt werden soll</param>
        <summary>Gibt den Höchstwert in einer Sequenz von <see cref="T:System.Decimal" />-Werten zurück, die NULL-Werte zulassen</summary>
        <returns>Ein Wert vom Typ <c>Nullable&lt;Decimal&gt;</c> in C# oder <c>Nullable(Of Decimal)</c> in Visual Basic, der dem Höchstwert in der Sequenz entspricht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29>-Methode verwendet die <xref:System.Decimal> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Wenn die Quell Sequenz leer ist oder nur Werte enthält, die `null`sind, gibt diese Funktion `null`zurück.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Max(System::Collections::Generic::IEnumerable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Double" />-Werten, die NULL-Werte zulassen und deren Höchstwert bestimmt werden soll</param>
        <summary>Gibt den Höchstwert in einer Sequenz von <see cref="T:System.Double" />-Werten zurück, die NULL-Werte zulassen</summary>
        <returns>Ein Wert vom Typ <c>Nullable&lt;Double&gt;</c> in C# oder <c>Nullable(Of Double)</c> in Visual Basic, der dem Höchstwert in der Sequenz entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29>-Methode verwendet die <xref:System.Double> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Wenn die Quell Sequenz leer ist oder nur Werte enthält, die `null`sind, gibt diese Funktion `null`zurück.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz zu ermitteln.  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Max(System::Collections::Generic::IEnumerable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int32" />-Werten, die NULL-Werte zulassen und deren Höchstwert bestimmt werden soll</param>
        <summary>Gibt den Höchstwert in einer Sequenz von <see cref="T:System.Int32" />-Werten zurück, die NULL-Werte zulassen</summary>
        <returns>Ein Wert vom Typ <c>Nullable&lt;Int32&gt;</c> in C# oder <c>Nullable(Of Int32)</c> in Visual Basic, der dem Höchstwert in der Sequenz entspricht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29>-Methode verwendet die <xref:System.Int32> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Wenn die Quell Sequenz leer ist oder nur Werte enthält, die `null`sind, gibt diese Funktion `null`zurück.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Max(System::Collections::Generic::IEnumerable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int64" />-Werten, die NULL-Werte zulassen und deren Höchstwert bestimmt werden soll</param>
        <summary>Gibt den Höchstwert in einer Sequenz von <see cref="T:System.Int64" />-Werten zurück, die NULL-Werte zulassen</summary>
        <returns>Ein Wert vom Typ <c>Nullable&lt;Int64&gt;</c> in C# oder <c>Nullable(Of Int64)</c> in Visual Studio, der dem Höchstwert in der Sequenz entspricht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29>-Methode verwendet die <xref:System.Int64> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Wenn die Quell Sequenz leer ist oder nur Werte enthält, die `null`sind, gibt diese Funktion `null`zurück.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Max(System::Collections::Generic::IEnumerable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Single" />-Werten, die NULL-Werte zulassen und deren Höchstwert bestimmt werden soll</param>
        <summary>Gibt den Höchstwert in einer Sequenz von <see cref="T:System.Single" />-Werten zurück, die NULL-Werte zulassen</summary>
        <returns>Ein Wert vom Typ <c>Nullable&lt;Single&gt;</c> in C# oder <c>Nullable(Of Single)</c> in Visual Basic, der dem Höchstwert in der Sequenz entspricht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29>-Methode verwendet die <xref:System.Single> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Wenn die Quell Sequenz leer ist oder nur Werte enthält, die `null`sind, gibt diese Funktion `null`zurück.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max (source As IEnumerable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Max(System::Collections::Generic::IEnumerable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;single&gt; -&gt; single" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Single" />-Werten, deren Höchstwert bestimmt werden soll</param>
        <summary>Gibt den Höchstwert in einer Sequenz von <see cref="T:System.Single" />-Werten zurück</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29>-Methode verwendet die <xref:System.Single> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Max source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <summary>Gibt den Höchstwert in einer generischen Sequenz zurück</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Type `TSource` <xref:System.IComparable%601>implementiert, verwendet die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>-Methode diese Implementierung, um Werte zu vergleichen. Andernfalls, wenn Type `TSource` <xref:System.IComparable>implementiert, wird diese Implementierung zum Vergleichen von Werten verwendet.  
  
 Wenn `TSource` ein Referenztyp ist und die Quell Sequenz leer ist oder nur Werte enthält, die `null`sind, gibt diese Methode `null`zurück.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz von <xref:System.IComparable%601> Objekten zu ermitteln.  
  
 [!code-csharp[System.Linq.Enumerable#57](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#57)]
 [!code-vb[System.Linq.Enumerable#57](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#57)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Kein Objekt in <paramref name="source" /> implementiert die <see cref="T:System.IComparable" />- oder <see cref="T:System.IComparable`1" />-Schnittstelle.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf, und gibt den maximalen <see cref="T:System.Decimal" />-Wert zurück</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Decimal%7D%29>-Methode verwendet die <xref:System.Decimal> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere <xref:System.Decimal>.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf, und gibt den maximalen <see cref="T:System.Double" />-Wert zurück</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>-Methode verwendet die <xref:System.Double> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere <xref:System.Double>.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf, und gibt den maximalen <see cref="T:System.Int32" />-Wert zurück</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>-Methode verwendet die <xref:System.Int32> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere <xref:System.Int32>.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf, und gibt den maximalen <see cref="T:System.Int64" />-Wert zurück</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29>-Methode verwendet die <xref:System.Int64> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere <xref:System.Int64>.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf, und gibt den maximalen <see cref="T:System.Decimal" />-Wert zurück, der NULL-Werte zulässt</summary>
        <returns>Der Wert vom Typ <c>Nullable&lt;Decimal&gt;</c> in C# oder <c>Nullable(Of Decimal)</c> in Visual Basic, der dem Höchstwert in der Sequenz entspricht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%29>-Methode verwendet die <xref:System.Decimal> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere `Nullable<Decimal>` in C# Visual Basic oder `Nullable(Of Decimal)`.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf, und gibt den maximalen <see cref="T:System.Double" />-Wert zurück, der NULL-Werte zulässt</summary>
        <returns>Der Wert vom Typ <c>Nullable&lt;Double&gt;</c> in C# oder <c>Nullable(Of Double)</c> in Visual Basic, der dem Höchstwert in der Sequenz entspricht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%29>-Methode verwendet die <xref:System.Double> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere `Nullable<Double>` in C# Visual Basic oder `Nullable(Of Double)`.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf, und gibt den maximalen <see cref="T:System.Int32" />-Wert zurück, der NULL-Werte zulässt</summary>
        <returns>Der Wert vom Typ <c>Nullable&lt;Int32&gt;</c> in C# oder <c>Nullable(Of Int32)</c> in Visual Basic, der dem Höchstwert in der Sequenz entspricht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%29>-Methode verwendet die <xref:System.Int32> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere `Nullable<Int32>` in C# Visual Basic oder `Nullable(Of Int32)`.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf, und gibt den maximalen <see cref="T:System.Int64" />-Wert zurück, der NULL-Werte zulässt</summary>
        <returns>Der Wert vom Typ <c>Nullable&lt;Int64&gt;</c> in C# oder <c>Nullable(Of Int64)</c> in Visual Basic, der dem Höchstwert in der Sequenz entspricht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%29>-Methode verwendet die <xref:System.Int64> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere `Nullable<Int64>` in C# Visual Basic oder `Nullable(Of Int64)`.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf, und gibt den maximalen <see cref="T:System.Single" />-Wert zurück, der NULL-Werte zulässt</summary>
        <returns>Der Wert des Typs <c>Nullable&lt;Single&gt;</c> in C# oder <c>Nullable(Of Single)</c> in Visual Basic, der dem Höchstwert in der Sequenz entspricht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%29>-Methode verwendet die <xref:System.Single> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere `Nullable<Single>` in C# Visual Basic oder `Nullable(Of Single)`.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf, und gibt den maximalen <see cref="T:System.Single" />-Wert zurück</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29>-Methode verwendet die <xref:System.Single> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere <xref:System.Single>.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Max&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Max&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Max(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Max(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Max : seq&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; 'Result" Usage="System.Linq.Enumerable.Max (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Der Typ des von <paramref name="selector" /> zurückgegebenen Werts.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Höchstwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer generischen Sequenz eine Transformationsfunktion auf, und gibt den höchsten Ergebniswert zurück</summary>
        <returns>Der Höchstwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Type `TResult` <xref:System.IComparable%601>implementiert, verwendet diese Methode diese Implementierung, um Werte zu vergleichen. Andernfalls, wenn Type `TResult` <xref:System.IComparable>implementiert, wird diese Implementierung zum Vergleichen von Werten verwendet.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Max()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Max%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den maximalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Min">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Mindestwert in einer Sequenz von Werten zurück</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Min(System::Collections::Generic::IEnumerable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Decimal" />-Werten, deren Mindestwert bestimmt werden soll</param>
        <summary>Gibt den Mindestwert in einer Sequenz von <see cref="T:System.Decimal" />-Werten zurück</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29>-Methode verwendet die <xref:System.Decimal> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Min(System::Collections::Generic::IEnumerable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;double&gt; -&gt; double" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Double" />-Werten, deren Mindestwert bestimmt werden soll</param>
        <summary>Gibt den Mindestwert in einer Sequenz von <see cref="T:System.Double" />-Werten zurück</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29>-Methode verwendet die <xref:System.Double> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz zu ermitteln.  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Min(System::Collections::Generic::IEnumerable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;int&gt; -&gt; int" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int32" />-Werten, deren Mindestwert bestimmt werden soll</param>
        <summary>Gibt den Mindestwert in einer Sequenz von <see cref="T:System.Int32" />-Werten zurück</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29>-Methode verwendet die <xref:System.Int32> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Min(System::Collections::Generic::IEnumerable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int64" />-Werten, deren Mindestwert bestimmt werden soll</param>
        <summary>Gibt den Mindestwert in einer Sequenz von <see cref="T:System.Int64" />-Werten zurück</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29>-Methode verwendet die <xref:System.Int64> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Min(System::Collections::Generic::IEnumerable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Decimal" />-Werten, die NULL-Werte zulassen und deren Mindestwert bestimmt werden soll</param>
        <summary>Gibt den Mindestwert in einer Sequenz von <see cref="T:System.Decimal" />-Werten zurück, die NULL-Werte zulassen</summary>
        <returns>Ein Wert vom Typ <c>Nullable&lt;Decimal&gt;</c> in C# oder <c>Nullable(Of Decimal)</c> in Visual Basic, der dem Mindestwert in der Sequenz entspricht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29>-Methode verwendet die <xref:System.Decimal> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Wenn die Quell Sequenz leer ist oder nur Werte enthält, die `null`sind, gibt diese Funktion `null`zurück.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Min(System::Collections::Generic::IEnumerable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Double" />-Werten, die NULL-Werte zulassen und deren Mindestwert bestimmt werden soll</param>
        <summary>Gibt den Mindestwert in einer Sequenz von <see cref="T:System.Double" />-Werten zurück, die NULL-Werte zulassen</summary>
        <returns>Der Wert vom Typ <c>Nullable&lt;Double&gt;</c> in C# oder <c>Nullable(Of Double)</c> in Visual Basic, der dem Mindestwert in der Sequenz entspricht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29>-Methode verwendet die <xref:System.Double> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Wenn die Quell Sequenz leer ist oder nur Werte enthält, die `null`sind, gibt diese Funktion `null`zurück.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Min(System::Collections::Generic::IEnumerable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int32" />-Werten, die NULL-Werte zulassen und deren Mindestwert bestimmt werden soll</param>
        <summary>Gibt den Mindestwert in einer Sequenz von <see cref="T:System.Int32" />-Werten zurück, die NULL-Werte zulassen</summary>
        <returns>Ein Wert vom Typ <c>Nullable&lt;Int32&gt;</c> in C# oder <c>Nullable(Of Int32)</c> in Visual Basic, der dem Mindestwert in der Sequenz entspricht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29>-Methode verwendet die <xref:System.Int32> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Wenn die Quell Sequenz leer ist oder nur Werte enthält, die `null`sind, gibt diese Funktion `null`zurück.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz zu ermitteln.  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Min(System::Collections::Generic::IEnumerable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int64" />-Werten, die NULL-Werte zulassen und deren Mindestwert bestimmt werden soll</param>
        <summary>Gibt den Mindestwert in einer Sequenz von <see cref="T:System.Int64" />-Werten zurück, die NULL-Werte zulassen</summary>
        <returns>Ein Wert vom Typ <c>Nullable&lt;Int64&gt;</c> in C# oder <c>Nullable(Of Int64)</c> in Visual Basic, der dem Mindestwert in der Sequenz entspricht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29>-Methode verwendet die <xref:System.Int64> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Wenn die Quell Sequenz leer ist oder nur Werte enthält, die `null`sind, gibt diese Funktion `null`zurück.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Min(System::Collections::Generic::IEnumerable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Single" />-Werten, die NULL-Werte zulassen und deren Mindestwert bestimmt werden soll</param>
        <summary>Gibt den Mindestwert in einer Sequenz von <see cref="T:System.Single" />-Werten zurück, die NULL-Werte zulassen</summary>
        <returns>Der Wert des Typs <c>Nullable&lt;Single&gt;</c> in C# oder <c>Nullable(Of Single)</c> in Visual Basic, der dem Mindestwert in der Sequenz entspricht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29>-Methode verwendet die <xref:System.Single> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Wenn die Quell Sequenz leer ist oder nur Werte enthält, die `null`sind, gibt diese Funktion `null`zurück.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min (source As IEnumerable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Min(System::Collections::Generic::IEnumerable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;single&gt; -&gt; single" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Single" />-Werten, deren Mindestwert bestimmt werden soll</param>
        <summary>Gibt den Mindestwert in einer Sequenz von <see cref="T:System.Single" />-Werten zurück</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29>-Methode verwendet die <xref:System.Single> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz zu ermitteln.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Min source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <summary>Gibt den Mindestwert in einer generischen Sequenz zurück</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Type `TSource` <xref:System.IComparable%601>implementiert, verwendet diese Methode diese Implementierung, um Werte zu vergleichen. Andernfalls, wenn Type `TSource` <xref:System.IComparable>implementiert, wird diese Implementierung zum Vergleichen von Werten verwendet.  
  
 Wenn `TSource` ein Referenztyp ist und die Quell Sequenz leer ist oder nur Werte enthält, die `null`sind, gibt diese Funktion `null`zurück.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz von <xref:System.IComparable%601> Objekten zu bestimmen.  
  
 [!code-csharp[System.Linq.Enumerable#67](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#67)]
 [!code-vb[System.Linq.Enumerable#67](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#67)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Kein Objekt in <paramref name="source" /> implementiert die <see cref="T:System.IComparable" />- oder <see cref="T:System.IComparable`1" />-Schnittstelle.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf, und gibt den minimalen <see cref="T:System.Decimal" />-Wert zurück</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Decimal%7D%29>-Methode verwendet die <xref:System.Decimal> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere <xref:System.Decimal>.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf, und gibt den minimalen <see cref="T:System.Double" />-Wert zurück</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29>-Methode verwendet die <xref:System.Double> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere <xref:System.Double>.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf, und gibt den minimalen <see cref="T:System.Int32" />-Wert zurück</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29>-Methode verwendet die <xref:System.Int32> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere <xref:System.Int32>.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf, und gibt den minimalen <see cref="T:System.Int64" />-Wert zurück</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29>-Methode verwendet die <xref:System.Int64> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere <xref:System.Int64>.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf, und gibt den minimalen <see cref="T:System.Decimal" />-Wert zurück, der NULL-Werte zulässt</summary>
        <returns>Der Wert vom Typ <c>Nullable&lt;Decimal&gt;</c> in C# oder <c>Nullable(Of Decimal)</c> in Visual Basic, der dem Mindestwert in der Sequenz entspricht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%29>-Methode verwendet die <xref:System.Decimal> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere `Nullable<Decimal>` in C# Visual Basic oder `Nullable(Of Decimal)`.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf, und gibt den minimalen <see cref="T:System.Double" />-Wert zurück, der NULL-Werte zulässt</summary>
        <returns>Der Wert vom Typ <c>Nullable&lt;Double&gt;</c> in C# oder <c>Nullable(Of Double)</c> in Visual Basic, der dem Mindestwert in der Sequenz entspricht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%29>-Methode verwendet die <xref:System.Double> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere `Nullable<Double>` in C# Visual Basic oder `Nullable(Of Double)`.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf, und gibt den minimalen <see cref="T:System.Int32" />-Wert zurück, der NULL-Werte zulässt</summary>
        <returns>Der Wert vom Typ <c>Nullable&lt;Int32&gt;</c> in C# oder <c>Nullable(Of Int32)</c> in Visual Basic, der dem Mindestwert in der Sequenz entspricht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%29>-Methode verwendet die <xref:System.Int32> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member der Quelle in einen numerischen Typ projiziert, insbesondere `Nullable<Int32>` C# in Visual Basic oder `Nullable(Of Int32)`.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf, und gibt den minimalen <see cref="T:System.Int64" />-Wert zurück, der NULL-Werte zulässt</summary>
        <returns>Der Wert vom Typ <c>Nullable&lt;Int64&gt;</c> in C# oder <c>Nullable(Of Int64)</c> in Visual Basic, der dem Mindestwert in der Sequenz entspricht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%29>-Methode verwendet die <xref:System.Int64> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere `Nullable<Int64>` in C# Visual Basic oder `Nullable(Of Int64)`.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf, und gibt den minimalen <see cref="T:System.Single" />-Wert zurück, der NULL-Werte zulässt</summary>
        <returns>Der Wert des Typs <c>Nullable&lt;Single&gt;</c> in C# oder <c>Nullable(Of Single)</c> in Visual Basic, der dem Mindestwert in der Sequenz entspricht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%29>-Methode verwendet die <xref:System.Single> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere `Nullable<Single>` in C# Visual Basic oder `Nullable(Of Single)`.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer Sequenz eine Transformationsfunktion auf, und gibt den minimalen <see cref="T:System.Single" />-Wert zurück</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29>-Methode verwendet die <xref:System.Single> Implementierung von <xref:System.IComparable%601>, um Werte zu vergleichen.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere <xref:System.Single>.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="source" /> enthält keine Elemente.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Min&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Min&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Min(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TResult Min(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Min : seq&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; 'Result" Usage="System.Linq.Enumerable.Min (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Der Typ des von <paramref name="selector" /> zurückgegebenen Werts.</typeparam>
        <param name="source">Eine Sequenz von Werten, deren Mindestwert bestimmt werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Ruft für jedes Element einer generischen Sequenz eine Transformationsfunktion auf, und gibt den niedrigsten Ergebniswert zurück</summary>
        <returns>Der Mindestwert in der Sequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Type `TResult` <xref:System.IComparable%601>implementiert, verwendet diese Methode diese Implementierung, um Werte zu vergleichen. Andernfalls, wenn Type `TResult` <xref:System.IComparable>implementiert, wird diese Implementierung zum Vergleichen von Werten verwendet.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Min()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Min%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> verwendet wird, um den minimalen Wert in einer Sequenz von projizierten Werten zu bestimmen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="OfType&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; OfType&lt;TResult&gt; (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; OfType&lt;TResult&gt;(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OfType``1(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OfType(Of TResult) (source As IEnumerable) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ OfType(System::Collections::IEnumerable ^ source);" />
      <MemberSignature Language="F#" Value="static member OfType : System.Collections.IEnumerable -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.OfType source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ, nach dem die Elemente der Sequenz gefiltert werden sollen.</typeparam>
        <param name="source">Das <see cref="T:System.Collections.IEnumerable" />, dessen Elemente gefiltert werden sollen</param>
        <summary>Filtert die Elemente eines <see cref="T:System.Collections.IEnumerable" /> anhand eines angegebenen Typs</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das Elemente aus der Eingabesequenz vom Typ <paramref name="TResult" /> enthält</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Die <xref:System.Linq.Enumerable.OfType%60%601%28System.Collections.IEnumerable%29>-Methode gibt nur die Elemente in `source` zurück, die in den Typ `TResult`umgewandelt werden können. Um stattdessen eine Ausnahme zu erhalten, wenn ein Element nicht in den Typ `TResult`umgewandelt werden kann, verwenden Sie <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>.  
  
 Diese Methode ist eine der wenigen Standard Abfrage Operator-Methoden, die auf eine Auflistung angewendet werden können, die über einen nicht parametrisierten Typ verfügt, z. b. einen <xref:System.Collections.ArrayList>. Dies liegt daran, dass <xref:System.Linq.Enumerable.OfType%2A> den Typ <xref:System.Collections.IEnumerable>erweitert. <xref:System.Linq.Enumerable.OfType%2A> kann nicht nur auf Auflistungen angewendet werden, die auf dem parametrisierten <xref:System.Collections.Generic.IEnumerable%601> Typ basieren, sondern auch auf Sammlungen, die auf dem nicht parametrisierten <xref:System.Collections.IEnumerable> Typ basieren.  
  
 Durch Anwenden von <xref:System.Linq.Enumerable.OfType%2A> auf eine Auflistung, die <xref:System.Collections.IEnumerable>implementiert, erhalten Sie die Möglichkeit, die Auflistung mithilfe der Standard Abfrage Operatoren abzufragen. Wenn Sie z. b. ein Typargument von <xref:System.Object> für <xref:System.Linq.Enumerable.OfType%2A> angeben, wird ein C# Objekt des Typs `IEnumerable<Object>` in oder `IEnumerable(Of Object)` in Visual Basic zurückgegeben, auf den die Standard Abfrage Operatoren angewendet werden können.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.OfType%2A> zum Filtern der Elemente einer <xref:System.Collections.IEnumerable>verwendet wird.  
  
 [!code-csharp[System.Linq.Enumerable#69](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#69)]
 [!code-vb[System.Linq.Enumerable#69](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortiert die Elemente einer Sequenz in aufsteigender Reihenfolge</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ OrderBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.OrderBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <summary>Sortiert die Elemente einer Sequenz in aufsteigender Reihenfolge nach einem Schlüssel</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedEnumerable`1" />, dessen Elemente nach einem Schlüssel sortiert werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Um eine Sequenz nach den Werten der Elemente selbst zu sortieren, geben Sie die Identitäts Funktion (`x => x` in C# Visual oder `Function(x) x` in Visual Basic) für `keySelector`an.  
  
 Es werden zwei Methoden definiert, um den Typ <xref:System.Linq.IOrderedEnumerable%601>zu erweitern, d. h. den Rückgabetyp dieser Methode. Diese beiden Methoden, nämlich `ThenBy` und `ThenByDescending`, ermöglichen es Ihnen, zusätzliche Sortierkriterien zum Sortieren einer Sequenz anzugeben. `ThenBy` und `ThenByDescending` geben auch eine <xref:System.Linq.IOrderedEnumerable%601>zurück. Dies bedeutet, dass eine beliebige Anzahl aufeinander folgender Aufrufe an `ThenBy` oder `ThenByDescending` erfolgen kann.  
  
> [!NOTE]
>  Da <xref:System.Linq.IOrderedEnumerable%601> von <xref:System.Collections.Generic.IEnumerable%601>erbt, können Sie <xref:System.Linq.Enumerable.OrderBy%2A> oder <xref:System.Linq.Enumerable.OrderByDescending%2A> auf die Ergebnisse eines Aufrufes <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> oder <xref:System.Linq.Enumerable.ThenByDescending%2A>aufzurufen. Dadurch wird eine neue primäre Reihenfolge eingeführt, die die zuvor festgelegte Reihenfolge ignoriert.  
  
 Diese Methode vergleicht Schlüssel mit dem Standardcomparer <xref:System.Collections.Generic.Comparer%601.Default%2A>.  
  
 Diese Methode führt eine stabile Sortierung aus. Das heißt, wenn die Schlüssel zweier Elemente gleich sind, wird die Reihenfolge der Elemente beibehalten. Im Gegensatz dazu behält eine instabile Sortierung nicht die Reihenfolge von Elementen mit demselben Schlüssel bei.  
  
 In der Abfrage Ausdruckssyntax wird eine `orderby` ( C#Visual) oder `Order By` (Visual Basic)-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.OrderBy%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.OrderBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> zum Sortieren der Elemente einer Sequenz verwendet wird.  
  
 [!code-csharp[System.Linq.Enumerable#70](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#70)]
 [!code-vb[System.Linq.Enumerable#70](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#70)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        <altmember cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
        <related type="Article" href="~/docs/csharp/language-reference/keywords/orderby-clause.md">orderby-Klausel (C#-Referenz)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/order-by-clause.md">ORDER BY-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderBy(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ OrderBy(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderBy : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.OrderBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Sortiert die Elemente einer Sequenz mithilfe eines angegebenen Vergleichs in aufsteigender Reihenfolge</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedEnumerable`1" />, dessen Elemente nach einem Schlüssel sortiert werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Um eine Sequenz nach den Werten der Elemente selbst zu sortieren, geben Sie die Identitäts Funktion (`x => x` in C# Visual oder `Function(x) x` in Visual Basic) für `keySelector`an.  
  
 Es werden zwei Methoden definiert, um den Typ <xref:System.Linq.IOrderedEnumerable%601>zu erweitern, d. h. den Rückgabetyp dieser Methode. Diese beiden Methoden, nämlich `ThenBy` und `ThenByDescending`, ermöglichen es Ihnen, zusätzliche Sortierkriterien zum Sortieren einer Sequenz anzugeben. `ThenBy` und `ThenByDescending` geben auch eine <xref:System.Linq.IOrderedEnumerable%601>zurück. Dies bedeutet, dass eine beliebige Anzahl aufeinander folgender Aufrufe an `ThenBy` oder `ThenByDescending` erfolgen kann.  
  
> [!NOTE]
>  Da <xref:System.Linq.IOrderedEnumerable%601> von <xref:System.Collections.Generic.IEnumerable%601>erbt, können Sie <xref:System.Linq.Enumerable.OrderBy%2A> oder <xref:System.Linq.Enumerable.OrderByDescending%2A> auf die Ergebnisse eines Aufrufes <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> oder <xref:System.Linq.Enumerable.ThenByDescending%2A>aufzurufen. Dadurch wird eine neue primäre Reihenfolge eingeführt, die die zuvor festgelegte Reihenfolge ignoriert.  
  
 Wenn `comparer` `null`ist, wird der Standardcomparer <xref:System.Collections.Generic.Comparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet.  
  
 Diese Methode führt eine stabile Sortierung aus. Das heißt, wenn die Schlüssel zweier Elemente gleich sind, wird die Reihenfolge der Elemente beibehalten. Im Gegensatz dazu behält eine instabile Sortierung nicht die Reihenfolge von Elementen mit demselben Schlüssel bei.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        <altmember cref="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortiert die Elemente einer Sequenz in absteigender Reihenfolge.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ OrderByDescending(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.OrderByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <summary>Sortiert die Elemente einer Sequenz in absteigender Reihenfolge nach einem Schlüssel</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedEnumerable`1" />, dessen Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Um eine Sequenz nach den Werten der Elemente selbst zu sortieren, geben Sie die Identitäts Funktion (`x => x` in C# Visual oder `Function(x) x` in Visual Basic) für `keySelector`an.  
  
 Ein Beispiel für diese Methode finden Sie unter <xref:System.Linq.Enumerable.OrderByDescending%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29>.  
  
 Es werden zwei Methoden definiert, um den Typ <xref:System.Linq.IOrderedEnumerable%601>zu erweitern, d. h. den Rückgabetyp dieser Methode. Diese beiden Methoden, nämlich `ThenBy` und `ThenByDescending`, ermöglichen es Ihnen, zusätzliche Sortierkriterien zum Sortieren einer Sequenz anzugeben. `ThenBy` und `ThenByDescending` geben auch eine <xref:System.Linq.IOrderedEnumerable%601>zurück. Dies bedeutet, dass eine beliebige Anzahl aufeinander folgender Aufrufe an `ThenBy` oder `ThenByDescending` erfolgen kann.  
  
> [!NOTE]
>  Da <xref:System.Linq.IOrderedEnumerable%601> von <xref:System.Collections.Generic.IEnumerable%601>erbt, können Sie <xref:System.Linq.Enumerable.OrderBy%2A> oder <xref:System.Linq.Enumerable.OrderByDescending%2A> auf die Ergebnisse eines Aufrufes <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> oder <xref:System.Linq.Enumerable.ThenByDescending%2A>aufzurufen. Dadurch wird eine neue primäre Reihenfolge eingeführt, die die zuvor festgelegte Reihenfolge ignoriert.  
  
 Diese Methode vergleicht Schlüssel mit dem Standardcomparer <xref:System.Collections.Generic.Comparer%601.Default%2A>.  
  
 Diese Methode führt eine stabile Sortierung aus. Das heißt, wenn die Schlüssel zweier Elemente gleich sind, wird die Reihenfolge der Elemente beibehalten. Im Gegensatz dazu behält eine instabile Sortierung nicht die Reihenfolge von Elementen mit demselben Schlüssel bei.  
  
 In der Abfrage Ausdruckssyntax wird eine `orderby descending` ( C#Visual) oder `Order By Descending` (Visual Basic)-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.OrderByDescending%2A>übersetzt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        <altmember cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
        <related type="Article" href="~/docs/csharp/language-reference/keywords/orderby-clause.md">orderby-Klausel (C#-Referenz)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/order-by-clause.md">ORDER BY-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function OrderByDescending(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ OrderByDescending(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member OrderByDescending : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.OrderByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Eine Sequenz von anzuordnenden Werten.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus einem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Sortiert die Elemente einer Sequenz mithilfe eines angegebenen Vergleichs in absteigender Reihenfolge.</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedEnumerable`1" />, dessen Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Um eine Sequenz nach den Werten der Elemente selbst zu sortieren, geben Sie die Identitäts Funktion (`x => x` in C# Visual oder `Function(x) x` in Visual Basic) für `keySelector`an.  
  
 Es werden zwei Methoden definiert, um den Typ <xref:System.Linq.IOrderedEnumerable%601>zu erweitern, d. h. den Rückgabetyp dieser Methode. Diese beiden Methoden, nämlich `ThenBy` und `ThenByDescending`, ermöglichen es Ihnen, zusätzliche Sortierkriterien zum Sortieren einer Sequenz anzugeben. `ThenBy` und `ThenByDescending` geben auch eine <xref:System.Linq.IOrderedEnumerable%601>zurück. Dies bedeutet, dass eine beliebige Anzahl aufeinander folgender Aufrufe an `ThenBy` oder `ThenByDescending` erfolgen kann.  
  
> [!NOTE]
>  Da <xref:System.Linq.IOrderedEnumerable%601> von <xref:System.Collections.Generic.IEnumerable%601>erbt, können Sie <xref:System.Linq.Enumerable.OrderBy%2A> oder <xref:System.Linq.Enumerable.OrderByDescending%2A> auf die Ergebnisse eines Aufrufes <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> oder <xref:System.Linq.Enumerable.ThenByDescending%2A>aufzurufen. Dadurch wird eine neue primäre Reihenfolge eingeführt, die die zuvor festgelegte Reihenfolge ignoriert.  
  
 Wenn `comparer` `null`ist, wird der Standardcomparer <xref:System.Collections.Generic.Comparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet.  
  
 Diese Methode führt eine stabile Sortierung aus. Das heißt, wenn die Schlüssel zweier Elemente gleich sind, wird die Reihenfolge der Elemente beibehalten. Im Gegensatz dazu behält eine instabile Sortierung nicht die Reihenfolge von Elementen mit demselben Schlüssel bei.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.OrderByDescending%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> verwendet wird, um die Elemente einer Sequenz in absteigender Reihenfolge zu sortieren, indem eine Transformations Funktion und ein benutzerdefinierter Vergleich verwendet wird.  
  
 [!code-csharp[System.Linq.Enumerable#71](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#71)]
 [!code-vb[System.Linq.Enumerable#71](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#71)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
        <altmember cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      </Docs>
    </Member>
    <Member MemberName="Prepend&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Prepend&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Prepend&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Prepend(Of TSource) (source As IEnumerable(Of TSource), element As TSource) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Prepend(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, TSource element);" />
      <MemberSignature Language="F#" Value="static member Prepend : seq&lt;'Source&gt; * 'Source -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Prepend (source, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netstandard-2.1" />
        <Parameter Name="element" Type="TSource" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Wertesequenz.</param>
        <param name="element">Der <paramref name="source" /> voranzustellende Wert.</param>
        <summary>Fügt einen Wert am Anfang der Sequenz ein.</summary>
        <returns>Eine neue Sequenz, die mit <paramref name="element" /> beginnt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[    
          
## Remarks  
  
> [!NOTE]
>  Diese Methode ändert nicht die Elemente der Auflistung. Stattdessen wird eine Kopie der Auflistung mit dem neuen Element erstellt.
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.Prepend%2A> ein Wert am Anfang der Sequenz vorangestellt wird.  
  
 [!code-csharp[System.Linq.Enumerable#202](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#202)]
 [!code-vb[System.Linq.Enumerable#202](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#202)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Range">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;int&gt; Range (int start, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;int32&gt; Range(int32 start, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Range(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Range (start As Integer, count As Integer) As IEnumerable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;int&gt; ^ Range(int start, int count);" />
      <MemberSignature Language="F#" Value="static member Range : int * int -&gt; seq&lt;int&gt;" Usage="System.Linq.Enumerable.Range (start, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Der Wert der ersten ganzen Zahl in der Sequenz.</param>
        <param name="count">Die Anzahl der aufeinander folgenden ganzen Zahlen, die generiert werden sollen.</param>
        <summary>Generiert eine Sequenz von ganzen Zahlen in einem angegebenen Bereich</summary>
        <returns>Eine <c>IEnumerable&lt;Int32&gt;</c>-Schnittstelle in C# oder <c>IEnumerable(Of Int32)</c> in Visual Basic, die einen Bereich sequenzieller ganzer Zahlen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Range%2A> verwendet wird, um eine Sequenz von-Werten zu generieren.  
  
 [!code-csharp[System.Linq.Enumerable#72](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#72)]
 [!code-vb[System.Linq.Enumerable#72](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#72)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="start" /> + <paramref name="count" /> -1 ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Repeat&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Repeat&lt;TResult&gt; (TResult element, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Repeat&lt;TResult&gt;(!!TResult element, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Repeat``1(``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Repeat(Of TResult) (element As TResult, count As Integer) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Repeat(TResult element, int count);" />
      <MemberSignature Language="F#" Value="static member Repeat : 'Result * int -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Repeat (element, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="element" Type="TResult" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Der Typ des Werts, der in der Ergebnissequenz wiederholt werden soll.</typeparam>
        <param name="element">Der zu wiederholende Wert.</param>
        <param name="count">Die gewünschte Anzahl der Wiederholungen des Werts in der generierten Sequenz.</param>
        <summary>Generiert eine Sequenz, die einen Wert mehrfach enthält</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das einen wiederholten Wert enthält</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Repeat%2A> verwendet wird, um eine Sequenz eines wiederholten Werts zu generieren.  
  
 [!code-csharp[System.Linq.Enumerable#73](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#73)]
 [!code-vb[System.Linq.Enumerable#73](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#73)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ist kleiner als 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Reverse&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Reverse&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reverse(Of TSource) (source As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Reverse(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Reverse : seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Reverse source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine umzukehrende Sequenz von Werten.</param>
        <summary>Kehrt die Reihenfolge der Elemente in einer Sequenz um</summary>
        <returns>Eine Sequenz , deren Elemente den Elementen der Eingabesequenz in umgekehrter Reihenfolge entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Im Gegensatz zu <xref:System.Linq.Enumerable.OrderBy%2A>berücksichtigt diese Sortiermethode nicht die eigentlichen Werte selbst, um die Reihenfolge zu bestimmen. Stattdessen werden nur die Elemente in umgekehrter Reihenfolge zurückgegeben, aus denen Sie von der zugrunde liegenden Quelle erstellt werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Reverse%2A> verwendet wird, um die Reihenfolge der Elemente in einem Array umzukehren.  
  
 [!code-csharp[System.Linq.Enumerable#74](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#74)]
 [!code-vb[System.Linq.Enumerable#74](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#74)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Projiziert jedes Element einer Sequenz in ein neues Format.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Select(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : seq&lt;'Source&gt; * Func&lt;'Source, int, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Der Typ des von <paramref name="selector" /> zurückgegebenen Werts.</typeparam>
        <param name="source">Eine Sequenz von Werten, für die eine Transformationsfunktion aufgerufen werden soll.</param>
        <param name="selector">Eine Transformierenfunktion, die auf jedes Quellelement angewendet werden soll. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein neues Format, indem der Index des Elements integriert wird</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen Elemente das Ergebnis des Aufrufs einer Transformationsfunktion für jedes Element von <paramref name="source" /> sind</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Das erste Argument für `selector` das das zu verarbeitende Element darstellt. Das zweite Argument für `selector` stellt den NULL basierten Index dieses Elements in der Quell Sequenz dar. Dies kann hilfreich sein, wenn sich die Elemente in einer bekannten Reihenfolge befinden und Sie beispielsweise mit einem Element an einem bestimmten Index vorgehen möchten. Dies kann auch hilfreich sein, wenn Sie den Index von einem oder mehreren Elementen abrufen möchten.  
  
 Diese Projektions Methode erfordert, dass die Transformations Funktion `selector`einen Wert für jeden Wert in der Quell Sequenz, `source`, erzeugt. Wenn `selector` einen Wert zurückgibt, der selbst eine Auflistung ist, muss der Consumer die unter Sequenzen manuell durchlaufen. In einer solchen Situation ist es möglicherweise besser, wenn die Abfrage eine einzelne zusammengefügte Sequenz von Werten zurückgibt. Um dies zu erreichen, verwenden Sie die <xref:System.Linq.Enumerable.SelectMany%2A>-Methode anstelle von <xref:System.Linq.Enumerable.Select%2A>. Obwohl `SelectMany` ähnlich wie `Select`funktioniert, unterscheidet sich dies insofern, als dass die Transform-Funktion eine Auflistung zurückgibt, die dann durch `SelectMany` erweitert wird, bevor Sie zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Select%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%29> verwendet wird, um eine Sequenz von Werten zu projizieren und den Index der einzelnen Elemente zu verwenden.  
  
 [!code-csharp-interactive[System.Linq.Enumerable#76](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#76)]
 [!code-vb[System.Linq.Enumerable#76](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#76)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Select(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Select(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TResult&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Select : seq&lt;'Source&gt; * Func&lt;'Source, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Select (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Der Typ des von <paramref name="selector" /> zurückgegebenen Werts.</typeparam>
        <param name="source">Eine Sequenz von Werten, für die eine Transformationsfunktion aufgerufen werden soll.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein neues Format.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen Elemente das Ergebnis des Aufrufs einer Transformationsfunktion für jedes Element von <paramref name="source" /> sind</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Diese Projektions Methode erfordert, dass die Transformations Funktion `selector`einen Wert für jeden Wert in der Quell Sequenz, `source`, erzeugt. Wenn `selector` einen Wert zurückgibt, der selbst eine Auflistung ist, muss der Consumer die unter Sequenzen manuell durchlaufen. In einer solchen Situation ist es möglicherweise besser, wenn die Abfrage eine einzelne zusammengefügte Sequenz von Werten zurückgibt. Um dies zu erreichen, verwenden Sie die <xref:System.Linq.Enumerable.SelectMany%2A>-Methode anstelle von <xref:System.Linq.Enumerable.Select%2A>. Obwohl `SelectMany` ähnlich wie `Select`funktioniert, unterscheidet sich dies insofern, als dass die Transform-Funktion eine Auflistung zurückgibt, die dann durch `SelectMany` erweitert wird, bevor Sie zurückgegeben wird.  
  
 In der Abfrage Ausdruckssyntax wird eine `select` ( C#Visual) oder `Select` (Visual Basic)-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Select%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Select%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> verwendet wird, um eine Sequenz von-Werten zu projizieren.  
  
 [!code-csharp-interactive[System.Linq.Enumerable#75](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#75)]
 [!code-vb[System.Linq.Enumerable#75](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#75)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/csharp/language-reference/keywords/select-clause.md">select-Klausel (C#-Referenz)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/select-clause.md">Select-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SelectMany&lt;TSource,TResult&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, und fasst die resultierenden Sequenzen in einer einzigen Sequenz zusammen</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, IEnumerable(Of TResult))) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ SelectMany(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : seq&lt;'Source&gt; * Func&lt;'Source, seq&lt;'Result&gt;&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Der Typ der von <paramref name="selector" /> zurückgegebenen Elemente der Sequenz.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, und fasst die resultierenden Sequenzen in einer einzigen Sequenz zusammen</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen Elemente das Ergebnis eines Aufrufs der 1:n-Transformationsfunktion für jedes Element der Eingabesequenz sind</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Die <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>-Methode listet die Eingabe Sequenz auf, verwendet eine Transformations Funktion, um jedes Element einem <xref:System.Collections.Generic.IEnumerable%601>zuzuordnen, und listet dann die Elemente jedes solchen <xref:System.Collections.Generic.IEnumerable%601> Objekts auf und gibt Sie aus. Das heißt, für jedes Element von `source`wird `selector` aufgerufen und eine Sequenz von Werten zurückgegeben. <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> dann diese zweidimensionale Auflistung von Auflistungen zu einem eindimensionalen <xref:System.Collections.Generic.IEnumerable%601> und gibt Sie zurück. Wenn eine Abfrage z. b. <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> verwendet, um die Bestellungen (vom Typ `Order`) für jeden Kunden in einer Datenbank abzurufen, ist das Ergebnis vom C# Typ `IEnumerable<Order>` in oder `IEnumerable(Of Order)` in Visual Basic. Wenn die Abfrage stattdessen <xref:System.Linq.Enumerable.Select%2A> zum Abrufen der Aufträge verwendet, wird die Auflistung von Auftrags Sammlungen nicht kombiniert, und das Ergebnis ist vom Typ `IEnumerable<List<Order>>` in C# Visual Basic oder `IEnumerable(Of List(Of Order))`.  
  
 In der Abfrage Ausdruckssyntax wird jede `from`-Klausel C#(Visual) oder `From`-Klausel (Visual Basic) nach der ersten-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.SelectMany%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> verwendet wird, um eine 1: n-Projektion über ein Array auszuführen.  
  
 [!code-csharp[System.Linq.Enumerable#77](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#77)]
 [!code-vb[System.Linq.Enumerable#77](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#77)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/csharp/language-reference/keywords/from-clause.md">from-Klausel (C#-Referenz)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/from-clause.md">From-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TResult) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer, IEnumerable(Of TResult))) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ SelectMany(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TResult&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : seq&lt;'Source&gt; * Func&lt;'Source, int, seq&lt;'Result&gt;&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.SelectMany (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TResult">Der Typ der von <paramref name="selector" /> zurückgegebenen Elemente der Sequenz.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="selector">Eine Transformierenfunktion, die auf jedes Quellelement angewendet werden soll. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, und fasst die resultierenden Sequenzen zu einer einzigen Sequenz zusammen Der Index jedes Quellelements wird im projizierten Format des jeweiligen Elements verwendet.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen Elemente das Ergebnis eines Aufrufs der 1:n-Transformationsfunktion für jedes Element einer Eingabesequenz sind</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Die <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>-Methode listet die Eingabe Sequenz auf, verwendet eine Transformations Funktion, um jedes Element einem <xref:System.Collections.Generic.IEnumerable%601>zuzuordnen, und listet dann die Elemente jedes solchen <xref:System.Collections.Generic.IEnumerable%601> Objekts auf und gibt Sie aus. Das heißt, für jedes Element von `source`wird `selector` aufgerufen und eine Sequenz von Werten zurückgegeben. <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> dann diese zweidimensionale Auflistung von Auflistungen zu einem eindimensionalen <xref:System.Collections.Generic.IEnumerable%601> und gibt Sie zurück. Wenn eine Abfrage z. b. <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> verwendet, um die Bestellungen (vom Typ `Order`) für jeden Kunden in einer Datenbank abzurufen, ist das Ergebnis vom C# Typ `IEnumerable<Order>` in oder `IEnumerable(Of Order)` in Visual Basic. Wenn die Abfrage stattdessen <xref:System.Linq.Enumerable.Select%2A> zum Abrufen der Aufträge verwendet, wird die Auflistung von Auftrags Sammlungen nicht kombiniert, und das Ergebnis ist vom Typ `IEnumerable<List<Order>>` in C# Visual Basic oder `IEnumerable(Of List(Of Order))`.  
  
 Das erste Argument für `selector` das das zu verarbeitende Element darstellt. Das zweite Argument für `selector` stellt den NULL basierten Index dieses Elements in der Quell Sequenz dar. Dies kann hilfreich sein, wenn sich die Elemente in einer bekannten Reihenfolge befinden und Sie beispielsweise mit einem Element an einem bestimmten Index vorgehen möchten. Dies kann auch hilfreich sein, wenn Sie den Index von einem oder mehreren Elementen abrufen möchten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> verwendet wird, um eine 1: n-Projektion über ein Array auszuführen und den Index der einzelnen äußeren Elemente zu verwenden.  
  
 [!code-csharp[System.Linq.Enumerable#78](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#78)]
 [!code-vb[System.Linq.Enumerable#78](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#78)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As IEnumerable(Of TSource), collectionSelector As Func(Of TSource, IEnumerable(Of TCollection)), resultSelector As Func(Of TSource, TCollection, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ SelectMany(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^ collectionSelector, Func&lt;TSource, TCollection, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : seq&lt;'Source&gt; * Func&lt;'Source, seq&lt;'Collection&gt;&gt; * Func&lt;'Source, 'Collection, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TCollection">Der Typ der Zwischenelemente, die von <paramref name="collectionSelector" /> erfasst werden.</typeparam>
        <typeparam name="TResult">Der Typ der Elemente in der resultierenden Sequenz.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="collectionSelector">Eine Transformationsfunktion, die auf jedes Element der Eingabesequenz angewendet werden soll</param>
        <param name="resultSelector">Eine Transformationsfunktion, die auf jedes Element der Zwischensequenz angewendet werden soll</param>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, fasst die resultierenden Sequenzen zu einer einzigen Sequenz zusammen und ruft für jedes Element in dieser Sequenz eine Ergebnisauswahlfunktion auf.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen Elemente erzeugt werden, indem für jedes Element von <paramref name="collectionSelector" /> die 1:n-Transformationsfunktion <paramref name="source" /> aufgerufen wird, und anschließend jedes Element der Sequenz und sein entsprechendes Quellelement einem Ergebniselement zugeordnet werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Die <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>-Methode ist nützlich, wenn Sie die Elemente `source` im Gültigkeitsbereich der Abfrage Logik aufbewahren müssen, die nach dem <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>-Aufrufvorgang auftritt. Ein Codebeispiel hierfür finden Sie im Beispielabschnitt. Wenn eine bidirektionale Beziehung zwischen Objekten vom Typ `TSource` und Objekten vom Typ `TCollection`vorhanden ist, d. h., wenn ein Objekt vom Typ `TCollection` eine Eigenschaft zum Abrufen des `TSource` Objekts bereitstellt, das es erzeugt hat, benötigen Sie diese Überladung von <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>nicht. Stattdessen können Sie <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> verwenden und durch das `TCollection`-Objekt zurück zum `TSource` Objekt navigieren.  
  
 In der Abfrage Ausdruckssyntax wird jede `from`-Klausel C#(Visual) oder `From`-Klausel (Visual Basic) nach der ersten-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.SelectMany%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29> verwendet wird, um eine 1: n-Projektion über ein Array auszuführen und eine Ergebnis Auswahlfunktion zu verwenden, um jedes entsprechende Element aus der Quell Sequenz im Gültigkeitsbereich des letzten Aufrufes `Select`beizubehalten.  
  
 [!code-csharp[System.Linq.Enumerable#124](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#124)]
 [!code-vb[System.Linq.Enumerable#124](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#124)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="collectionSelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/csharp/language-reference/keywords/from-clause.md">from-Klausel (C#-Referenz)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/from-clause.md">From-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SelectMany(Of TSource, TCollection, TResult) (source As IEnumerable(Of TSource), collectionSelector As Func(Of TSource, Integer, IEnumerable(Of TCollection)), resultSelector As Func(Of TSource, TCollection, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TCollection, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ SelectMany(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, System::Collections::Generic::IEnumerable&lt;TCollection&gt; ^&gt; ^ collectionSelector, Func&lt;TSource, TCollection, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member SelectMany : seq&lt;'Source&gt; * Func&lt;'Source, int, seq&lt;'Collection&gt;&gt; * Func&lt;'Source, 'Collection, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.SelectMany (source, collectionSelector, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TCollection">Der Typ der Zwischenelemente, die von <paramref name="collectionSelector" /> erfasst werden.</typeparam>
        <typeparam name="TResult">Der Typ der Elemente in der resultierenden Sequenz.</typeparam>
        <param name="source">Eine Sequenz von zu projizierenden Werten.</param>
        <param name="collectionSelector">Eine Transformierenfunktion, die auf jedes Quellelement angewendet werden soll. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <param name="resultSelector">Eine Transformationsfunktion, die auf jedes Element der Zwischensequenz angewendet werden soll</param>
        <summary>Projiziert jedes Element einer Sequenz in ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, fasst die resultierenden Sequenzen zu einer einzigen Sequenz zusammen und ruft für jedes Element in dieser Sequenz eine Ergebnisauswahlfunktion auf. Der Index jedes Quellelements wird im projizierten Zwischenformat des jeweiligen Elements verwendet.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen Elemente erzeugt werden, indem für jedes Element von <paramref name="collectionSelector" /> die 1:n-Transformationsfunktion <paramref name="source" /> aufgerufen wird, und anschließend jedes Element der Sequenz und sein entsprechendes Quellelement einem Ergebniselement zugeordnet werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Die <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>-Methode ist nützlich, wenn Sie die Elemente `source` im Gültigkeitsbereich der Abfrage Logik aufbewahren müssen, die nach dem <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>-Aufrufvorgang auftritt. Ein Codebeispiel hierfür finden Sie im Beispielabschnitt. Wenn eine bidirektionale Beziehung zwischen Objekten vom Typ `TSource` und Objekten vom Typ `TCollection`vorhanden ist, d. h., wenn ein Objekt vom Typ `TCollection` eine Eigenschaft zum Abrufen des `TSource` Objekts bereitstellt, das es erzeugt hat, benötigen Sie diese Überladung von <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>nicht. Stattdessen können Sie <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> verwenden und durch das `TCollection`-Objekt zurück zum `TSource` Objekt navigieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="collectionSelector" /> oder <paramref name="resultSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SequenceEqual&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob zwei Sequenzen durch einen Gleichheitsvergleich als gleich bestimmt werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : seq&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Enumerable.SequenceEqual (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das mit <paramref name="second" /> verglichen werden soll.</param>
        <param name="second">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das mit der ersten Sequenz verglichen werden soll</param>
        <summary>Bestimmt, ob zwei Sequenzen gleich sind, indem die Elemente mithilfe des Standardgleichheitsvergleichs für ihren Typ verglichen werden</summary>
        <returns><see langword="true" />, wenn die zwei Quellsequenzen von gleicher Länge sind und ihre entsprechenden Elemente durch den Standardgleichheitsvergleich für ihren Typ als gleich bestimmt werden, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `SequenceEqual<TSource>(IEnumerable<TSource>, IEnumerable<TSource>)`-Methode listet die beiden Quell Sequenzen parallel auf und vergleicht entsprechende Elemente mithilfe des Standard Gleichheits Vergleichs für `TSource`<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>. 

 Der Standard Gleichheits Vergleich, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, wird verwendet, um Werte der Typen zu vergleichen. Um einen benutzerdefinierten Datentyp zu vergleichen, müssen Sie die <xref:System.Object.Equals%2A> und die <xref:System.Object.GetHashCode%2A> Methoden überschreiben und optional die <xref:System.IEquatable%601> generische Schnittstelle in den benutzerdefinierten Typ implementieren. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>-Eigenschaft.
  
## Examples  
 In den folgenden Codebeispielen wird veranschaulicht, wie `SequenceEqual<TSource>(IEnumerable<TSource>, IEnumerable<TSource>)` verwendet wird, um zu bestimmen, ob zwei Sequenzen gleich sind. In den ersten beiden Beispielen bestimmt die-Methode, ob die verglichenen Sequenzen Verweise auf dieselben Objekte enthalten. Im dritten und vierten Beispiel vergleicht die-Methode die tatsächlichen Daten der Objekte innerhalb der Sequenzen.  
  
 In diesem Beispiel sind die Sequenzen gleich.  
  
 [!code-csharp[System.Linq.Enumerable#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#32)]
 [!code-vb[System.Linq.Enumerable#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#32)]  
  
 Im folgenden Codebeispiel werden zwei Sequenzen verglichen, die nicht gleich sind. Beachten Sie, dass die Sequenzen identische Daten enthalten, aber da die Objekte, die Sie enthalten, über unterschiedliche Verweise verfügen, werden die Sequenzen nicht als gleich betrachtet.  
  
 [!code-csharp[System.Linq.Enumerable#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#33)]
 [!code-vb[System.Linq.Enumerable#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#33)]  
  
 Wenn Sie die eigentlichen Daten der Objekte in den Sequenzen vergleichen möchten, anstatt nur Ihre Verweise zu vergleichen, müssen Sie die <xref:System.Collections.Generic.IEqualityComparer%601> generische Schnittstelle in der Klasse implementieren. Im folgenden Codebeispiel wird gezeigt, wie diese Schnittstelle in einer Hilfsklasse implementiert wird und <xref:System.Object.GetHashCode%2A>-und <xref:System.Object.Equals%2A> Methoden bereitgestellt werden.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
 [!code-vb[CSLINQEncapsulatedComparer#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#9)]  

 Nachdem Sie diese Schnittstelle implementiert haben, können Sie Sequenzen von `ProductA` Objekten in der `SequenceEqual<TSource>(IEnumerable<TSource>, IEnumerable<TSource>)`-Methode verwenden, wie im folgenden Beispiel gezeigt:
  
 [!code-csharp[CSLINQEncapsulatedComparer#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#8)]
 [!code-vb[CSLINQEncapsulatedComparer#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> oder <paramref name="second" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : seq&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; bool" Usage="System.Linq.Enumerable.SequenceEqual (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das mit <paramref name="second" /> verglichen werden soll.</param>
        <param name="second">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das mit der ersten Sequenz verglichen werden soll</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" />, der zum Vergleichen von Elementen verwendet werden soll.</param>
        <summary>Bestimmt, ob zwei Sequenzen gleich sind, indem ihre Elemente mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> verglichen werden</summary>
        <returns><see langword="true" />, wenn die zwei Quellsequenzen von gleicher Länge sind und ihre entsprechenden Elemente gemäß <paramref name="comparer" /> als gleich gelten, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29>-Methode listet die beiden Quell Sequenzen parallel auf und vergleicht entsprechende Elemente mithilfe der angegebenen <xref:System.Collections.Generic.IEqualityComparer%601>. Wenn `comparer` `null`ist, wird der Standard Gleichheits Vergleich (<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>) zum Vergleichen von Elementen verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein Gleichheits Vergleich implementiert wird, der in der <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29>-Methode verwendet werden kann.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Nachdem Sie diesen Vergleich implementiert haben, können Sie Sequenzen von `Product` Objekten in der <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29>-Methode verwenden, wie im folgenden Beispiel gezeigt:  
  
 [!code-csharp[CSLINQCustomComparer#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#8)]
 [!code-vb[CSLINQCustomComparer#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> oder <paramref name="second" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Single&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt ein einzelnes spezifisches Element einer Sequenz zurück</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Single : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Single source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen einziges Element zurückgegeben werden soll</param>
        <summary>Gibt das einzige Element einer Sequenz zurück und löst eine Ausnahme aus, wenn nicht genau ein Element in der Sequenz vorhanden ist.</summary>
        <returns>Das einzige Element der Eingabesequenz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>-Methode löst eine Ausnahme aus, wenn die Eingabe Sequenz leer ist. Wenn Sie stattdessen `null` zurückgeben möchten, wenn die Eingabe Sequenz leer ist, verwenden Sie <xref:System.Linq.Enumerable.SingleOrDefault%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> verwendet wird, um das einzige Element eines Arrays auszuwählen.  
  
 [!code-csharp[System.Linq.Enumerable#79](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#79)]
 [!code-vb[System.Linq.Enumerable#79](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#79)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, dass <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> eine Ausnahme auslöst, wenn die Sequenz nicht genau ein Element enthält.  
  
 [!code-csharp[System.Linq.Enumerable#80](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#80)]
 [!code-vb[System.Linq.Enumerable#80](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#80)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Eingabesequenz enthält mehr als ein Element.  
  
 - oder -  
  
 Die Eingabesequenz ist leer.</exception>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Single(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource Single(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Single : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.Single (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem ein einzelnes Element zurückgegeben werden soll</param>
        <param name="predicate">Eine Funktion zum Überprüfen eines Elements auf eine Bedingung.</param>
        <summary>Gibt das einzige Element einer Sequenz zurück, das eine angegebene Bedingung erfüllt, und löst eine Ausnahme aus, wenn mehrere solche Elemente vorhanden sind.</summary>
        <returns>Das einzige Element der Eingabesequenz, das eine Bedingung erfüllt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>-Methode löst eine Ausnahme aus, wenn die Eingabe Sequenz kein entsprechendes Element enthält. Wenn Sie stattdessen `null` zurückgeben möchten, wenn kein entsprechendes Element gefunden wird, verwenden Sie <xref:System.Linq.Enumerable.SingleOrDefault%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> verwendet wird, um das einzige Element eines Arrays auszuwählen, das eine Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Enumerable#81](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#81)]
 [!code-vb[System.Linq.Enumerable#81](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#81)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, dass <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> eine Ausnahme auslöst, wenn die Sequenz nicht genau ein Element enthält, das die Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Enumerable#82](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#82)]
 [!code-vb[System.Linq.Enumerable#82](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Kein Element erfüllt die Bedingung in <paramref name="predicate" />.  
  
- oder - 
Die Bedingung in <paramref name="predicate" /> wird von mehreren Elementen erfüllt.  
  
- oder - 
Die Quellsequenz ist leer.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SingleOrDefault&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt ein einzelnes spezifisches Element einer Sequenz oder einen Standardwert zurück, wenn dieses Element nicht gefunden wird</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As IEnumerable(Of TSource)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : seq&lt;'Source&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.SingleOrDefault source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen einziges Element zurückgegeben werden soll</param>
        <summary>Gibt das einzige Element einer Sequenz oder einen Standardwert zurück, wenn die Sequenz leer ist. Diese Methode löst eine Ausnahme aus, wenn mehrere Elemente in der Sequenz vorhanden sind.</summary>
        <returns>Das einzige Element der Eingabesequenz oder <see langword="default" />(<paramref name="TSource" />), wenn die Sequenz keine Elemente enthält</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für Verweis-und Werte zulässt-Typen ist `null`.  
  
 Die <xref:System.Linq.Enumerable.SingleOrDefault%2A>-Methode bietet keine Möglichkeit, einen Standardwert anzugeben. Wenn Sie einen anderen Standardwert als `default(TSource)`angeben möchten, verwenden Sie die <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>-Methode, wie im Beispiel Abschnitt beschrieben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> verwendet wird, um das einzige Element eines Arrays auszuwählen.  
  
 [!code-csharp[System.Linq.Enumerable#83](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#83)]
 [!code-vb[System.Linq.Enumerable#83](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#83)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, dass <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> einen Standardwert zurückgibt, wenn die Sequenz nicht genau ein Element enthält.  
  
 [!code-csharp[System.Linq.Enumerable#84](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#84)]
 [!code-vb[System.Linq.Enumerable#84](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#84)]  
  
 Manchmal ist der Wert von `default(TSource)` nicht der Standardwert, den Sie verwenden möchten, wenn die Auflistung keine Elemente enthält. Anstatt das Ergebnis für den unerwünschten Standardwert zu überprüfen und ggf. zu ändern, können Sie die <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29>-Methode verwenden, um den Standardwert anzugeben, den Sie verwenden möchten, wenn die Auflistung leer ist. Rufen Sie dann <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> auf, um das Element zu erhalten. Im folgenden Codebeispiel werden beide Techniken verwendet, um den Standardwert 1 zu erhalten, wenn eine Auflistung von Seitenzahlen leer ist. Da der Standardwert für eine Ganzzahl 0 ist, was normalerweise keine gültige Seitenzahl ist, muss der Standardwert stattdessen als 1 angegeben werden. Die erste Ergebnisvariable wird auf den unerwünschten Standardwert geprüft, nachdem die Ausführung der Abfrage abgeschlossen ist. Die zweite Ergebnisvariable wird mit <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> abgerufen, um den Standardwert 1 anzugeben.  
  
 [!code-csharp[System.Linq.Enumerable#128](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#128)]
 [!code-vb[System.Linq.Enumerable#128](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#128)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Eingabesequenz enthält mehr als ein Element.</exception>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SingleOrDefault(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As TSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TSource SingleOrDefault(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SingleOrDefault : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; 'Source" Usage="System.Linq.Enumerable.SingleOrDefault (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem ein einzelnes Element zurückgegeben werden soll</param>
        <param name="predicate">Eine Funktion zum Überprüfen eines Elements auf eine Bedingung.</param>
        <summary>Gibt das einzige Element einer Sequenz, das eine angegebene Bedingung erfüllt, oder einen Standardwert zurück, wenn kein solches Element vorhanden ist. Diese Methode löst eine Ausnahme aus, wenn mehrere Elemente die Bedingung erfüllen.</summary>
        <returns>Gibt das einzige Element der Eingabesequenz, das die Bedingung erfüllt, oder <see langword="default" />(<paramref name="TSource" />) zurück, wenn ein solches Element nicht gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für Verweis-und Werte zulässt-Typen ist `null`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> verwendet wird, um das einzige Element eines Arrays auszuwählen, das eine Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Enumerable#85](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#85)]
 [!code-vb[System.Linq.Enumerable#85](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#85)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, dass <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> einen Standardwert zurückgibt, wenn die Sequenz nicht genau ein Element enthält, das die Bedingung erfüllt.  
  
 [!code-csharp[System.Linq.Enumerable#86](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#86)]
 [!code-vb[System.Linq.Enumerable#86](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#86)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Bedingung in <paramref name="predicate" /> wird von mehreren Elementen erfüllt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Skip&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Skip&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Skip``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Skip(Of TSource) (source As IEnumerable(Of TSource), count As Integer) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Skip(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Skip : seq&lt;'Source&gt; * int -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Skip (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem Elemente zurückgegeben werden sollen</param>
        <param name="count">Die Anzahl der Elemente, die übersprungen werden sollen, bevor die übrigen Elemente zurückgegeben werden.</param>
        <summary>Umgeht eine festgelegte Anzahl von Elementen in einer Sequenz und gibt dann die übrigen Elemente zurück</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das die Elemente enthält, die nach dem angegebenen Index in der Eingabesequenz auftreten</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Wenn `source` weniger als `count` Elemente enthält, wird ein leerer <xref:System.Collections.Generic.IEnumerable%601> zurückgegeben. Wenn `count` kleiner oder gleich 0 (null) ist, werden alle Elemente `source` zurückgegeben.  
  
 Die Methoden <xref:System.Linq.Enumerable.Take%2A> und <xref:System.Linq.Enumerable.Skip%2A> sind funktionale Ergänzungen. Bei einer Sequenz `coll` und einer ganzzahligen `n`ergibt die Verkettung der Ergebnisse von `coll.Take(n)` und `coll.Skip(n)` dieselbe Sequenz wie `coll`.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Skip`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Skip%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Skip%2A> verwendet wird, um eine angegebene Anzahl von Elementen in einem sortierten Array zu überspringen und die restlichen Elemente zurückzugeben.  
  
 [!code-csharp[System.Linq.Enumerable#87](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#87)]
 [!code-vb[System.Linq.Enumerable#87](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/skip-clause.md">Skip-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="SkipLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipLast&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipLast&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipLast(Of TSource) (source As IEnumerable(Of TSource), count As Integer) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ SkipLast(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member SkipLast : seq&lt;'Source&gt; * int -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.SkipLast (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Umgeht Elemente in einer Sequenz, solange eine angegebene Bedingung true ist, und gibt dann die übrigen Elemente zurück</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ SkipWhile(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem Elemente zurückgegeben werden sollen</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Umgeht Elemente in einer Sequenz, solange eine angegebene Bedingung true ist, und gibt dann die übrigen Elemente zurück</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das die Elemente aus der Eingabesequenz ab dem ersten Element in der linearen Reihe enthält, das die in <paramref name="predicate" /> angegebene Überprüfung nicht besteht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>-Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Diese Methode testet jedes Element von `source` mithilfe von `predicate` und überspringt das-Element, wenn das Ergebnis `true`ist. Wenn die Prädikat Funktion `false` für ein Element zurückgibt, werden dieses Element und die restlichen Elemente in `source` zurückgegeben, und es sind keine weiteren Aufrufe von `predicate`vorhanden.  
  
 Wenn `predicate` `true` für alle Elemente in der Sequenz zurückgibt, wird ein leerer <xref:System.Collections.Generic.IEnumerable%601> zurückgegeben.  
  
 Die Methoden <xref:System.Linq.Enumerable.TakeWhile%2A> und <xref:System.Linq.Enumerable.SkipWhile%2A> sind funktionale Ergänzungen. Bei einer Sequenz `coll` und einer reinen Funktions `p`ergibt die Verkettung der Ergebnisse von `coll.TakeWhile(p)` und `coll.SkipWhile(p)` dieselbe Sequenz wie `coll`.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Skip While`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.SkipWhile%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> verwendet wird, um Elemente eines Arrays zu überspringen, solange eine Bedingung true ist.  
  
 [!code-csharp[System.Linq.Enumerable#88](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#88)]
 [!code-vb[System.Linq.Enumerable#88](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#88)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/skip-while-clause.md">Skip While-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SkipWhile(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ SkipWhile(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member SkipWhile : seq&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.SkipWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem Elemente zurückgegeben werden sollen</param>
        <param name="predicate">Eine Funktion zum Überprüfen jedes Quellelements auf eine Bedingung. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <summary>Umgeht Elemente in einer Sequenz, solange eine angegebene Bedingung true ist, und gibt dann die übrigen Elemente zurück In der Logik der Prädikatfunktion wird der Index des Elements verwendet.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das die Elemente aus der Eingabesequenz ab dem ersten Element in der linearen Reihe enthält, das die in <paramref name="predicate" /> angegebene Überprüfung nicht besteht</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Die <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29>-Methode testet jedes Element `source` mithilfe `predicate` und überspringt das-Element, wenn das Ergebnis `true`ist. Wenn die Prädikat Funktion `false` für ein Element zurückgibt, werden dieses Element und die restlichen Elemente in `source` zurückgegeben, und es sind keine weiteren Aufrufe von `predicate`vorhanden.  
  
 Wenn `predicate` `true` für alle Elemente in der Sequenz zurückgibt, wird ein leerer <xref:System.Collections.Generic.IEnumerable%601> zurückgegeben.  
  
 Das erste Argument von `predicate` das das zu testende Element darstellt. Das zweite Argument stellt den NULL basierten Index des Elements in `source`dar.  
  
 Die Methoden <xref:System.Linq.Enumerable.TakeWhile%2A> und <xref:System.Linq.Enumerable.SkipWhile%2A> sind funktionale Ergänzungen. Bei einer Sequenz `coll` und einer reinen Funktions `p`ergibt die Verkettung der Ergebnisse von `coll.TakeWhile(p)` und `coll.SkipWhile(p)` dieselbe Sequenz wie `coll`.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Skip While`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.SkipWhile%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mit <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> Elemente eines Arrays übersprungen werden, solange eine Bedingung, die vom Index des Elements abhängt, true ist.  
  
 [!code-csharp[System.Linq.Enumerable#89](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#89)]
 [!code-vb[System.Linq.Enumerable#89](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/skip-while-clause.md">Skip While-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sum">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet die Summe einer Sequenz von numerischen Werten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static decimal Sum (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Collections::Generic::IEnumerable&lt;System::Decimal&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Decimal" />-Werten, deren Summe berechnet werden soll</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Decimal" />-Werten</summary>
        <returns>Die Summe der Werte in der Sequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29> Methode gibt 0 (null) zurück, wenn `source` keine Elemente enthält.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Sum()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> verwendet wird, um die Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static double Sum (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Collections::Generic::IEnumerable&lt;double&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;double&gt; -&gt; double" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Double" />-Werten, deren Summe berechnet werden soll</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Double" />-Werten</summary>
        <returns>Die Summe der Werte in der Sequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt 0 (null) zurück, wenn `source` keine Elemente enthält.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Sum()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> verwendet wird, um die Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static int Sum (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Collections::Generic::IEnumerable&lt;int&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;int&gt; -&gt; int" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int32" />-Werten, deren Summe berechnet werden soll</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int32" />-Werten</summary>
        <returns>Die Summe der Werte in der Sequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt 0 (null) zurück, wenn `source` keine Elemente enthält.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Sum()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> verwendet wird, um die Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static long Sum (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Collections::Generic::IEnumerable&lt;long&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int64" />-Werten, deren Summe berechnet werden soll</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int64" />-Werten</summary>
        <returns>Die Summe der Werte in der Sequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt 0 (null) zurück, wenn `source` keine Elemente enthält.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Sum()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> verwendet wird, um die Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Collections::Generic::IEnumerable&lt;Nullable&lt;System::Decimal&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Decimal" />-Werten, die NULL zulassen, und deren Summe berechnet werden soll</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Decimal" />-Werten, die NULL zulassen</summary>
        <returns>Die Summe der Werte in der Sequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt 0 (null) zurück, wenn `source` keine Elemente enthält.  
  
 Das Ergebnis enthält keine Werte, die `null`werden.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Sum()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> verwendet wird, um die Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Collections::Generic::IEnumerable&lt;Nullable&lt;double&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Double" />-Werten, die NULL zulassen, und deren Summe berechnet werden soll</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Double" />-Werten, die NULL zulassen</summary>
        <returns>Die Summe der Werte in der Sequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt 0 (null) zurück, wenn `source` keine Elemente enthält.  
  
 Das Ergebnis enthält keine Werte, die `null`werden.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Sum()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> verwendet wird, um die Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Collections::Generic::IEnumerable&lt;Nullable&lt;int&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int32" />-Werten, die NULL zulassen, und deren Summe berechnet werden soll</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int32" />-Werten, die NULL zulassen</summary>
        <returns>Die Summe der Werte in der Sequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt 0 (null) zurück, wenn `source` keine Elemente enthält.  
  
 Das Ergebnis enthält keine Werte, die `null`werden.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Sum()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> verwendet wird, um die Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Collections::Generic::IEnumerable&lt;Nullable&lt;long&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Int64" />-Werten, die NULL zulassen, und deren Summe berechnet werden soll</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int64" />-Werten, die NULL zulassen</summary>
        <returns>Die Summe der Werte in der Sequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt 0 (null) zurück, wenn `source` keine Elemente enthält.  
  
 Das Ergebnis enthält keine Werte, die `null`werden.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Sum()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> verwendet wird, um die Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Collections::Generic::IEnumerable&lt;Nullable&lt;float&gt;&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Single" />-Werten, die NULL zulassen, und deren Summe berechnet werden soll</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Single" />-Werten, die NULL zulassen</summary>
        <returns>Die Summe der Werte in der Sequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt 0 (null) zurück, wenn `source` keine Elemente enthält.  
  
 Das Ergebnis enthält keine Werte, die `null`werden.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Sum()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> verwendet wird, um die Werte einer Sequenz zusammenzufassen.  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static float Sum (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum (source As IEnumerable(Of Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Collections::Generic::IEnumerable&lt;float&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;single&gt; -&gt; single" Usage="System.Linq.Enumerable.Sum source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Eine Sequenz von <see cref="T:System.Single" />-Werten, deren Summe berechnet werden soll</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Single" />-Werten</summary>
        <returns>Die Summe der Werte in der Sequenz</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt 0 (null) zurück, wenn `source` keine Elemente enthält.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Sum()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> verwendet wird, um die Werte einer Sequenz zusammenzufassen.  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Decimal)) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Decimal Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, System::Decimal&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, decimal&gt; -&gt; decimal" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, die zum Berechnen einer Summe verwendet werden</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Decimal" />-Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden</summary>
        <returns>Die Summe der projizierten Werte</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt 0 (null) zurück, wenn `source` keine Elemente enthält.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere <xref:System.Decimal>.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Sum()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> verwendet wird, um die projizierten Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Double)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static double Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, double&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, double&gt; -&gt; double" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, die zum Berechnen einer Summe verwendet werden</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Double" />-Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden</summary>
        <returns>Die Summe der projizierten Werte</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt 0 (null) zurück, wenn `source` keine Elemente enthält.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere <xref:System.Double>.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Sum()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> verwendet wird, um die projizierten Werte einer Sequenz zusammenzufassen.  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Integer)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static int Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, int&gt; -&gt; int" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, die zum Berechnen einer Summe verwendet werden</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int32" />-Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden</summary>
        <returns>Die Summe der projizierten Werte</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt 0 (null) zurück, wenn `source` keine Elemente enthält.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere <xref:System.Int32>.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Sum()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> verwendet wird, um die projizierten Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Long)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static long Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, long&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, int64&gt; -&gt; int64" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, die zum Berechnen einer Summe verwendet werden</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int64" />-Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden</summary>
        <returns>Die Summe der projizierten Werte</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt 0 (null) zurück, wenn `source` keine Elemente enthält.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere <xref:System.Int64>.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Sum()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> verwendet wird, um die projizierten Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Decimal))) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;System::Decimal&gt; Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;System::Decimal&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;decimal&gt;&gt; -&gt; Nullable&lt;decimal&gt;" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, die zum Berechnen einer Summe verwendet werden</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Decimal" />-Werten, die NULL zulassen, und die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden</summary>
        <returns>Die Summe der projizierten Werte</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt 0 (null) zurück, wenn `source` keine Elemente enthält.  
  
 Das Ergebnis enthält keine Werte, die `null`werden.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere `Nullable<Decimal>` in C# Visual Basic oder `Nullable(Of Decimal)`.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Sum()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> verwendet wird, um die projizierten Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Double))) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;double&gt; Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;double&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;double&gt;&gt; -&gt; Nullable&lt;double&gt;" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, die zum Berechnen einer Summe verwendet werden</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Double" />-Werten, die NULL zulassen, und die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden</summary>
        <returns>Die Summe der projizierten Werte</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt 0 (null) zurück, wenn `source` keine Elemente enthält.  
  
 Das Ergebnis enthält keine Werte, die `null`werden.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere `Nullable<Double>` in C# Visual Basic oder `Nullable(Of Double)`.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Sum()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> verwendet wird, um die projizierten Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Integer))) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;int&gt; Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;int&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int&gt;&gt; -&gt; Nullable&lt;int&gt;" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, die zum Berechnen einer Summe verwendet werden</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int32" />-Werten, die NULL zulassen, und die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden</summary>
        <returns>Die Summe der projizierten Werte</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt 0 (null) zurück, wenn `source` keine Elemente enthält.  
  
 Das Ergebnis enthält keine Werte, die `null`werden.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere `Nullable<Int32>` in C# Visual Basic oder `Nullable(Of Int32)`.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Sum()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> verwendet wird, um die projizierten Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Long))) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;long&gt; Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;long&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;int64&gt;&gt; -&gt; Nullable&lt;int64&gt;" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, die zum Berechnen einer Summe verwendet werden</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Int64" />-Werten, die NULL zulassen, und die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden</summary>
        <returns>Die Summe der projizierten Werte</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt 0 (null) zurück, wenn `source` keine Elemente enthält.  
  
 Das Ergebnis enthält keine Werte, die `null`werden.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion (`selector`) bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere C# `Nullable<Int64>` in oder `Nullable(Of Int64)` in Visual Basic  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Sum()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> verwendet wird, um die projizierten Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Die Summe ist größer als <see cref="F:System.Int64.MaxValue" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Nullable(Of Single))) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Nullable&lt;float&gt; Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, Nullable&lt;float&gt;&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, Nullable&lt;single&gt;&gt; -&gt; Nullable&lt;single&gt;" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, die zum Berechnen einer Summe verwendet werden</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Single" />-Werten, die NULL zulassen, und die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden</summary>
        <returns>Die Summe der projizierten Werte</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt 0 (null) zurück, wenn `source` keine Elemente enthält.  
  
 Das Ergebnis enthält keine Werte, die `null`werden.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere `Nullable<Single>` in C# Visual Basic oder `Nullable(Of Single)`.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Sum()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> verwendet wird, um die projizierten Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Sum(Of TSource) (source As IEnumerable(Of TSource), selector As Func(Of TSource, Single)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static float Sum(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, float&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="static member Sum : seq&lt;'Source&gt; * Func&lt;'Source, single&gt; -&gt; single" Usage="System.Linq.Enumerable.Sum (source, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz von Werten, die zum Berechnen einer Summe verwendet werden</param>
        <param name="selector">Eine Transformationsfunktion, die auf jedes Element angewendet werden soll.</param>
        <summary>Berechnet die Summe einer Sequenz von <see cref="T:System.Single" />-Werten, die durch den Aufruf einer Transformationsfunktion für jedes Element der Eingabesequenz ermittelt werden</summary>
        <returns>Die Summe der projizierten Werte</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29> Methode gibt 0 (null) zurück, wenn `source` keine Elemente enthält.  
  
 Sie können diese Methode auf eine Sequenz beliebiger Werte anwenden, wenn Sie eine Funktion `selector`bereitstellen, die die Member `source` in einen numerischen Typ projiziert, insbesondere <xref:System.Single>.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Aggregate Into Sum()`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Sum%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> verwendet wird, um die projizierten Werte einer Sequenz zusammenzufassen.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="selector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/aggregate-clause.md">Aggregate-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Take&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Take&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Take``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Take(Of TSource) (source As IEnumerable(Of TSource), count As Integer) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Take(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member Take : seq&lt;'Source&gt; * int -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Take (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="count">Die Anzahl der zurückzugebenden Elemente.</param>
        <summary>Gibt eine angegebene Anzahl von zusammenhängenden Elementen ab dem Anfang einer Sequenz zurück</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das die angegebene Anzahl von Elementen ab dem Anfang der Eingabesequenz enthält</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 <xref:System.Linq.Enumerable.Take%2A> listet `source` auf und führt Elemente aus, bis `count` Elemente zurückgegeben wurden oder `source` keine weiteren Elemente enthält. Wenn `count` die Anzahl der Elemente in `source`überschreitet, werden alle Elemente `source` zurückgegeben.  
  
 Wenn `count` kleiner oder gleich 0 (null) ist, wird `source` nicht aufgezählt, und es wird ein leerer <xref:System.Collections.Generic.IEnumerable%601> zurückgegeben.  
  
 Die Methoden <xref:System.Linq.Enumerable.Take%2A> und <xref:System.Linq.Enumerable.Skip%2A> sind funktionale Ergänzungen. Bei einer Sequenz `coll` und einer ganzzahligen `n`ergibt die Verkettung der Ergebnisse von `coll.Take(n)` und `coll.Skip(n)` dieselbe Sequenz wie `coll`.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Take`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Take%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Take%2A> verwendet wird, um Elemente vom Anfang einer Sequenz zurückzugeben.  
  
 [!code-csharp[System.Linq.Enumerable#99](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#99)]
 [!code-vb[System.Linq.Enumerable#99](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#99)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/take-clause.md">Take-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TakeLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeLast&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeLast&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeLast(Of TSource) (source As IEnumerable(Of TSource), count As Integer) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ TakeLast(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, int count);" />
      <MemberSignature Language="F#" Value="static member TakeLast : seq&lt;'Source&gt; * int -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.TakeLast (source, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TakeWhile&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt Elemente aus einer Sequenz zurück, solange eine angegebene Bedingung TRUE ist, und überspringt dann die übrigen Elemente</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ TakeWhile(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Eine Sequenz, aus der Elemente zurückgegeben werden sollen</param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Gibt Elemente aus einer Sequenz zurück, solange eine angegebene Bedingung TRUE ist</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das die Elemente aus der Eingabesequenz enthält, die vor dem Element auftreten, bei dem die Überprüfung nicht mehr erfolgreich ist</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Die <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>-Methode testet jedes Element `source` mithilfe `predicate` und gibt das-Element aus, wenn das Ergebnis `true`ist. Die Enumeration wird beendet, wenn die Prädikat Funktion `false` für ein Element zurückgibt oder wenn `source` keine weiteren Elemente enthält.  
  
 Die Methoden <xref:System.Linq.Enumerable.TakeWhile%2A> und <xref:System.Linq.Enumerable.SkipWhile%2A> sind funktionale Ergänzungen. Bei einer Sequenz `coll` und einer reinen Funktions `p`ergibt die Verkettung der Ergebnisse von `coll.TakeWhile(p)` und `coll.SkipWhile(p)` dieselbe Sequenz wie `coll`.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Take While`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.TakeWhile%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> verwendet wird, um Elemente vom Anfang einer Sequenz zurückzugeben, solange eine Bedingung true ist.  
  
 [!code-csharp[System.Linq.Enumerable#100](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#100)]
 [!code-vb[System.Linq.Enumerable#100](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#100)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/take-while-clause.md">Take While-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TakeWhile(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ TakeWhile(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member TakeWhile : seq&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.TakeWhile (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Die Sequenz, aus der Elemente zurückgegeben werden sollen.</param>
        <param name="predicate">Eine Funktion zum Überprüfen jedes Quellelements auf eine Bedingung. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <summary>Gibt Elemente aus einer Sequenz zurück, solange eine angegebene Bedingung TRUE ist In der Logik der Prädikatfunktion wird der Index des Elements verwendet.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das Elemente aus der Eingabesequenz enthält, die vor dem Element auftreten, bei dem die Überprüfung nicht mehr erfolgreich ist</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Die <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29>-Methode testet jedes Element `source` mithilfe `predicate` und gibt das-Element aus, wenn das Ergebnis `true`ist. Die Enumeration wird beendet, wenn die Prädikat Funktion `false` für ein Element zurückgibt oder wenn `source` keine weiteren Elemente enthält.  
  
 Das erste Argument von `predicate` das das zu testende Element darstellt. Das zweite Argument stellt den NULL basierten Index des Elements in `source`dar.  
  
 Die Methoden <xref:System.Linq.Enumerable.TakeWhile%2A> und <xref:System.Linq.Enumerable.SkipWhile%2A> sind funktionale Ergänzungen. Bei einer Sequenz `coll` und einer reinen Funktions `p`ergibt die Verkettung der Ergebnisse von `coll.TakeWhile(p)` und `coll.SkipWhile(p)` dieselbe Sequenz wie `coll`.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Take While`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.TakeWhile%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> verwendet wird, um Elemente vom Anfang einer Sequenz zurückzugeben, solange eine Bedingung, die den Index des Elements verwendet, true ist.  
  
 [!code-csharp[System.Linq.Enumerable#101](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#101)]
 [!code-vb[System.Linq.Enumerable#101](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#101)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/take-while-clause.md">Take While-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenBy&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt eine nachfolgende Sortierung der Elemente in einer Sequenz in aufsteigender Reihenfolge durch</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As IOrderedEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ ThenBy(System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.IOrderedEnumerable&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.ThenBy (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IOrderedEnumerable`1" /> mit den zu sortierenden Elementen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <summary>Führt eine nachfolgende Sortierung der Elemente in einer Sequenz in aufsteigender Reihenfolge nach einem Schlüssel durch</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedEnumerable`1" />, dessen Elemente nach einem Schlüssel sortiert werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Um eine Sequenz nach den Werten der Elemente selbst zu sortieren, geben Sie die Identitäts Funktion (`x => x` in C# Visual oder `Function(x) x` in Visual Basic) für `keySelector`an.  
  
 <xref:System.Linq.Enumerable.ThenBy%2A> und <xref:System.Linq.Enumerable.ThenByDescending%2A> werden definiert, um den Typ <xref:System.Linq.IOrderedEnumerable%601>zu erweitern, der auch der Rückgabetyp dieser Methoden ist. Mit diesem Entwurf können Sie mehrere Sortierkriterien angeben, indem Sie eine beliebige Anzahl von <xref:System.Linq.Enumerable.ThenBy%2A>-oder <xref:System.Linq.Enumerable.ThenByDescending%2A> Methoden anwenden.  
  
> [!NOTE]
>  Da <xref:System.Linq.IOrderedEnumerable%601> von <xref:System.Collections.Generic.IEnumerable%601>erbt, können Sie <xref:System.Linq.Enumerable.OrderBy%2A> oder <xref:System.Linq.Enumerable.OrderByDescending%2A> auf die Ergebnisse eines Aufrufes <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> oder <xref:System.Linq.Enumerable.ThenByDescending%2A>aufzurufen. Dadurch wird eine neue primäre Reihenfolge eingeführt, die die zuvor festgelegte Reihenfolge ignoriert.  
  
 Diese Methode vergleicht Schlüssel mit dem Standardcomparer <xref:System.Collections.Generic.Comparer%601.Default%2A>.  
  
 Diese Methode führt eine stabile Sortierung aus. Das heißt, wenn die Schlüssel zweier Elemente gleich sind, wird die Reihenfolge der Elemente beibehalten. Im Gegensatz dazu behält eine instabile Sortierung nicht die Reihenfolge von Elementen mit demselben Schlüssel bei.  
  
 In der Abfrage Ausdruckssyntax wird eine `orderby [first criterion], [second criterion]` ( C#Visual) oder `Order By [first criterion], [second criterion]` (Visual Basic)-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.ThenBy%2A>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.ThenBy%60%602%28System.Linq.IOrderedEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> verwendet wird, um eine sekundäre Reihenfolge der Elemente in einer Sequenz auszuführen.  
  
 [!code-csharp[System.Linq.Enumerable#102](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#102)]
 [!code-vb[System.Linq.Enumerable#102](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#102)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/csharp/language-reference/keywords/orderby-clause.md">orderby-Klausel (C#-Referenz)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/order-by-clause.md">ORDER BY-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenBy(Of TSource, TKey) (source As IOrderedEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ ThenBy(System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenBy : System.Linq.IOrderedEnumerable&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.ThenBy (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IOrderedEnumerable`1" /> mit den zu sortierenden Elementen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Führt mithilfe eines angegebenen Vergleichs eine nachfolgende Sortierung der Elemente in einer Sequenz in aufsteigender Reihenfolge durch</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedEnumerable`1" />, dessen Elemente nach einem Schlüssel sortiert werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Um eine Sequenz nach den Werten der Elemente selbst zu sortieren, geben Sie die Identitäts Funktion (`x => x` in C# Visual oder `Function(x) x` in Visual Basic) für `keySelector`an.  
  
 <xref:System.Linq.Enumerable.ThenBy%2A> und <xref:System.Linq.Enumerable.ThenByDescending%2A> werden definiert, um den Typ <xref:System.Linq.IOrderedEnumerable%601>zu erweitern, der auch der Rückgabetyp dieser Methoden ist. Mit diesem Entwurf können Sie mehrere Sortierkriterien angeben, indem Sie eine beliebige Anzahl von <xref:System.Linq.Enumerable.ThenBy%2A>-oder <xref:System.Linq.Enumerable.ThenByDescending%2A> Methoden anwenden.  
  
> [!NOTE]
>  Da <xref:System.Linq.IOrderedEnumerable%601> von <xref:System.Collections.Generic.IEnumerable%601>erbt, können Sie <xref:System.Linq.Enumerable.OrderBy%2A> oder <xref:System.Linq.Enumerable.OrderByDescending%2A> auf die Ergebnisse eines Aufrufes <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> oder <xref:System.Linq.Enumerable.ThenByDescending%2A>aufzurufen. Dadurch wird eine neue primäre Reihenfolge eingeführt, die die zuvor festgelegte Reihenfolge ignoriert.  
  
 Wenn `comparer` `null`ist, wird der Standardcomparer <xref:System.Collections.Generic.Comparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet.  
  
 Diese Methode führt eine stabile Sortierung aus. Das heißt, wenn die Schlüssel zweier Elemente gleich sind, wird die Reihenfolge der Elemente beibehalten. Im Gegensatz dazu behält eine instabile Sortierung nicht die Reihenfolge von Elementen mit demselben Schlüssel bei.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt eine nachfolgende Sortierung der Elemente in einer Sequenz in absteigender Reihenfolge durch</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As IOrderedEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ ThenByDescending(System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.IOrderedEnumerable&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.ThenByDescending (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IOrderedEnumerable`1" /> mit den zu sortierenden Elementen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <summary>Führt eine nachfolgende Sortierung der Elemente in einer Sequenz in absteigender Reihenfolge nach einem Schlüssel durch</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedEnumerable`1" />, dessen Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Um eine Sequenz nach den Werten der Elemente selbst zu sortieren, geben Sie die Identitäts Funktion (`x => x` in C# Visual oder `Function(x) x` in Visual Basic) für `keySelector`an.  
  
 <xref:System.Linq.Enumerable.ThenBy%2A> und <xref:System.Linq.Enumerable.ThenByDescending%2A> werden definiert, um den Typ <xref:System.Linq.IOrderedEnumerable%601>zu erweitern, der auch der Rückgabetyp dieser Methoden ist. Mit diesem Entwurf können Sie mehrere Sortierkriterien angeben, indem Sie eine beliebige Anzahl von <xref:System.Linq.Enumerable.ThenBy%2A>-oder <xref:System.Linq.Enumerable.ThenByDescending%2A> Methoden anwenden.  
  
> [!NOTE]
>  Da <xref:System.Linq.IOrderedEnumerable%601> von <xref:System.Collections.Generic.IEnumerable%601>erbt, können Sie <xref:System.Linq.Enumerable.OrderBy%2A> oder <xref:System.Linq.Enumerable.OrderByDescending%2A> auf die Ergebnisse eines Aufrufes <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> oder <xref:System.Linq.Enumerable.ThenByDescending%2A>aufzurufen. Dadurch wird eine neue primäre Reihenfolge eingeführt, die die zuvor festgelegte Reihenfolge ignoriert.  
  
 Diese Sortiermethode vergleicht Schlüssel mithilfe des Standardcomparer-<xref:System.Collections.Generic.Comparer%601.Default%2A>.  
  
 Diese Methode führt eine stabile Sortierung aus. Das heißt, wenn die Schlüssel zweier Elemente gleich sind, wird die Reihenfolge der Elemente beibehalten. Im Gegensatz dazu behält eine instabile Sortierung nicht die Reihenfolge von Elementen mit demselben Schlüssel bei.  
  
 In der C# Syntax des visuellen Abfrage Ausdrucks übersetzt eine `orderby [first criterion], [second criterion] descending`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.ThenByDescending%2A>.  
  
 In Visual Basic Abfrage Ausdruckssyntax wird eine `Order By [first criterion], [second criterion] Descending`-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.ThenByDescending%2A>übersetzt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/csharp/language-reference/keywords/orderby-clause.md">orderby-Klausel (C#-Referenz)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/order-by-clause.md">ORDER BY-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ThenByDescending(Of TSource, TKey) (source As IOrderedEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IComparer(Of TKey)) As IOrderedEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ ThenByDescending(System::Linq::IOrderedEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ThenByDescending : System.Linq.IOrderedEnumerable&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Linq.IOrderedEnumerable&lt;'Source&gt;" Usage="System.Linq.Enumerable.ThenByDescending (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Ein <see cref="T:System.Linq.IOrderedEnumerable`1" /> mit den zu sortierenden Elementen.</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Führt mithilfe eines angegebenen Vergleichs eine nachfolgende Sortierung der Elemente in einer Sequenz in absteigender Reihenfolge durch</summary>
        <returns>Ein <see cref="T:System.Linq.IOrderedEnumerable`1" />, dessen Elemente in absteigender Reihenfolge nach einem Schlüssel sortiert werden</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Um eine Sequenz nach den Werten der Elemente selbst zu sortieren, geben Sie die Identitäts Funktion (`x => x` in C# Visual oder `Function(x) x` in Visual Basic) für `keySelector`an.  
  
 <xref:System.Linq.Enumerable.ThenBy%2A> und <xref:System.Linq.Enumerable.ThenByDescending%2A> werden definiert, um den Typ <xref:System.Linq.IOrderedEnumerable%601>zu erweitern, der auch der Rückgabetyp dieser Methoden ist. Mit diesem Entwurf können Sie mehrere Sortierkriterien angeben, indem Sie eine beliebige Anzahl von <xref:System.Linq.Enumerable.ThenBy%2A>-oder <xref:System.Linq.Enumerable.ThenByDescending%2A> Methoden anwenden.  
  
> [!NOTE]
>  Da <xref:System.Linq.IOrderedEnumerable%601> von <xref:System.Collections.Generic.IEnumerable%601>erbt, können Sie <xref:System.Linq.Enumerable.OrderBy%2A> oder <xref:System.Linq.Enumerable.OrderByDescending%2A> auf die Ergebnisse eines Aufrufes <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> oder <xref:System.Linq.Enumerable.ThenByDescending%2A>aufzurufen. Dadurch wird eine neue primäre Reihenfolge eingeführt, die die zuvor festgelegte Reihenfolge ignoriert.  
  
 Wenn `comparer` `null`ist, wird der Standardcomparer <xref:System.Collections.Generic.Comparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet.  
  
 Diese Methode führt eine stabile Sortierung aus. Das heißt, wenn die Schlüssel zweier Elemente gleich sind, wird die Reihenfolge der Elemente beibehalten. Im Gegensatz dazu behält eine instabile Sortierung nicht die Reihenfolge von Elementen mit demselben Schlüssel bei.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.ThenByDescending%60%602%28System.Linq.IOrderedEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> verwendet wird, um eine sekundäre Sortierung der Elemente in einer Sequenz in absteigender Reihenfolge mithilfe eines benutzerdefinierten Vergleichs auszuführen.  
  
 [!code-csharp[System.Linq.Enumerable#103](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#103)]
 [!code-vb[System.Linq.Enumerable#103](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#103)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource[] ToArray&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource[] ToArray&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToArray``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToArray(Of TSource) (source As IEnumerable(Of TSource)) As TSource()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static cli::array &lt;TSource&gt; ^ ToArray(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ToArray : seq&lt;'Source&gt; -&gt; 'Source[]" Usage="System.Linq.Enumerable.ToArray source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem ein Array erstellt werden soll</param>
        <summary>Erstellt ein Array aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Ein Array, das die Elemente aus der Eingabesequenz enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.ToArray%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>-Methode erzwingt die sofortige Abfrage Auswertung und gibt ein Array zurück, das die Abfrageergebnisse enthält. Sie können diese Methode an Ihre Abfrage anfügen, um eine zwischengespeicherte Kopie der Abfrageergebnisse zu erhalten.  
  
 <xref:System.Linq.Enumerable.ToList%2A> weist ein ähnliches Verhalten auf, gibt jedoch einen <xref:System.Collections.Generic.List%601> anstelle eines Arrays zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.ToArray%2A> verwendet wird, um die sofortige Abfrage Auswertung zu erzwingen und ein Array von Ergebnissen zurückzugeben.  
  
 [!code-csharp[System.Linq.Enumerable#104](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#104)]
 [!code-vb[System.Linq.Enumerable#104](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#104)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein <see cref="T:System.Collections.Generic.Dictionary`2" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As Dictionary(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TSource&gt; ^ ToDictionary(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Source&gt;" Usage="System.Linq.Enumerable.ToDictionary (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem ein <see cref="T:System.Collections.Generic.Dictionary`2" /> erstellt werden soll</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <summary>Erstellt ein <see cref="T:System.Collections.Generic.Dictionary`2" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" /> gemäß einer angegebenen Schlüsselauswahlfunktion</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.Dictionary`2" />, das Schlüssel und Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.ToDictionary%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29>-Methode verwendet den Standard Gleichheits Vergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> zum Vergleichen von Schlüsseln.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.ToDictionary%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> verwendet wird, um mithilfe einer Schlüsselauswahl eine <xref:System.Collections.Generic.Dictionary%602> zu erstellen.  
  
 [!code-csharp[System.Linq.Enumerable#105](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#105)]
 [!code-vb[System.Linq.Enumerable#105](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#105)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="keySelector" /> erzeugt einen Schlüssel, der <see langword="null" /> ist.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keySelector" /> erzeugt für zwei Elemente doppelte Schlüssel.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As Dictionary(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TSource&gt; ^ ToDictionary(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Source&gt;" Usage="System.Linq.Enumerable.ToDictionary (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ der von <paramref name="keySelector" /> zurückgegebenen Schlüssel.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem ein <see cref="T:System.Collections.Generic.Dictionary`2" /> erstellt werden soll</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Erstellt ein <see cref="T:System.Collections.Generic.Dictionary`2" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" /> gemäß einer angegebenen Schlüsselauswahlfunktion und eines angegebenen Schlüsselvergleichs</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.Dictionary`2" />, das Schlüssel und Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` `null`ist, wird der standardmäßige Gleichheits Vergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="keySelector" /> erzeugt einen Schlüssel, der <see langword="null" /> ist.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keySelector" /> erzeugt für zwei Elemente doppelte Schlüssel.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As Dictionary(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TElement&gt; ^ ToDictionary(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Element&gt;" Usage="System.Linq.Enumerable.ToDictionary (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <typeparam name="TElement">Der Typ des von <paramref name="elementSelector" /> zurückgegebenen Werts.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem ein <see cref="T:System.Collections.Generic.Dictionary`2" /> erstellt werden soll</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="elementSelector">Eine Transformationsfunktion, mit der aus jedem Element ein Ergebniselementwert erzeugt wird.</param>
        <summary>Erstellt ein <see cref="T:System.Collections.Generic.Dictionary`2" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" /> entsprechend der angegebenen Schlüsselauswahlfunktion und Elementauswahlfunktion</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.Dictionary`2" />, das Werte vom Typ <paramref name="TElement" /> enthält, die aus der Eingabesequenz ausgewählt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.ToDictionary%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>-Methode verwendet den Standard Gleichheits Vergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> zum Vergleichen von Schlüsseln.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="keySelector" /> erzeugt einen Schlüssel, der <see langword="null" /> ist.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keySelector" /> erzeugt für zwei Elemente doppelte Schlüssel.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToDictionary(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As Dictionary(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::Dictionary&lt;TKey, TElement&gt; ^ ToDictionary(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToDictionary : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Element&gt;" Usage="System.Linq.Enumerable.ToDictionary (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <typeparam name="TElement">Der Typ des von <paramref name="elementSelector" /> zurückgegebenen Werts.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem ein <see cref="T:System.Collections.Generic.Dictionary`2" /> erstellt werden soll</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="elementSelector">Eine Transformationsfunktion, mit der aus jedem Element ein Ergebniselementwert erzeugt wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Erstellt ein <see cref="T:System.Collections.Generic.Dictionary`2" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" /> entsprechend einer angegebenen Schlüsselauswahlfunktion, einem Vergleich und einer Elementauswahlfunktion</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.Dictionary`2" />, das Werte vom Typ <paramref name="TElement" /> enthält, die aus der Eingabesequenz ausgewählt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` `null`ist, wird der standardmäßige Gleichheits Vergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="keySelector" /> erzeugt einen Schlüssel, der <see langword="null" /> ist.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keySelector" /> erzeugt für zwei Elemente doppelte Schlüssel.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToHashSet&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.HashSet&lt;TSource&gt; ToHashSet&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.HashSet`1&lt;!!TSource&gt; ToHashSet&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToHashSet``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToHashSet(Of TSource) (source As IEnumerable(Of TSource)) As HashSet(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::HashSet&lt;TSource&gt; ^ ToHashSet(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ToHashSet : seq&lt;'Source&gt; -&gt; System.Collections.Generic.HashSet&lt;'Source&gt;" Usage="System.Linq.Enumerable.ToHashSet source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem ein <see cref="T:System.Collections.Generic.HashSet`1" /> erstellt werden soll</param>
        <summary>Erstellt ein <see cref="T:System.Collections.Generic.HashSet`1" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.HashSet`1" />, das aus der Eingabesequenz ausgewählte Werte vom Typ TSource enthält.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToHashSet&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.HashSet&lt;TSource&gt; ToHashSet&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.HashSet`1&lt;!!TSource&gt; ToHashSet&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToHashSet(Of TSource) (source As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As HashSet(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::HashSet&lt;TSource&gt; ^ ToHashSet(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToHashSet : seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; System.Collections.Generic.HashSet&lt;'Source&gt;" Usage="System.Linq.Enumerable.ToHashSet (source, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem ein <see cref="T:System.Collections.Generic.HashSet`1" /> erstellt werden soll</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Erstellt ein <see cref="T:System.Collections.Generic.HashSet`1" />-Element aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" />-Element mithilfe des <paramref name="comparer" /> zum Vergleichen von Schlüsseln.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.HashSet`1" />, das Werte vom Typ <paramref name="TSource" /> enthält, die aus der Eingabesequenz ausgewählt werden.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToList&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.List&lt;TSource&gt; ToList&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.List`1&lt;!!TSource&gt; ToList&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToList(Of TSource) (source As IEnumerable(Of TSource)) As List(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::List&lt;TSource&gt; ^ ToList(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member ToList : seq&lt;'Source&gt; -&gt; System.Collections.Generic.List&lt;'Source&gt;" Usage="System.Linq.Enumerable.ToList source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Das <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem eine <see cref="T:System.Collections.Generic.List`1" /> erstellt werden soll</param>
        <summary>Erstellt ein <see cref="T:System.Collections.Generic.List`1" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.List`1" />, die Elemente aus der Eingabesequenz enthält</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.ToList%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>-Methode erzwingt die sofortige Abfrage Auswertung und gibt eine <xref:System.Collections.Generic.List%601> zurück, die die Abfrageergebnisse enthält. Sie können diese Methode an Ihre Abfrage anfügen, um eine zwischengespeicherte Kopie der Abfrageergebnisse zu erhalten.  
  
 <xref:System.Linq.Enumerable.ToArray%2A> weist ein ähnliches Verhalten auf, gibt aber ein Array anstelle eines <xref:System.Collections.Generic.List%601>zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.ToList%2A> verwendet wird, um die sofortige Abfrage Auswertung zu erzwingen und eine <xref:System.Collections.Generic.List%601> zurückzugeben, die die Abfrageergebnisse enthält.  
  
 [!code-csharp[System.Linq.Enumerable#106](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#106)]
 [!code-vb[System.Linq.Enumerable#106](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#106)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLookup&lt;TSource,TKey&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein generisches <see cref="T:System.Linq.Lookup`2" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" /></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey)) As ILookup(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TSource&gt; ^ ToLookup(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector);" />
      <MemberSignature Language="F#" Value="static member ToLookup : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Source&gt;" Usage="System.Linq.Enumerable.ToLookup (source, keySelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Das <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem eine <see cref="T:System.Linq.Lookup`2" /> erstellt werden soll</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Lookup`2" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" /> gemäß einer angegebenen Schlüsselauswahlfunktion</summary>
        <returns>Ein <see cref="T:System.Linq.Lookup`2" />, das Schlüssel und Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.ToLookup%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29>-Methode gibt ein <xref:System.Linq.Lookup%602>zurück, ein 1: n-Wörterbuch, das Schlüsselwerten Auflistungen zuordnet. Ein <xref:System.Linq.Lookup%602> unterscheidet sich von einem <xref:System.Collections.Generic.Dictionary%602>, das eine eins-zu-Eins-Zuordnung von Schlüsseln zu einzelnen Werten ausführt.  
  
 Der standardmäßige Gleichheits Vergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> wird zum Vergleichen von Schlüsseln verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), comparer As IEqualityComparer(Of TKey)) As ILookup(Of TKey, TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TSource&gt; ^ ToLookup(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToLookup : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Source&gt;" Usage="System.Linq.Enumerable.ToLookup (source, keySelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <param name="source">Das <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem eine <see cref="T:System.Linq.Lookup`2" /> erstellt werden soll</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Lookup`2" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" /> gemäß einer angegebenen Schlüsselauswahlfunktion und eines angegebenen Schlüsselvergleichs</summary>
        <returns>Ein <see cref="T:System.Linq.Lookup`2" />, das Schlüssel und Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.ToLookup%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29>-Methode gibt ein <xref:System.Linq.Lookup%602>zurück, ein 1: n-Wörterbuch, das Schlüsselwerten Auflistungen zuordnet. Ein <xref:System.Linq.Lookup%602> unterscheidet sich von einem <xref:System.Collections.Generic.Dictionary%602>, das eine eins-zu-Eins-Zuordnung von Schlüsseln zu einzelnen Werten ausführt.  
  
 Wenn `comparer` `null`ist, wird der standardmäßige Gleichheits Vergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement)) As ILookup(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TElement&gt; ^ ToLookup(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector);" />
      <MemberSignature Language="F#" Value="static member ToLookup : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Element&gt;" Usage="System.Linq.Enumerable.ToLookup (source, keySelector, elementSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <typeparam name="TElement">Der Typ des von <paramref name="elementSelector" /> zurückgegebenen Werts.</typeparam>
        <param name="source">Das <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem eine <see cref="T:System.Linq.Lookup`2" /> erstellt werden soll</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="elementSelector">Eine Transformationsfunktion, mit der aus jedem Element ein Ergebniselementwert erzeugt wird.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Lookup`2" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" /> entsprechend der angegebenen Schlüsselauswahlfunktion und Elementauswahlfunktion</summary>
        <returns>Ein <see cref="T:System.Linq.Lookup`2" />, das Werte vom Typ <paramref name="TElement" /> enthält, die aus der Eingabesequenz ausgewählt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>-Methode gibt ein <xref:System.Linq.Lookup%602>zurück, ein 1: n-Wörterbuch, das Schlüsselwerten Auflistungen zuordnet. Ein <xref:System.Linq.Lookup%602> unterscheidet sich von einem <xref:System.Collections.Generic.Dictionary%602>, das eine eins-zu-Eins-Zuordnung von Schlüsseln zu einzelnen Werten ausführt.  
  
 Der standardmäßige Gleichheits Vergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> wird zum Vergleichen von Schlüsseln verwendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> verwendet wird, um mithilfe einer Schlüsselauswahl Funktion und einer Elementauswahl Funktion eine <xref:System.Linq.Lookup%602> zu erstellen.  
  
 [!code-csharp[System.Linq.Enumerable#107](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#107)]
 [!code-vb[System.Linq.Enumerable#107](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#107)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToLookup(Of TSource, TKey, TElement) (source As IEnumerable(Of TSource), keySelector As Func(Of TSource, TKey), elementSelector As Func(Of TSource, TElement), comparer As IEqualityComparer(Of TKey)) As ILookup(Of TKey, TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TKey, typename TElement&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Linq::ILookup&lt;TKey, TElement&gt; ^ ToLookup(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, TKey&gt; ^ keySelector, Func&lt;TSource, TElement&gt; ^ elementSelector, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member ToLookup : seq&lt;'Source&gt; * Func&lt;'Source, 'Key&gt; * Func&lt;'Source, 'Element&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Linq.ILookup&lt;'Key, 'Element&gt;" Usage="System.Linq.Enumerable.ToLookup (source, keySelector, elementSelector, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <typeparam name="TKey">Der Typ des von <paramref name="keySelector" /> zurückgegebenen Schlüssels.</typeparam>
        <typeparam name="TElement">Der Typ des von <paramref name="elementSelector" /> zurückgegebenen Werts.</typeparam>
        <param name="source">Das <see cref="T:System.Collections.Generic.IEnumerable`1" />, aus dem eine <see cref="T:System.Linq.Lookup`2" /> erstellt werden soll</param>
        <param name="keySelector">Eine Funktion zum Extrahieren eines Schlüssels aus jedem Element.</param>
        <param name="elementSelector">Eine Transformationsfunktion, mit der aus jedem Element ein Ergebniselementwert erzeugt wird.</param>
        <param name="comparer">Ein <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Schlüsseln.</param>
        <summary>Erstellt ein <see cref="T:System.Linq.Lookup`2" /> aus einem <see cref="T:System.Collections.Generic.IEnumerable`1" /> entsprechend einer angegebenen Schlüsselauswahlfunktion, einem Vergleich und einer Elementauswahlfunktion</summary>
        <returns>Ein <see cref="T:System.Linq.Lookup`2" />, das Werte vom Typ <paramref name="TElement" /> enthält, die aus der Eingabesequenz ausgewählt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29>-Methode gibt ein <xref:System.Linq.Lookup%602>zurück, ein 1: n-Wörterbuch, das Schlüsselwerten Auflistungen zuordnet. Ein <xref:System.Linq.Lookup%602> unterscheidet sich von einem <xref:System.Collections.Generic.Dictionary%602>, das eine eins-zu-Eins-Zuordnung von Schlüsseln zu einzelnen Werten ausführt.  
  
 Wenn `comparer` `null`ist, wird der standardmäßige Gleichheits Vergleich <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> zum Vergleichen von Schlüsseln verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="keySelector" /> oder <paramref name="elementSelector" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Union&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erzeugt die Vereinigungsmenge von zwei Sequenzen</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Union(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Union : seq&lt;'Source&gt; * seq&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Union (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen unterschiedliche Elemente die erste Menge für die Gesamtmenge bilden</param>
        <param name="second">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen unterschiedliche Elemente die zweite Menge für die Gesamtmenge bilden</param>
        <summary>Erzeugt die Vereinigungsmenge von zwei Sequenzen mithilfe des Standardgleichheitsvergleichs</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das die Elemente aus beiden Eingabesequenzen ohne Duplikate enthält</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Diese Methode schließt Duplikate aus der Rückgabe Menge aus. Dies ist ein anderes Verhalten wie die <xref:System.Linq.Enumerable.Concat%2A>-Methode, die alle Elemente in den Eingabe Sequenzen, einschließlich Duplikate, zurückgibt.  
  
 Der Standard Gleichheits Vergleich, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, wird zum Vergleichen von Werten der Typen verwendet, die die <xref:System.Collections.Generic.IEqualityComparer%601> generische Schnittstelle implementieren. Um einen benutzerdefinierten Datentyp zu vergleichen, müssen Sie diese Schnittstelle implementieren und ihre eigenen <xref:System.Object.GetHashCode%2A> und <xref:System.Object.Equals%2A> Methoden für den-Typ bereitstellen.  
  
 Wenn das Objekt, das von dieser Methode zurückgegeben wird, aufgezählt wird, `Union` `first` und `second` in dieser Reihenfolge aufzählt und jedes Element, das noch nicht zurückgegeben wurde, ergibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie `Union<TSource>(IEnumerable<TSource>, IEnumerable<TSource>)` verwendet wird, um die Union von zwei Sequenzen von Ganzzahlen abzurufen.  
  
 [!code-csharp-interactive[System.Linq.Enumerable#109](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#109)]
 [!code-vb[System.Linq.Enumerable#109](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#109)]  
  
 Wenn Sie Sequenzen von Objekten eines benutzerdefinierten Datentyps vergleichen möchten, müssen Sie den <xref:System.IEquatable%601> generischen Schnittstelle in einer Hilfsklasse implementieren. Im folgenden Codebeispiel wird veranschaulicht, wie diese Schnittstelle in einem benutzerdefinierten Datentyp implementiert wird und <xref:System.Object.GetHashCode%2A>-und <xref:System.Object.Equals%2A> Methoden überschrieben werden.
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
 [!code-vb[CSLINQEncapsulatedComparer#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#9)]  

 Nachdem Sie diese Schnittstelle implementiert haben, können Sie Sequenzen von `ProductA` Objekten in der `Union<TSource>(IEnumerable<TSource>, IEnumerable<TSource>)`-Methode verwenden, wie im folgenden Beispiel gezeigt:  
  
 [!code-csharp[CSLINQEncapsulatedComparer#10](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#10)]
 [!code-vb[CSLINQEncapsulatedComparer#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#10)]

[!code-csharp[CSLINQEncapsulatedComparer#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#4)]
[!code-vb[CSLINQEncapsulatedComparer#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> oder <paramref name="second" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Union(Of TSource) (first As IEnumerable(Of TSource), second As IEnumerable(Of TSource), comparer As IEqualityComparer(Of TSource)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Union(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ second, System::Collections::Generic::IEqualityComparer&lt;TSource&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Union : seq&lt;'Source&gt; * seq&lt;'Source&gt; * System.Collections.Generic.IEqualityComparer&lt;'Source&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Union (first, second, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente der Eingabesequenzen.</typeparam>
        <param name="first">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen unterschiedliche Elemente die erste Menge für die Gesamtmenge bilden</param>
        <param name="second">Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, dessen unterschiedliche Elemente die zweite Menge für die Gesamtmenge bilden</param>
        <param name="comparer">Der <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> zum Vergleichen von Werten</param>
        <summary>Erzeugt mithilfe eines angegebenen <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> die Vereinigungsmenge von zwei Sequenzen</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das die Elemente aus beiden Eingabesequenzen ohne Duplikate enthält</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Wenn `comparer` `null`ist, wird der Standard Gleichheits Vergleich (<xref:System.Collections.Generic.EqualityComparer%601.Default%2A>) verwendet, um Werte zu vergleichen.  
  
 Wenn das Objekt, das von dieser Methode zurückgegeben wird, aufgezählt wird, <xref:System.Linq.Enumerable.Union%2A> `first` und `second` in dieser Reihenfolge aufzählt und jedes Element, das noch nicht zurückgegeben wurde, ergibt.  
  
 Die <xref:System.Linq.Enumerable.Concat%2A>-Methode unterscheidet sich von der <xref:System.Linq.Enumerable.Union%2A>-Methode, da die <xref:System.Linq.Enumerable.Concat%2A>-Methode alle Elemente in den Eingabe Sequenzen einschließlich Duplikaten zurückgibt, während <xref:System.Linq.Enumerable.Union%2A> nur eindeutige Werte zurückgibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein Gleichheits Vergleich implementiert wird, der in der <xref:System.Linq.Enumerable.Union%2A>-Methode verwendet werden kann.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Nachdem Sie diesen Vergleich implementiert haben, können Sie Sequenzen von `Product` Objekten in der <xref:System.Linq.Enumerable.Union%2A>-Methode verwenden, wie im folgenden Beispiel gezeigt:  
  
 [!code-csharp[CSLINQCustomComparer#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#2)]
 [!code-vb[CSLINQCustomComparer#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#2)]  
[!code-csharp[CSLINQCustomComparer#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#4)]
[!code-vb[CSLINQCustomComparer#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> oder <paramref name="second" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Where&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Filtert eine Sequenz von Werten basierend auf einem Prädikat.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Where(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : seq&lt;'Source&gt; * Func&lt;'Source, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein zu filterndes <see cref="T:System.Collections.Generic.IEnumerable`1" /></param>
        <param name="predicate">Eine Funktion, mit der jedes Element auf eine Bedingung überprüft wird.</param>
        <summary>Filtert eine Sequenz von Werten basierend auf einem Prädikat.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das Elemente aus der Eingabesequenz enthält, die die Bedingung erfüllen</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 In der Abfrage Ausdruckssyntax wird eine `where` ( C#Visual) oder `Where` (Visual Basic)-Klausel in einen Aufruf von <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>übersetzt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> zum Filtern einer Sequenz verwendet wird.  
  
 [!code-csharp[System.Linq.Enumerable#110](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#110)]
 [!code-vb[System.Linq.Enumerable#110](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#110)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/csharp/language-reference/keywords/where-clause.md">where-Klausel (C#-Referenz)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/queries/where-clause.md">Where-Klausel (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Where(Of TSource) (source As IEnumerable(Of TSource), predicate As Func(Of TSource, Integer, Boolean)) As IEnumerable(Of TSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ Where(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TSource, int, bool&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Where : seq&lt;'Source&gt; * Func&lt;'Source, int, bool&gt; -&gt; seq&lt;'Source&gt;" Usage="System.Linq.Enumerable.Where (source, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Der Typ der Elemente von <paramref name="source" />.</typeparam>
        <param name="source">Ein zu filterndes <see cref="T:System.Collections.Generic.IEnumerable`1" /></param>
        <param name="predicate">Eine Funktion zum Überprüfen jedes Quellelements auf eine Bedingung. Der zweite Parameter der Funktion stellt den Index des Quellelements dar.</param>
        <summary>Filtert eine Sequenz von Werten basierend auf einem Prädikat. In der Logik der Prädikatfunktion wird der Index der einzelnen Elemente verwendet.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das Elemente aus der Eingabesequenz enthält, die die Bedingung erfüllen</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Das erste Argument von `predicate` das das zu testende Element darstellt. Das zweite Argument stellt den NULL basierten Index des Elements in `source`dar.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> verwendet wird, um eine Sequenz auf der Grundlage eines Prädikats zu filtern, das den Index der einzelnen Elemente einschließt.  
  
 [!code-csharp[System.Linq.Enumerable#111](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#111)]
 [!code-vb[System.Linq.Enumerable#111](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#111)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="predicate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;ValueTuple&lt;TFirst,TSecond&gt;&gt; Zip&lt;TFirst,TSecond&gt; (this System.Collections.Generic.IEnumerable&lt;TFirst&gt; first, System.Collections.Generic.IEnumerable&lt;TSecond&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;valuetype System.ValueTuple`2&lt;!!TFirst, !!TSecond&gt;&gt; Zip&lt;TFirst, TSecond&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TFirst&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Zip(Of TFirst, TSecond) (first As IEnumerable(Of TFirst), second As IEnumerable(Of TSecond)) As IEnumerable(Of ValueTuple(Of TFirst, TSecond))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFirst, typename TSecond&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;ValueTuple&lt;TFirst, TSecond&gt;&gt; ^ Zip(System::Collections::Generic::IEnumerable&lt;TFirst&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSecond&gt; ^ second);" />
      <MemberSignature Language="F#" Value="static member Zip : seq&lt;'First&gt; * seq&lt;'Second&gt; -&gt; seq&lt;ValueTuple&lt;'First, 'Second&gt;&gt;" Usage="System.Linq.Enumerable.Zip (first, second)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.ValueTuple&lt;TFirst,TSecond&gt;&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="netcore-3.0">
            <AttributeName>System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "First", "Second" })</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TFirst&gt;" RefType="this" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">Der Typ der Elemente der ersten Eingabesequenz.</typeparam>
        <typeparam name="TSecond">Der Typ der Elemente der zweiten Eingabesequenz.</typeparam>
        <param name="first">Die erste Sequenz, die zusammengeführt werden soll</param>
        <param name="second">Die zweite Sequenz, die zusammengeführt werden soll</param>
        <summary>Erzeugt eine Tupelsequenz mit Elementen aus den beiden angegebenen Sequenzen.</summary>
        <returns>Eine Tupelsequenz mit Elementen, die der ersten und zweiten Sequenz in dieser Reihenfolge entnommen wurden.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TFirst&gt; first, System.Collections.Generic.IEnumerable&lt;TSecond&gt; second, Func&lt;TFirst,TSecond,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TFirst&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; second, class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Zip(Of TFirst, TSecond, TResult) (first As IEnumerable(Of TFirst), second As IEnumerable(Of TSecond), resultSelector As Func(Of TFirst, TSecond, TResult)) As IEnumerable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFirst, typename TSecond, typename TResult&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Collections::Generic::IEnumerable&lt;TResult&gt; ^ Zip(System::Collections::Generic::IEnumerable&lt;TFirst&gt; ^ first, System::Collections::Generic::IEnumerable&lt;TSecond&gt; ^ second, Func&lt;TFirst, TSecond, TResult&gt; ^ resultSelector);" />
      <MemberSignature Language="F#" Value="static member Zip : seq&lt;'First&gt; * seq&lt;'Second&gt; * Func&lt;'First, 'Second, 'Result&gt; -&gt; seq&lt;'Result&gt;" Usage="System.Linq.Enumerable.Zip (first, second, resultSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TFirst&gt;" RefType="this" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TFirst,TSecond,TResult&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">Der Typ der Elemente der ersten Eingabesequenz.</typeparam>
        <typeparam name="TSecond">Der Typ der Elemente der zweiten Eingabesequenz.</typeparam>
        <typeparam name="TResult">Der Typ der Elemente in der Ergebnissequenz.</typeparam>
        <param name="first">Die erste Sequenz, die zusammengeführt werden soll</param>
        <param name="second">Die zweite Sequenz, die zusammengeführt werden soll</param>
        <param name="resultSelector">Eine Funktion, die angibt, wie die Elemente der zwei Sequenzen zusammengeführt werden sollen</param>
        <summary>Wendet eine Funktion auf die entsprechenden Elemente von zwei Sequenzen an, und erzeugt eine Sequenz der Ergebnisse</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" />, das die zusammengeführten Elemente der beiden Eingabesequenzen enthält</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird mithilfe von verzögerter Ausführung implementiert. Der unmittelbare Rückgabewert ist ein Objekt, das alle Informationen speichert, die zum Ausführen der Aktion erforderlich sind. Die durch diese Methode dargestellte Abfrage wird erst ausgeführt, wenn das Objekt durch Aufrufen der `GetEnumerator` Methode direkt oder mithilfe `foreach` in der Visualisierung C# oder `For Each` in Visual Basic aufgezählt wird.  
  
 Die-Methode führt jedes Element der ersten Sequenz mit einem Element zusammen, das in der zweiten Sequenz denselben Index aufweist. Wenn die Sequenzen nicht die gleiche Anzahl von Elementen aufweisen, führt die Methode Sequenzen zusammen, bis Sie das Ende eines von Ihnen erreicht. Wenn eine Sequenz z. b. über drei Elemente und die andere eine Sequenz über vier Elemente verfügt, enthält die Ergebnis Sequenz nur drei Elemente.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Linq.Enumerable.Zip%2A>-Methode verwendet wird, um zwei Sequenzen zusammenzuführen.  
  
 [!code-csharp[System.Linq.Enumerable#200](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#200)]
 [!code-vb[System.Linq.Enumerable#200](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#200)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="first" /> oder <paramref name="second" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
