<Type Name="TypeDescriptionProvider" FullName="System.ComponentModel.TypeDescriptionProvider">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b88ec9c085b8e59f0db7b40277a6be8ed9929825" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58717048" /></Metadata><TypeSignature Language="C#" Value="public abstract class TypeDescriptionProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TypeDescriptionProvider extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.TypeDescriptionProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TypeDescriptionProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeDescriptionProvider abstract" />
  <TypeSignature Language="F#" Value="type TypeDescriptionProvider = class" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt ergänzende Metadaten für <see cref="T:System.ComponentModel.TypeDescriptor" /> bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.TypeDescriptionProvider> -Klasse dynamisch erweitert die Typinformationen, die einen Typ oder ein Objekt durch Hinzufügen, ändern oder Ausblenden von Eigenschaften wie z. B. Attribute, Eigenschaften und Ereignisse zugeordnet. Mehrere Typ Beschreibung Anbieterklassen, die Metadaten zu einem einzelnen bieten möglich <xref:System.ComponentModel.TypeDescriptor>.  
  
 Es gibt zwei Möglichkeiten zum Zuordnen einer <xref:System.ComponentModel.TypeDescriptionProvider> mit einem <xref:System.ComponentModel.TypeDescriptor>:  
  
-   Zur Entwurfszeit, wenn die Zielklasse werden die entsprechenden zugewiesen kann <xref:System.ComponentModel.TypeDescriptionProviderAttribute> Tag.  
  
-   Zur Laufzeit Wenn bei mindestens einer von der <xref:System.ComponentModel.TypeDescriptor.AddProvider%2A> Methoden der <xref:System.ComponentModel.TypeDescriptor> -Klasse kann aufgerufen werden. Diese überladenen Methoden erfordert entweder das Zielobjekt oder den Klassentyp.  
  
 Die <xref:System.ComponentModel.TypeDescriptionProvider> Klasse stützt sich auf ein übergeordnetes Objekt des gleichen Typs, während der Erstellung angegeben. Dadurch können abgeleitete Klassen <xref:System.ComponentModel.CustomTypeDescriptor> selektiv Methoden überschreiben.  
  
 Instanzen von <xref:System.ComponentModel.TypeDescriptionProvider> werden nur auf Anforderung erstellt und Minimierung der Auswirkungen von benutzerdefinierten Typen von Informationen über die Leistung.  
  
 Diese Klasse kann nicht vererbt werden.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Der abgeleitete Typ gekennzeichnet werden kann, als <see langword="internal" /> oder <see langword="private" />, jedoch eine Instanz des Typs erstellt werden kann, mit der <see cref="T:System.ComponentModel.TypeDescriptor" /> Klasse. Führen Sie nicht geschrieben Sie werden, dass die unsicheren Code durch Annahme des Aufrufers als vertrauenswürdig eingestuft wird. Nehmen Sie stattdessen an, dass Aufrufer Instanzen des Typs bei teilweiser Vertrauenswürdigkeit erstellen können.</para></block>
    <altmember cref="Overload:System.ComponentModel.TypeDescriptor.AddProvider" />
    <altmember cref="T:System.ComponentModel.TypeDescriptionProviderAttribute" />
    <altmember cref="T:System.ComponentModel.ICustomTypeDescriptor" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ComponentModel.TypeDescriptionProvider" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeDescriptionProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeDescriptionProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ComponentModel.TypeDescriptionProvider" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor entspricht dem Aufrufen des anderen <xref:System.ComponentModel.TypeDescriptionProvider.%23ctor%28System.ComponentModel.TypeDescriptionProvider%29> Konstruktor mit einem Parameterwert, der `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.#ctor(System.ComponentModel.TypeDescriptionProvider)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeDescriptionProvider (System.ComponentModel.TypeDescriptionProvider parent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.TypeDescriptionProvider parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.#ctor(System.ComponentModel.TypeDescriptionProvider)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (parent As TypeDescriptionProvider)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeDescriptionProvider(System::ComponentModel::TypeDescriptionProvider ^ parent);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.TypeDescriptionProvider : System.ComponentModel.TypeDescriptionProvider -&gt; System.ComponentModel.TypeDescriptionProvider" Usage="new System.ComponentModel.TypeDescriptionProvider parent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="parent" Type="System.ComponentModel.TypeDescriptionProvider" />
      </Parameters>
      <Docs>
        <param name="parent">Der übergeordnete Typbeschreibungsanbieter.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ComponentModel.TypeDescriptionProvider" />-Klasse unter Verwendung eines übergeordneten Typbeschreibungsanbieters.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `parent` Parameter `null`, dass alle <xref:System.ComponentModel.TypeDescriptionProvider> Methoden Standardwerte zurück. Andernfalls alle <xref:System.ComponentModel.TypeDescriptionProvider> Methoden werden an die Methoden der Delegieren `parent`.  
  
 Die folgende Tabelle zeigt die Standard-Rückgabewerte für <xref:System.ComponentModel.TypeDescriptionProvider> Methoden.  
  
|Methode|Standard-Rückgabewert|  
|------------|--------------------------|  
|<xref:System.ComponentModel.TypeDescriptionProvider.GetCache%2A>|`null`|  
|<xref:System.ComponentModel.TypeDescriptionProvider.CreateInstance%2A>|Ein neu erstelltes Objekt durch einen Aufruf der <xref:System.Activator.CreateInstance%2A> Methode.|  
|<xref:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor%2A>|Standard-Instanz eine <xref:System.ComponentModel.CustomTypeDescriptor> Klasse.|  
|<xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A>|Standard-Instanz eine <xref:System.ComponentModel.CustomTypeDescriptor> Klasse.|  
|<xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A>|Die `objectType` ersten Parameter.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.CustomTypeDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (IServiceProvider provider, Type objectType, Type[] argTypes, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(class System.IServiceProvider provider, class System.Type objectType, class System.Type[] argTypes, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateInstance (provider As IServiceProvider, objectType As Type, argTypes As Type(), args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(IServiceProvider ^ provider, Type ^ objectType, cli::array &lt;Type ^&gt; ^ argTypes, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : IServiceProvider * Type * Type[] * obj[] -&gt; obj&#xA;override this.CreateInstance : IServiceProvider * Type * Type[] * obj[] -&gt; obj" Usage="typeDescriptionProvider.CreateInstance (provider, objectType, argTypes, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IServiceProvider" />
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="argTypes" Type="System.Type[]" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="provider">Ein optionaler Dienstanbieter.</param>
        <param name="objectType">Der Typ des zu erstellenden Objekts. Dieser Parameter ist nie <see langword="null" />.</param>
        <param name="argTypes">Ein optionales Array von Typen, die die Parametertypen darstellen, die an den Konstruktor des Objekts übergeben werden sollen. Dieses Array kann <see langword="null" /> sein oder die Länge 0 haben.</param>
        <param name="args">Ein optionales Array von Parameterwerten, das an den Konstruktor des Objekts übergeben werden soll.</param>
        <summary>Erstellt ein Objekt, das einen anderen Datentyp ersetzen kann.</summary>
        <returns>Das ersetzende <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IServiceProvider> gemäß der `provider` ist übergebener eingehender Parameter der <xref:System.ComponentModel.TypeDescriptor.CreateInstance%2A?displayProperty=nameWithType> Methode der <xref:System.ComponentModel.TypeDescriptor> Klasse. Wenn `provider` nicht `null`, der Dienstanbieter kann von den Typbeschreibungsanbieter verwendet werden, um zusätzlichen Kontext zu der Aufruf zur auftragskontoerstellung zu erhalten.  
  
 Die <xref:System.ComponentModel.TypeDescriptionProvider.CreateInstance%2A> Methode ist `virtual` und, in der Standardeinstellung gibt das Ergebnis der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> Methode Wenn `provider` ist `null`. Wenn `provider` ist `null`, ruft diese Methode die <xref:System.ComponentModel.TypeDescriptionProvider.CreateInstance%2A> -Methode der der übergeordnete Anbieter.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn die abgeleitete Klasse nicht daran eine Instanz ersetzen interessiert ist, muss sie nur die basisimplementierung aufrufen.</para></block>
        <altmember cref="M:System.ComponentModel.TypeDescriptor.CreateInstance(System.IServiceProvider,System.Type,System.Type[],System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="GetCache">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary GetCache (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionary GetCache(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetCache(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCache (instance As Object) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionary ^ GetCache(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="abstract member GetCache : obj -&gt; System.Collections.IDictionary&#xA;override this.GetCache : obj -&gt; System.Collections.IDictionary" Usage="typeDescriptionProvider.GetCache instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Das Objekt, für das der Cache abgerufen werden soll.</param>
        <summary>Ruft einen objektbezogenen Cache ab, auf den als <see cref="T:System.Collections.IDictionary" /> der Schlüssel-Wert-Paare zugegriffen wird.</summary>
        <returns>Ein <see cref="T:System.Collections.IDictionary" />, wenn das bereitgestellte Objekt das Zwischenspeichern unterstützt; andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.ComponentModel.TypeDescriptor> erfordern u. u. komplexe Operationen in Auflistungen von Metadaten. Da die Typen nicht für die Lebensdauer einer Domäne, entladen werden die <xref:System.ComponentModel.TypeDescriptor> Klasse werden die Ergebnisse dieser Vorgänge basierend auf Typ automatisch zwischengespeichert. Allerdings verwenden einige Vorgänge live Objektinstanzen. Diese Vorgänge können nicht zwischengespeichert werden, in der <xref:System.ComponentModel.TypeDescriptor> Klasse, da sie Zwischenspeichern das Objekt verhindern würde Garbage collection. Stattdessen die <xref:System.ComponentModel.TypeDescriptor> Klasse ermöglicht, für einen Cache pro-Objekt als eine <xref:System.Collections.IDictionary> von Schlüssel/Wert-Paare in ein Objekt vorhanden ist. Die <xref:System.ComponentModel.TypeDescriptionProvider.GetCache%2A> Methode gibt eine Instanz dieses Caches zurück. Die <xref:System.ComponentModel.TypeDescriptionProvider.GetCache%2A> Methode zurück `null` Wenn es keinen unterstützten Cache für ein Objekt.  
  
 Der Standardwert <xref:System.ComponentModel.TypeDescriptionProvider> von verwendeten <xref:System.ComponentModel.TypeDescriptor> überprüft das Objekt, um festzustellen, ob es sich um eine positionierte Komponente ist, die implementiert die <xref:System.ComponentModel.Design.IDictionaryService> Schnittstelle. Wenn das Objekt ist, wird den Wörterbuchdienst zum Speichern des Objekts Caches. Andernfalls wird von dem Objekt zurückgegeben `null`. Andere Typbeschreibungsanbietern können hier ihre eigene Implementierung bereitstellen. Beispielsweise können Abhängigkeitsobjekte, die nur eine Eigenschaft vom Typ Anfügen <xref:System.Collections.IDictionary>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.ComponentModel.Design.IDictionaryService" />
      </Docs>
    </Member>
    <Member MemberName="GetExtendedTypeDescriptor">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.ICustomTypeDescriptor GetExtendedTypeDescriptor (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.ICustomTypeDescriptor GetExtendedTypeDescriptor(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExtendedTypeDescriptor (instance As Object) As ICustomTypeDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::ICustomTypeDescriptor ^ GetExtendedTypeDescriptor(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="abstract member GetExtendedTypeDescriptor : obj -&gt; System.ComponentModel.ICustomTypeDescriptor&#xA;override this.GetExtendedTypeDescriptor : obj -&gt; System.ComponentModel.ICustomTypeDescriptor" Usage="typeDescriptionProvider.GetExtendedTypeDescriptor instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ICustomTypeDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Das Objekt, für das der erweiterte Typdeskriptor abgerufen wird.</param>
        <summary>Ruft einen erweiterten benutzerdefinierten Typdeskriptor für das gegebene Objekt ab.</summary>
        <returns>Ein <see cref="T:System.ComponentModel.ICustomTypeDescriptor" />, der erweiterte Metadaten für das Objekt enthalten kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein erweiterte Typdeskriptor ist ein benutzerdefinierter Typdeskriptor, die Angebote, die Eigenschaften, die dieses Objekt, aber das andere Objekte hinzugefügt haben nicht, sind tatsächlich für das Objekt definiert. Z. B. in der [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] Komponente, Modellobjekte, implementieren die <xref:System.ComponentModel.IExtenderProvider> Schnittstelle kann Eigenschaften anfügen, auf andere Objekte, die sich im selben logischen Container befinden. Die überladene <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> Methoden geben einen Typdeskriptor, die diese zusätzlichen erweiterten Eigenschaften bietet keine zurück. Die <xref:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor%2A> Methode gibt den Satz der diese erweiterten Eigenschaften. Die <xref:System.ComponentModel.TypeDescriptor> werden die Ergebnisse dieser Sammlungen zwei Eigenschaft automatisch zusammengeführt. Während der [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] Komponentenmodell unterstützt nur erweiterte Eigenschaften <xref:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor%2A> kann für erweiterte Attribute als auch für Ereignisse verwendet werden, wenn Sie der Typbeschreibungsanbieter unterstützt.  
  
 <xref:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor%2A> ist `virtual` und, in der Standardeinstellung gibt einen benutzerdefinierten Typdeskriptor, die leere Ergebnisse zurückgibt, wenn keine übergeordnete Anbieter übergeben wurde. Wenn ein übergeordnete Anbieter übergeben wurde, ruft diese Methode der übergeordnete Anbieter <xref:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeDescriptor" />
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="GetExtenderProviders">
      <MemberSignature Language="C#" Value="protected internal virtual System.ComponentModel.IExtenderProvider[] GetExtenderProviders (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.ComponentModel.IExtenderProvider[] GetExtenderProviders(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetExtenderProviders(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetExtenderProviders (instance As Object) As IExtenderProvider()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual cli::array &lt;System::ComponentModel::IExtenderProvider ^&gt; ^ GetExtenderProviders(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="abstract member GetExtenderProviders : obj -&gt; System.ComponentModel.IExtenderProvider[]&#xA;override this.GetExtenderProviders : obj -&gt; System.ComponentModel.IExtenderProvider[]" Usage="typeDescriptionProvider.GetExtenderProviders instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IExtenderProvider[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="instance">Das Objekt, für das Extenderanbieter abgerufen werden sollen.</param>
        <summary>Ruft die Extenderanbieter für das angegebene Objekt ab.</summary>
        <returns>Ein Array von Extenderanbietern für <paramref name="instance" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFullComponentName">
      <MemberSignature Language="C#" Value="public virtual string GetFullComponentName (object component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetFullComponentName(object component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetFullComponentName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFullComponentName (component As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetFullComponentName(System::Object ^ component);" />
      <MemberSignature Language="F#" Value="abstract member GetFullComponentName : obj -&gt; string&#xA;override this.GetFullComponentName : obj -&gt; string" Usage="typeDescriptionProvider.GetFullComponentName component" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="component">Die angegebene Komponente.</param>
        <summary>Ruft den Namen der angegebenen Komponente ab, oder <see langword="null" />, wenn der Komponente kein Name zugewiesen ist.</summary>
        <returns>Der Name der angegebenen Komponente.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="component" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetReflectionType">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt normale Reflektion eines Objekts aus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public Type GetReflectionType (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetReflectionType(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetReflectionType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetReflectionType (instance As Object) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetReflectionType(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="member this.GetReflectionType : obj -&gt; Type" Usage="typeDescriptionProvider.GetReflectionType instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Eine Instanz des Typs (sollte nicht <see langword="null" /> sein).</param>
        <summary>Führt normale Reflektion eines gegebenen Objekts aus.</summary>
        <returns>Der Typ der Reflexion für dieses <paramref name="instance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> Methode ist eine Low-Level-Version von der <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> Methode. Wenn keine benutzerdefinierten Typdeskriptor für ein Objekt befinden kann <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> aufgerufen, um normale Reflektion eines Objekts durchzuführen.  
  
 Verwenden Sie diese methodenüberladung aus, wenn Sie einen Deskriptor Typmember aufgerufen haben, der eine Instanz anstelle eines Typs verwendet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> ist <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public Type GetReflectionType (Type objectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetReflectionType(class System.Type objectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetReflectionType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetReflectionType (objectType As Type) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetReflectionType(Type ^ objectType);" />
      <MemberSignature Language="F#" Value="member this.GetReflectionType : Type -&gt; Type" Usage="typeDescriptionProvider.GetReflectionType objectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="objectType">Der Objekttyp, für den <see cref="T:System.Reflection.IReflect" /> abgerufen wird.</param>
        <summary>Führt normale Reflektion eines Typs aus.</summary>
        <returns>Der Typ der Reflexion für dieses <paramref name="objectType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> Methode ist eine Low-Level-Version von der <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> Methode. Wenn keine benutzerdefinierten Typdeskriptor für ein Objekt befinden kann <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> aufgerufen, um normale Reflektion eines Objekts durchzuführen.  
  
 Verwenden Sie diese methodenüberladung, wenn Sie einen Deskriptor Typmember aufgerufen haben, der einen Typ statt einer Instanz verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="objectType" /> ist <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="GetReflectionType">
      <MemberSignature Language="C#" Value="public virtual Type GetReflectionType (Type objectType, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetReflectionType(class System.Type objectType, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetReflectionType(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReflectionType (objectType As Type, instance As Object) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetReflectionType(Type ^ objectType, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="abstract member GetReflectionType : Type * obj -&gt; Type&#xA;override this.GetReflectionType : Type * obj -&gt; Type" Usage="typeDescriptionProvider.GetReflectionType (objectType, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objectType">Der Objekttyp, für den <see cref="T:System.Reflection.IReflect" /> abgerufen wird.</param>
        <param name="instance">Eine Instanz des Typs. Kann <see langword="null" /> sein.</param>
        <summary>Führt normale Reflektion eines gegebenen Objekts mit dem gegebenen Typ aus.</summary>
        <returns>Der Typ der Reflexion für dieses <paramref name="objectType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> Methode ist eine Low-Level-Version von der <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> Methode. Wenn keine benutzerdefinierten Typdeskriptor für ein Objekt befinden kann <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> aufgerufen, um normale Reflektion eines Objekts durchzuführen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Diese Methode wird als <see langword="virtual" />, und von der Standardeinstellung gibt <paramref name="objectType" /> , wenn keine übergeordnete Anbieter übergeben wurde. Wenn ein übergeordnete Anbieter übergeben wurde, ruft diese Methode der übergeordnete Anbieter <see cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetReflectionType" /> Methode.</para></block>
        <altmember cref="Overload:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor" />
      </Docs>
    </Member>
    <Member MemberName="GetRuntimeType">
      <MemberSignature Language="C#" Value="public virtual Type GetRuntimeType (Type reflectionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetRuntimeType(class System.Type reflectionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetRuntimeType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRuntimeType (reflectionType As Type) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetRuntimeType(Type ^ reflectionType);" />
      <MemberSignature Language="F#" Value="abstract member GetRuntimeType : Type -&gt; Type&#xA;override this.GetRuntimeType : Type -&gt; Type" Usage="typeDescriptionProvider.GetRuntimeType reflectionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reflectionType" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="reflectionType">Der Typ, der in seine Laufzeitentsprechung konvertiert werden soll.</param>
        <summary>Konvertiert einen Reflektionstyp in einen Laufzeittyp.</summary>
        <returns>Ein <see cref="T:System.Type" />, der die Laufzeitentsprechung von <paramref name="reflectionType" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.TypeDescriptionProvider.GetRuntimeType%2A> -Methode kehrt das Ergebnis der <xref:System.ComponentModel.TypeDescriptionProvider.GetReflectionType%2A> Methode konvertiert einen Reflektionstyp in einen Common Language Runtime-Typ zurück. Mithilfe der <xref:System.ComponentModel.TypeDescriptionProvider.GetRuntimeType%2A> ist die bevorzugte Methode gegenüber der Verwendung der <xref:System.Type.UnderlyingSystemType%2A> -Eigenschaft, die in früheren Versionen verwendet wurde, um den Runtime-Typ zurückzugeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="reflectionType" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeDescriptor">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen benutzerdefinierten Typdeskriptor für den gegebenen Typ oder das gegebene Objekt ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeDescriptor">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ICustomTypeDescriptor GetTypeDescriptor (object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.ICustomTypeDescriptor GetTypeDescriptor(object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeDescriptor (instance As Object) As ICustomTypeDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::ICustomTypeDescriptor ^ GetTypeDescriptor(System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="member this.GetTypeDescriptor : obj -&gt; System.ComponentModel.ICustomTypeDescriptor" Usage="typeDescriptionProvider.GetTypeDescriptor instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ICustomTypeDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Eine Instanz des Typs. Kann <see langword="null" /> sein, wenn keine Instanz an den <see cref="T:System.ComponentModel.TypeDescriptor" /> übergeben würde.</param>
        <summary>Ruft einen benutzerdefinierten Typdeskriptor für das gegebene Objekt ab.</summary>
        <returns>Ein <see cref="T:System.ComponentModel.ICustomTypeDescriptor" />, der Metadaten für den Typ bereitstellen kann.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeDescriptor">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ICustomTypeDescriptor GetTypeDescriptor (Type objectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.ICustomTypeDescriptor GetTypeDescriptor(class System.Type objectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeDescriptor (objectType As Type) As ICustomTypeDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::ICustomTypeDescriptor ^ GetTypeDescriptor(Type ^ objectType);" />
      <MemberSignature Language="F#" Value="member this.GetTypeDescriptor : Type -&gt; System.ComponentModel.ICustomTypeDescriptor" Usage="typeDescriptionProvider.GetTypeDescriptor objectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ICustomTypeDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="objectType">Der Objekttyp, für den der Typdeskriptor abgerufen wird.</param>
        <summary>Ruft einen benutzerdefinierten Typdeskriptor für den gegebenen Typ ab.</summary>
        <returns>Ein <see cref="T:System.ComponentModel.ICustomTypeDescriptor" />, der Metadaten für den Typ bereitstellen kann.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeDescriptor">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.ICustomTypeDescriptor GetTypeDescriptor (Type objectType, object instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.ICustomTypeDescriptor GetTypeDescriptor(class System.Type objectType, object instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeDescriptor (objectType As Type, instance As Object) As ICustomTypeDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::ICustomTypeDescriptor ^ GetTypeDescriptor(Type ^ objectType, System::Object ^ instance);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeDescriptor : Type * obj -&gt; System.ComponentModel.ICustomTypeDescriptor&#xA;override this.GetTypeDescriptor : Type * obj -&gt; System.ComponentModel.ICustomTypeDescriptor" Usage="typeDescriptionProvider.GetTypeDescriptor (objectType, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ICustomTypeDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectType" Type="System.Type" />
        <Parameter Name="instance" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objectType">Der Objekttyp, für den der Typdeskriptor abgerufen wird.</param>
        <param name="instance">Eine Instanz des Typs. Kann <see langword="null" /> sein, wenn keine Instanz an den <see cref="T:System.ComponentModel.TypeDescriptor" /> übergeben würde.</param>
        <summary>Ruft einen benutzerdefinierten Typdeskriptor für den gegebenen Typ und das gegebene Objekt ab.</summary>
        <returns>Ein <see cref="T:System.ComponentModel.ICustomTypeDescriptor" />, der Metadaten für den Typ bereitstellen kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird als `virtual` und gibt standardmäßig einen leeren Deskriptor zurück, wenn keine übergeordnete Anbieter übergeben wurde. Wenn ein übergeordnete Anbieter übergeben wurde, ruft diese Methode der übergeordnete Anbieter <xref:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor%2A> Methode.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Die <see cref="M:System.ComponentModel.TypeDescriptionProvider.GetTypeDescriptor(System.Type,System.Object)" /> Methode sollte einen benutzerdefinierten Typdeskriptor für das Objekt zurückgeben. Wenn die Methode keine Typinformationen für das Objekt bereitstellt, sollte es zurückgeben <see langword="null" />.</para></block>
        <altmember cref="M:System.ComponentModel.TypeDescriptionProvider.GetExtendedTypeDescriptor(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IsSupportedType">
      <MemberSignature Language="C#" Value="public virtual bool IsSupportedType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSupportedType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.TypeDescriptionProvider.IsSupportedType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSupportedType(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member IsSupportedType : Type -&gt; bool&#xA;override this.IsSupportedType : Type -&gt; bool" Usage="typeDescriptionProvider.IsSupportedType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, der auf Kompatibilität überprüft werden soll.</param>
        <summary>Ruft einen Wert ab, der angibt, ob der angegebene Typ mit der Typbeschreibung und der Kette von Typbeschreibungsanbietern kompatibel ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="type" /> mit der Typbeschreibung und der Kette von Typbeschreibungsanbietern kompatibel ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>