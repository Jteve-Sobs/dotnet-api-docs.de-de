<Type Name="MaskedTextProvider" FullName="System.ComponentModel.MaskedTextProvider">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9c383ca2bbc7319c3cf71770d8901bd28e99c585" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70337381" /></Metadata><TypeSignature Language="C#" Value="public class MaskedTextProvider : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MaskedTextProvider extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.MaskedTextProvider" />
  <TypeSignature Language="VB.NET" Value="Public Class MaskedTextProvider&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MaskedTextProvider : ICloneable" />
  <TypeSignature Language="F#" Value="type MaskedTextProvider = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt einen Maskenanalysedienst dar, der von einer beliebigen Anzahl von Steuerelementen, die Maskierung unterstützen, verwendet werden kann, z. B. dem <see cref="T:System.Windows.Forms.MaskedTextBox" />-Steuerelement.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Forms.MaskedTextBox> -Steuerelement enthält eine Maske, die aus Literalzeichen und Formatierungs Elementen besteht, die alle Benutzereingaben mit testet. Anstatt eine bestimmte Mask-Engine-Engine <xref:System.Windows.Forms.MaskedTextBox>permanent zuzuordnen, stellt Windows Forms Sie als separaten Dienst bereit, der durch die <xref:System.ComponentModel.MaskedTextProvider> -Klasse dargestellt wird, die die Syntax der in der Dokumentation für beschriebenen Maskierungs Sprache definiert. die <xref:System.Windows.Forms.MaskedTextBox.Mask%2A> -Eigenschaft.  
  
 Viele der Member der <xref:System.Windows.Forms.MaskedTextBox> -Klasse verweisen Ihre Implementierung auf ähnliche Member der zugeordneten. <xref:System.ComponentModel.MaskedTextProvider> Beispielsweise bezieht sich <xref:System.Windows.Forms.MaskedTextBox.PromptChar%2A?displayProperty=nameWithType> die-Eigenschaft <xref:System.Windows.Forms.MaskedTextBox> der-Klasse auf den gesamten <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> <xref:System.ComponentModel.MaskedTextProvider> Zugriff auf den der-Klasse.  
  
 Das von <xref:System.ComponentModel.MaskedTextProvider> verwendete Masken Bearbeitungsmodul wird nach dem maskierten Bearbeitungs Steuerelement modelliert, das in Microsoft Visual Basic Version 6 enthalten war. Die Maskierungs Sprache wird in der Dokumentation für die <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> -Eigenschaft beschrieben.  
  
 Die folgenden drei unterschiedlichen Zeichen folgen sind an <xref:System.ComponentModel.MaskedTextProvider> der-Klasse beteiligt.  
  
|Zeichen folgen Name|Beschreibung|  
|-----------------|-----------------|  
|Eingabezeichen oder Zeichenfolge|Stellt die Zeichen dar, die als Eingabe verwendet werden, auf die die Maske angewendet wird. In Wirklichkeit kann die Eingabe Zeichenfolge aus mehreren Eingabe Vorgängen bestehen, einschließlich <xref:System.ComponentModel.MaskedTextProvider.Add%2A>, <xref:System.ComponentModel.MaskedTextProvider.Replace%2A>, <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A>und <xref:System.ComponentModel.MaskedTextProvider.Remove%2A>. Daher kann nicht direkt auf die Eingabe Zeichenfolge zugegriffen werden. Aspekte der Eingabe Zeichenfolgen-Behandlung sind jedoch über die <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> Eigenschaften <xref:System.ComponentModel.MaskedTextProvider.AsciiOnly%2A>und <xref:System.ComponentModel.MaskedTextProvider.ResetOnPrompt%2A>, und <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> verfügbar.|  
|Format|Stellt die Eingabe Formatierung dar, mit der die Eingabe Zeichenfolge in die formatierte Zeichenfolge transformiert wird. Diese Zeichenfolge wird in <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> festgelegt, und der Zugriff erfolgt primär über die <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> -Eigenschaft. Merkmale der Maske sind auch über andere Member verfügbar, wie z. b <xref:System.ComponentModel.MaskedTextProvider.Length%2A>. <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A>die Eigenschaften <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> , und.|  
|Formatierte Zeichenfolge|Stellt die Zeichenfolge dar, die ergibt, wenn die vollständige Maske auf die Eingabe Zeichenfolge angewendet wird. Die formatierte Zeichenfolge kann mit vielen Membern der-Klasse abgefragt werden <xref:System.ComponentModel.MaskedTextProvider.Item%2A>, <xref:System.ComponentModel.MaskedTextProvider.Length%2A>einschließlich <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A>, <xref:System.ComponentModel.MaskedTextProvider.MaskFull%2A>, <xref:System.ComponentModel.MaskedTextProvider.MaskCompleted%2A>, <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom%2A>,, usw. Der vollständige Wert der formatierten Zeichenfolge ist über <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> die <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> -Methode und die-Methode verfügbar.|  
  
> [!NOTE]
>  Die Eingabe Zeichenfolge kann eine direkte Benutzereingabe darstellen, wie im Fall <xref:System.Windows.Forms.MaskedTextBox>von, oder kann von anderen Prozessen generiert werden, die nicht direkt den Benutzereingabe-/Ausgabevorgängen zugeordnet sind.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.MaskedTextBox" />
    <altmember cref="P:System.Windows.Forms.MaskedTextBox.MaskedTextProvider" />
    <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ComponentModel.MaskedTextProvider" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider mask" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="mask">Ein <see cref="T:System.String" />, der die Eingabemaske darstellt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ComponentModel.MaskedTextProvider" />-Klasse unter Verwendung der angegebenen Maske.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Verwendung dieses Konstruktors entspricht exakt dem folgenden <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> aufrufskonstruktor:  
  
 `MaskedTextProvider(mask , null, true, '_', '\0', false)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, bool restrictToAscii);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, bool restrictToAscii) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, restrictToAscii As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, bool restrictToAscii);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * bool -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, restrictToAscii)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="restrictToAscii" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask">Ein <see cref="T:System.String" />, der die Eingabemaske darstellt.</param>
        <param name="restrictToAscii"><see langword="true" />, um die Eingabe auf ASCII-kompatible Zeichen zu beschränken, andernfalls <see langword="false" />, um den gesamten Unicode-Satz zuzulassen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ComponentModel.MaskedTextProvider" />-Klasse unter Verwendung der angegebenen Maske und des angegebenen ASCII-Einschränkungswerts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Verwendung dieses Konstruktors entspricht exakt dem folgenden <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> aufrufskonstruktor:  
  
 `MaskedTextProvider(mask , null, true, '_', '\0', restrictToASCII)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, culture As CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * System.Globalization.CultureInfo -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, culture)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="mask">Ein <see cref="T:System.String" />, der die Eingabemaske darstellt.</param>
        <param name="culture">Eine <see cref="T:System.Globalization.CultureInfo" />, mit deren Hilfe regionsabhängige Trennzeichen festgelegt werden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ComponentModel.MaskedTextProvider" />-Klasse unter Verwendung der angegebenen Maske und der angegebenen Kultur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Verwendung dieses Konstruktors entspricht exakt dem folgenden <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> aufrufskonstruktor:  
  
 `MaskedTextProvider(mask , culture, true, '_', '\0', false)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Culture" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, char passwordChar, bool allowPromptAsInput);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, char passwordChar, bool allowPromptAsInput) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Char,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, passwordChar As Char, allowPromptAsInput As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, char passwordChar, bool allowPromptAsInput);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * char * bool -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, passwordChar, allowPromptAsInput)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="passwordChar" Type="System.Char" />
        <Parameter Name="allowPromptAsInput" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask">Ein <see cref="T:System.String" />, der die Eingabemaske darstellt.</param>
        <param name="passwordChar">Ein <see cref="T:System.Char" />, der für in eine Kennwortzeichenfolge eingegebene Zeichen angezeigt wird.</param>
        <param name="allowPromptAsInput"><see langword="true" />, um die Eingabe des Aufforderungszeichens zuzulassen, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert unter Verwendung der angegebenen Maske, des angegebenen Kennwortzeichens und des Aufforderungsverwendungswerts eine neue Instanz der <see cref="T:System.ComponentModel.MaskedTextProvider" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Verwendung dieses Konstruktors entspricht exakt dem folgenden <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> aufrufskonstruktor:  
  
 `MaskedTextProvider(mask , null, allowPromptAsInput, '_', passwordChar, false)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, System.Globalization.CultureInfo culture, bool restrictToAscii);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, class System.Globalization.CultureInfo culture, bool restrictToAscii) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Globalization.CultureInfo,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, culture As CultureInfo, restrictToAscii As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, System::Globalization::CultureInfo ^ culture, bool restrictToAscii);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * System.Globalization.CultureInfo * bool -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, culture, restrictToAscii)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="restrictToAscii" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask">Ein <see cref="T:System.String" />, der die Eingabemaske darstellt.</param>
        <param name="culture">Eine <see cref="T:System.Globalization.CultureInfo" />, mit deren Hilfe regionsabhängige Trennzeichen festgelegt werden.</param>
        <param name="restrictToAscii"><see langword="true" />, um die Eingabe auf ASCII-kompatible Zeichen zu beschränken, andernfalls <see langword="false" />, um den gesamten Unicode-Satz zuzulassen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ComponentModel.MaskedTextProvider" />-Klasse unter Verwendung der angegebenen Maske und Kultur sowie des angegebenen ASCII-Einschränkungswerts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Verwendung dieses Konstruktors entspricht exakt dem folgenden <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> aufrufskonstruktor:  
  
 `MaskedTextProvider(mask , culture, true, '_', '\0', restrictToAscii)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Culture" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, System.Globalization.CultureInfo culture, char passwordChar, bool allowPromptAsInput);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, class System.Globalization.CultureInfo culture, char passwordChar, bool allowPromptAsInput) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Globalization.CultureInfo,System.Char,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, culture As CultureInfo, passwordChar As Char, allowPromptAsInput As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, System::Globalization::CultureInfo ^ culture, char passwordChar, bool allowPromptAsInput);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * System.Globalization.CultureInfo * char * bool -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, culture, passwordChar, allowPromptAsInput)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="passwordChar" Type="System.Char" />
        <Parameter Name="allowPromptAsInput" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask">Ein <see cref="T:System.String" />, der die Eingabemaske darstellt.</param>
        <param name="culture">Eine <see cref="T:System.Globalization.CultureInfo" />, mit deren Hilfe regionsabhängige Trennzeichen festgelegt werden.</param>
        <param name="passwordChar">Ein <see cref="T:System.Char" />, der für in eine Kennwortzeichenfolge eingegebene Zeichen angezeigt wird.</param>
        <param name="allowPromptAsInput"><see langword="true" />, um die Eingabe des Aufforderungszeichens zuzulassen, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert unter Verwendung der angegebenen Maske und Kultur, des angegebenen Kennwortzeichens und des Aufforderungsverwendungswerts eine neue Instanz der <see cref="T:System.ComponentModel.MaskedTextProvider" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Verwendung dieses Konstruktors entspricht exakt dem folgenden <xref:System.ComponentModel.MaskedTextProvider.%23ctor%28System.String%2CSystem.Globalization.CultureInfo%2CSystem.Boolean%2CSystem.Char%2CSystem.Char%2CSystem.Boolean%29?displayProperty=nameWithType> aufrufskonstruktor:  
  
 `MaskedTextProvider(mask , culture, allowPromptAsInput, '_', passwordChar, false)`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Culture" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MaskedTextProvider (string mask, System.Globalization.CultureInfo culture, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string mask, class System.Globalization.CultureInfo culture, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.#ctor(System.String,System.Globalization.CultureInfo,System.Boolean,System.Char,System.Char,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mask As String, culture As CultureInfo, allowPromptAsInput As Boolean, promptChar As Char, passwordChar As Char, restrictToAscii As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MaskedTextProvider(System::String ^ mask, System::Globalization::CultureInfo ^ culture, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.MaskedTextProvider : string * System.Globalization.CultureInfo * bool * char * char * bool -&gt; System.ComponentModel.MaskedTextProvider" Usage="new System.ComponentModel.MaskedTextProvider (mask, culture, allowPromptAsInput, promptChar, passwordChar, restrictToAscii)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mask" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="allowPromptAsInput" Type="System.Boolean" />
        <Parameter Name="promptChar" Type="System.Char" />
        <Parameter Name="passwordChar" Type="System.Char" />
        <Parameter Name="restrictToAscii" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mask">Ein <see cref="T:System.String" />, der die Eingabemaske darstellt.</param>
        <param name="culture">Eine <see cref="T:System.Globalization.CultureInfo" />, mit deren Hilfe regionsabhängige Trennzeichen festgelegt werden.</param>
        <param name="allowPromptAsInput">Ein <see cref="T:System.Boolean" />-Wert, der angibt, ob das Aufforderungszeichen als gültiges Eingabezeichen zugelassen werden soll.</param>
        <param name="promptChar">Ein <see cref="T:System.Char" />, der als Platzhalter für Benutzereingaben angezeigt wird.</param>
        <param name="passwordChar">Ein <see cref="T:System.Char" />, der für in eine Kennwortzeichenfolge eingegebene Zeichen angezeigt wird.</param>
        <param name="restrictToAscii"><see langword="true" />, um die Eingabe auf ASCII-kompatible Zeichen zu beschränken, andernfalls <see langword="false" />, um den gesamten Unicode-Satz zuzulassen.</param>
        <summary>Initialisiert unter Verwendung der angegebenen Maske und Kultur, des angegebenen Aufforderungsverwendungswerts, des Kennwortzeichens und des ASCII-Einschränkungswerts eine neue Instanz der <see cref="T:System.ComponentModel.MaskedTextProvider" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor stellt das allgemeinste überladene Formular dar. Der `mask` -Parameter muss der von der <xref:System.ComponentModel.MaskedTextProvider> -Klasse definierten Maskierungs Sprache entsprechen, die <xref:System.Windows.Forms.MaskedTextBox> in der <xref:System.Windows.Forms.MaskedTextBox.Mask%2A?displayProperty=nameWithType> -Eigenschaft der-Klasse ausführlich erläutert wird.  
  
 Da neutrale Kulturen nicht auf kulturspezifische Informationen abgefragt werden können, verwendet der <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> Konstruktor die <xref:System.Globalization.CultureInfo.GetCultures%2A> -Methode, um nach der ersten nicht neutralen Kultur zu suchen, die zum Bestimmen der richtigen Trennzeichen verwendet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Maskenparameter hat den Wert <see langword="null" /> oder <see cref="F:System.String.Empty" />.  
  
- oder - 
Die Maske enthält ein oder mehrere nicht druckbare Zeichen.</exception>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.Mask" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.Clone" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Culture" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt der formatierten Zeichenfolge ein Eingabezeichen oder eine Eingabezeichenfolge hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (char input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Add(char input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Add(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (input As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Add(char input);" />
      <MemberSignature Language="F#" Value="member this.Add : char -&gt; bool" Usage="maskedTextProvider.Add input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="input">Ein <see cref="T:System.Char" />-Wert, der an die formatierte Zeichenfolge angefügt werden soll.</param>
        <summary>Fügt das angegebene Eingabezeichen am Ende der formatierten Zeichenfolge hinzu.</summary>
        <returns><see langword="true" />, wenn das Eingabezeichen erfolgreich hinzugefügt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Add%28System.Char%29> -Methode fügt `input` den Zeichen Wert der ersten verfügbaren Position in der formatierten Zeichenfolge nach der zuletzt zugewiesenen Position hinzu, die durch die <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A> -Eigenschaft dargestellt wird. Diese Methode kann aus einem der folgenden Gründe nicht ausgeführt werden:  
  
-   Der Eingabe Wert, `input`, ist nicht druckbar oder stimmt nicht mit dem entsprechenden Mask-Element überein.  
  
-   In der formatierten Zeichenfolge sind keine Bearbeitungs Positionen verfügbar, oder nach der letzten zugewiesenen Position sind keine Bearbeitungs Positionen verfügbar.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Add(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Add(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Add(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Add : string -&gt; bool" Usage="maskedTextProvider.Add input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Ein <see cref="T:System.String" /> mit Zeichenwerten, die an die formatierte Zeichenfolge angefügt werden sollen.</param>
        <summary>Fügt die Zeichen aus der angegebenen Eingabezeichenfolge am Ende der formatierten Zeichenfolge hinzu.</summary>
        <returns><see langword="true" />, wenn alle Zeichen aus der Eingabezeichenfolge erfolgreich hinzugefügt wurden, andernfalls <see langword="false" />, um anzugeben, dass keine Zeichen hinzugefügt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Add%28System.String%29> -Methode fügt die Zeichen aus `input` der Zeichenfolge der formatierten Zeichenfolge hinzu, beginnend mit der <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A>ersten verfügbaren Position nach. Diese Methode kann aus einem der folgenden Gründe nicht ausgeführt werden:  
  
-   Alle Zeichen im Eingabe Wert, `input`, sind nicht druckbar, oder der Eingabe Wert stimmt nicht mit dem entsprechenden Mask-Element überein.  
  
-   Nach der letzten zugewiesenen Position sind nicht genügend Bearbeitungs Positionen in der formatierten Zeichenfolge vorhanden.  
  
 Wenn diese Methode fehlschlägt, werden keine Ergänzungen vorgenommen, und die `false`Methode gibt zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (char input, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Add(char input, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Add(System.Char,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (input As Char, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Add(char input, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Add : char * int * MaskedTextResultHint -&gt; bool" Usage="maskedTextProvider.Add (input, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Ein <see cref="T:System.Char" />-Wert, der an die formatierte Zeichenfolge angefügt werden soll.</param>
        <param name="testPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an der versucht wurde, das Zeichen hinzuzufügen. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" />, mit dem das Ergebnis des Vorgangs kurz beschrieben wird. Ein Ausgabeparameter.</param>
        <summary>Fügt das angegebene Eingabezeichen am Ende der formatierten Zeichenfolge hinzu und gibt dann Positions- und beschreibende Informationen aus.</summary>
        <returns><see langword="true" />, wenn das Eingabezeichen erfolgreich hinzugefügt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Add%28System.Char%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> -Methode versucht, den `input` Zeichen Wert der ersten verfügbaren Position in der formatierten Zeichenfolge nach der zuletzt zugewiesenen Position hinzuzufügen, die durch die <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A> -Eigenschaft dargestellt wird. Bei dieser Methode tritt ein Fehler auf, wenn alle verfügbaren Positionen vor der letzten zugewiesenen Position liegen. Diese Methode kann aus einem der folgenden Gründe nicht ausgeführt werden:  
  
-   Der Eingabe Wert, `input`, ist nicht druckbar oder stimmt nicht mit dem entsprechenden Mask-Element überein.  
  
-   In der formatierten Zeichenfolge sind keine Bearbeitungs Positionen verfügbar, oder nach der letzten zugewiesenen Position sind keine Bearbeitungs Positionen verfügbar.  
  
 Diese Methode funktioniert genauso wie die überschriebene Version, die einen <xref:System.Char> einzelnen Parameter <xref:System.ComponentModel.MaskedTextProvider.Add%28System.Char%29>,, mit dem Unterschied, dass Sie zusätzliche Informationen ausgibt.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (string input, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Add(string input, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Add(System.String,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (input As String, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Add(System::String ^ input, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Add : string * int * MaskedTextResultHint -&gt; bool" Usage="maskedTextProvider.Add (input, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Ein <see cref="T:System.String" /> mit Zeichenwerten, die an die formatierte Zeichenfolge angefügt werden sollen.</param>
        <param name="testPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an der versucht wurde, das Zeichen hinzuzufügen. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" />, mit dem das Ergebnis des Vorgangs kurz beschrieben wird. Ein Ausgabeparameter.</param>
        <summary>Fügt die Zeichen aus der angegebenen Eingabezeichenfolge am Ende der formatierten Zeichenfolge hinzu und gibt dann Positions- und beschreibende Informationen aus.</summary>
        <returns><see langword="true" />, wenn alle Zeichen aus der Eingabezeichenfolge erfolgreich hinzugefügt wurden, andernfalls <see langword="false" />, um anzugeben, dass keine Zeichen hinzugefügt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Add%28System.String%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> -Methode fügt die Zeichen aus `input` der Zeichenfolge der formatierten Zeichenfolge hinzu, beginnend mit der <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A>ersten verfügbaren Position nach. Diese Methode kann aus einem der folgenden Gründe nicht ausgeführt werden:  
  
-   Alle Zeichen im Eingabe Wert, `input`, sind nicht druckbar, oder der Eingabe Wert stimmt nicht mit dem entsprechenden Mask-Element überein.  
  
-   Nach der letzten zugewiesenen Position sind nicht genügend Bearbeitungs Positionen in der formatierten Zeichenfolge vorhanden.  
  
 Wenn diese Methode fehlschlägt, werden keine Ergänzungen vorgenommen, und die `false`Methode gibt zurück.  
  
 Diese Methode funktioniert genauso wie die überschriebene Version, die einen <xref:System.String> einzelnen Parameter <xref:System.ComponentModel.MaskedTextProvider.Add%28System.String%29>,, mit dem Unterschied, dass Sie zusätzliche Informationen ausgibt.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="AllowPromptAsInput">
      <MemberSignature Language="C#" Value="public bool AllowPromptAsInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowPromptAsInput" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllowPromptAsInput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowPromptAsInput { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowPromptAsInput : bool" Usage="System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Aufforderungszeichen als gültiges Eingabezeichen behandelt werden soll.</summary>
        <value><see langword="true" />, wenn der Benutzer <see cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" /> im Steuerelement eingeben darf, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> Wert der Eigenschaft wird <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> im Konstruktor festgelegt.  
  
 Selbst wenn <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> ist `true`, muss das Aufforderungs Zeichen für die aktuelle Position in der Maske gültig sein, damit Sie akzeptiert wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.AllowPromptAsInput" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
      </Docs>
    </Member>
    <Member MemberName="AsciiOnly">
      <MemberSignature Language="C#" Value="public bool AsciiOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsciiOnly" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsciiOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AsciiOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AsciiOnly : bool" Usage="System.ComponentModel.MaskedTextProvider.AsciiOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Maske Zeichen akzeptiert, die nicht dem ASCII-Zeichensatz angehören.</summary>
        <value><see langword="true" />, wenn nur ASCII akzeptiert wird, und <see langword="false" />, wenn <see cref="T:System.ComponentModel.MaskedTextProvider" /> jedes beliebige Unicode-Zeichen akzeptieren darf. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.ComponentModel.MaskedTextProvider.AsciiOnly%2A> Wert der Eigenschaft wird <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> im Konstruktor festgelegt.  
  
 Wenn `true`, <xref:System.ComponentModel.MaskedTextProvider.AsciiOnly%2A> wird die Benutzereingabe auf den ASCII-Zeichensatz beschränkt.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.AsciiOnly" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
      </Docs>
    </Member>
    <Member MemberName="AssignedEditPositionCount">
      <MemberSignature Language="C#" Value="public int AssignedEditPositionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AssignedEditPositionCount" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AssignedEditPositionCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AssignedEditPositionCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AssignedEditPositionCount : int" Usage="System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl von bearbeitbaren Zeichenpositionen ab, denen bereits erfolgreich ein Eingabewert zugewiesen wurde.</summary>
        <value>Ein <see cref="T:System.Int32" /> mit der Anzahl der in der Eingabemaske enthaltenen bearbeitbaren Zeichenpositionen, denen bereits ein Zeichenwert in der formatierten Zeichenfolge zugewiesen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Gesamtanzahl der bearbeitbaren Zeichen Positionen, die durch <xref:System.ComponentModel.MaskedTextProvider.EditPositionCount%2A> die <xref:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount%2A> -Eigenschaft dargestellt werden, sollte der Summe der <xref:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount%2A> -Eigenschaft und der-Eigenschaft entsprechen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="AvailableEditPositionCount">
      <MemberSignature Language="C#" Value="public int AvailableEditPositionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AvailableEditPositionCount" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableEditPositionCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AvailableEditPositionCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AvailableEditPositionCount : int" Usage="System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der bearbeitbaren Zeichenpositionen in der Eingabemaske ab, denen bisher noch kein Eingabewert zugewiesen wurde.</summary>
        <value>Ein <see cref="T:System.Int32" /> mit der Anzahl der bearbeitbaren Zeichenpositionen, denen bisher noch kein Zeichenwert zugewiesen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Gesamtanzahl der bearbeitbaren Zeichen Positionen, die durch <xref:System.ComponentModel.MaskedTextProvider.EditPositionCount%2A> die <xref:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount%2A> -Eigenschaft dargestellt werden, sollte der Summe der <xref:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount%2A> -Eigenschaft und der-Eigenschaft entsprechen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Clear">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht alle Eingabezeichen aus der formatierten Zeichenfolge.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="maskedTextProvider.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle bearbeitbaren Eingabezeichen aus der formatierten Zeichenfolge und ersetzt sie durch Aufforderungszeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Clear> -Methode initialisiert die formatierte Zeichenfolge erneut, wobei das Eingabe Aufforderungs Zeichen in alle bearbeitbaren Positionen eingefügt wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear (out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear([out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Clear(System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear (ByRef resultHint As MaskedTextResultHint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear([Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Clear : MaskedTextResultHint -&gt; unit" Usage="maskedTextProvider.Clear resultHint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" />, mit dem das Ergebnis des Vorgangs kurz beschrieben wird. Ein Ausgabeparameter.</param>
        <summary>Löscht alle bearbeitbaren Eingabezeichen aus der formatierten Zeichenfolge, ersetzt sie durch Aufforderungszeichen und gibt dann beschreibende Informationen aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Clear%28System.ComponentModel.MaskedTextResultHint%40%29> -Methode initialisiert die formatierte Zeichenfolge erneut, wobei das Eingabe Aufforderungs Zeichen in alle bearbeitbaren Positionen eingefügt wird. Sie funktioniert gleichwertig mit der überschriebenen Version, die keine Parameter <xref:System.ComponentModel.MaskedTextProvider.Clear>annimmt,, außer Sie gibt zusätzliche Informationen aus.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="maskedTextProvider.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Kopie der aktuellen <see cref="T:System.ComponentModel.MaskedTextProvider" />.</summary>
        <returns>Das von dieser Methode erstellte <see cref="T:System.ComponentModel.MaskedTextProvider" />-Objekt, umgewandelt in ein Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Clone%2A> -Methode gibt eine neue Kopie der aktuellen <xref:System.ComponentModel.MaskedTextProvider>zurück.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.#ctor" />
        <altmember cref="T:System.ICloneable" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Culture { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.Culture" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Culture : System.Globalization.CultureInfo" Usage="System.ComponentModel.MaskedTextProvider.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Kultur ab, die den Wert der lokalisierbaren Trennzeichen und Platzhalter in der Eingabemaske bestimmt.</summary>
        <value>Ein <see cref="T:System.Globalization.CultureInfo" /> mit den der Eingabemaske zugeordneten Kulturinformationen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Culture%2A> -Eigenschaft wird <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> im-Konstruktor festgelegt.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.Culture" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPasswordChar">
      <MemberSignature Language="C#" Value="public static char DefaultPasswordChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property char DefaultPasswordChar" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultPasswordChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property char DefaultPasswordChar { char get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPasswordChar : char" Usage="System.ComponentModel.MaskedTextProvider.DefaultPasswordChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das zur Verdeckung von Benutzereingaben verwendete Standardkennwortzeichen ab.</summary>
        <value>Ein <see cref="T:System.Char" />, der das Standardkennwortzeichen darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar%2A> -Eigenschaft ist in der <xref:System.ComponentModel.MaskedTextProvider> -Klasse als Sternchen (*) definiert.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.UseSystemPasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IsPassword" />
      </Docs>
    </Member>
    <Member MemberName="EditPositionCount">
      <MemberSignature Language="C#" Value="public int EditPositionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 EditPositionCount" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EditPositionCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int EditPositionCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.EditPositionCount : int" Usage="System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der bearbeitbaren Positionen in der formatierten Zeichenfolge ab.</summary>
        <value>Ein <see cref="T:System.Int32" /> mit der Anzahl der bearbeitbaren Positionen in der formatierten Zeichenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Gesamtanzahl der bearbeitbaren Zeichen Positionen, die durch <xref:System.ComponentModel.MaskedTextProvider.EditPositionCount%2A> die <xref:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount%2A> -Eigenschaft dargestellt werden, muss der Summe der <xref:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount%2A> -Eigenschaft und der-Eigenschaft entsprechen. Dieser Wert enthält sowohl das erforderliche als auch das optionale bearbeitbare Zeichen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="EditPositions">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator EditPositions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator EditPositions" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EditPositions As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IEnumerator ^ EditPositions { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EditPositions : System.Collections.IEnumerator" Usage="System.ComponentModel.MaskedTextProvider.EditPositions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen neu erstellten Enumerator für die bearbeitbaren Positionen in der formatierten Zeichenfolge ab.</summary>
        <value>Ein <see cref="T:System.Collections.IEnumerator" />, der Enumeration über die bearbeitbaren Positionen in der formatierten Zeichenfolge unterstützt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei jedem Zugriff auf die <xref:System.ComponentModel.MaskedTextProvider.EditPositions%2A> -Eigenschaft wird eine temporäre Auflistung von bearbeitbaren Positionen erstellt, die <xref:System.Collections.IEnumerator> von abgerufen werden.  
  
 Diese Auflistung ist schreibgeschützt.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindAssignedEditPositionFrom">
      <MemberSignature Language="C#" Value="public int FindAssignedEditPositionFrom (int position, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindAssignedEditPositionFrom(int32 position, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAssignedEditPositionFrom (position As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindAssignedEditPositionFrom(int position, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindAssignedEditPositionFrom : int * bool -&gt; int" Usage="maskedTextProvider.FindAssignedEditPositionFrom (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Suche gestartet werden soll.</param>
        <param name="direction">Ein <see cref="T:System.Boolean" />, der die Suchrichtung angibt: <see langword="true" />, um vorwärts zu suchen, oder <see langword="false" />, um rückwärts zu suchen.</param>
        <summary>Gibt die Position der ersten zugewiesenen bearbeitbaren Position nach der angegebenen Position in der angegebenen Suchrichtung zurück.</summary>
        <returns>Bei erfolgreicher Suche ein <see cref="T:System.Int32" />, der die nullbasierte Position der ersten zugewiesenen bearbeitbaren Position darstellt, die gefunden wurde, andernfalls <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die formatierte Zeichenfolge besteht aus bearbeitbaren Zeichen und Literalen, die aus der Maske kopiert werden. Die bearbeitbaren Zeichen Positionen werden entweder von dem Eingabe Aufforderungs Zeichen, das aus der Maske kopiert wird, wenn Sie nicht zugewiesen sind, oder mit einem gültigen Eingabezeichen belegt, wenn Ihnen eine Eingabe zugewiesen wurde.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom%2A> -Methode wird verwendet, um nach der angegebenen Position und Suchrichtung nach dem ersten zugewiesenen Zeichen zu suchen. Das Ergebnis kann dann als Parameter an den <xref:System.ComponentModel.MaskedTextProvider.Item%2A> Indexer übergeben werden, um den zugewiesenen Wert an dieser Position zu erhalten.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom%2A> - <xref:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom%2A> Methode und die-Methode sind Ergänzungen dieser Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindAssignedEditPositionInRange">
      <MemberSignature Language="C#" Value="public int FindAssignedEditPositionInRange (int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindAssignedEditPositionInRange(int32 startPosition, int32 endPosition, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAssignedEditPositionInRange (startPosition As Integer, endPosition As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindAssignedEditPositionInRange(int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindAssignedEditPositionInRange : int * int * bool -&gt; int" Usage="maskedTextProvider.FindAssignedEditPositionInRange (startPosition, endPosition, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Suche beginnt.</param>
        <param name="endPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Suche endet.</param>
        <param name="direction">Ein <see cref="T:System.Boolean" />, der die Suchrichtung angibt: <see langword="true" />, um vorwärts zu suchen, oder <see langword="false" />, um rückwärts zu suchen.</param>
        <summary>Gibt die Position der ersten zugewiesenen bearbeitbaren Position zwischen den angegebenen Positionen in der angegebenen Suchrichtung zurück.</summary>
        <returns>Bei erfolgreicher Suche ein <see cref="T:System.Int32" />, der die nullbasierte Position der ersten zugewiesenen bearbeitbaren Position darstellt, die gefunden wurde, andernfalls <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die formatierte Zeichenfolge besteht aus bearbeitbaren Zeichen und Literalen, die aus der Maske kopiert werden. Die bearbeitbaren Zeichen Positionen werden entweder von dem Eingabe Aufforderungs Zeichen, das aus der Maske kopiert wird, wenn Sie nicht zugewiesen sind, oder mit einem gültigen Eingabezeichen belegt, wenn Ihnen eine Eingabe zugewiesen wurde.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange%2A> -Methode wird verwendet, um mithilfe der angegebenen Suchrichtung nach dem ersten zugewiesenen Zeichen zwischen zwei angegebenen Positionen (einschließlich) zu suchen. Das Ergebnis kann dann als Parameter an den <xref:System.ComponentModel.MaskedTextProvider.Item%2A> Indexer übergeben werden, um den zugewiesenen Wert an dieser Position zu erhalten.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange%2A> - <xref:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange%2A> Methode und die-Methode sind Ergänzungen dieser Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindEditPositionFrom">
      <MemberSignature Language="C#" Value="public int FindEditPositionFrom (int position, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindEditPositionFrom(int32 position, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindEditPositionFrom (position As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindEditPositionFrom(int position, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindEditPositionFrom : int * bool -&gt; int" Usage="maskedTextProvider.FindEditPositionFrom (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Suche gestartet werden soll.</param>
        <param name="direction">Ein <see cref="T:System.Boolean" />, der die Suchrichtung angibt: <see langword="true" />, um vorwärts zu suchen, oder <see langword="false" />, um rückwärts zu suchen.</param>
        <summary>Gibt die Position der ersten bearbeitbaren Position nach der angegebenen Position in der angegebenen Suchrichtung zurück.</summary>
        <returns>Bei erfolgreicher Suche ein <see cref="T:System.Int32" />, der die nullbasierte Position der ersten bearbeitbaren Position darstellt, die gefunden wurde, andernfalls <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom%2A> -Methode wird verwendet, um nach der angegebenen Position nach der nächsten zugewiesenen oder nicht zugewiesenen bearbeitbaren Position in der formatierten Zeichenfolge zu suchen.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom%2A> -Methode ist das Komplement dieser Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindEditPositionInRange">
      <MemberSignature Language="C#" Value="public int FindEditPositionInRange (int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindEditPositionInRange(int32 startPosition, int32 endPosition, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindEditPositionInRange (startPosition As Integer, endPosition As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindEditPositionInRange(int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindEditPositionInRange : int * int * bool -&gt; int" Usage="maskedTextProvider.FindEditPositionInRange (startPosition, endPosition, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Suche beginnt.</param>
        <param name="endPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Suche endet.</param>
        <param name="direction">Ein <see cref="T:System.Boolean" />, der die Suchrichtung angibt: <see langword="true" />, um vorwärts zu suchen, oder <see langword="false" />, um rückwärts zu suchen.</param>
        <summary>Gibt die Position der ersten bearbeitbaren Position zwischen den angegebenen Positionen in der angegebenen Suchrichtung zurück.</summary>
        <returns>Bei erfolgreicher Suche ein <see cref="T:System.Int32" />, der die nullbasierte Position der ersten bearbeitbaren Position darstellt, die gefunden wurde, andernfalls <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange%2A> -Methode wird verwendet, um mithilfe der angegebenen Suchrichtung nach dem ersten bearbeitbaren Zeichen zwischen zwei angegebenen Positionen (einschließlich) zu suchen. Das Ergebnis kann dann als Parameter an den <xref:System.ComponentModel.MaskedTextProvider.Item%2A> Indexer übergeben werden, um den zugewiesenen Wert an dieser Position zu erhalten.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange%2A> -Methode ist das Komplement dieser Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindNonEditPositionFrom">
      <MemberSignature Language="C#" Value="public int FindNonEditPositionFrom (int position, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindNonEditPositionFrom(int32 position, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindNonEditPositionFrom (position As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindNonEditPositionFrom(int position, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindNonEditPositionFrom : int * bool -&gt; int" Usage="maskedTextProvider.FindNonEditPositionFrom (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Suche gestartet werden soll.</param>
        <param name="direction">Ein <see cref="T:System.Boolean" />, der die Suchrichtung angibt: <see langword="true" />, um vorwärts zu suchen, oder <see langword="false" />, um rückwärts zu suchen.</param>
        <summary>Gibt die Position der ersten nicht-bearbeitbaren Position nach der angegebenen Position in der angegebenen Suchrichtung zurück.</summary>
        <returns>Bei erfolgreicher Suche ein <see cref="T:System.Int32" />, der die nullbasierte Position der ersten gefundenen Literalposition darstellt, andernfalls <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom%2A> -Methode wird verwendet, um nach der angegebenen Position nach dem nächsten Literalzeichen in der formatierten Zeichenfolge zu suchen. Das Ergebnis kann dann als Parameter an den <xref:System.ComponentModel.MaskedTextProvider.Item%2A> Indexer übergeben werden, um den Literalwert an dieser Position zu erhalten.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom%2A> -Methode ist das Komplement dieser Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindNonEditPositionInRange">
      <MemberSignature Language="C#" Value="public int FindNonEditPositionInRange (int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindNonEditPositionInRange(int32 startPosition, int32 endPosition, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindNonEditPositionInRange (startPosition As Integer, endPosition As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindNonEditPositionInRange(int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindNonEditPositionInRange : int * int * bool -&gt; int" Usage="maskedTextProvider.FindNonEditPositionInRange (startPosition, endPosition, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Suche beginnt.</param>
        <param name="endPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Suche endet.</param>
        <param name="direction">Ein <see cref="T:System.Boolean" />, der die Suchrichtung angibt: <see langword="true" />, um vorwärts zu suchen, oder <see langword="false" />, um rückwärts zu suchen.</param>
        <summary>Gibt die Position der ersten nicht-bearbeitbaren Position zwischen den angegebenen Positionen in der angegebenen Suchrichtung zurück.</summary>
        <returns>Bei erfolgreicher Suche ein <see cref="T:System.Int32" />, der die nullbasierte Position der ersten gefundenen Literalposition darstellt, andernfalls <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange%2A> -Methode wird verwendet, um anhand der angegebenen Suchrichtung nach dem ersten Literalzeichen zwischen zwei angegebenen Positionen (einschließlich) zu suchen. Das Ergebnis kann dann als Parameter an den <xref:System.ComponentModel.MaskedTextProvider.Item%2A> Indexer übergeben werden, um den Literalwert an dieser Position zu erhalten.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange%2A> -Methode ist das Komplement dieser Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindUnassignedEditPositionFrom">
      <MemberSignature Language="C#" Value="public int FindUnassignedEditPositionFrom (int position, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindUnassignedEditPositionFrom(int32 position, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindUnassignedEditPositionFrom (position As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindUnassignedEditPositionFrom(int position, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindUnassignedEditPositionFrom : int * bool -&gt; int" Usage="maskedTextProvider.FindUnassignedEditPositionFrom (position, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="position">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Suche gestartet werden soll.</param>
        <param name="direction">Ein <see cref="T:System.Boolean" />, der die Suchrichtung angibt: <see langword="true" />, um vorwärts zu suchen, oder <see langword="false" />, um rückwärts zu suchen.</param>
        <summary>Gibt die Position der ersten nicht zugewiesenen bearbeitbaren Position nach der angegebenen Position in der angegebenen Suchrichtung zurück.</summary>
        <returns>Bei erfolgreicher Suche ein <see cref="T:System.Int32" />, der die nullbasierte Position der ersten nicht zugewiesenen bearbeitbaren Position darstellt, die gefunden wurde, andernfalls <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die formatierte Zeichenfolge besteht aus bearbeitbaren Zeichen und Literalen, die aus der Maske kopiert werden. Die bearbeitbaren Zeichen Positionen werden entweder von dem Eingabe Aufforderungs Zeichen, das aus der Maske kopiert wird, wenn Sie nicht zugewiesen sind, oder mit einem gültigen Eingabezeichen belegt, wenn Ihnen eine Eingabe zugewiesen wurde.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom%2A> -Methode wird verwendet, um nach der angegebenen Position und Suchrichtung nach dem ersten nicht zugewiesenen Zeichen zu suchen. Das Eingabe Aufforderungs Zeichen sollte diese Position belegen.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom%2A> - <xref:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom%2A> Methode und die-Methode sind Ergänzungen dieser Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FindUnassignedEditPositionInRange">
      <MemberSignature Language="C#" Value="public int FindUnassignedEditPositionInRange (int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindUnassignedEditPositionInRange(int32 startPosition, int32 endPosition, bool direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindUnassignedEditPositionInRange (startPosition As Integer, endPosition As Integer, direction As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindUnassignedEditPositionInRange(int startPosition, int endPosition, bool direction);" />
      <MemberSignature Language="F#" Value="member this.FindUnassignedEditPositionInRange : int * int * bool -&gt; int" Usage="maskedTextProvider.FindUnassignedEditPositionInRange (startPosition, endPosition, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="startPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Suche beginnt.</param>
        <param name="endPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Suche endet.</param>
        <param name="direction">Ein <see cref="T:System.Boolean" />, der die Suchrichtung angibt: <see langword="true" />, um vorwärts zu suchen, oder <see langword="false" />, um rückwärts zu suchen.</param>
        <summary>Gibt die Position der ersten nicht zugewiesenen bearbeitbaren Position zwischen den angegebenen Positionen in der angegebenen Suchrichtung zurück.</summary>
        <returns>Bei erfolgreicher Suche ein <see cref="T:System.Int32" />, der die nullbasierte Position der ersten nicht zugewiesenen bearbeitbaren Position darstellt, die gefunden wurde, andernfalls <see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die formatierte Zeichenfolge besteht aus bearbeitbaren Zeichen und Literalen, die aus der Maske kopiert werden. Die bearbeitbaren Zeichen Positionen werden entweder von dem Eingabe Aufforderungs Zeichen, das aus der Maske kopiert wird, wenn Sie nicht zugewiesen sind, oder mit einem gültigen Eingabezeichen belegt, wenn Ihnen eine Eingabe zugewiesen wurde.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionInRange%2A> -Methode wird verwendet, um mithilfe der angegebenen Suchrichtung nach dem ersten nicht zugewiesenen Zeichen zwischen zwei angegebenen Positionen (einschließlich) zu suchen. Das Eingabe Aufforderungs Zeichen sollte diese Position belegen.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange%2A> - <xref:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange%2A> Methode und die-Methode sind Ergänzungen dieser Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetOperationResultFromHint">
      <MemberSignature Language="C#" Value="public static bool GetOperationResultFromHint (System.ComponentModel.MaskedTextResultHint hint);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GetOperationResultFromHint(valuetype System.ComponentModel.MaskedTextResultHint hint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.GetOperationResultFromHint(System.ComponentModel.MaskedTextResultHint)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetOperationResultFromHint (hint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GetOperationResultFromHint(System::ComponentModel::MaskedTextResultHint hint);" />
      <MemberSignature Language="F#" Value="static member GetOperationResultFromHint : System.ComponentModel.MaskedTextResultHint -&gt; bool" Usage="System.ComponentModel.MaskedTextProvider.GetOperationResultFromHint hint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hint" Type="System.ComponentModel.MaskedTextResultHint" />
      </Parameters>
      <Docs>
        <param name="hint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" />-Wert, der i. d. R. als Ausgabeparameter eines vorherigen Vorgangs abgerufen wird.</param>
        <summary>Bestimmt, ob der angegebene <see cref="T:System.ComponentModel.MaskedTextResultHint" /> einen Erfolg oder ein Fehlschlagen anzeigt.</summary>
        <returns><see langword="true" />, wenn der angegebene <see cref="T:System.ComponentModel.MaskedTextResultHint" />-Wert einen Erfolg darstellt, andernfalls <see langword="false" />, wenn er ein Fehlschlagen darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgenden Methoden der <xref:System.ComponentModel.MaskedTextProvider> -Klasse enthalten einen Parameter vom Typ <xref:System.ComponentModel.MaskedTextResultHint> , der verwendet wird, um Informationen über den Vorgang der Methode auszugeben: <xref:System.ComponentModel.MaskedTextProvider.Clear%2A> <xref:System.ComponentModel.MaskedTextProvider.Add%2A>, <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A>, <xref:System.ComponentModel.MaskedTextProvider.Remove%2A>, <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A>, <xref:System.ComponentModel.MaskedTextProvider.Replace%2A> , , <xref:System.ComponentModel.MaskedTextProvider.Set%2A>, <xref:System.ComponentModel.MaskedTextProvider.VerifyChar%2A>und .<xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> Die <xref:System.ComponentModel.MaskedTextProvider.GetOperationResultFromHint%2A> -Methode interpretiert diesen Wert und gibt einen booleschen Wert zurück, der <xref:System.ComponentModel.MaskedTextResultHint> angibt, ob die signalisiert hat, dass der Vorgang erfolgreich war oder fehlgeschlagen ist.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.MaskedTextResultHint" />
      </Docs>
    </Member>
    <Member MemberName="IncludeLiterals">
      <MemberSignature Language="C#" Value="public bool IncludeLiterals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeLiterals" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeLiterals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeLiterals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeLiterals : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob in der Eingabemaske vorhandene Literalzeichen in die formatierte Zeichenfolge aufgenommen werden, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn Literalzeichen aufgenommen werden, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> Eigenschaften <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> und bestimmen, ob beim Aufrufen der <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> -Methode Eingabe Aufforderungs-und Literalzeichen angezeigt werden. Wenn Sie diese beiden Eigenschaften auf `false`festlegen, stellt die analysierte Zeichenfolge nur die Zeichen dar, die vom Benutzer eingegeben werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
      </Docs>
    </Member>
    <Member MemberName="IncludePrompt">
      <MemberSignature Language="C#" Value="public bool IncludePrompt { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludePrompt" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludePrompt As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludePrompt { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludePrompt : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.IncludePrompt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob mithilfe von <see cref="P:System.Windows.Forms.MaskedTextBox.PromptChar" /> bei der Anzeige der formatierten Zeichenfolge das Nichtvorhandensein von Benutzereingaben angegeben wird, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn das Aufforderungszeichen zur Darstellung der Positionen verwendet wird, an denen keine Benutzereingaben vorgenommen wurden, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> Eigenschaften <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> und bestimmen, ob beim Aufrufen der <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> -Methode Eingabe Aufforderungs-und Literalzeichen angezeigt werden. Wenn Sie diese beiden Eigenschaften auf `false`festlegen, stellt die analysierte Zeichenfolge nur die Zeichen dar, die vom Benutzer eingegeben werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InsertAt">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt an einer bestimmten Position innerhalb der formatierten Zeichenfolge ein Zeichen oder eine Zeichenfolge ein.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public bool InsertAt (char input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertAt(char input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.InsertAt(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAt (input As Char, position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool InsertAt(char input, int position);" />
      <MemberSignature Language="F#" Value="member this.InsertAt : char * int -&gt; bool" Usage="maskedTextProvider.InsertAt (input, position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Der einzufügende <see cref="T:System.Char" />.</param>
        <param name="position">Die nullbasierte Position in der formatierten Zeichenfolge, an der das Zeichen eingefügt werden soll.</param>
        <summary>Fügt das angegebene Zeichen an der angegebenen Position innerhalb der formatierten Zeichenfolge ein.</summary>
        <returns><see langword="true" />, wenn die Einfügung erfolgreich war, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A> -Methode fügt ein Zeichen in die erste Bearbeitungs Position an oder hinter dem durch den `pos` -Parameter angegebenen ein. Mit dieser Methode werden alle vorhandenen Zeichen nach der Einfügemarke um eine Position verschoben, um Platz für `input` das eingefügte Zeichen zu schaffen. Wenn einer der folgenden Fehler auftritt, wird der Einfügevorgang nicht ausgeführt, und die `false`Methode gibt zurück.  
  
-   Der `pos` -Parameter ist kleiner als 0 (null) <xref:System.ComponentModel.MaskedTextProvider.Length%2A> oder größer als der der formatierten Zeichenfolge.  
  
-   Ein bearbeitbares Zeichen wurde in der formatierten Zeichenfolge an oder hinter der angegebenen Position `pos`nicht gefunden.  
  
-   Das Einfügezeichen ist kein gültiges Eingabezeichen, `input`da es nicht druckbar ist oder nicht mit dem entsprechenden Masken Element übereinstimmt.  
  
-   Rechts von der Einfügemarke sind keine Positionen verfügbar, sodass vorhandene Zeichen nicht verschoben werden können.  
  
-   Wenn Sie die vorhandenen Zeichen verschieben, würde dies zu einer Verletzung der Maske führen.  
  
 Eine leere `input` Zeichenfolge führt nicht zu einer Änderung in der formatierten Zeichenfolge `true`, sondern wird zurückgegeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public bool InsertAt (string input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertAt(string input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.InsertAt(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAt (input As String, position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool InsertAt(System::String ^ input, int position);" />
      <MemberSignature Language="F#" Value="member this.InsertAt : string * int -&gt; bool" Usage="maskedTextProvider.InsertAt (input, position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Der einzufügende <see cref="T:System.String" />.</param>
        <param name="position">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Eingabezeichenfolge eingefügt werden soll.</param>
        <summary>Fügt die angegebene Zeichenfolge an einer angegebenen Position innerhalb der formatierten Zeichenfolge ein.</summary>
        <returns><see langword="true" />, wenn die Einfügung erfolgreich war, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A> der-Methode wird jedes Zeichen `input` aus der Zeichenfolge in die Bearbeitungs Positionen `pos` an der Position und darüber eingefügt. Mit dieser Methode werden alle vorhandenen Zeichen nach der Einfügemarke um eine Position für jedes eingefügte Zeichen verschoben. Wenn einer der folgenden Fehler auftritt, wird kein Einfügevorgang ausgeführt, und die `false`Methode gibt zurück.  
  
-   Der `pos` -Parameter ist kleiner als 0 (null) <xref:System.ComponentModel.MaskedTextProvider.Length%2A> oder größer als der der formatierten Zeichenfolge.  
  
-   Nicht genügend bearbeitbare Zeichen sind in der formatierten Zeichenfolge an oder hinter der `pos`angegebenen Position vorhanden, um alle Zeichen aus der `input` Zeichenfolge einzufügen.  
  
-   Mindestens eines der Einfügezeichen ist kein gültiges Eingabezeichen, da Sie nicht druckbar sind oder nicht mit dem entsprechenden Masken Element übereinstimmen.  
  
-   Rechts von der Einfügemarke sind nicht genügend Positionen verfügbar, sodass vorhandene Zeichen nicht verschoben werden können.  
  
-   Wenn Sie die vorhandenen Zeichen verschieben, würde dies zu einer Verletzung der Maske führen. Beachten Sie, dass diese Verschiebung während des Einfügens jedes einzelnen Zeichens auftritt.  
  
 Eine leere `input` Zeichenfolge führt nicht zu einer Änderung in der formatierten Zeichenfolge `true`, sondern wird zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public bool InsertAt (char input, int position, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertAt(char input, int32 position, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.InsertAt(System.Char,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAt (input As Char, position As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool InsertAt(char input, int position, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.InsertAt : char * int * int * MaskedTextResultHint -&gt; bool" Usage="maskedTextProvider.InsertAt (input, position, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Der einzufügende <see cref="T:System.Char" />.</param>
        <param name="position">Die nullbasierte Position in der formatierten Zeichenfolge, an der das Zeichen eingefügt werden soll.</param>
        <param name="testPosition">Bei Erfolg der Methode die Position, an der zuletzt ein Zeichen eingefügt wurde, andernfalls die erste Position, an der die Einfügung fehlgeschlagen ist. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" />, mit dem das Ergebnis des Einfügevorgangs kurz beschrieben wird. Ein Ausgabeparameter.</param>
        <summary>Fügt das angegebene Zeichen an der angegebenen Position innerhalb der formatierten Zeichenfolge ein und gibt die letzte Einfügeposition sowie den Status des Vorgangs zurück.</summary>
        <returns><see langword="true" />, wenn die Einfügung erfolgreich war, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A> -Methode fügt ein Zeichen in die erste Bearbeitungs Position an oder hinter dem durch den `pos` -Parameter angegebenen ein. Mit dieser Methode werden alle vorhandenen Zeichen nach der Einfügemarke um eine Position verschoben, um Platz für `input` das eingefügte Zeichen zu schaffen. Wenn einer der folgenden Fehler auftritt, wird der Einfügevorgang nicht ausgeführt, und die `false`Methode gibt zurück.  
  
-   Der `pos` -Parameter ist kleiner als 0 (null) <xref:System.ComponentModel.MaskedTextProvider.Length%2A> oder größer als der der formatierten Zeichenfolge.  
  
-   Ein bearbeitbares Zeichen wurde in der formatierten Zeichenfolge an oder hinter der angegebenen Position `pos`nicht gefunden.  
  
-   Das Einfügezeichen ist kein gültiges Eingabezeichen, `input`da es nicht druckbar ist oder nicht mit dem entsprechenden Masken Element übereinstimmt.  
  
-   Rechts von der Einfügemarke sind keine Positionen verfügbar, sodass vorhandene Zeichen nicht verschoben werden können.  
  
-   Wenn Sie die vorhandenen Zeichen verschieben, würde dies zu einer Verletzung der Maske führen.  
  
 Eine leere `input` Zeichenfolge führt nicht zu einer Änderung in der formatierten Zeichenfolge `true`, sondern wird zurückgegeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="InsertAt">
      <MemberSignature Language="C#" Value="public bool InsertAt (string input, int position, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool InsertAt(string input, int32 position, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.InsertAt(System.String,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAt (input As String, position As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool InsertAt(System::String ^ input, int position, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.InsertAt : string * int * int * MaskedTextResultHint -&gt; bool" Usage="maskedTextProvider.InsertAt (input, position, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Der einzufügende <see cref="T:System.String" />.</param>
        <param name="position">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Eingabezeichenfolge eingefügt werden soll.</param>
        <param name="testPosition">Bei Erfolg der Methode die Position, an der zuletzt ein Zeichen eingefügt wurde, andernfalls die erste Position, an der die Einfügung fehlgeschlagen ist. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" />, mit dem das Ergebnis des Einfügevorgangs kurz beschrieben wird. Ein Ausgabeparameter.</param>
        <summary>Fügt die angegebene Zeichenfolge an einer angegebenen Position innerhalb der formatierten Zeichenfolge ein und gibt die letzte Einfügeposition sowie den Status des Vorgangs zurück.</summary>
        <returns><see langword="true" />, wenn die Einfügung erfolgreich war, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit <xref:System.ComponentModel.MaskedTextProvider.InsertAt%2A> der-Methode wird jedes Zeichen `input` aus der Zeichenfolge in die Bearbeitungs Positionen `pos` an der Position und darüber eingefügt. Mit dieser Methode werden alle vorhandenen Zeichen nach der Einfügemarke um eine Position für jedes eingefügte Zeichen verschoben. Wenn einer der folgenden Fehler auftritt, wird kein Einfügevorgang ausgeführt, und die `false`Methode gibt zurück.  
  
-   Der `pos` -Parameter ist kleiner als 0 (null) <xref:System.ComponentModel.MaskedTextProvider.Length%2A> oder größer als der der formatierten Zeichenfolge.  
  
-   Nicht genügend bearbeitbare Zeichen sind in der formatierten Zeichenfolge an oder hinter der `pos`angegebenen Position vorhanden, um alle Zeichen aus der `input` Zeichenfolge einzufügen.  
  
-   Mindestens eines der Einfügezeichen ist kein gültiges Eingabezeichen, da Sie nicht druckbar sind oder nicht mit dem entsprechenden Masken Element übereinstimmen.  
  
-   Rechts von der Einfügemarke sind nicht genügend Positionen verfügbar, sodass vorhandene Zeichen nicht verschoben werden können.  
  
-   Wenn Sie die vorhandenen Zeichen verschieben, würde dies zu einer Verletzung der Maske führen. Beachten Sie, dass diese Verschiebung während des Einfügens jedes einzelnen Zeichens auftritt.  
  
 Eine leere `input` Zeichenfolge führt nicht zu einer Änderung in der formatierten Zeichenfolge `true`, sondern wird zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="InvalidIndex">
      <MemberSignature Language="C#" Value="public static int InvalidIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 InvalidIndex" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property InvalidIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int InvalidIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.InvalidIndex : int" Usage="System.ComponentModel.MaskedTextProvider.InvalidIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Obergrenze des ungültigen Indexbereichs ab.</summary>
        <value>Ein Wert, der den von der Anbieterimplementierung bestimmten größten ungültigen Index darstellt. Wenn beispielsweise der niedrigste gültige Index 0 ist, gibt diese Eigenschaft -1 zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.InvalidIndex%2A> -Eigenschaft wird zur Darstellung eines Ergebnisses verwendet, das für Indizierungs Vorgänge nicht gültig ist, <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A> z. b. die-Methode.  
  
 Wenn Sie den Anbieter verwenden oder einen eigenen implementieren, sollten Sie diese Eigenschaft verwenden, um zu entscheiden, ob ein Index ungültig ist, anstatt sich mit ungültigen Werten hart zu codieren.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindAssignedEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindNonEditPositionInRange(System.Int32,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsAvailablePosition">
      <MemberSignature Language="C#" Value="public bool IsAvailablePosition (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAvailablePosition(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAvailablePosition (position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAvailablePosition(int position);" />
      <MemberSignature Language="F#" Value="member this.IsAvailablePosition : int -&gt; bool" Usage="maskedTextProvider.IsAvailablePosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Die zu überprüfende nullbasierte Position in der Maske.</param>
        <summary>Bestimmt, ob die angegebene Position zugewiesen werden kann.</summary>
        <returns><see langword="true" />, wenn die angegebene Position in der formatierten Zeichenfolge bearbeitbar ist und noch nicht zugewiesen wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.IsAvailablePosition%2A> -Methode `true` gibt nur dann zurück, wenn alle der folgenden Bedingungen zutreffen:  
  
-   Der `pos` -Parameter liegt innerhalb der Begrenzungen der formatierten Zeichenfolge, d. h., der Wert ist größer als oder gleich 0 ( <xref:System.ComponentModel.MaskedTextProvider.Length%2A> null) und kleiner als der der formatierten Zeichenfolge.  
  
-   Die angegebene Position ist ein bearbeitbares Zeichen.  
  
-   Dieser Position wurde noch kein Zeichen zugewiesen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindUnassignedEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsEditPosition">
      <MemberSignature Language="C#" Value="public bool IsEditPosition (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEditPosition(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEditPosition (position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEditPosition(int position);" />
      <MemberSignature Language="F#" Value="member this.IsEditPosition : int -&gt; bool" Usage="maskedTextProvider.IsEditPosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Die zu überprüfende nullbasierte Position in der Maske.</param>
        <summary>Bestimmt, ob die angegebene Position bearbeitbar ist.</summary>
        <returns><see langword="true" />, wenn die angegebene Position in der formatierten Zeichenfolge bearbeitbar ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.IsEditPosition%2A> -Methode `true` gibt nur dann zurück, wenn die beiden folgenden Bedingungen zutreffen:  
  
-   Der `pos` -Parameter liegt innerhalb der Begrenzungen der formatierten Zeichenfolge, d. h., der Wert ist größer als oder gleich 0 ( <xref:System.ComponentModel.MaskedTextProvider.Length%2A> null) und kleiner als der der formatierten Zeichenfolge.  
  
-   Die angegebene Position ist ein bearbeitbares Zeichen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsPassword">
      <MemberSignature Language="C#" Value="public bool IsPassword { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPassword" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.IsPassword" />
      <MemberSignature Language="VB.NET" Value="Public Property IsPassword As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPassword { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsPassword : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.IsPassword" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der bestimmt, ob auf die formatierte Zeichenfolge Kennwortschutz angewendet werden soll, oder legt einen solchen Wert fest.</summary>
        <value><see langword="true" />, wenn die Eingabezeichenfolge als Kennwortzeichenfolge behandelt werden soll, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Kenn Wort Schutz kann mit einer der folgenden zwei Methoden initiiert werden:  
  
-   Festlegen der <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> -Eigenschaft auf einen nicht`null` --Wert.  
  
-   Festlegen der <xref:System.ComponentModel.MaskedTextProvider.IsPassword%2A> -Eigenschaft `true`auf, wodurch auch die <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> -Eigenschaft auf <xref:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar%2A> den-Wert festgelegt wird.  
  
 <xref:System.ComponentModel.MaskedTextProvider.IsPassword%2A>wird von der- <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> Methode <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> und der-Methode verwendet, um zu bestimmen, ob die eigentlichen Eingabe <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A>Zeichen angezeigt oder mit der-Methode maskiert werden  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
      </Docs>
    </Member>
    <Member MemberName="IsValidInputChar">
      <MemberSignature Language="C#" Value="public static bool IsValidInputChar (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValidInputChar(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsValidInputChar (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsValidInputChar(char c);" />
      <MemberSignature Language="F#" Value="static member IsValidInputChar : char -&gt; bool" Usage="System.ComponentModel.MaskedTextProvider.IsValidInputChar c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Der zu testende <see cref="T:System.Char" />-Wert.</param>
        <summary>Bestimmt, ob das angegebene Zeichen ein gültiges Eingabezeichen ist.</summary>
        <returns><see langword="true" />, wenn das angegebene Zeichen einen gültigen Eingabewert enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gültige Eingabezeichen sind alle druckbaren Zeichen, einschließlich Buchstaben, Ziffern, Interpunktions Zeichen, Symbolen und Leerzeichen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidMaskChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AsciiOnly" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
      </Docs>
    </Member>
    <Member MemberName="IsValidMaskChar">
      <MemberSignature Language="C#" Value="public static bool IsValidMaskChar (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValidMaskChar(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsValidMaskChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsValidMaskChar (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsValidMaskChar(char c);" />
      <MemberSignature Language="F#" Value="static member IsValidMaskChar : char -&gt; bool" Usage="System.ComponentModel.MaskedTextProvider.IsValidMaskChar c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Der zu testende <see cref="T:System.Char" />-Wert.</param>
        <summary>Bestimmt, ob das angegebene Zeichen ein gültiges Maskenzeichen ist.</summary>
        <returns><see langword="true" />, wenn das angegebene Zeichen einen gültigen Maskenwert enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gültige Masken Zeichen umfassen alle druckbaren Zeichen, einschließlich Buchstaben, Ziffern, Interpunktions Zeichen, Symbolen und Leerzeichen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
      </Docs>
    </Member>
    <Member MemberName="IsValidPasswordChar">
      <MemberSignature Language="C#" Value="public static bool IsValidPasswordChar (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValidPasswordChar(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsValidPasswordChar (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsValidPasswordChar(char c);" />
      <MemberSignature Language="F#" Value="static member IsValidPasswordChar : char -&gt; bool" Usage="System.ComponentModel.MaskedTextProvider.IsValidPasswordChar c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Der zu testende <see cref="T:System.Char" />-Wert.</param>
        <summary>Bestimmt, ob das angegebene Zeichen ein gültiges Kennwortzeichen ist.</summary>
        <returns><see langword="true" />, wenn das angegebene Zeichen einen gültigen Kennwortwert enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gültige Kenn Wort Zeichen umfassen alle druckbaren Zeichen und das NULL-Zeichen, das verwendet wird, um die Kenn Wort Funktionalität zu deaktivieren. Zu den druckbaren Zeichen zählen Buchstaben, Ziffern, Interpunktions Zeichen, Symbole und Leerzeichen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IsPassword" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidMaskChar(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : char" Usage="System.ComponentModel.MaskedTextProvider.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Ein nullbasierter Index des abzurufenden Elements.</param>
        <summary>Ruft das Element an der angegebenen Position in der formatierten Zeichenfolge ab.</summary>
        <value>Der <see cref="T:System.Char" /> an der angegebenen Position in der formatierten Zeichenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Item%2A> -Eigenschaft ist der Standardindexer <xref:System.ComponentModel.MaskedTextProvider> für die-Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> ist kleiner als 0 (null) oder größer oder gleich der <see cref="P:System.ComponentModel.MaskedTextProvider.Length" /> der Maske.</exception>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositions" />
      </Docs>
    </Member>
    <Member MemberName="LastAssignedPosition">
      <MemberSignature Language="C#" Value="public int LastAssignedPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LastAssignedPosition" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastAssignedPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LastAssignedPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LastAssignedPosition : int" Usage="System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft in der Maske den Index des ganz rechts stehenden, der Maske zugeordneten Eingabezeichens ab.</summary>
        <value>Wenn der Maske mindestens ein Eingabezeichen zugeordnet wurde, ein <see cref="T:System.Int32" /> mit dem Index der am weitesten rechts zugeordneten Position, andernfalls<see cref="P:System.ComponentModel.MaskedTextProvider.InvalidIndex" />, wenn keine Position zugeordnet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.LastAssignedPosition%2A> -Eigenschaft stellt die weit entfernte Bearbeitungs Position in der Maske relativ zum Ursprung dar, der ein Eingabezeichen zugewiesen wurde. Für Sprachen, die von links nach rechts (LTR) gelesen werden, wie z. b. Englisch, ist dies die am weitesten rechts zugewiesene Position. für Sprachen, die von rechts nach links (RTL) gelesen werden, wäre dies die linke Position.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.ComponentModel.MaskedTextProvider.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Länge der Maske ohne Maskenmodifiziererzeichen ab.</summary>
        <value>Ein <see cref="T:System.Int32" /> mit der Anzahl der in der Maske enthaltenen Positionen mit Ausnahme von Zeichen zur Änderung der Maskeneingabe.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Length%2A> -Eigenschaft stellt die Gesamtzahl der Zeichen in der Maske dar, einschließlich literaler und bearbeitbarer Zeichen. Die Anzahl der Literalzeichen kann bestimmt werden, indem der Wert von <xref:System.ComponentModel.MaskedTextProvider.EditPositionCount%2A> <xref:System.ComponentModel.MaskedTextProvider.Length%2A>von subtrahieren wird.  
  
 <xref:System.ComponentModel.MaskedTextProvider.Length%2A>Beschreibt auch die Länge der formatierten Zeichenfolge, einschließlich der Eingabezeichen, Literale und Eingabe Aufforderungs Zeichen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      </Docs>
    </Member>
    <Member MemberName="Mask">
      <MemberSignature Language="C#" Value="public string Mask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Mask" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.Mask" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mask As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Mask { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Mask : string" Usage="System.ComponentModel.MaskedTextProvider.Mask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Eingabemaske ab.</summary>
        <value>Ein <see cref="T:System.String" /> mit der vollständigen Maske.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> -Eigenschaft wird <xref:System.ComponentModel.MaskedTextProvider.%23ctor%2A> im-Konstruktor festgelegt. Diese Maske darf nur gültige Zeichen enthalten, die von der Maskierungs Sprache definiert werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.Mask" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.#ctor" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Item(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.MaskFull" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.MaskCompleted" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.Clone" />
      </Docs>
    </Member>
    <Member MemberName="MaskCompleted">
      <MemberSignature Language="C#" Value="public bool MaskCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaskCompleted" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.MaskCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaskCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MaskCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MaskCompleted : bool" Usage="System.ComponentModel.MaskedTextProvider.MaskCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob in der formatierten Zeichenfolge alle erforderlichen Eingaben erfolgt sind.</summary>
        <value><see langword="true" />, wenn alle erforderlichen Eingaben in der Maske erfolgt sind, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.MaskCompleted%2A> -Eigenschaft prüft nur erforderliche Eingabeelemente. Verwenden Sie stattdessen die <xref:System.Windows.Forms.MaskedTextBox.MaskFull%2A?displayProperty=nameWithType> -Eigenschaft <xref:System.Windows.Forms.MaskedTextBox> der-Klasse, um zu bestimmen, ob alle erforderlichen und optionalen Eingabeelemente eingegeben wurden.  
  
 Der aktuelle Wert der <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> -Eigenschaft bestimmt, welche Formatierungs Elemente als erforderlich angesehen werden und welche optional sind.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.MaskCompleted" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.MaskFull" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      </Docs>
    </Member>
    <Member MemberName="MaskFull">
      <MemberSignature Language="C#" Value="public bool MaskFull { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaskFull" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.MaskFull" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaskFull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MaskFull { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MaskFull : bool" Usage="System.ComponentModel.MaskedTextProvider.MaskFull" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob in der formatierten Zeichenfolge alle erforderlichen und optionalen Eingaben erfolgt sind.</summary>
        <value><see langword="true" />, wenn alle erforderlichen und optionalen Eingaben erfolgt sind, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie stattdessen die <xref:System.ComponentModel.MaskedTextProvider.MaskCompleted%2A> -Eigenschaft, um zu überprüfen, ob nur erforderliche Eingabeelemente eingegeben wurden. Der aktuelle Wert der <xref:System.ComponentModel.MaskedTextProvider.Mask%2A> -Eigenschaft bestimmt, welche Formatierungs Elemente als erforderlich angesehen werden und welche optional sind.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.MaskFull" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.MaskCompleted" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.EditPositionCount" />
      </Docs>
    </Member>
    <Member MemberName="PasswordChar">
      <MemberSignature Language="C#" Value="public char PasswordChar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char PasswordChar" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      <MemberSignature Language="VB.NET" Value="Public Property PasswordChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char PasswordChar { char get(); void set(char value); };" />
      <MemberSignature Language="F#" Value="member this.PasswordChar : char with get, set" Usage="System.ComponentModel.MaskedTextProvider.PasswordChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Zeichen ab, das das eigentliche Eingabezeichen ersetzen soll, oder legt dieses fest.</summary>
        <value>Der als Kennwortzeichen verwendete <see cref="T:System.Char" />-Wert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei vertraulichen Benutzereingaben ist es üblich, die tatsächlichen Informationen zu verbergen, die der Benutzer während der Ausgabe Vorgänge eingegeben hat. Wenn die <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> -Eigenschaft auf ein nicht--`null` Zeichen festgelegt ist <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> , geben Ausgabe <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methoden wie und die Eingabezeichen mit dem angegebenen Kenn Wort Zeichen aus. Wenn diese Eigenschaft auf `null` festgelegt wird, werden Kenn Wort Schutzfunktionen deaktiviert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das bei der Festlegung dieser Eigenschaft angegebene Kennwortzeichen entspricht dem aktuellen Aufforderungszeichen <see cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />. Die zwei Zeichen müssen unterschiedlich sein.</exception>
        <exception cref="T:System.ArgumentException">Das bei der Festlegung dieser Eigenschaft angegebene Zeichen ist kein durch die <see cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" />-Methode festgelegtes gültiges Kennwortzeichen.</exception>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.PasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.DefaultPasswordChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IsPassword" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
      </Docs>
    </Member>
    <Member MemberName="PromptChar">
      <MemberSignature Language="C#" Value="public char PromptChar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char PromptChar" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
      <MemberSignature Language="VB.NET" Value="Public Property PromptChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char PromptChar { char get(); void set(char value); };" />
      <MemberSignature Language="F#" Value="member this.PromptChar : char with get, set" Usage="System.ComponentModel.MaskedTextProvider.PromptChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Zeichen ab, mit dem das Nichtvorhandensein von Benutzereingaben für alle verfügbaren Bearbeitungspositionen dargestellt wird, oder legt dieses Zeichen fest.</summary>
        <value>Das Zeichen, über das der Benutzer zur Eingabe aufgefordert wird. Der Standardwert ist ein Unterstrich (_).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> -Eigenschaft stellt das Aufforderungs Zeichen dar, das <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> von <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> den-und-Methoden verwendet wird, um den aktuellen Zustand der formatierten Eingabe Zeichenfolge darzustellen. Ein Eingabe Aufforderungs Zeichen wird in bearbeitbare Positionen eingefügt, denen noch kein Eingabe Wert zugewiesen wurde. Einige Versionen der <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> -Methode hängen auch vom Wert <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> der-Eigenschaft ab.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das bei der Festlegung dieser Eigenschaft angegebene Aufforderungszeichen entspricht dem aktuellen Kennwortzeichen <see cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />. Die zwei Zeichen müssen unterschiedlich sein.</exception>
        <exception cref="T:System.ArgumentException">Das bei der Festlegung dieser Eigenschaft angegebene Zeichen ist kein durch die <see cref="M:System.ComponentModel.MaskedTextProvider.IsValidPasswordChar(System.Char)" />-Methode festgelegtes gültiges Kennwortzeichen.</exception>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.PromptChar" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AssignedEditPositionCount" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AvailableEditPositionCount" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Entfernt das zuletzt zugewiesene Zeichen aus der formatierten Zeichenfolge.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove();" />
      <MemberSignature Language="F#" Value="member this.Remove : unit -&gt; bool" Usage="maskedTextProvider.Remove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt das zuletzt zugewiesene Zeichen aus der formatierten Zeichenfolge.</summary>
        <returns><see langword="true" />, wenn das Zeichen erfolgreich entfernt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Remove%2A> -Methode hat keine Auswirkungen, wenn der Maske noch keine Zeichen zugewiesen sind.  
  
 Wenn das zuletzt zugewiesene Zeichen aus der formatierten Zeichenfolge entfernt wird, wird das bearbeitbare Masken Zeichen für diese Position zurückgesetzt und ermöglicht nachfolgende Eingaben.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove([out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Remove(System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove([Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * MaskedTextResultHint -&gt; bool" Usage="maskedTextProvider.Remove (testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="testPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an der das Zeichen entfernt wurde. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" />, mit dem das Ergebnis des Vorgangs kurz beschrieben wird. Ein Ausgabeparameter.</param>
        <summary>Entfernt das zuletzt zugewiesene Zeichen aus der formatierten Zeichenfolge und gibt dann die Löschposition sowie beschreibende Informationen aus.</summary>
        <returns><see langword="true" />, wenn das Zeichen erfolgreich entfernt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Remove%2A> -Methode hat keine Auswirkungen, wenn der Maske noch keine Zeichen zugewiesen sind.  
  
 Wenn das zuletzt zugewiesene Zeichen aus der formatierten Zeichenfolge entfernt wird, wird das bearbeitbare Masken Zeichen für diese Position zurückgesetzt und ermöglicht nachfolgende Eingaben.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.LastAssignedPosition" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveAt">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Entfernt ein oder mehrere zugewiesene Zeichen aus der formatierten Zeichenfolge.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public bool RemoveAt (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAt(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAt (position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAt(int position);" />
      <MemberSignature Language="F#" Value="member this.RemoveAt : int -&gt; bool" Usage="maskedTextProvider.RemoveAt position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Die nullbasierte Position des zu entfernenden zugewiesenen Zeichens.</param>
        <summary>Entfernt das zugewiesene Zeichen an der angegebenen Position aus der formatierten Zeichenfolge.</summary>
        <returns><see langword="true" />, wenn das Zeichen erfolgreich entfernt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> -Methode hat keine Auswirkung, wenn an der angegebenen Entfernungs Position keine zugewiesenen Zeichen vorhanden sind. Literalzeichen sind von dieser Methode nicht betroffen.  
  
 Wenn ein Zeichen entfernt wird, werden die verbleibenden höher positionierten Zeichen in der Maske nach links verschoben, um die vom Entfernungs Vorgang erstellte Lücke auszufüllen. Frei gewordenen Positionen werden für die Eingabe zurückgesetzt. Wenn das Verschieben der Zeichen durch die Masken Definition verhindert wird, erfolgt keine Entfernung, und <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> es `false`wird zurückgegeben.  
  
 Dieser Methoden Aufrufwert entspricht dem folgenden-Befehl der überladenen <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%28System.Int32%2CSystem.Int32%29> Version:  
  
 `RemoveAt(pos, pos);`  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public bool RemoveAt (int startPosition, int endPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAt(int32 startPosition, int32 endPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.RemoveAt(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAt (startPosition As Integer, endPosition As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAt(int startPosition, int endPosition);" />
      <MemberSignature Language="F#" Value="member this.RemoveAt : int * int -&gt; bool" Usage="maskedTextProvider.RemoveAt (startPosition, endPosition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startPosition">Der nullbasierte Index des zuerst zu entfernenden zugewiesenen Zeichens.</param>
        <param name="endPosition">Der nullbasierte Index des zuletzt zu entfernenden zugewiesenen Zeichens.</param>
        <summary>Entfernt die zugewiesenen Zeichen zwischen den angegebenen Positionen aus der formatierten Zeichenfolge.</summary>
        <returns><see langword="true" />, wenn das Zeichen erfolgreich entfernt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> -Methode hat keine Auswirkung, wenn die angegebenen Entfernungs Positionen keine zugewiesenen Zeichen enthalten.  
  
 Wenn ein Zeichen entfernt wird, werden die verbleibenden höher positionierten Zeichen in der Maske nach links verschoben, um die vom Entfernungs Vorgang erstellte Lücke auszufüllen. Frei gewordenen Positionen werden für die Eingabe zurückgesetzt. Wenn das Verschieben der Zeichen durch die Masken Definition verhindert wird, erfolgt keine Entfernung, und <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> es `false`wird zurückgegeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public bool RemoveAt (int startPosition, int endPosition, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAt(int32 startPosition, int32 endPosition, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.RemoveAt(System.Int32,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAt (startPosition As Integer, endPosition As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAt(int startPosition, int endPosition, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.RemoveAt : int * int * int * MaskedTextResultHint -&gt; bool" Usage="maskedTextProvider.RemoveAt (startPosition, endPosition, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="startPosition">Der nullbasierte Index des zuerst zu entfernenden zugewiesenen Zeichens.</param>
        <param name="endPosition">Der nullbasierte Index des zuletzt zu entfernenden zugewiesenen Zeichens.</param>
        <param name="testPosition">Bei Erfolg die nullbasierte Position in der formatierten Zeichenfolge, an der die Zeichen entfernt wurden, andernfalls die erste Position, an der der Vorgang fehlgeschlagen ist. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" />, mit dem das Ergebnis des Vorgangs kurz beschrieben wird. Ein Ausgabeparameter.</param>
        <summary>Entfernt die zwischen den angegebenen Positionen zugewiesenen Zeichen aus der formatierten Zeichenfolge und gibt dann die Löschposition sowie beschreibende Informationen aus.</summary>
        <returns><see langword="true" />, wenn das Zeichen erfolgreich entfernt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> -Methode hat keine Auswirkung, wenn die angegebenen Entfernungs Positionen keine zugewiesenen Zeichen enthalten.  
  
 Wenn ein Zeichen entfernt wird, werden die verbleibenden höher positionierten Zeichen in der Maske nach links verschoben, um die vom Entfernungs Vorgang erstellte Lücke auszufüllen. Frei gewordenen Positionen werden für die Eingabe zurückgesetzt. Wenn das Verschieben der Zeichen durch die Masken Definition verhindert wird, erfolgt keine Entfernung, und <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> es `false`wird zurückgegeben.  
  
 Diese Version von <xref:System.ComponentModel.MaskedTextProvider.RemoveAt%2A> bietet zwei zusätzliche Ausgabeparameter, um weitere Informationen über den Vorgang der Methode zu übermitteln.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ersetzt ein oder mehrere bearbeitbare Zeichen in der formatierten Zeichenfolge durch die angegebenen Zeichen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (char input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(char input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As Char, position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(char input, int position);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * int -&gt; bool" Usage="maskedTextProvider.Replace (input, position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Der <see cref="T:System.Char" />-Wert, der den vorhandenen Wert ersetzt.</param>
        <param name="position">Die nullbasierte Position, an der nach dem ersten zu ersetzenden bearbeitbaren Zeichen gesucht werden soll.</param>
        <summary>Ersetzt ein einzelnes Zeichen an oder hinter der angegebenen Position durch den angegebenen Zeichenwert.</summary>
        <returns><see langword="true" />, wenn das Zeichen erfolgreich ersetzt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.Char%2CSystem.Int32%29> -Methode sucht nach der ersten bearbeitbaren Position in der formatierten Zeichenfolge an oder hinter `pos`der angegebenen Position. Wenn ein solcher gefunden wird, wird der Wert der bearbeitbaren Position in das angegebene Zeichen `input`geändert. Die folgenden Bedingungen führen zu einem Fehler, der `false` bewirkt, dass kein Austausch ausgeführt und der Wert zurückgegeben wird:  
  
-   Der `pos` -Parameter ist kleiner als 0 (null) <xref:System.ComponentModel.MaskedTextProvider.Length%2A> oder größer als der der formatierten Zeichenfolge.  
  
-   Ein bearbeitbares Zeichen wurde in der formatierten Zeichenfolge an oder hinter der angegebenen Position `pos`nicht gefunden.  
  
-   Das Ersetzungs Zeichen `input`ist kein gültiges Eingabezeichen, da es nicht druckbar ist oder nicht mit dem entsprechenden Mask-Element übereinstimmt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.FindEditPositionFrom(System.Int32,System.Boolean)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (string input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(string input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(System::String ^ input, int position);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * int -&gt; bool" Usage="maskedTextProvider.Replace (input, position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Der <see cref="T:System.String" />-Wert, durch den die vorhandenen bearbeitbaren Zeichen ersetzt werden.</param>
        <param name="position">Die nullbasierte Position, an der nach dem ersten zu ersetzenden bearbeitbaren Zeichen gesucht werden soll.</param>
        <summary>Ersetzt einen Bereich bearbeitbarer Zeichen und beginnt dabei an der angegebenen Position sowie mit der angegebenen Zeichenfolge.</summary>
        <returns><see langword="true" />, wenn alle Zeichen erfolgreich ersetzt wurden, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.String%2CSystem.Int32%29> -Methode sucht nach der ersten bearbeitbaren Position an oder hinter der angegebenen `pos`Position. Unter der Annahme, dass nach diesem Punkt ausreichend bearbeitbare Positionen vorhanden sind, werden die vorhandenen Zeichen Werte nacheinander durch den Inhalt des Parameters `input`für die Ersetzungs Zeichenfolge ersetzt.  
  
 Die folgenden Bedingungen werden als Fehler betrachtet. Wenn ein Fehler auftritt, erfolgt keine Ersetzung und <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.String%2CSystem.Int32%29> gibt `false`zurück.  
  
-   Der `pos` -Parameter ist kleiner als 0 (null) <xref:System.ComponentModel.MaskedTextProvider.Length%2A> oder größer als der der formatierten Zeichenfolge.  
  
-   Es sind nicht genügend bearbeitbare Positionen in der formatierten Zeichenfolge vorhanden, um den Inhalt der Ersetzungs Zeichenfolge zu speichern.  
  
-   Einer der Ersatz Zeichen Werte ist ungültig, weil er nicht druckbar ist oder nicht mit dem entsprechenden Masken Element übereinstimmt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (char input, int position, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(char input, int32 position, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.Char,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As Char, position As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(char input, int position, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * int * int * MaskedTextResultHint -&gt; bool" Usage="maskedTextProvider.Replace (input, position, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Der <see cref="T:System.Char" />-Wert, der den vorhandenen Wert ersetzt.</param>
        <param name="position">Die nullbasierte Position, an der nach dem ersten zu ersetzenden bearbeitbaren Zeichen gesucht werden soll.</param>
        <param name="testPosition">Bei Erfolg die nullbasierte Position in der formatierten Zeichenfolge, an der das letzte Zeichen ersetzt wurde, andernfalls die erste Position, an der der Vorgang fehlgeschlagen ist. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" />, mit dem das Ergebnis der Ersetzung kurz beschrieben wird. Ein Ausgabeparameter.</param>
        <summary>Ersetzt ein einzelnes Zeichen an oder hinter der angegebenen Position durch den angegebenen Zeichenwert und gibt dann die Löschposition sowie beschreibende Informationen aus.</summary>
        <returns><see langword="true" />, wenn das Zeichen erfolgreich ersetzt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.Char%2CSystem.Int32%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> -Methode sucht nach der ersten bearbeitbaren Position in der formatierten Zeichenfolge an oder hinter `pos`der angegebenen Position. Wenn ein solcher gefunden wird, wird der Wert der bearbeitbaren Position in das angegebene Zeichen `input`geändert. Jede der folgenden Bedingungen führt zu einer Fehlerbedingung, die bewirkt, dass keine Ersetzung durchgeführt wird und der `false` Wert zurückgegeben wird:  
  
-   Der `pos` -Parameter ist kleiner als 0 (null) <xref:System.ComponentModel.MaskedTextProvider.Length%2A> oder größer als der der formatierten Zeichenfolge.  
  
-   Ein bearbeitbares Zeichen wurde in der formatierten Zeichenfolge an oder hinter der angegebenen Position `pos`nicht gefunden.  
  
-   Das Ersetzungs Zeichen `input`ist kein gültiges Eingabezeichen, da es nicht druckbar ist oder nicht mit dem entsprechenden Mask-Element übereinstimmt.  
  
 Zusätzlich zum Rückgabewert verfügt diese Methode über zwei Ausgabeparameter, um zusätzliche Informationen über den Ersetzungs Vorgang bereitzustellen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (string input, int position, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(string input, int32 position, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.String,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, position As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(System::String ^ input, int position, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * int * int * MaskedTextResultHint -&gt; bool" Usage="maskedTextProvider.Replace (input, position, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Der <see cref="T:System.String" />-Wert, durch den die vorhandenen bearbeitbaren Zeichen ersetzt werden.</param>
        <param name="position">Die nullbasierte Position, an der nach dem ersten zu ersetzenden bearbeitbaren Zeichen gesucht werden soll.</param>
        <param name="testPosition">Bei Erfolg die nullbasierte Position in der formatierten Zeichenfolge, an der das letzte Zeichen ersetzt wurde, andernfalls die erste Position, an der der Vorgang fehlgeschlagen ist. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" />, mit dem das Ergebnis der Ersetzung kurz beschrieben wird. Ein Ausgabeparameter.</param>
        <summary>Ersetzt einen Bereich bearbeitbarer Zeichen beginnend an der angegebenen Position und mit der angegebenen Zeichenfolge und gibt dann die Löschposition sowie beschreibende Informationen aus.</summary>
        <returns><see langword="true" />, wenn alle Zeichen erfolgreich ersetzt wurden, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.String%2CSystem.Int32%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> -Methode sucht nach der ersten bearbeitbaren Position an oder hinter der angegebenen `pos`Position. Unter der Annahme, dass nach diesem Punkt ausreichend bearbeitbare Positionen vorhanden sind, werden die vorhandenen Zeichen Werte nacheinander durch den Inhalt des Parameters `input`für die Ersetzungs Zeichenfolge ersetzt.  
  
 Die folgenden Bedingungen werden als Fehler betrachtet. Wenn ein Fehler auftritt, erfolgt keine Ersetzung und <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.String%2CSystem.Int32%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> gibt `false`zurück.  
  
-   Der `pos` -Parameter ist kleiner als 0 (null) <xref:System.ComponentModel.MaskedTextProvider.Length%2A> oder größer als der der formatierten Zeichenfolge.  
  
-   Es sind nicht genügend bearbeitbare Positionen in der formatierten Zeichenfolge vorhanden, um den Inhalt der Ersetzungs Zeichenfolge zu speichern.  
  
-   Einer der Ersatz Zeichen Werte ist ungültig, weil er nicht druckbar ist oder nicht mit dem entsprechenden Masken Element übereinstimmt.  
  
 Zusätzlich zum Rückgabewert verfügt diese Methode über zwei Ausgabeparameter, um zusätzliche Informationen über den Ersetzungs Vorgang bereitzustellen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (char input, int startPosition, int endPosition, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(char input, int32 startPosition, int32 endPosition, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.Char,System.Int32,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As Char, startPosition As Integer, endPosition As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(char input, int startPosition, int endPosition, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * int * int * int * MaskedTextResultHint -&gt; bool" Usage="maskedTextProvider.Replace (input, startPosition, endPosition, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Der <see cref="T:System.Char" />-Wert, der den vorhandenen Wert ersetzt.</param>
        <param name="startPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Ersetzung beginnt.</param>
        <param name="endPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Ersetzung endet.</param>
        <param name="testPosition">Bei Erfolg die nullbasierte Position in der formatierten Zeichenfolge, an der das letzte Zeichen ersetzt wurde, andernfalls die erste Position, an der der Vorgang fehlgeschlagen ist. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" />, mit dem das Ergebnis der Ersetzung kurz beschrieben wird. Ein Ausgabeparameter.</param>
        <summary>Ersetzt ein einzelnes Zeichen zwischen der angegebenen Anfangs- und Endposition durch den angegebenen Zeichenwert und gibt dann die Löschposition sowie beschreibende Informationen aus.</summary>
        <returns><see langword="true" />, wenn das Zeichen erfolgreich ersetzt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Replace%28System.Char%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%40%2CSystem.ComponentModel.MaskedTextResultHint%40%29> -Methode sucht in der formatierten Zeichenfolge nach der ersten bearbeitbaren Position zwischen den angegebenen Start-und Endpositionen. Wenn ein solcher gefunden wird, wird der Wert der bearbeitbaren Position in das angegebene Zeichen `input`geändert. Jede der folgenden Bedingungen führt zu einer Fehlerbedingung, die bewirkt, dass keine Ersetzung durchgeführt wird und der `false` Wert zurückgegeben wird:  
  
-   Der `startPos` - `endPos` Parameter oder der-Parameter zeigen vor dem Anfang der formatierten Zeichenfolge oder über das Ende hinaus.  
  
-   Ein bearbeitbares Zeichen wurde im angegebenen Intervall nicht gefunden.  
  
-   Das Ersetzungs Zeichen `input`ist kein gültiges Eingabezeichen, da es nicht druckbar ist oder nicht mit dem entsprechenden Mask-Element übereinstimmt.  
  
 Zusätzlich zum Rückgabewert verfügt diese Methode über zwei Ausgabeparameter, um zusätzliche Informationen über den Ersetzungs Vorgang bereitzustellen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public bool Replace (string input, int startPosition, int endPosition, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Replace(string input, int32 startPosition, int32 endPosition, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Replace(System.String,System.Int32,System.Int32,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, startPosition As Integer, endPosition As Integer, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Replace(System::String ^ input, int startPosition, int endPosition, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * int * int * int * MaskedTextResultHint -&gt; bool" Usage="maskedTextProvider.Replace (input, startPosition, endPosition, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="endPosition" Type="System.Int32" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Der <see cref="T:System.String" />-Wert, durch den die vorhandenen bearbeitbaren Zeichen ersetzt werden.</param>
        <param name="startPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Ersetzung beginnt.</param>
        <param name="endPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Ersetzung endet.</param>
        <param name="testPosition">Bei Erfolg die nullbasierte Position in der formatierten Zeichenfolge, an der das letzte Zeichen ersetzt wurde, andernfalls die erste Position, an der der Vorgang fehlgeschlagen ist. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" />, mit dem das Ergebnis der Ersetzung kurz beschrieben wird. Ein Ausgabeparameter.</param>
        <summary>Ersetzt einen Bereich bearbeitbarer Zeichen zwischen der angegebenen Anfangs- und Endposition durch die angegebene Zeichenfolge und gibt dann die Löschposition sowie beschreibende Informationen aus.</summary>
        <returns><see langword="true" />, wenn alle Zeichen erfolgreich ersetzt wurden, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Replace%2A> -Methode sucht in der formatierten Zeichenfolge nach der ersten bearbeitbaren Position zwischen den angegebenen Start-und Endpositionen. Unter der Annahme, dass nach diesem Punkt ausreichend bearbeitbare Positionen vorhanden sind, werden die vorhandenen Zeichen Werte nacheinander durch den Inhalt des Parameters `input`für die Ersetzungs Zeichenfolge ersetzt.  
  
 Die folgenden Bedingungen werden als Fehler betrachtet. Wenn ein Fehler auftritt, erfolgt keine Ersetzung und <xref:System.ComponentModel.MaskedTextProvider.Replace%2A> gibt `false`zurück.  
  
-   Der `startPos` - `endPos` Parameter oder der-Parameter zeigen vor dem Anfang der formatierten Zeichenfolge oder über das Ende hinaus.  
  
-   Es sind nicht genügend bearbeitbare Positionen in der formatierten Zeichenfolge vorhanden, um den Inhalt der Ersetzungs Zeichenfolge zu speichern.  
  
-   Einer der Ersatz Zeichen Werte ist ungültig, weil er nicht druckbar ist oder nicht mit dem entsprechenden Masken Element übereinstimmt.  
  
 Zusätzlich zum Rückgabewert verfügt diese Methode über zwei Ausgabeparameter, um zusätzliche Informationen über den Ersetzungs Vorgang bereitzustellen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
      </Docs>
    </Member>
    <Member MemberName="ResetOnPrompt">
      <MemberSignature Language="C#" Value="public bool ResetOnPrompt { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResetOnPrompt" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
      <MemberSignature Language="VB.NET" Value="Public Property ResetOnPrompt As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ResetOnPrompt { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ResetOnPrompt : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der bestimmt, wie ein dem Aufforderungszeichen entsprechendes Eingabezeichen behandelt werden soll, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn die Eingabe des Aufforderungszeichens die Zurücksetzung der aktuellen bearbeitbaren Position in der Maske zur Folge hat, andernfalls <see langword="false" />, um anzugeben, dass das Aufforderungszeichen wie ein normales Eingabezeichen verarbeitet werden soll. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider>kann zwei Kategorien von Zeichen, paces und Eingabe Aufforderungs Zeichen auf besondere Weise behandeln. Normalerweise wird jedes Eingabezeichen anhand der Maske getestet und entweder akzeptiert oder abgelehnt. Wenn Sie davon ausgehen, dass <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> die-Eigenschaft auf einen anderen Wert als `null`festgelegt ist, <xref:System.ComponentModel.MaskedTextProvider.ResetOnPrompt%2A> führt das `true` Festlegen der-Eigenschaft auf zu einer besonderen Verarbeitung für das Eingabe Aufforderungs Zeichen. Wenn ein Prompt-Zeichen hinzugefügt wird, bewirkt dies, dass die aktuelle Maske-Zeichenposition gelöscht und die aktuelle Position auf das nächste bearbeitbare Zeichen erweitert wird.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ResetOnPrompt%2A>hat Vorrang vor der <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> -Eigenschaft, wie in der folgenden Tabelle beschrieben.  
  
|<xref:System.ComponentModel.MaskedTextProvider.ResetOnPrompt%2A>|<xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A>|Resultierendes Verhalten|  
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------|  
|`true`|`true`|Das Eingabe Aufforderungs Zeichen kann hinzugefügt werden und bewirkt, dass die aktuelle Masken Position zurückgesetzt wird. Der Standardwert.|  
|`true`|`false`|Das Eingabe Aufforderungs Zeichen kann hinzugefügt werden und bewirkt, dass die aktuelle Masken Position zurückgesetzt wird.|  
|`false`|`true`|Das Eingabe Aufforderungs Zeichen wird als normales Eingabezeichen verarbeitet.|  
|`false`|`false`|Das Eingabe Aufforderungs Zeichen ist ungültig, und Methoden, die versuchen, das Zeichen hinzuzufügen, schlagen fehl.|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.ResetOnPrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PromptChar" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.Clear" />
      </Docs>
    </Member>
    <Member MemberName="ResetOnSpace">
      <MemberSignature Language="C#" Value="public bool ResetOnSpace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResetOnSpace" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
      <MemberSignature Language="VB.NET" Value="Public Property ResetOnSpace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ResetOnSpace { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ResetOnSpace : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der bestimmt, wie ein eingegebenes Leerzeichen zu behandeln ist, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn die Eingabe des Leerzeichens die Zurücksetzung der aktuellen bearbeitbaren Position in der Maske zur Folge hat, andernfalls <see langword="false" />, um anzugeben, dass das Leerzeichen wie ein normales Eingabezeichen verarbeitet werden soll. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.MaskedTextProvider>kann zwei Kategorien von Zeichen, Leerzeichen und Eingabe Aufforderungs Zeichen auf besondere Weise behandeln. Normalerweise wird jedes Eingabezeichen anhand der Maske getestet und entweder akzeptiert oder abgelehnt. Das Festlegen <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> der- `true` Eigenschaft auf führt dazu, dass die aktuelle Masken Zeichenposition gelöscht wird und die aktuelle Position auf das nächste bearbeitbare Zeichen erweitert wird.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A>ist nützlich, wenn Sie Text zuweisen, der mit Ausnahme der Eingabeaufforderung gespeichert wurde, wobei die Eingabeaufforderung durch ein Leerzeichen ersetzt wird. Vor dem Wiederherstellen einer solchen Zeichen <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> Folge `true` setzt das Festlegen von auf die Eingabe Aufforderungs Zeichen an den Positionen zurück, die von Leerzeichen in der Eingabe Zeichenfolge  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.ResetOnSpace" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt die formatierte Zeichenfolge auf die angegebene Eingabezeichenfolge fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Set(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Set (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Set : string -&gt; bool" Usage="maskedTextProvider.Set input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Der <see cref="T:System.String" />-Wert, über den die formatierte Zeichenfolge festgelegt wird.</param>
        <summary>Legt die formatierte Zeichenfolge auf die angegebene Eingabezeichenfolge fest.</summary>
        <returns><see langword="true" />, wenn alle Zeichen erfolgreich festgelegt wurden, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Set%2A> -Methode löscht den vorhandenen Inhalt der formatierten Zeichenfolge und wendet dann die Maske `input` auf die Zeichenfolge an, um den Inhalt der formatierten Zeichenfolge zu aktualisieren.  
  
 Die folgenden Bedingungen werden als Fehler betrachtet. Wenn ein Fehler auftritt, bleibt die formatierte Zeichenfolge unverändert <xref:System.ComponentModel.MaskedTextProvider.Set%2A> und `false`gibt zurück.  
  
-   Es sind nicht genügend bearbeitbare Positionen in der formatierten Zeichenfolge vorhanden, um den Inhalt der Ersetzungs Zeichenfolge zu speichern.  
  
-   Einer der Ersatz Zeichen Werte ist ungültig, weil er nicht druckbar ist oder nicht mit dem entsprechenden Masken Element übereinstimmt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set (string input, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set(string input, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.Set(System.String,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Set (input As String, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set(System::String ^ input, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.Set : string * int * MaskedTextResultHint -&gt; bool" Usage="maskedTextProvider.Set (input, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Der <see cref="T:System.String" />-Wert, über den die formatierte Zeichenfolge festgelegt wird.</param>
        <param name="testPosition">Bei Erfolg die nullbasierte Position in der formatierten Zeichenfolge, an der das letzte Zeichen festgelegt wurde, andernfalls die erste Position, an der der Vorgang fehlgeschlagen ist. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" />, mit dem das Ergebnis des Festlegungsvorgangs kurz beschrieben wird. Ein Ausgabeparameter.</param>
        <summary>Legt die formatierte Zeichenfolge auf die angegebene Eingabezeichenfolge fest und gibt anschließend die Löschposition sowie beschreibende Informationen aus.</summary>
        <returns><see langword="true" />, wenn alle Zeichen erfolgreich festgelegt wurden, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.Set%2A> -Methode löscht den vorhandenen Inhalt der formatierten Zeichenfolge und wendet dann die Maske `input` auf die Zeichenfolge an, um den Inhalt der formatierten Zeichenfolge zu aktualisieren.  
  
 Die folgenden Bedingungen werden als Fehler betrachtet. Wenn ein Fehler auftritt, bleibt die formatierte Zeichenfolge unverändert <xref:System.ComponentModel.MaskedTextProvider.Set%2A> und `false`gibt zurück.  
  
-   Es sind nicht genügend bearbeitbare Positionen in der formatierten Zeichenfolge vorhanden, um den Inhalt der Ersetzungs Zeichenfolge zu speichern.  
  
-   Einer der Ersatz Zeichen Werte ist ungültig, weil er nicht druckbar ist oder nicht mit dem entsprechenden Masken Element übereinstimmt.  
  
 Diese Version von <xref:System.ComponentModel.MaskedTextProvider.Set%2A> bietet zwei zusätzliche Ausgabeparameter, um weitere Informationen über den Vorgang der Methode zu übermitteln.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Add" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Clear" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.InsertAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Remove" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.RemoveAt" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Replace" />
      </Docs>
    </Member>
    <Member MemberName="SkipLiterals">
      <MemberSignature Language="C#" Value="public bool SkipLiterals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipLiterals" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipLiterals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipLiterals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipLiterals : bool with get, set" Usage="System.ComponentModel.MaskedTextProvider.SkipLiterals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob Literalzeichenpositionen in der Maske durch ihnen entsprechende Werte überschrieben werden dürfen, oder legt einen solchen Wert fest.</summary>
        <value><see langword="true" />, um das Wiederhinzufügen von Literalzeichen zuzulassen, andernfalls <see langword="false" />, wenn das Überschreiben von Literalzeichen durch den Benutzer nicht erlaubt werden soll. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eingabemasken können Literale und bearbeitbare Zeichen enthalten. Wenn versucht wird, der Position in einer Maske, die von einem <xref:System.Windows.Forms.MaskedTextBox.SkipLiterals%2A> literalobjekt belegt ist, ein Eingabezeichen hinzuzufügen, wird das Ergebnis durch den Wert der-Eigenschaft bestimmt.  
  
-   Wenn diese Eigenschaft ist `true`, ist es zulässig, ein Literale mit dem gleichen Wert zu überschreiben, wenn Eingabezeichen hinzugefügt werden. Ein Schrägstrich-Zeichen Wert `'/'`,, könnte z. b. der dritten Position der Maske `"00/00/000"`hinzugefügt werden.  
  
-   Wenn diese Eigenschaft ist `false`, ist es nicht zulässig, einen beliebigen Wert einer Masken Position zuzuweisen, die von einem Literalzeichen belegt wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MaskedTextBox.SkipLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnPrompt" />
      </Docs>
    </Member>
    <Member MemberName="ToDisplayString">
      <MemberSignature Language="C#" Value="public string ToDisplayString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToDisplayString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
      <MemberSignature Language="VB.NET" Value="Public Function ToDisplayString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToDisplayString();" />
      <MemberSignature Language="F#" Value="member this.ToDisplayString : unit -&gt; string" Usage="maskedTextProvider.ToDisplayString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die formatierte Zeichenfolge in anzeigbarer Form zurück.</summary>
        <returns>Der formatierte <see cref="T:System.String" /> mit Aufforderungszeichen und Maskenliteralzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A> -Methode enthält immer Eingabe Aufforderungs-und Literalzeichen im Rückgabewert, unabhängig vom Wert <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> der <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> -Eigenschaft oder der-Eigenschaft. Diese Methode zeigt immer Kenn Wort Zeichen an, <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> wenn die-Eigenschaft auf einen anderen Zeichen Wert `null`als festgelegt ist.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToDisplayString%2A>wird häufig verwendet, um die Zeichenfolge zu erhalten, die in zugeordneten Benutzeroberflächen <xref:System.Windows.Forms.MaskedTextBox>Elementen wie angezeigt werden soll.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.ToString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die formatierte Zeichenfolge zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="maskedTextProvider.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die formatierte Zeichenfolge zurück, die alle zugewiesenen Zeichenwerte umfasst.</summary>
        <returns>Der formatierte <see cref="T:System.String" />, der alle zugewiesenen Zeichenwerte umfasst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Version der überladenen <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methode enthält, fordert und Literale gemäß der aktuellen Werte von der <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> und <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> Eigenschaften bzw. Es werden immer die ursprünglichen Eingabezeichen zurückgegeben, wobei der Wert der <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> Eigenschaft ignoriert wird.  
  
> [!IMPORTANT]
>  Da durch diese Methode Informationen angezeigt werden, die in der Regel in der Benutzeroberfläche durch Kenn Wort Zeichen geschützt werden, sollten Sie mit äußerster Vorsicht verwendet werden, um zu vermeiden, dass sensible Benutzerdaten versehentlich angezeigt werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool ignorePasswordChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool ignorePasswordChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (ignorePasswordChar As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(bool ignorePasswordChar);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool -&gt; string" Usage="maskedTextProvider.ToString ignorePasswordChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ignorePasswordChar" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ignorePasswordChar"><see langword="true" />, um die tatsächlich bearbeitbaren Zeichen zurückzugeben, andernfalls <see langword="false" />, um anzugeben, dass die <see cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />-Eigenschaft zu beachten ist.</param>
        <summary>Gibt die formatierte Zeichenfolge (optional einschließlich von Kennwortzeichen) zurück.</summary>
        <returns>Der formatierte <see cref="T:System.String" />, der Literalzeichen, Aufforderungszeichen und optional auch Kennwortzeichen umfasst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Version der überladenen <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methode enthält, fordert und Literale gemäß der aktuellen Werte von der <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> und <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> Eigenschaften bzw. Wenn der `ignorePasswordChar` -Parameter `true`ist, gibt er die ursprünglichen Eingabezeichen zurück, wobei der Wert der <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> -Eigenschaft ignoriert wird. Wenn dieser Parameter ist `false`, wird das Kenn Wort Zeichen verwendet, um bearbeitbare Benutzereingaben zu <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> verbergen, wenn die-Eigenschaft auf einen `null`anderen Wert als festgelegt ist.  
  
> [!IMPORTANT]
>  Da diese Methode möglicherweise Informationen aufzeigt, die in der Benutzeroberfläche in der Regel durch Kenn Wort Zeichen geschützt werden, sollte Sie mit äußerster Vorsicht verwendet werden, um zu vermeiden, dass sensible Benutzerdaten versehentlich angezeigt werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool includePrompt, bool includeLiterals);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool includePrompt, bool includeLiterals) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (includePrompt As Boolean, includeLiterals As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(bool includePrompt, bool includeLiterals);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool * bool -&gt; string" Usage="maskedTextProvider.ToString (includePrompt, includeLiterals)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrompt" Type="System.Boolean" />
        <Parameter Name="includeLiterals" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrompt"><see langword="true" />, um Aufforderungszeichen in die Rückgabezeichenfolge einzuschließen, andernfalls <see langword="false" />.</param>
        <param name="includeLiterals"><see langword="true" />, um Literalzeichen in die Rückgabezeichenfolge einzuschließen, andernfalls <see langword="false" />.</param>
        <summary>Gibt die formatierte Zeichenfolge (optional einschließlich Aufforderungs- und Literalzeichen) zurück.</summary>
        <returns>Der formatierte <see cref="T:System.String" />, der alle zugewiesenen Zeichenwerte und optional Literal- und Aufforderungszeichen umfasst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Version der überladenen <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methode enthält, fordert und Literale nach den Werten der der `IncludePrompt` und `IncludeLiterals` Parameter bzw. Beachten Sie, dass diese Parameter die Werte der <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> Eigenschaften überschreiben. Diese Methode gibt immer die ursprünglichen Eingabezeichen zurück, wobei der Wert der <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> Eigenschaft ignoriert wird.  
  
> [!IMPORTANT]
>  Da durch diese Methode Informationen angezeigt werden, die in der Regel in der Benutzeroberfläche durch Kenn Wort Zeichen geschützt werden, sollten Sie mit äußerster Vorsicht verwendet werden, um zu vermeiden, dass sensible Benutzerdaten versehentlich angezeigt werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsAvailablePosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startPosition, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startPosition, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startPosition As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startPosition, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="maskedTextProvider.ToString (startPosition, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Ausgabe beginnt.</param>
        <param name="length">Die Anzahl der zurückzugebenden Zeichen.</param>
        <summary>Gibt eine Teilzeichenfolge der formatierten Zeichenfolge zurück.</summary>
        <returns>Bei Erfolg eine Teilzeichenfolge des formatierten <see cref="T:System.String" />, die alle zugewiesenen Zeichenwerte umfasst, andernfalls die <see cref="F:System.String.Empty" />-Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Version der überladenen <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methode gibt eine Teil Zeichenfolge der formatierten Zeichenfolge zurück, beginnend an der Position `startPos` und einschließlich der nachfolgenden `length` Anzahl von Zeichen, die durch den-Parameter angegeben werden. Die zurückgegebene Zeichenfolge enthält, fordert und Literale gemäß der aktuellen Werte von der <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> und <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> Eigenschaften bzw. Die Rückgabe Zeichenfolge enthält die ursprünglichen Eingabezeichen. die <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> -Eigenschaft wird immer ignoriert.  
  
> [!IMPORTANT]
>  Da durch diese Methode Informationen angezeigt werden, die in der Regel in der Benutzeroberfläche durch Kenn Wort Zeichen geschützt werden, sollten Sie mit äußerster Vorsicht verwendet werden, um zu vermeiden, dass sensible Benutzerdaten versehentlich angezeigt werden.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToString%2A>führt die folgenden Aktionen aus, wenn es Abweichungen in den Eingabe Parametern gibt:  
  
-   Wenn `startPos` kleiner als 0 (null) ist, wird die Anfangsposition auf 0 festgelegt.  
  
-   Wenn `startPos` größer oder gleich der tatsächlichen <xref:System.ComponentModel.MaskedTextProvider.Length%2A> der formatierten Zeichenfolge ist, wird die <xref:System.String.Empty> Zeichenfolge zurückgegeben.  
  
-   Wenn `length` größer als die verbleibende Anzahl von Zeichen nach der Anfangsposition ist, werden nur die verbleibenden Zeichen zurückgegeben.  
  
-   Wenn `length` kleiner oder gleich 0 (null) ist, <xref:System.String.Empty> wird die Zeichenfolge zurückgegeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool ignorePasswordChar, int startPosition, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool ignorePasswordChar, int32 startPosition, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (ignorePasswordChar As Boolean, startPosition As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(bool ignorePasswordChar, int startPosition, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool * int * int -&gt; string" Usage="maskedTextProvider.ToString (ignorePasswordChar, startPosition, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ignorePasswordChar" Type="System.Boolean" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ignorePasswordChar"><see langword="true" />, um die tatsächlich bearbeitbaren Zeichen zurückzugeben, andernfalls <see langword="false" />, um anzugeben, dass die <see cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />-Eigenschaft zu beachten ist.</param>
        <param name="startPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Ausgabe beginnt.</param>
        <param name="length">Die Anzahl der zurückzugebenden Zeichen.</param>
        <summary>Gibt eine Teilzeichenfolge der formatierten Zeichenfolge (optional einschließlich von Kennwortzeichen) zurück.</summary>
        <returns>Bei Erfolg eine Teilzeichenfolge des formatierten <see cref="T:System.String" />, die Literal-, Aufforderungs- und optional Kennwortzeichen einschließt, andernfalls die <see cref="F:System.String.Empty" />-Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Version der überladenen <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methode gibt eine Teil Zeichenfolge der formatierten Zeichenfolge zurück, beginnend an der Position `startPos` und einschließlich der nachfolgenden `length` Anzahl von Zeichen, die durch den-Parameter angegeben werden. Die zurückgegebene Zeichenfolge enthält, fordert und Literale gemäß der aktuellen Werte von der <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> und <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> Eigenschaften bzw. Wenn der `ignorePasswordChar` -Parameter `true`ist, gibt er die ursprünglichen Eingabezeichen zurück, wobei der Wert der <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> -Eigenschaft ignoriert wird. Wenn dieser Parameter ist `false`, wird das Kenn Wort Zeichen verwendet, um bearbeitbare Benutzereingaben zu <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> verbergen, wenn die-Eigenschaft auf einen `null`anderen Wert als festgelegt ist.  
  
> [!IMPORTANT]
>  Da diese Methode möglicherweise Informationen aufzeigt, die in der Benutzeroberfläche in der Regel durch Kenn Wort Zeichen geschützt werden, sollte Sie mit äußerster Vorsicht verwendet werden, um zu vermeiden, dass sensible Benutzerdaten versehentlich angezeigt werden.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToString%2A>führt die folgenden Aktionen aus, wenn es Abweichungen in den Eingabe Parametern gibt:  
  
-   Wenn `startPos` kleiner als 0 (null) ist, wird die Anfangsposition auf 0 festgelegt.  
  
-   Wenn `startPos` größer oder gleich der tatsächlichen <xref:System.ComponentModel.MaskedTextProvider.Length%2A> der formatierten Zeichenfolge ist, wird die <xref:System.String.Empty> Zeichenfolge zurückgegeben.  
  
-   Wenn `length` größer als die verbleibende Anzahl von Zeichen nach der Anfangsposition ist, werden nur die verbleibenden Zeichen zurückgegeben.  
  
-   Wenn `length` kleiner oder gleich 0 (null) ist, <xref:System.String.Empty> wird die Zeichenfolge zurückgegeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool includePrompt, bool includeLiterals, int startPosition, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool includePrompt, bool includeLiterals, int32 startPosition, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean,System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (includePrompt As Boolean, includeLiterals As Boolean, startPosition As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(bool includePrompt, bool includeLiterals, int startPosition, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool * bool * int * int -&gt; string" Usage="maskedTextProvider.ToString (includePrompt, includeLiterals, startPosition, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrompt" Type="System.Boolean" />
        <Parameter Name="includeLiterals" Type="System.Boolean" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="includePrompt"><see langword="true" />, um Aufforderungszeichen in die Rückgabezeichenfolge einzuschließen, andernfalls <see langword="false" />.</param>
        <param name="includeLiterals"><see langword="true" />, um Literalzeichen in die Rückgabezeichenfolge einzuschließen, andernfalls <see langword="false" />.</param>
        <param name="startPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Ausgabe beginnt.</param>
        <param name="length">Die Anzahl der zurückzugebenden Zeichen.</param>
        <summary>Gibt eine Teilzeichenfolge der formatierten Zeichenfolge (optional einschließlich Aufforderungs- und Literalzeichen) zurück.</summary>
        <returns>Bei Erfolg eine Teilzeichenfolge des formatierten <see cref="T:System.String" />, die alle zugewiesenen Zeichenwerte und optional Literal- und Aufforderungszeichen umfasst, andernfalls die <see cref="F:System.String.Empty" />-Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Version der überladenen <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methode gibt eine Teil Zeichenfolge der formatierten Zeichenfolge zurück, beginnend an der Position `startPos` und einschließlich der nachfolgenden `length` Anzahl von Zeichen, die durch den-Parameter angegeben werden. Die zurückgegebene Zeichenfolge enthält, fordert und Literale nach den Werten der der `IncludePrompt` und `IncludeLiterals` Parameter bzw. Beachten Sie, dass diese Parameter die Werte der <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> Eigenschaften überschreiben. Diese Methode gibt immer die ursprünglichen Eingabezeichen zurück, wobei der Wert der <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> Eigenschaft ignoriert wird.  
  
> [!IMPORTANT]
>  Da durch diese Methode Informationen angezeigt werden, die in der Regel in der Benutzeroberfläche durch Kenn Wort Zeichen geschützt werden, sollten Sie mit äußerster Vorsicht verwendet werden, um zu vermeiden, dass sensible Benutzerdaten versehentlich angezeigt werden.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToString%2A>führt die folgenden Aktionen aus, wenn es Abweichungen in den Eingabe Parametern gibt:  
  
-   Wenn `startPos` kleiner als 0 (null) ist, wird die Anfangsposition auf 0 festgelegt.  
  
-   Wenn `startPos` größer oder gleich der tatsächlichen <xref:System.ComponentModel.MaskedTextProvider.Length%2A> der formatierten Zeichenfolge ist, wird die <xref:System.String.Empty> Zeichenfolge zurückgegeben.  
  
-   Wenn `length` größer als die verbleibende Anzahl von Zeichen nach der Anfangsposition ist, werden nur die verbleibenden Zeichen zurückgegeben.  
  
-   Wenn `length` kleiner oder gleich 0 (null) ist, <xref:System.String.Empty> wird die Zeichenfolge zurückgegeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (bool ignorePasswordChar, bool includePrompt, bool includeLiterals, int startPosition, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(bool ignorePasswordChar, bool includePrompt, bool includeLiterals, int32 startPosition, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.ToString(System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (ignorePasswordChar As Boolean, includePrompt As Boolean, includeLiterals As Boolean, startPosition As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(bool ignorePasswordChar, bool includePrompt, bool includeLiterals, int startPosition, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : bool * bool * bool * int * int -&gt; string" Usage="maskedTextProvider.ToString (ignorePasswordChar, includePrompt, includeLiterals, startPosition, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ignorePasswordChar" Type="System.Boolean" />
        <Parameter Name="includePrompt" Type="System.Boolean" />
        <Parameter Name="includeLiterals" Type="System.Boolean" />
        <Parameter Name="startPosition" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ignorePasswordChar"><see langword="true" />, um die tatsächlich bearbeitbaren Zeichen zurückzugeben, andernfalls <see langword="false" />, um anzugeben, dass die <see cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />-Eigenschaft zu beachten ist.</param>
        <param name="includePrompt"><see langword="true" />, um Aufforderungszeichen in die Rückgabezeichenfolge einzuschließen, andernfalls <see langword="false" />.</param>
        <param name="includeLiterals"><see langword="true" />, um Literalzeichen in die Rückgabezeichenfolge einzuschließen, andernfalls <see langword="false" />.</param>
        <param name="startPosition">Die nullbasierte Position in der formatierten Zeichenfolge, an der die Ausgabe beginnt.</param>
        <param name="length">Die Anzahl der zurückzugebenden Zeichen.</param>
        <summary>Gibt eine Teilzeichenfolge der formatierten Zeichenfolge (optional einschließlich Aufforderungs-, Literal- und Kennwortzeichen) zurück.</summary>
        <returns>Bei Erfolg eine Teilzeichenfolge des formatierten <see cref="T:System.String" />, die alle zugewiesenen Zeichenwerte und optional Literal-, Aufforderungs- und Kennwortzeichen umfasst, andernfalls die <see cref="F:System.String.Empty" />-Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Version der überladenen <xref:System.ComponentModel.MaskedTextProvider.ToString%2A> Methode gibt eine Teil Zeichenfolge der formatierten Zeichenfolge zurück, beginnend an der Position `startPos` und einschließlich der nachfolgenden `length` Anzahl von Zeichen, die durch den-Parameter angegeben werden. Die zurückgegebene Zeichenfolge enthält, fordert und Literale nach den Werten der der `IncludePrompt` und `IncludeLiterals` Parameter bzw. Beachten Sie, dass diese Parameter die Werte der <xref:System.ComponentModel.MaskedTextProvider.IncludePrompt%2A> Eigenschaften <xref:System.ComponentModel.MaskedTextProvider.IncludeLiterals%2A> und überschreiben. Wenn der `ignorePasswordChar` -Parameter `true`ist, gibt er die ursprünglichen Eingabezeichen zurück, wobei der Wert der <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> -Eigenschaft ignoriert wird. Wenn dieser Parameter ist `false`, wird das Kenn Wort Zeichen verwendet, um bearbeitbare Benutzereingaben zu <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> verbergen, wenn die-Eigenschaft auf einen `null`anderen Wert als festgelegt ist.  
  
> [!IMPORTANT]
>  Da diese Methode möglicherweise Informationen aufzeigt, die in der Benutzeroberfläche in der Regel durch Kenn Wort Zeichen geschützt werden, sollte Sie mit äußerster Vorsicht verwendet werden, um zu vermeiden, dass sensible Benutzerdaten versehentlich angezeigt werden.  
  
 <xref:System.ComponentModel.MaskedTextProvider.ToString%2A>führt die folgenden Aktionen aus, wenn es Abweichungen in den Eingabe Parametern gibt:  
  
-   Wenn `startPos` kleiner als 0 (null) ist, wird die Anfangsposition auf 0 festgelegt.  
  
-   Wenn `startPos` größer oder gleich der tatsächlichen <xref:System.ComponentModel.MaskedTextProvider.Length%2A> der formatierten Zeichenfolge ist, wird die <xref:System.String.Empty> Zeichenfolge zurückgegeben.  
  
-   Wenn `length` größer als die verbleibende Anzahl von Zeichen nach der Anfangsposition ist, werden nur die verbleibenden Zeichen zurückgegeben.  
  
-   Wenn `length` kleiner oder gleich 0 (null) ist, <xref:System.String.Empty> wird die Zeichenfolge zurückgegeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.ToDisplayString" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludePrompt" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.IncludeLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.PasswordChar" />
      </Docs>
    </Member>
    <Member MemberName="VerifyChar">
      <MemberSignature Language="C#" Value="public bool VerifyChar (char input, int position, out System.ComponentModel.MaskedTextResultHint hint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyChar(char input, int32 position, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; hint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyChar (input As Char, position As Integer, ByRef hint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyChar(char input, int position, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % hint);" />
      <MemberSignature Language="F#" Value="member this.VerifyChar : char * int * MaskedTextResultHint -&gt; bool" Usage="maskedTextProvider.VerifyChar (input, position, hint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
        <Parameter Name="hint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Der zu testende <see cref="T:System.Char" />-Wert.</param>
        <param name="position">Die Position in der Maske, gegen die das Eingabezeichen geprüft werden soll.</param>
        <param name="hint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" />, mit dem das Ergebnis des Vorgangs kurz beschrieben wird. Ein Ausgabeparameter.</param>
        <summary>Prüft, ob das angegebene Zeichen erfolgreich an der angegebenen Position festgelegt werden konnte.</summary>
        <returns><see langword="true" />, wenn das angegebene Zeichen für die angegebene Position gültig ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.MaskedTextProvider.VerifyChar%2A> -Methode testet, ob ein einzelner Zeichen Wert gültige Eingaben an der angegebenen Position in der formatierten Zeichenfolge darstellt. Diese Methode wird aus `false` den folgenden Gründen zurückgegeben:  
  
-   Der `pos` -Parameter ist kleiner als 0 (null) <xref:System.ComponentModel.MaskedTextProvider.Length%2A> oder größer <xref:System.ComponentModel.MaskedTextProvider.Mask%2A>als der von.  
  
-   Das Zeichen `input` ist kein gültiges Eingabezeichen, wie von der <xref:System.ComponentModel.MaskedTextProvider.IsValidInputChar%2A> -Methode festgelegt.  
  
-   Der `input` ist nicht mit dem Mask-Element an der angegebenen Position, `pos`, kompatibel.  
  
 Die letzte Bedingung hängt möglicherweise <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A>vom aktuellen Wert der Eigenschaften, <xref:System.ComponentModel.MaskedTextProvider.AsciiOnly%2A>, <xref:System.ComponentModel.MaskedTextProvider.PasswordChar%2A> <xref:System.ComponentModel.MaskedTextProvider.PromptChar%2A> und <xref:System.ComponentModel.MaskedTextProvider.SkipLiterals%2A> ab.  
  
 Verwenden Sie stattdessen eine der <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> -Methoden, um eine gesamte Eingabe Zeichenfolge für die Maske zu testen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsEditPosition(System.Int32)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyEscapeChar(System.Char,System.Int32)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
      </Docs>
    </Member>
    <Member MemberName="VerifyEscapeChar">
      <MemberSignature Language="C#" Value="public bool VerifyEscapeChar (char input, int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyEscapeChar(char input, int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.VerifyEscapeChar(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyEscapeChar (input As Char, position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyEscapeChar(char input, int position);" />
      <MemberSignature Language="F#" Value="member this.VerifyEscapeChar : char * int -&gt; bool" Usage="maskedTextProvider.VerifyEscapeChar (input, position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Char" />
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Der zu testende <see cref="T:System.Char" />-Wert.</param>
        <param name="position">Die Position in der Maske, gegen die das Eingabezeichen geprüft werden soll.</param>
        <summary>Prüft, ob das angegebene Zeichen an der angegebenen Position mit Escapezeichen versehen werden würde.</summary>
        <returns><see langword="true" />, wenn das angegebene Zeichen an der angegebenen Position mit Escapezeichen versehen werden würde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Zeichen wird als Escapezeichen bezeichnet *, wenn es* eine gültige Eingabe ist, aber dieser Position in der formatierten Zeichenfolge nicht zugewiesen ist. Escapezeichen werden in die folgenden drei Kategorien eingeteilt:  
  
-   Eingabe Aufforderungs Zeichen, wenn <xref:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput%2A> die- `true`Eigenschaft den Wert hat.  
  
-   Eingabezeichen werden mit Escapezeichen versehen, wenn Sie über denselben Wert wie das Literale in der <xref:System.ComponentModel.MaskedTextProvider.SkipLiterals%2A> Maske verfügen `true`, und wenn die-Eigenschaft ist.  
  
-   Leerzeichen werden mit Escapezeichen versehen `true`, wenn die <xref:System.ComponentModel.MaskedTextProvider.ResetOnSpace%2A> Eigenschaft ist.  
  
 Die <xref:System.ComponentModel.MaskedTextProvider.VerifyEscapeChar%2A> -Methode gibt auch `false` dann zurück `pos` , wenn der-Parameter kleiner <xref:System.ComponentModel.MaskedTextProvider.Mask%2A>als 0 ( <xref:System.ComponentModel.MaskedTextProvider.Length%2A> null) oder größer als der von ist.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.IsValidInputChar(System.Char)" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.VerifyString" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.AllowPromptAsInput" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.SkipLiterals" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.ResetOnSpace" />
      </Docs>
    </Member>
    <MemberGroup MemberName="VerifyString">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prüft, ob die angegebene Zeichenfolge erfolgreich festgelegt werden konnte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VerifyString">
      <MemberSignature Language="C#" Value="public bool VerifyString (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyString(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.VerifyString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyString (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyString(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.VerifyString : string -&gt; bool" Usage="maskedTextProvider.VerifyString input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Der zu testende <see cref="T:System.String" />-Wert.</param>
        <summary>Prüft, ob die angegebene Zeichenfolge erfolgreich festgelegt werden konnte.</summary>
        <returns><see langword="true" />, wenn die angegebene Zeichenfolge eine gültige Eingabe ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> wendet die `input` Zeichenfolge auf die Maske an, ohne die formatierte Zeichenfolge tatsächlich zu `input` ändern, um zu testen, <xref:System.ComponentModel.MaskedTextProvider.Set%2A> ob in einem entsprechenden Vorgang gültig wäre. Diese Methode gibt auch `true` dann zurück, `null` wenn die Eingabe oder die Länge 0 (null) aufweist  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
      </Docs>
    </Member>
    <Member MemberName="VerifyString">
      <MemberSignature Language="C#" Value="public bool VerifyString (string input, out int testPosition, out System.ComponentModel.MaskedTextResultHint resultHint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyString(string input, [out] int32&amp; testPosition, [out] valuetype System.ComponentModel.MaskedTextResultHint&amp; resultHint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.MaskedTextProvider.VerifyString(System.String,System.Int32@,System.ComponentModel.MaskedTextResultHint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyString (input As String, ByRef testPosition As Integer, ByRef resultHint As MaskedTextResultHint) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyString(System::String ^ input, [Runtime::InteropServices::Out] int % testPosition, [Runtime::InteropServices::Out] System::ComponentModel::MaskedTextResultHint % resultHint);" />
      <MemberSignature Language="F#" Value="member this.VerifyString : string * int * MaskedTextResultHint -&gt; bool" Usage="maskedTextProvider.VerifyString (input, testPosition, resultHint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="testPosition" Type="System.Int32" RefType="out" />
        <Parameter Name="resultHint" Type="System.ComponentModel.MaskedTextResultHint" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Der zu testende <see cref="T:System.String" />-Wert.</param>
        <param name="testPosition">Bei Erfolg die nullbasierte Position des zuletzt geprüften Zeichens, andernfalls die erste Position, an der die Prüfung fehlschlug. Ein Ausgabeparameter.</param>
        <param name="resultHint">Ein <see cref="T:System.ComponentModel.MaskedTextResultHint" />, mit dem das Ergebnis der Prüfung kurz beschrieben wird. Ein Ausgabeparameter.</param>
        <summary>Prüft, ob die angegebene Zeichenfolge erfolgreich festgelegt werden konnte, und gibt dann die Position und beschreibende Informationen aus.</summary>
        <returns><see langword="true" />, wenn die angegebene Zeichenfolge eine gültige Eingabe ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> wendet die `input` Zeichenfolge auf die Maske an, ohne die formatierte Zeichenfolge tatsächlich zu `input` ändern, um zu testen, <xref:System.ComponentModel.MaskedTextProvider.Set%2A> ob in einem entsprechenden Vorgang gültig wäre. Diese Methode gibt auch `true` dann zurück, `null` wenn die Eingabe oder die Länge 0 (null) aufweist  
  
 Diese Version von <xref:System.ComponentModel.MaskedTextProvider.VerifyString%2A> bietet zwei zusätzliche Ausgabeparameter, um weitere Informationen über den Vorgang der Methode zu übermitteln.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.ComponentModel.MaskedTextProvider.Set" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Mask" />
        <altmember cref="M:System.ComponentModel.MaskedTextProvider.VerifyChar(System.Char,System.Int32,System.ComponentModel.MaskedTextResultHint@)" />
        <altmember cref="P:System.ComponentModel.MaskedTextProvider.Length" />
      </Docs>
    </Member>
  </Members>
</Type>
