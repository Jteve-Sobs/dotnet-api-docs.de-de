<Type Name="BackgroundWorker" FullName="System.ComponentModel.BackgroundWorker">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b27a54879d28ef5dc51b2516c2f0c7bc16275b3c" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75148038" /></Metadata><TypeSignature Language="C#" Value="public class BackgroundWorker : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BackgroundWorker extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.BackgroundWorker" />
  <TypeSignature Language="VB.NET" Value="Public Class BackgroundWorker&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class BackgroundWorker : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type BackgroundWorker = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("DoWork")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Führt einen Vorgang im separaten Thread aus.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.BackgroundWorker>-Klasse ermöglicht es Ihnen, einen Vorgang in einem separaten, dedizierten Thread auszuführen. Zeitaufwändige Vorgänge wie Downloads und Datenbanktransaktionen können dazu führen, dass die Benutzeroberfläche nicht mehr reagiert, während Sie ausgeführt wird. Wenn Sie eine reaktionsfähige Benutzeroberfläche mit langen Verzögerungen im Zusammenhang mit solchen Vorgängen haben möchten, bietet die <xref:System.ComponentModel.BackgroundWorker>-Klasse eine bequeme Lösung.  
  
 Um im Hintergrund einen zeitaufwändigen Vorgang auszuführen, erstellen Sie eine <xref:System.ComponentModel.BackgroundWorker> und lauschen auf Ereignisse, die den Fortschritt des Vorgangs melden, und signalisieren, wenn der Vorgang abgeschlossen ist. Sie können die <xref:System.ComponentModel.BackgroundWorker> Programm gesteuert erstellen, oder Sie können Sie von der Registerkarte **Komponenten** der **Toolbox**auf das Formular ziehen. Wenn Sie die <xref:System.ComponentModel.BackgroundWorker> im Windows Forms-Designer erstellen, wird Sie in der Komponenten Leiste angezeigt, und ihre Eigenschaften werden im Eigenschaftenfenster angezeigt.  
  
 Um für einen Hintergrund Vorgang einzurichten, fügen Sie einen Ereignishandler für das <xref:System.ComponentModel.BackgroundWorker.DoWork>-Ereignis hinzu. Aufrufen Sie den zeitaufwändigen Vorgang in diesem Ereignishandler. Um den Vorgang zu starten, wenden Sie <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>an. Um Benachrichtigungen über Statusaktualisierungen zu erhalten, behandeln Sie das <xref:System.ComponentModel.BackgroundWorker.ProgressChanged>-Ereignis. Um eine Benachrichtigung zu erhalten, wenn der Vorgang abgeschlossen ist, behandeln Sie das <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted>-Ereignis.  
  
> [!NOTE]
>  Sie müssen darauf achten, dass Sie keine Benutzeroberflächen Objekte in Ihrem <xref:System.ComponentModel.BackgroundWorker.DoWork>-Ereignishandler bearbeiten. Kommunizieren Sie stattdessen über die Ereignisse <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> und <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> mit der Benutzeroberfläche.  
>   
>  <xref:System.ComponentModel.BackgroundWorker> Ereignisse werden nicht über <xref:System.AppDomain> Grenzen hinweg gemarshallt. Verwenden Sie keine <xref:System.ComponentModel.BackgroundWorker> Komponente, um Multithread-Vorgänge in mehr als einer <xref:System.AppDomain>auszuführen.  
  
 Wenn für den Hintergrund Vorgang ein-Parameter erforderlich ist, müssen Sie <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> mit dem-Parameter aufrufen. Innerhalb des <xref:System.ComponentModel.BackgroundWorker.DoWork> Ereignis Handlers können Sie den Parameter aus der Eigenschaft <xref:System.ComponentModel.DoWorkEventArgs.Argument%2A?displayProperty=nameWithType> extrahieren.  
  
 Weitere Informationen zu <xref:System.ComponentModel.BackgroundWorker> finden Sie unter [Gewusst wie: Ausführen eines Vorgangs im Hintergrund](~/docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Grundlagen der <xref:System.ComponentModel.BackgroundWorker>-Klasse zum asynchronen Ausführen eines zeitaufwändigen Vorgangs veranschaulicht. Die folgende Abbildung zeigt ein Beispiel für die Ausgabe.  
  
 ![Einfaches BackgroundWorker-Beispiel](~/add/media/backgroundworker-simple.png "Einfaches Beispiel für BackgroundWorker")  
  
 Um diesen Code zu testen, erstellen Sie eine Windows Forms-Anwendung. Fügen Sie ein <xref:System.Windows.Forms.Label> `cancelAsyncButton`-Steuerelement mit dem Namen `resultLabel` hinzu, und fügen Sie zwei <xref:System.Windows.Forms.Button>-Steuerelemente namens `startAsyncButton` Erstellen Sie <xref:System.Windows.Forms.Control.Click> Ereignishandler für beide Schaltflächen. Fügen Sie auf der Registerkarte **Komponenten** der Toolbox eine <xref:System.ComponentModel.BackgroundWorker> Komponente mit dem Namen `backgroundWorker1`hinzu. Erstellen Sie <xref:System.ComponentModel.BackgroundWorker.DoWork>-, <xref:System.ComponentModel.BackgroundWorker.ProgressChanged>-und <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted>-Ereignishandler für die <xref:System.ComponentModel.BackgroundWorker>. Ersetzen Sie im Code für das Formular den vorhandenen Code durch den folgenden Code.  
  
 [!code-csharp[System.ComponentModel.BackgroundWorkerSimple#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.componentmodel.backgroundworkersimple/cs/form1.cs#1)]
 [!code-vb[System.ComponentModel.BackgroundWorkerSimple#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.componentmodel.backgroundworkersimple/vb/form1.vb#1)]  
  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.ComponentModel.BackgroundWorker>-Klasse zum asynchronen Ausführen eines zeitaufwändigen Vorgangs veranschaulicht. Die folgende Abbildung zeigt ein Beispiel für die Ausgabe.  
  
 ![BackgroundWorker-Beispiel für "fbonacci"](~/add/media/backgroundworker-fibonacci.png "Fibonacci-Beispiel für BackgroundWorker")  
  
 Durch den-Vorgang wird die ausgewählte "fbonacci"-Nummer berechnet, während der Berechnung Statusaktualisierungen gemeldet und eine ausstehende Berechnung abgebrochen werden.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#1)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#1)]
 [!code-vb[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
    <related type="Article" href="https://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557">Empfohlene Vorgehensweise für das verwaltete Threading</related>
    <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BackgroundWorker ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BackgroundWorker();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ComponentModel.BackgroundWorker" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert einen <xref:System.ComponentModel.BackgroundWorker>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : unit -&gt; unit" Usage="backgroundWorker.CancelAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fordert das Abbrechen eines anstehenden Hintergrundvorgangs an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> übermittelt eine Anforderung, den ausstehenden Hintergrund Vorgang zu beenden, und legt die <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A>-Eigenschaft auf `true`fest.  
  
 Wenn Sie <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A>aufgerufen haben, hat die Worker-Methode die Möglichkeit, die Ausführung zu beenden und zu beenden. Der Workercode sollte die <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A>-Eigenschaft regelmäßig überprüfen, um festzustellen, ob er `true`ist.  
  
> [!CAUTION]
>  Beachten Sie, dass der Code im <xref:System.ComponentModel.BackgroundWorker.DoWork> Ereignishandler seine Arbeit beenden kann, wenn eine Abbruch Anforderung ausgeführt wird, und ihre Abruf Schleife kann übersehen, dass <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> auf `true`festgelegt wird. In diesem Fall wird das <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A>-Flag <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> im <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Ereignishandler nicht auf `true`festgelegt, obwohl eine Abbruch Anforderung erfolgt ist. Diese Situation wird als *Racebedingung* bezeichnet und ist ein häufiges Problem bei der Multithreadprogrammierung. Weitere Informationen zu Problemen beim Entwerfen von Multithreading finden Sie unter [bewährte Methoden für das verwaltete Threading](~/docs/standard/threading/managed-threading-best-practices.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A>-Methode verwendet wird, um einen asynchronen Vorgang ("Background") abzubrechen. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.ComponentModel.BackgroundWorker>-Klasse bereitgestellt wird.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#4)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#4)]
 [!code-vb[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" /> ist <see langword="false" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="CancellationPending">
      <MemberSignature Language="C#" Value="public bool CancellationPending { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CancellationPending" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.CancellationPending" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CancellationPending As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CancellationPending { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CancellationPending : bool" Usage="System.ComponentModel.BackgroundWorker.CancellationPending" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Anwendung den Abbruch eines Hintergrundvorgangs angefordert hat.</summary>
        <value><see langword="true" />, wenn die Anwendung den Abbruch eines Hintergrundvorgangs angefordert hat, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> `true`ist, wurde die <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A>-Methode auf dem <xref:System.ComponentModel.BackgroundWorker>aufgerufen.  
  
 Diese Eigenschaft ist für die Verwendung durch den Arbeits Thread gedacht, der regelmäßig <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> überprüfen und den Hintergrund Vorgang abbrechen soll, wenn er auf `true`festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A>-Eigenschaft verwendet wird, um eine <xref:System.ComponentModel.BackgroundWorker> über Ihren Abbruch Zustand abzufragen. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.ComponentModel.BackgroundWorker>-Klasse bereitgestellt wird.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#8)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#8)]
 [!code-vb[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#8)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="backgroundWorker.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="backgroundWorker.Dispose disposing" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1" />
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="backgroundWorker.Dispose disposing" FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DoWork">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.DoWorkEventHandler DoWork;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.DoWorkEventHandler DoWork" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.DoWork" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoWork As DoWorkEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::DoWorkEventHandler ^ DoWork;" />
      <MemberSignature Language="F#" Value="member this.DoWork : System.ComponentModel.DoWorkEventHandler " Usage="member this.DoWork : System.ComponentModel.DoWorkEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DoWorkEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn <see cref="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync" /> aufgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn Sie die <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>-Methode aufzurufen. An dieser Stelle starten Sie den Vorgang, der die potenziell zeitaufwändige Arbeit ausführt.  
  
 Der Code im <xref:System.ComponentModel.BackgroundWorker.DoWork> Ereignishandler sollte den <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A>-Eigenschafts Wert regelmäßig überprüfen und den Vorgang abbrechen, wenn er `true`ist. Wenn dies auftritt, können Sie das <xref:System.ComponentModel.CancelEventArgs.Cancel%2A>-Flag von <xref:System.ComponentModel.DoWorkEventArgs?displayProperty=nameWithType> auf `true`festlegen, und das <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A>-Flag <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> in Ihrem <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted>-Ereignishandler wird auf `true`festgelegt.  
  
> [!CAUTION]
>  Beachten Sie, dass der Code im <xref:System.ComponentModel.BackgroundWorker.DoWork> Ereignishandler seine Arbeit beenden kann, wenn eine Abbruch Anforderung ausgeführt wird, und ihre Abruf Schleife kann übersehen, dass <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> auf `true`festgelegt wird. In diesem Fall wird das <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A>-Flag <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> im <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Ereignishandler nicht auf `true`festgelegt, obwohl eine Abbruch Anforderung erfolgt ist. Diese Situation wird als *Racebedingung* bezeichnet und ist ein häufiges Problem bei der Multithreadprogrammierung. Weitere Informationen zu Problemen beim Entwerfen von Multithreading finden Sie unter [bewährte Methoden für das verwaltete Threading](~/docs/standard/threading/managed-threading-best-practices.md).  
  
 Wenn Ihr Vorgang ein Ergebnis erzeugt, können Sie das Ergebnis der <xref:System.ComponentModel.DoWorkEventArgs.Result%2A?displayProperty=nameWithType>-Eigenschaft zuweisen. Diese ist für den <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted>-Ereignishandler in der <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType>-Eigenschaft verfügbar.  
  
 Wenn der Vorgang eine Ausnahme auslöst, die der Code nicht behandelt, fängt der <xref:System.ComponentModel.BackgroundWorker> die Ausnahme ab und übergibt sie an den <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted>-Ereignishandler, wo er als <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>-Eigenschaft des <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType>verfügbar gemacht wird. Wenn Sie unter dem Visual Studio-Debugger ausgeführt werden, unterbricht der Debugger an der Stelle im <xref:System.ComponentModel.BackgroundWorker.DoWork> Ereignishandler, an dem die nicht behandelte Ausnahme ausgelöst wurde. Wenn Sie mehr als eine <xref:System.ComponentModel.BackgroundWorker>haben, sollten Sie nicht direkt darauf verweisen, da dadurch der <xref:System.ComponentModel.BackgroundWorker.DoWork>-Ereignishandler mit einer bestimmten Instanz von <xref:System.ComponentModel.BackgroundWorker>koppeln würde. Stattdessen sollten Sie auf Ihre <xref:System.ComponentModel.BackgroundWorker> zugreifen, indem Sie den `sender`-Parameter in den <xref:System.ComponentModel.BackgroundWorker.DoWork>-Ereignishandler umwandeln.  
  
 Sie müssen darauf achten, dass Sie keine Benutzeroberflächen Objekte in Ihrem <xref:System.ComponentModel.BackgroundWorker.DoWork>-Ereignishandler bearbeiten. Kommunizieren Sie stattdessen über die <xref:System.ComponentModel.BackgroundWorker> Ereignisse mit der Benutzeroberfläche.  
  
 Weitere Informationen zum Behandeln von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.ComponentModel.BackgroundWorker.DoWork>-Ereignisses zum Starten eines asynchronen Vorgangs veranschaulicht. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.ComponentModel.BackgroundWorker>-Klasse bereitgestellt wird.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#5)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#5)]
 [!code-vb[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#5)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557">Empfohlene Vorgehensweise für das verwaltete Threading</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="IsBusy">
      <MemberSignature Language="C#" Value="public bool IsBusy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBusy" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.IsBusy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBusy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBusy { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBusy : bool" Usage="System.ComponentModel.BackgroundWorker.IsBusy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.ComponentModel.BackgroundWorker" /> einen asynchronen Vorgang ausführt.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.ComponentModel.BackgroundWorker" /> einen asynchronen Vorgang ausführt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.ComponentModel.BackgroundWorker> startet einen asynchronen Vorgang, wenn Sie <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>aufruft.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.ComponentModel.BackgroundWorker.IsBusy%2A>-Eigenschaft verwendet wird, um auf den Abschluss eines <xref:System.ComponentModel.BackgroundWorker> Vorgangs zu warten. Dieses Codebeispiel ist Teil eines größeren Beispiels, das unter Vorgehens [Weise: Herunterladen einer Datei im Hintergrund](~/docs/framework/winforms/controls/how-to-download-a-file-in-the-background.md)beschrieben wird.  
  
 [!code-csharp[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/CS/Form1.cs#2)]
 [!code-vb[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
        <altmember cref="T:System.EventArgs" />
        <altmember cref="Overload:System.ComponentModel.BackgroundWorker.RunWorkerAsync" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="OnDoWork">
      <MemberSignature Language="C#" Value="protected virtual void OnDoWork (System.ComponentModel.DoWorkEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDoWork(class System.ComponentModel.DoWorkEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnDoWork(System.ComponentModel.DoWorkEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDoWork (e As DoWorkEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDoWork(System::ComponentModel::DoWorkEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDoWork : System.ComponentModel.DoWorkEventArgs -&gt; unit&#xA;override this.OnDoWork : System.ComponentModel.DoWorkEventArgs -&gt; unit" Usage="backgroundWorker.OnDoWork e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.DoWorkEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.ComponentModel.BackgroundWorker.DoWork" /> aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnProgressChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnProgressChanged (System.ComponentModel.ProgressChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnProgressChanged(class System.ComponentModel.ProgressChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnProgressChanged (e As ProgressChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnProgressChanged(System::ComponentModel::ProgressChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnProgressChanged : System.ComponentModel.ProgressChangedEventArgs -&gt; unit&#xA;override this.OnProgressChanged : System.ComponentModel.ProgressChangedEventArgs -&gt; unit" Usage="backgroundWorker.OnProgressChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.ProgressChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.ComponentModel.BackgroundWorker.OnProgressChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.ComponentModel.BackgroundWorker.OnProgressChanged%2A>-Methode verwendet wird, um den Fortschritt eines asynchronen Vorgangs zu melden. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.ComponentModel.AsyncOperationManager>-Klasse bereitgestellt wird.  
  
 [!code-csharp[System.ComponentModel.AsyncOperationManager#24](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.AsyncOperationManager/CS/primenumbercalculatormain.cs#24)]
 [!code-vb[System.ComponentModel.AsyncOperationManager#24](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.AsyncOperationManager/VB/primenumbercalculatormain.vb#24)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="OnRunWorkerCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRunWorkerCompleted (System.ComponentModel.RunWorkerCompletedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRunWorkerCompleted(class System.ComponentModel.RunWorkerCompletedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRunWorkerCompleted (e As RunWorkerCompletedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRunWorkerCompleted(System::ComponentModel::RunWorkerCompletedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventArgs -&gt; unit&#xA;override this.OnRunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventArgs -&gt; unit" Usage="backgroundWorker.OnRunWorkerCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.RunWorkerCompletedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das Ereignis <see cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="ProgressChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.ProgressChangedEventHandler ProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.ProgressChangedEventHandler ProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProgressChanged As ProgressChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::ProgressChangedEventHandler ^ ProgressChanged;" />
      <MemberSignature Language="F#" Value="member this.ProgressChanged : System.ComponentModel.ProgressChangedEventHandler " Usage="member this.ProgressChanged : System.ComponentModel.ProgressChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ProgressChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn <see cref="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" /> aufgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn Sie die <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A>-Methode aufzurufen.  
  
 Weitere Informationen zum Behandeln von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.ComponentModel.BackgroundWorker.ProgressChanged>-Ereignisses veranschaulicht, um den Fortschritt eines asynchronen Vorgangs an den Benutzer zu melden. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.ComponentModel.BackgroundWorker>-Klasse bereitgestellt wird.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#7)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#7)]
 [!code-vb[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReportProgress">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löst das Ereignis <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" /> aus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReportProgress">
      <MemberSignature Language="C#" Value="public void ReportProgress (int percentProgress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReportProgress(int32 percentProgress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReportProgress (percentProgress As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReportProgress(int percentProgress);" />
      <MemberSignature Language="F#" Value="member this.ReportProgress : int -&gt; unit" Usage="backgroundWorker.ReportProgress percentProgress" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percentProgress" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="percentProgress">Bereits abgeschlossener Teil des Hintergrundvorgangs in Prozent (1-100).</param>
        <summary>Löst das Ereignis <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den Hintergrund Vorgang zum Melden des Fortschritts benötigen, können Sie die <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A>-Methode aufzurufen, um das <xref:System.ComponentModel.BackgroundWorker.ProgressChanged>-Ereignis zu erhöhen. Der Eigenschafts Wert <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> muss `true`sein, oder <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> löst eine <xref:System.InvalidOperationException>aus.  
  
 Es liegt an Ihnen, eine sinnvolle Methode zum Messen des Fortschritts des Hintergrund Vorgangs als Prozentsatz der abgeschlossenen Gesamtaufgabe zu implementieren.  
  
 Der-<xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> Methode wird asynchron aufgerufen und wird sofort zurückgegeben. Der <xref:System.ComponentModel.BackgroundWorker.ProgressChanged>-Ereignishandler wird in dem Thread ausgeführt, der die <xref:System.ComponentModel.BackgroundWorker>erstellt hat.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A>-Methode verwendet wird, um den Fortschritt eines asynchronen Vorgangs an den Benutzer zu melden. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.ComponentModel.BackgroundWorker>-Klasse bereitgestellt wird.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#8)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#8)]
 [!code-vb[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" />-Eigenschaft ist auf <see langword="false" /> festgelegt.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="ReportProgress">
      <MemberSignature Language="C#" Value="public void ReportProgress (int percentProgress, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReportProgress(int32 percentProgress, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReportProgress (percentProgress As Integer, userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReportProgress(int percentProgress, System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.ReportProgress : int * obj -&gt; unit" Usage="backgroundWorker.ReportProgress (percentProgress, userState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percentProgress" Type="System.Int32" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="percentProgress">Bereits abgeschlossener Teil des Hintergrundvorgangs in Prozent (1-100).</param>
        <param name="userState">Ein eindeutiges <see cref="T:System.Object" />, das den Benutzerzustand angibt. Wird als <see cref="P:System.ComponentModel.ProgressChangedEventArgs.UserState" />-Eigenschaft von <see cref="T:System.ComponentModel.ProgressChangedEventArgs" />zurückgegeben.</param>
        <summary>Löst das Ereignis <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den Hintergrund Vorgang zum Melden des Fortschritts benötigen, können Sie die <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A>-Methode aufzurufen, um das <xref:System.ComponentModel.BackgroundWorker.ProgressChanged>-Ereignis zu erhöhen. Der Eigenschafts Wert <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> muss `true`werden, oder <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> löst eine <xref:System.InvalidOperationException>aus.  
  
 Es liegt an Ihnen, eine sinnvolle Methode zum Messen des Fortschritts des Hintergrund Vorgangs als Prozentsatz der abgeschlossenen Gesamtaufgabe zu implementieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A>-Methode verwendet wird, um den Fortschritt eines asynchronen Vorgangs an den Benutzer zu melden. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Windows.Forms.ToolStripProgressBar>-Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Windows.Forms.ToolStripProgressBar#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ToolStripProgressBar/CS/form1.cs#10)]
 [!code-vb[System.Windows.Forms.ToolStripProgressBar#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ToolStripProgressBar/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" />-Eigenschaft ist auf <see langword="false" /> festgelegt.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunWorkerAsync">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet die Ausführung eines Hintergrundvorgangs.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunWorkerAsync">
      <MemberSignature Language="C#" Value="public void RunWorkerAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunWorkerAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunWorkerAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunWorkerAsync();" />
      <MemberSignature Language="F#" Value="member this.RunWorkerAsync : unit -&gt; unit" Usage="backgroundWorker.RunWorkerAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet die Ausführung eines Hintergrundvorgangs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>-Methode sendet eine Anforderung, um den asynchronen Vorgang zu starten. Wenn die Anforderung gewartet wird, wird das <xref:System.ComponentModel.BackgroundWorker.DoWork>-Ereignis ausgelöst, das wiederum die Ausführung des Hintergrund Vorgangs startet.  
  
 Wenn der Hintergrund Vorgang bereits ausgeführt wird, wird durch das erneute Aufrufen von <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> eine <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>-Methode zum Starten eines asynchronen Vorgangs veranschaulicht. Es ist Teil eines größeren Beispiels [, das unter Vorgehensweise: Herunterladen einer Datei im Hintergrund](~/docs/framework/winforms/controls/how-to-download-a-file-in-the-background.md)beschrieben wird.  
  
 [!code-csharp[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/CS/Form1.cs#2)]
 [!code-vb[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.ComponentModel.BackgroundWorker.IsBusy" /> ist <see langword="true" />.</exception>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.DoWork" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557">Empfohlene Vorgehensweise für das verwaltete Threading</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="RunWorkerAsync">
      <MemberSignature Language="C#" Value="public void RunWorkerAsync (object argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunWorkerAsync(object argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunWorkerAsync (argument As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunWorkerAsync(System::Object ^ argument);" />
      <MemberSignature Language="F#" Value="member this.RunWorkerAsync : obj -&gt; unit" Usage="backgroundWorker.RunWorkerAsync argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Parameter, der von dem Hintergrundvorgang verwendet wird, der im <see cref="E:System.ComponentModel.BackgroundWorker.DoWork" />-Ereignishandler ausgeführt wird.</param>
        <summary>Startet die Ausführung eines Hintergrundvorgangs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>-Methode sendet eine Anforderung, um den asynchronen Vorgang zu starten. Wenn die Anforderung gewartet wird, wird das <xref:System.ComponentModel.BackgroundWorker.DoWork>-Ereignis ausgelöst, das wiederum die Ausführung des Hintergrund Vorgangs startet.  
  
 Wenn für den Vorgang ein-Parameter erforderlich ist, können Sie ihn als `argument` Parameter angeben, um <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>.  
  
 Wenn der Hintergrund Vorgang bereits ausgeführt wird, wird durch das erneute Aufrufen von <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> eine <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>-Methode zum Starten eines asynchronen Vorgangs veranschaulicht. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.ComponentModel.BackgroundWorker>-Klasse bereitgestellt wird.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#3)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#3)]
 [!code-vb[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.ComponentModel.BackgroundWorker.IsBusy" /> ist <see langword="true" />.</exception>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.DoWork" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557">Empfohlene Vorgehensweise für das verwaltete Threading</related>
      </Docs>
    </Member>
    <Member MemberName="RunWorkerCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.RunWorkerCompletedEventHandler RunWorkerCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.RunWorkerCompletedEventHandler RunWorkerCompleted" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RunWorkerCompleted As RunWorkerCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::RunWorkerCompletedEventHandler ^ RunWorkerCompleted;" />
      <MemberSignature Language="F#" Value="member this.RunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventHandler " Usage="member this.RunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.RunWorkerCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Hintergrundvorgang entweder abgeschlossen ist, abgebrochen wurde oder eine Ausnahme ausgelöst hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn der <xref:System.ComponentModel.BackgroundWorker.DoWork> Ereignishandler zurückgibt.  
  
 Wenn der Vorgang erfolgreich abgeschlossen wurde und das Ergebnis im <xref:System.ComponentModel.BackgroundWorker.DoWork>-Ereignishandler zugewiesen ist, können Sie über die Eigenschaft <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> auf das Ergebnis zugreifen.  
  
 Die <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>-Eigenschaft von <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> gibt an, dass vom Vorgang eine Ausnahme ausgelöst wurde.  
  
 Die <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A>-Eigenschaft von <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> gibt an, ob eine Abbruch Anforderung vom Hintergrund Vorgang verarbeitet wurde. Wenn der Code im <xref:System.ComponentModel.BackgroundWorker.DoWork> Ereignishandler eine Abbruch Anforderung erkennt, indem er das <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A>-Flag prüft und das <xref:System.ComponentModel.CancelEventArgs.Cancel%2A>-Flag von <xref:System.ComponentModel.DoWorkEventArgs?displayProperty=nameWithType> auf `true`festlegt, wird das <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A>-Flag von <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> auch auf `true`festgelegt.  
  
> [!CAUTION]
>  Beachten Sie, dass der Code im <xref:System.ComponentModel.BackgroundWorker.DoWork> Ereignishandler seine Arbeit beenden kann, wenn eine Abbruch Anforderung ausgeführt wird, und ihre Abruf Schleife kann übersehen, dass <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> auf `true`festgelegt wird. In diesem Fall wird das <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A>-Flag <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> im <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Ereignishandler nicht auf `true`festgelegt, obwohl eine Abbruch Anforderung erfolgt ist. Diese Situation wird als *Racebedingung* bezeichnet und ist ein häufiges Problem bei der Multithreadprogrammierung. Weitere Informationen zu Problemen beim Entwerfen von Multithreading finden Sie unter [bewährte Methoden für das verwaltete Threading](~/docs/standard/threading/managed-threading-best-practices.md).  
  
 Der <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted>-Ereignishandler sollte vor dem Zugriff auf die <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> Eigenschaft immer die <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType>-und <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A?displayProperty=nameWithType>-Eigenschaften überprüfen. Wenn eine Ausnahme ausgelöst wurde oder der Vorgang abgebrochen wurde, löst der Zugriff auf die <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType>-Eigenschaft eine Ausnahme aus.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted>-Ereignis verwendet wird, um das Ergebnis eines asynchronen Vorgangs zu behandeln. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.ComponentModel.BackgroundWorker>-Klasse bereitgestellt wird.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#6)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#6)]
 [!code-vb[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#6)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="WorkerReportsProgress">
      <MemberSignature Language="C#" Value="public bool WorkerReportsProgress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WorkerReportsProgress" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" />
      <MemberSignature Language="VB.NET" Value="Public Property WorkerReportsProgress As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WorkerReportsProgress { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.WorkerReportsProgress : bool with get, set" Usage="System.ComponentModel.BackgroundWorker.WorkerReportsProgress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.ComponentModel.BackgroundWorker" /> Fortschrittsaktualisierungen melden kann, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.ComponentModel.BackgroundWorker" /> Fortschrittsaktualisierungen unterstützt, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie die <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A>-Eigenschaft auf `true` fest, wenn der <xref:System.ComponentModel.BackgroundWorker> Statusaktualisierungen unterstützen soll. Wenn diese Eigenschaft `true`ist, kann der Benutzercode die <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A>-Methode aufzurufen, um das <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> Ereignis zu erhöhen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="WorkerSupportsCancellation">
      <MemberSignature Language="C#" Value="public bool WorkerSupportsCancellation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WorkerSupportsCancellation" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" />
      <MemberSignature Language="VB.NET" Value="Public Property WorkerSupportsCancellation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WorkerSupportsCancellation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.WorkerSupportsCancellation : bool with get, set" Usage="System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.ComponentModel.BackgroundWorker" /> asynchrone Abbrüche unterstützt, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.ComponentModel.BackgroundWorker" /> Abbrüche unterstützt, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie die <xref:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation%2A>-Eigenschaft auf `true` fest, wenn der <xref:System.ComponentModel.BackgroundWorker> Abbruch unterstützen soll. Wenn diese Eigenschaft `true`ist, können Sie die <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A>-Methode aufzurufen, um einen Hintergrund Vorgang zu unterbrechen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.BackgroundWorker.CancelAsync" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
  </Members>
</Type>
