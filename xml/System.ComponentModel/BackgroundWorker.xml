<Type Name="BackgroundWorker" FullName="System.ComponentModel.BackgroundWorker">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5276c36b9c54cf2d9d6aa12b2187170d6956ce38" /><Meta Name="ms.sourcegitcommit" Value="8544f14c8194a55eb22d46721b0bbe46f345c063" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/21/2019" /><Meta Name="ms.locfileid" Value="69668034" /></Metadata><TypeSignature Language="C#" Value="public class BackgroundWorker : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BackgroundWorker extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.BackgroundWorker" />
  <TypeSignature Language="VB.NET" Value="Public Class BackgroundWorker&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class BackgroundWorker : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type BackgroundWorker = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("DoWork")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Führt einen Vorgang für einen getrennten Thread aus.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit <xref:System.ComponentModel.BackgroundWorker> der-Klasse können Sie einen Vorgang in einem separaten, dedizierten Thread ausführen. Zeitaufwändige Vorgänge wie Downloads und Datenbanktransaktionen können dazu führen, dass die Benutzeroberfläche nicht mehr reagiert, während Sie ausgeführt wird. Wenn Sie eine reaktionsfähige Benutzeroberfläche benötigen und lange Verzögerungen im Zusammenhang mit solchen Vorgängen auftreten <xref:System.ComponentModel.BackgroundWorker> , stellt die-Klasse eine bequeme Lösung bereit.  
  
 Wenn Sie einen zeitaufwändigen Vorgang im Hintergrund ausführen möchten, erstellen <xref:System.ComponentModel.BackgroundWorker> Sie einen, und lauschen Sie auf Ereignisse, die den Fortschritt des Vorgangs melden und signalisieren, wann der Vorgang abgeschlossen ist. Sie können das <xref:System.ComponentModel.BackgroundWorker> Programm gesteuert erstellen, oder Sie können es von der Registerkarte **Komponenten** der **Toolbox**auf das Formular ziehen. Wenn Sie die <xref:System.ComponentModel.BackgroundWorker> im Windows Forms-Designer erstellen, wird Sie in der Komponenten Leiste angezeigt, und ihre Eigenschaften werden in der Eigenschaftenfenster angezeigt.  
  
 Um für einen Hintergrund Vorgang einzurichten, fügen Sie einen Ereignishandler für das <xref:System.ComponentModel.BackgroundWorker.DoWork> -Ereignis hinzu. Aufrufen Sie den zeitaufwändigen Vorgang in diesem Ereignishandler. Um den Vorgang zu starten, <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>wird aufgerufen. Um Benachrichtigungen über Statusaktualisierungen zu erhalten, behandeln <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> Sie das-Ereignis. Um eine Benachrichtigung zu erhalten, wenn der Vorgang abgeschlossen ist, <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> behandeln Sie das-Ereignis.  
  
> [!NOTE]
>  Sie müssen darauf achten, dass Sie keine Benutzeroberflächen Objekte in Ihrem <xref:System.ComponentModel.BackgroundWorker.DoWork> Ereignishandler bearbeiten. Kommunizieren Sie stattdessen über das <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> -Ereignis und das- <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Ereignis mit der Benutzeroberfläche.  
>   
>  <xref:System.ComponentModel.BackgroundWorker>Ereignisse werden nicht über Grenzen hinweg <xref:System.AppDomain> gemarshallt. Verwenden <xref:System.ComponentModel.BackgroundWorker> Sie keine-Komponente, um Multithread-Vorgänge in mehr als <xref:System.AppDomain>einem auszuführen.  
  
 Wenn für den Hintergrund Vorgang ein-Parameter erforderlich <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> ist, müssen Sie mit dem-Parameter aufrufen. Innerhalb des <xref:System.ComponentModel.BackgroundWorker.DoWork> -Ereignis Handlers können Sie den-Parameter aus <xref:System.ComponentModel.DoWorkEventArgs.Argument%2A?displayProperty=nameWithType> der-Eigenschaft extrahieren.  
  
 Weitere Informationen zu <xref:System.ComponentModel.BackgroundWorker> finden Sie unter [Gewusst wie: Ausführen eines Vorgangs im Hintergrund](~/docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Grundlagen der <xref:System.ComponentModel.BackgroundWorker> -Klasse zum asynchronen Ausführen eines zeitaufwändigen Vorgangs veranschaulicht. Die folgende Abbildung zeigt ein Beispiel für die Ausgabe.  
  
 ![Einfaches BackgroundWorker-Beispiel] (~/add/media/backgroundworker-simple.png "Einfaches BackgroundWorker-Beispiel")  
  
 Um diesen Code zu testen, erstellen Sie eine Windows Forms-Anwendung. Fügen Sie <xref:System.Windows.Forms.Label> ein Steuer `resultLabel` Element mit dem <xref:System.Windows.Forms.Button> Namen hinzu `startAsyncButton` , `cancelAsyncButton`und fügen Sie zwei Steuerelemente Erstellen <xref:System.Windows.Forms.Control.Click> Sie Ereignishandler für beide Schaltflächen. Fügen Sie auf der Registerkarte **Komponenten** der Toolbox eine <xref:System.ComponentModel.BackgroundWorker> Komponente mit `backgroundWorker1`dem Namen hinzu. Erstellen <xref:System.ComponentModel.BackgroundWorker.DoWork>Sie <xref:System.ComponentModel.BackgroundWorker.ProgressChanged>die Ereignis <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Handler, und für den <xref:System.ComponentModel.BackgroundWorker>. Ersetzen Sie im Code für das Formular den vorhandenen Code durch den folgenden Code.  
  
 [!code-csharp[System.ComponentModel.BackgroundWorkerSimple#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.componentmodel.backgroundworkersimple/cs/form1.cs#1)]
 [!code-vb[System.ComponentModel.BackgroundWorkerSimple#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.componentmodel.backgroundworkersimple/vb/form1.vb#1)]  
  
 Im folgenden Codebeispiel wird die Verwendung <xref:System.ComponentModel.BackgroundWorker> der-Klasse zum asynchronen Ausführen eines zeitaufwändigen Vorgangs veranschaulicht. Die folgende Abbildung zeigt ein Beispiel für die Ausgabe.  
  
 ![BackgroundWorker-Beispiel für "fbonacci] " (~/add/media/backgroundworker-fibonacci.png "BackgroundWorker-Beispiel für \"fbonacci") "  
  
 Durch den-Vorgang wird die ausgewählte "fbonacci"-Nummer berechnet, während der Berechnung Statusaktualisierungen gemeldet und eine ausstehende Berechnung abgebrochen werden.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#1)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#1)]
 [!code-vb[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
    <related type="Article" href="https://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557">Empfohlene Vorgehensweise für das verwaltete Threading</related>
    <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BackgroundWorker ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BackgroundWorker();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ComponentModel.BackgroundWorker" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert eine <xref:System.ComponentModel.BackgroundWorker>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : unit -&gt; unit" Usage="backgroundWorker.CancelAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fordert das Abbrechen eines anstehenden Hintergrundvorgangs an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A>sendet eine Anforderung, um den ausstehenden Hintergrund Vorgang zu beenden und <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> die- `true`Eigenschaft auf festgelegt.  
  
 Wenn Sie <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A>den Befehl ausführen, hat die Worker-Methode die Möglichkeit, die Ausführung zu beenden und den Vorgang zu beenden. Der Workercode sollte die <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> -Eigenschaft regelmäßig überprüfen, um festzustellen, ob Sie auf `true`festgelegt wurde.  
  
> [!CAUTION]
>  Beachten Sie, dass der <xref:System.ComponentModel.BackgroundWorker.DoWork> Code im-Ereignishandler seine Arbeit beenden kann, wenn eine Abbruch Anforderung ausgeführt wird, und ihre Abruf Schleife <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> kann nicht auf `true`festgelegt werden. In diesem Fall wird das <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> -Flag <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> von im <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> -Ereignishandler nicht auf `true`festgelegt, obwohl eine Abbruch Anforderung erfolgt ist. Diese Situation wird als *Racebedingung* bezeichnet und ist ein häufiges Problem bei der Multithreadprogrammierung. Weitere Informationen zu Problemen beim Entwerfen von Multithreading finden Sie unter [bewährte Methoden für das verwaltete Threading](~/docs/standard/threading/managed-threading-best-practices.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> -Methode verwendet wird, um einen asynchronen Vorgang ("Background") abzubrechen. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.ComponentModel.BackgroundWorker> -Klasse bereitgestellt wird.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#4)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#4)]
 [!code-vb[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" /> ist <see langword="false" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="CancellationPending">
      <MemberSignature Language="C#" Value="public bool CancellationPending { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CancellationPending" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.CancellationPending" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CancellationPending As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CancellationPending { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CancellationPending : bool" Usage="System.ComponentModel.BackgroundWorker.CancellationPending" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Anwendung den Abbruch eines Hintergrundvorgangs angefordert hat.</summary>
        <value><see langword="true" />, wenn die Anwendung den Abbruch eines Hintergrundvorgangs angefordert hat, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> ist `true`, wird die <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> -Methode für <xref:System.ComponentModel.BackgroundWorker>aufgerufen.  
  
 Diese Eigenschaft ist für die Verwendung durch den Arbeits Thread gedacht, der den Hintergrund <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> Vorgang in regelmäßigen Abständen überprüfen und abbrechen soll, `true`wenn er auf festgelegt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> -Eigenschaft verwendet wird <xref:System.ComponentModel.BackgroundWorker> , um eine über Ihren Abbruch Zustand abzufragen. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.ComponentModel.BackgroundWorker> -Klasse bereitgestellt wird.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#8)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#8)]
 [!code-vb[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#8)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="backgroundWorker.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="backgroundWorker.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DoWork">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.DoWorkEventHandler DoWork;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.DoWorkEventHandler DoWork" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.DoWork" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoWork As DoWorkEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::DoWorkEventHandler ^ DoWork;" />
      <MemberSignature Language="F#" Value="member this.DoWork : System.ComponentModel.DoWorkEventHandler " Usage="member this.DoWork : System.ComponentModel.DoWorkEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DoWorkEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn <see cref="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync" /> aufgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn Sie die <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> -Methode aufzurufen. An dieser Stelle starten Sie den Vorgang, der die potenziell zeitaufwändige Arbeit ausführt.  
  
 Der Code im- <xref:System.ComponentModel.BackgroundWorker.DoWork> Ereignishandler sollte den <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> -Eigenschafts Wert in regelmäßigen Abständen überprüfen und den `true`Vorgang abbrechen, wenn dies der Fall ist. Wenn dies auftritt, können <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Sie das-Flag von <xref:System.ComponentModel.DoWorkEventArgs?displayProperty=nameWithType> auf `true`festlegen, und das <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> - <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> Flag von <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> im-Ereignishandler wird auf `true`festgelegt.  
  
> [!CAUTION]
>  Beachten Sie, dass der <xref:System.ComponentModel.BackgroundWorker.DoWork> Code im-Ereignishandler seine Arbeit beenden kann, wenn eine Abbruch Anforderung ausgeführt wird, und ihre Abruf Schleife <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> kann nicht auf `true`festgelegt werden. In diesem Fall wird das <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> -Flag <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> von im <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> -Ereignishandler nicht auf `true`festgelegt, obwohl eine Abbruch Anforderung erfolgt ist. Diese Situation wird als *Racebedingung* bezeichnet und ist ein häufiges Problem bei der Multithreadprogrammierung. Weitere Informationen zu Problemen beim Entwerfen von Multithreading finden Sie unter [bewährte Methoden für das verwaltete Threading](~/docs/standard/threading/managed-threading-best-practices.md).  
  
 Wenn der Vorgang ein Ergebnis erzeugt, können Sie das Ergebnis der <xref:System.ComponentModel.DoWorkEventArgs.Result%2A?displayProperty=nameWithType> Eigenschaft zuweisen. Diese wird dem <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> -Ereignishandler in der <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> -Eigenschaft zur Verfügung gestellt.  
  
 Wenn der Vorgang eine Ausnahme auslöst, die der <xref:System.ComponentModel.BackgroundWorker> Code nicht behandelt, fängt die Ausnahme ab und übergibt sie an den <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> -Ereignishandler, wo <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> Sie als-Eigenschaft von <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType>verfügbar gemacht wird. Wenn Sie unter dem Visual Studio-Debugger ausgeführt werden, unterbricht der Debugger an dem Punkt im <xref:System.ComponentModel.BackgroundWorker.DoWork> Ereignishandler, an dem die nicht behandelte Ausnahme ausgelöst wurde. Wenn Sie über mehrere <xref:System.ComponentModel.BackgroundWorker>verfügen, sollten Sie nicht direkt darauf verweisen, da dies den <xref:System.ComponentModel.BackgroundWorker.DoWork> Ereignishandler mit einer bestimmten Instanz von <xref:System.ComponentModel.BackgroundWorker>verknüpfen würde. Stattdessen sollten Sie auf den zugreifen <xref:System.ComponentModel.BackgroundWorker> , indem Sie `sender` den-Parameter <xref:System.ComponentModel.BackgroundWorker.DoWork> in den-Ereignishandler umwandeln.  
  
 Sie müssen darauf achten, dass Sie keine Benutzeroberflächen Objekte in Ihrem <xref:System.ComponentModel.BackgroundWorker.DoWork> Ereignishandler bearbeiten. Kommunizieren Sie stattdessen über die <xref:System.ComponentModel.BackgroundWorker> -Ereignisse mit der Benutzeroberfläche.  
  
 Weitere Informationen zum Behandeln von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.ComponentModel.BackgroundWorker.DoWork> -Ereignisses zum Starten eines asynchronen Vorgangs veranschaulicht. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.ComponentModel.BackgroundWorker> -Klasse bereitgestellt wird.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#5)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#5)]
 [!code-vb[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#5)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557">Empfohlene Vorgehensweise für das verwaltete Threading</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="IsBusy">
      <MemberSignature Language="C#" Value="public bool IsBusy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBusy" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.IsBusy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBusy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBusy { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBusy : bool" Usage="System.ComponentModel.BackgroundWorker.IsBusy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.ComponentModel.BackgroundWorker" /> einen asynchronen Vorgang ausführt.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.ComponentModel.BackgroundWorker" /> einen asynchronen Vorgang ausführt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Startet einen asynchronen Vorgang, wenn aufgerufen <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>wird. <xref:System.ComponentModel.BackgroundWorker>  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.ComponentModel.BackgroundWorker.IsBusy%2A> -Eigenschaft verwendet wird, um auf <xref:System.ComponentModel.BackgroundWorker> den Abschluss eines-Vorgangs zu warten. Dieses Codebeispiel ist Teil eines größeren Beispiels, das unter [Vorgehensweise: Herunterladen einer Datei im Hintergrund](~/docs/framework/winforms/controls/how-to-download-a-file-in-the-background.md).  
  
 [!code-csharp[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/CS/Form1.cs#2)]
 [!code-vb[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
        <altmember cref="T:System.EventArgs" />
        <altmember cref="Overload:System.ComponentModel.BackgroundWorker.RunWorkerAsync" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="OnDoWork">
      <MemberSignature Language="C#" Value="protected virtual void OnDoWork (System.ComponentModel.DoWorkEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDoWork(class System.ComponentModel.DoWorkEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnDoWork(System.ComponentModel.DoWorkEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDoWork (e As DoWorkEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDoWork(System::ComponentModel::DoWorkEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDoWork : System.ComponentModel.DoWorkEventArgs -&gt; unit&#xA;override this.OnDoWork : System.ComponentModel.DoWorkEventArgs -&gt; unit" Usage="backgroundWorker.OnDoWork e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.DoWorkEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.ComponentModel.BackgroundWorker.DoWork" /> -Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnProgressChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnProgressChanged (System.ComponentModel.ProgressChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnProgressChanged(class System.ComponentModel.ProgressChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnProgressChanged (e As ProgressChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnProgressChanged(System::ComponentModel::ProgressChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnProgressChanged : System.ComponentModel.ProgressChangedEventArgs -&gt; unit&#xA;override this.OnProgressChanged : System.ComponentModel.ProgressChangedEventArgs -&gt; unit" Usage="backgroundWorker.OnProgressChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.ProgressChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.ComponentModel.BackgroundWorker.OnProgressChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung <xref:System.ComponentModel.BackgroundWorker.OnProgressChanged%2A> der-Methode veranschaulicht, um den Fortschritt eines asynchronen Vorgangs zu melden. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.ComponentModel.AsyncOperationManager> -Klasse bereitgestellt wird.  
  
 [!code-csharp[System.ComponentModel.AsyncOperationManager#24](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.AsyncOperationManager/CS/primenumbercalculatormain.cs#24)]
 [!code-vb[System.ComponentModel.AsyncOperationManager#24](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.AsyncOperationManager/VB/primenumbercalculatormain.vb#24)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="OnRunWorkerCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRunWorkerCompleted (System.ComponentModel.RunWorkerCompletedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRunWorkerCompleted(class System.ComponentModel.RunWorkerCompletedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRunWorkerCompleted (e As RunWorkerCompletedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRunWorkerCompleted(System::ComponentModel::RunWorkerCompletedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventArgs -&gt; unit&#xA;override this.OnRunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventArgs -&gt; unit" Usage="backgroundWorker.OnRunWorkerCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.RunWorkerCompletedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see cref="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para></block>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="ProgressChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.ProgressChangedEventHandler ProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.ProgressChangedEventHandler ProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProgressChanged As ProgressChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::ProgressChangedEventHandler ^ ProgressChanged;" />
      <MemberSignature Language="F#" Value="member this.ProgressChanged : System.ComponentModel.ProgressChangedEventHandler " Usage="member this.ProgressChanged : System.ComponentModel.ProgressChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ProgressChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn <see cref="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" /> aufgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn Sie die <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> -Methode aufzurufen.  
  
 Weitere Informationen zum Behandeln von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> -Ereignisses veranschaulicht, um den Fortschritt eines asynchronen Vorgangs an den Benutzer zu melden. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.ComponentModel.BackgroundWorker> -Klasse bereitgestellt wird.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#7)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#7)]
 [!code-vb[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReportProgress">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löst das <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />-Ereignis aus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReportProgress">
      <MemberSignature Language="C#" Value="public void ReportProgress (int percentProgress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReportProgress(int32 percentProgress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReportProgress (percentProgress As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReportProgress(int percentProgress);" />
      <MemberSignature Language="F#" Value="member this.ReportProgress : int -&gt; unit" Usage="backgroundWorker.ReportProgress percentProgress" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percentProgress" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="percentProgress">Bereits abgeschlossener Teil des Hintergrundvorgangs in Prozent (1-100).</param>
        <summary>Löst das <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den Hintergrund Vorgang zum Melden des Fortschritts benötigen, können Sie die <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> -Methode zum Abrufen des <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> -Ereignisses aufruft. Der <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> Eigenschafts Wert muss `true`sein, <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> oder es wird <xref:System.InvalidOperationException>eine ausgelöst.  
  
 Es liegt an Ihnen, eine sinnvolle Methode zum Messen des Fortschritts des Hintergrund Vorgangs als Prozentsatz der abgeschlossenen Gesamtaufgabe zu implementieren.  
  
 Der- <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> Methodenaufrufe erfolgt asynchron und wird sofort zurückgegeben. Der <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> -Ereignishandler wird in dem Thread ausgeführt, <xref:System.ComponentModel.BackgroundWorker>der das erstellt hat.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> der-Methode veranschaulicht, um den Fortschritt eines asynchronen Vorgangs an den Benutzer zu melden. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.ComponentModel.BackgroundWorker> -Klasse bereitgestellt wird.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#8)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#8)]
 [!code-vb[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" />-Eigenschaft ist auf <see langword="false" /> festgelegt.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="ReportProgress">
      <MemberSignature Language="C#" Value="public void ReportProgress (int percentProgress, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReportProgress(int32 percentProgress, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReportProgress (percentProgress As Integer, userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReportProgress(int percentProgress, System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.ReportProgress : int * obj -&gt; unit" Usage="backgroundWorker.ReportProgress (percentProgress, userState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percentProgress" Type="System.Int32" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="percentProgress">Bereits abgeschlossener Teil des Hintergrundvorgangs in Prozent (1-100).</param>
        <param name="userState">Das an <see cref="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync(System.Object)" /> übergebene Zustandsobjekt.</param>
        <summary>Löst das <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den Hintergrund Vorgang zum Melden des Fortschritts benötigen, können Sie die <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> -Methode zum Abrufen des <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> -Ereignisses aufruft. Der <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> Eigenschafts Wert `true`muss sein <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> oder eine <xref:System.InvalidOperationException>auslösen.  
  
 Es liegt an Ihnen, eine sinnvolle Methode zum Messen des Fortschritts des Hintergrund Vorgangs als Prozentsatz der abgeschlossenen Gesamtaufgabe zu implementieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> der-Methode veranschaulicht, um den Fortschritt eines asynchronen Vorgangs an den Benutzer zu melden. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Windows.Forms.ToolStripProgressBar> -Klasse bereitgestellt wird.  
  
 [!code-csharp[System.Windows.Forms.ToolStripProgressBar#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ToolStripProgressBar/CS/form1.cs#10)]
 [!code-vb[System.Windows.Forms.ToolStripProgressBar#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ToolStripProgressBar/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" />-Eigenschaft ist auf <see langword="false" /> festgelegt.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunWorkerAsync">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet die Ausführung eines Hintergrundvorgangs.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunWorkerAsync">
      <MemberSignature Language="C#" Value="public void RunWorkerAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunWorkerAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunWorkerAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunWorkerAsync();" />
      <MemberSignature Language="F#" Value="member this.RunWorkerAsync : unit -&gt; unit" Usage="backgroundWorker.RunWorkerAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet die Ausführung eines Hintergrundvorgangs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> -Methode sendet eine Anforderung, um den asynchronen Vorgang zu starten. Wenn die Anforderung gewartet wird, wird <xref:System.ComponentModel.BackgroundWorker.DoWork> das-Ereignis ausgelöst, das wiederum die Ausführung des Hintergrund Vorgangs startet.  
  
 Wenn der Hintergrund Vorgang bereits ausgeführt wird, wird <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> durch den erneuten Aufruf <xref:System.InvalidOperationException>von ein-Wert aufgerufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> der-Methode zum Starten eines asynchronen Vorgangs veranschaulicht. Es ist Teil eines größeren Beispiels, das unter [Vorgehensweise: Herunterladen einer Datei im Hintergrund](~/docs/framework/winforms/controls/how-to-download-a-file-in-the-background.md).  
  
 [!code-csharp[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/CS/Form1.cs#2)]
 [!code-vb[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.ComponentModel.BackgroundWorker.IsBusy" /> ist <see langword="true" />.</exception>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.DoWork" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557">Empfohlene Vorgehensweise für das verwaltete Threading</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="RunWorkerAsync">
      <MemberSignature Language="C#" Value="public void RunWorkerAsync (object argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunWorkerAsync(object argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunWorkerAsync (argument As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunWorkerAsync(System::Object ^ argument);" />
      <MemberSignature Language="F#" Value="member this.RunWorkerAsync : obj -&gt; unit" Usage="backgroundWorker.RunWorkerAsync argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Parameter, der von dem Hintergrundvorgang verwendet wird, der im <see cref="E:System.ComponentModel.BackgroundWorker.DoWork" />-Ereignishandler ausgeführt wird.</param>
        <summary>Startet die Ausführung eines Hintergrundvorgangs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> -Methode sendet eine Anforderung, um den asynchronen Vorgang zu starten. Wenn die Anforderung gewartet wird, wird <xref:System.ComponentModel.BackgroundWorker.DoWork> das-Ereignis ausgelöst, das wiederum die Ausführung des Hintergrund Vorgangs startet.  
  
 Wenn für den Vorgang ein-Parameter erforderlich ist, können Sie ihn `argument` als Parameter <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>für angeben.  
  
 Wenn der Hintergrund Vorgang bereits ausgeführt wird, wird <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> durch den erneuten Aufruf <xref:System.InvalidOperationException>von ein-Wert aufgerufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> der-Methode zum Starten eines asynchronen Vorgangs veranschaulicht. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.ComponentModel.BackgroundWorker> -Klasse bereitgestellt wird.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#3)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#3)]
 [!code-vb[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.ComponentModel.BackgroundWorker.IsBusy" /> ist <see langword="true" />.</exception>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.DoWork" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557">Empfohlene Vorgehensweise für das verwaltete Threading</related>
      </Docs>
    </Member>
    <Member MemberName="RunWorkerCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.RunWorkerCompletedEventHandler RunWorkerCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.RunWorkerCompletedEventHandler RunWorkerCompleted" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RunWorkerCompleted As RunWorkerCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::RunWorkerCompletedEventHandler ^ RunWorkerCompleted;" />
      <MemberSignature Language="F#" Value="member this.RunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventHandler " Usage="member this.RunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.RunWorkerCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Hintergrundvorgang entweder abgeschlossen ist, abgebrochen wurde oder eine Ausnahme ausgelöst hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn <xref:System.ComponentModel.BackgroundWorker.DoWork> der Ereignishandler zurückgibt.  
  
 Wenn der Vorgang erfolgreich abgeschlossen wurde und das Ergebnis im- <xref:System.ComponentModel.BackgroundWorker.DoWork> Ereignishandler zugewiesen ist, können Sie über die <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> -Eigenschaft auf das Ergebnis zugreifen.  
  
 Die <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> -Eigenschaft <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> von gibt an, dass vom Vorgang eine Ausnahme ausgelöst wurde.  
  
 Die <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> -Eigenschaft <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> von gibt an, ob eine Abbruch Anforderung vom Hintergrund Vorgang verarbeitet wurde. Wenn <xref:System.ComponentModel.BackgroundWorker.DoWork> der Code im-Ereignishandler eine Abbruch Anforderung erkennt, indem er das <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> -Flag überprüft <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> und das <xref:System.ComponentModel.DoWorkEventArgs?displayProperty=nameWithType> - `true`Flag von <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> auf festlegt <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> , wird das-Flag von ebenfalls auf festgelegt. `true`.  
  
> [!CAUTION]
>  Beachten Sie, dass der <xref:System.ComponentModel.BackgroundWorker.DoWork> Code im-Ereignishandler seine Arbeit beenden kann, wenn eine Abbruch Anforderung ausgeführt wird, und ihre Abruf Schleife <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> kann nicht auf `true`festgelegt werden. In diesem Fall wird das <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> -Flag <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> von im <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> -Ereignishandler nicht auf `true`festgelegt, obwohl eine Abbruch Anforderung erfolgt ist. Diese Situation wird als *Racebedingung* bezeichnet und ist ein häufiges Problem bei der Multithreadprogrammierung. Weitere Informationen zu Problemen beim Entwerfen von Multithreading finden Sie unter [bewährte Methoden für das verwaltete Threading](~/docs/standard/threading/managed-threading-best-practices.md).  
  
 Der Ereignishandler sollte vor dem Zugriff <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> auf <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A?displayProperty=nameWithType> die <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> Eigenschaft immer die Eigenschaften und überprüfen. <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Wenn eine Ausnahme ausgelöst wurde oder der Vorgang abgebrochen wurde, löst der <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> Zugriff auf die-Eigenschaft eine Ausnahme aus.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie das <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> -Ereignis verwendet wird, um das Ergebnis eines asynchronen Vorgangs zu behandeln. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.ComponentModel.BackgroundWorker> -Klasse bereitgestellt wird.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#6)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#6)]
 [!code-vb[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#6)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="WorkerReportsProgress">
      <MemberSignature Language="C#" Value="public bool WorkerReportsProgress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WorkerReportsProgress" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" />
      <MemberSignature Language="VB.NET" Value="Public Property WorkerReportsProgress As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WorkerReportsProgress { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.WorkerReportsProgress : bool with get, set" Usage="System.ComponentModel.BackgroundWorker.WorkerReportsProgress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.ComponentModel.BackgroundWorker" /> Fortschrittsaktualisierungen melden kann, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.ComponentModel.BackgroundWorker" /> Fortschrittsaktualisierungen unterstützt, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> die-`true` Eigenschaft auf fest, wenn Statusaktualisierungen vonunterstütztwerdensollen.<xref:System.ComponentModel.BackgroundWorker> Wenn diese Eigenschaft ist `true`, kann der Benutzercode die <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> -Methode aufzurufen <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> , um das-Ereignis zu erhöhen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="WorkerSupportsCancellation">
      <MemberSignature Language="C#" Value="public bool WorkerSupportsCancellation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WorkerSupportsCancellation" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" />
      <MemberSignature Language="VB.NET" Value="Public Property WorkerSupportsCancellation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WorkerSupportsCancellation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.WorkerSupportsCancellation : bool with get, set" Usage="System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.ComponentModel.BackgroundWorker" /> asynchrone Abbrüche unterstützt, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.ComponentModel.BackgroundWorker" /> Abbrüche unterstützt, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie <xref:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation%2A> die- `true` Eigenschaft auf fest, <xref:System.ComponentModel.BackgroundWorker> wenn der abgebrochen werden soll. Wenn diese Eigenschaft ist `true`, können Sie die <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> -Methode zum Unterbrechen eines Hintergrund Vorgangs aufzurufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.BackgroundWorker.CancelAsync" />
        <related type="Article" href="https://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="https://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
  </Members>
</Type>
