<Type Name="BackgroundWorker" FullName="System.ComponentModel.BackgroundWorker">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="39f7c80e09eb1e4015b00c77fb7fae56e118bba5" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48631325" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class BackgroundWorker : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BackgroundWorker extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.BackgroundWorker" />
  <TypeSignature Language="VB.NET" Value="Public Class BackgroundWorker&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class BackgroundWorker : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type BackgroundWorker = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("DoWork")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Führt einen Vorgang im separaten Thread aus.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.BackgroundWorker> Klasse können Sie einen Vorgang in einem separaten, dedizierten Thread auszuführen. Zeitaufwändige Operationen wie Downloads und Datenbanktransaktionen können dazu führen, dass Ihre Benutzeroberfläche (UI) scheint, als ob er beendet wurde, reagieren, während sie ausgeführt werden. Wenn Sie eine reaktionsfähige Benutzeroberfläche und lange Verzögerungen bei solchen Vorgängen vermeiden die <xref:System.ComponentModel.BackgroundWorker> Klasse bietet eine praktische Lösung.  
  
 Um einen zeitaufwändigen Vorgang im Hintergrund auszuführen, erstellen eine <xref:System.ComponentModel.BackgroundWorker> und zum Lauschen auf Ereignisse, die den Status der Operation und Signal zu melden, wenn der Vorgang abgeschlossen ist. Sie erstellen die <xref:System.ComponentModel.BackgroundWorker> programmgesteuert oder ziehen sie auf das Formular aus der **Komponenten** auf der Registerkarte die **Toolbox**. Bei der Erstellung der <xref:System.ComponentModel.BackgroundWorker> im Windows Forms-Designer, in der Komponentenleiste angezeigt, und seine Eigenschaften im Eigenschaftenfenster angezeigt werden.  
  
 Um eine Hintergrundoperation einzurichten, fügen Sie einen Ereignishandler für die <xref:System.ComponentModel.BackgroundWorker.DoWork> Ereignis. Rufen Sie den zeitaufwändigen Vorgang in diesem Ereignishandler ein. Um den Vorgang zu starten, rufen <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>. Um Benachrichtigungen von statusaktualisierungen zu empfangen, verarbeiten die <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> Ereignis. Um eine Benachrichtigung zu erhalten, wenn der Vorgang abgeschlossen ist, behandelt der <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Ereignis.  
  
> [!NOTE]
>  Achten Sie nicht zum Bearbeiten von UI-Objekte in Ihrem <xref:System.ComponentModel.BackgroundWorker.DoWork> -Ereignishandler. Kommunizieren Sie stattdessen mit der Benutzeroberfläche, über die <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> und <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Ereignisse.  
>   
>  <xref:System.ComponentModel.BackgroundWorker> Ereignisse werden nicht über gemarshallt <xref:System.AppDomain> Grenzen. Verwenden Sie keine <xref:System.ComponentModel.BackgroundWorker> Komponente auszuführenden Vorgänge mit mehreren Threads in mehr als einer <xref:System.AppDomain>.  
  
 Wenn der Hintergrundvorgang Parameter erfordert, rufen Sie <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> mit dem-Parameter. In der <xref:System.ComponentModel.BackgroundWorker.DoWork> -Ereignishandler können Sie den Parameter aus Extrahieren der <xref:System.ComponentModel.DoWorkEventArgs.Argument%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Weitere Informationen zu <xref:System.ComponentModel.BackgroundWorker> finden Sie unter [Gewusst wie: Ausführen eines Vorgangs im Hintergrund](~/docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die Grundlagen der <xref:System.ComponentModel.BackgroundWorker> -Klasse für einen zeitaufwändigen Vorgang, der asynchron ausgeführt. Die folgende Abbildung zeigt ein Beispiel der Ausgabe.  
  
 ![Einfaches Beispiel für BackgroundWorker](~/add/media/backgroundworker-simple.png "einfaches Beispiel für BackgroundWorker")  
  
 Um diesen Code zu testen, erstellen Sie eine Windows Forms-Anwendung. Hinzufügen einer <xref:System.Windows.Forms.Label> Steuerelement mit dem Namen `resultLabel` und Hinzufügen von zwei <xref:System.Windows.Forms.Button> -Steuerelemente namens `startAsyncButton` und `cancelAsyncButton`. Erstellen Sie <xref:System.Windows.Forms.Control.Click> -Ereignishandlern für beide Schaltflächen. Von der **Komponenten** Registerkarte der Toolbox hinzufügen einer <xref:System.ComponentModel.BackgroundWorker> Komponente, die mit dem Namen `backgroundWorker1`. Erstellen Sie <xref:System.ComponentModel.BackgroundWorker.DoWork>, <xref:System.ComponentModel.BackgroundWorker.ProgressChanged>, und <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> -Ereignishandlern für die <xref:System.ComponentModel.BackgroundWorker>. Ersetzen Sie in den Code für das Formular den vorhandenen Code durch den folgenden Code ein.  
  
 [!code-csharp[System.ComponentModel.BackgroundWorkerSimple#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.componentmodel.backgroundworkersimple/cs/form1.cs#1)]
 [!code-vb[System.ComponentModel.BackgroundWorkerSimple#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.componentmodel.backgroundworkersimple/vb/form1.vb#1)]  
  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.ComponentModel.BackgroundWorker> -Klasse für einen zeitaufwändigen Vorgang, der asynchron ausgeführt. Die folgende Abbildung zeigt ein Beispiel der Ausgabe.  
  
 ![BackgroundWorker Fibonacci-Beispiel](~/add/media/backgroundworker-fibonacci.png "BackgroundWorker Fibonacci-Beispiel")  
  
 Der Vorgang die ausgewählten Fibonacci-Zahl berechnet, meldet statusaktualisierungen, die während der Berechnung durchgeführt wird und ermöglicht eine ausstehende Berechnung abgebrochen werden soll.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#1)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#1)]
 [!code-vb[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
    <related type="Article" href="http://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557">Empfohlene Vorgehensweise für das verwaltete Threading</related>
    <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BackgroundWorker ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BackgroundWorker();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ComponentModel.BackgroundWorker" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert ein <xref:System.ComponentModel.BackgroundWorker>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : unit -&gt; unit" Usage="backgroundWorker.CancelAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fordert das Abbrechen eines anstehenden Hintergrundvorgangs an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> sendet eine Anforderung an den anstehenden Hintergrundvorgangs und legt die <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> Eigenschaft `true`.  
  
 Beim Aufruf <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A>, die Worker-Methode die Möglichkeit hat, beendet die Ausführung und beenden. Der Workercode sollte in regelmäßigen Abständen Prüfen der <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> Eigenschaft, um festzustellen, ob es festgelegt wurde `true`.  
  
> [!CAUTION]
>  Beachten Sie, Ihren Code in die <xref:System.ComponentModel.BackgroundWorker.DoWork> -Ereignishandler kann seine Arbeit abgeschlossen, wie eine abbruchanforderung erfolgt, und Ihre Abrufschleife kann übersehen <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> festgelegt `true`. In diesem Fall die <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> flag von <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> in Ihre <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> -Ereignishandler kann nicht festgelegt werden, um `true`, auch wenn ein Abbruch angefordert wurde. Diese Situation wird aufgerufen, eine *Racebedingung* und ist ein häufiges Problem bei der Multithreadprogrammierung. Weitere Informationen zu multithreading entwerfen Probleme finden Sie unter [Managed Threading Best Practices](~/docs/standard/threading/managed-threading-best-practices.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> Methode, um einen asynchronen ("Hintergrund")-Vorgang abzubrechen. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.ComponentModel.BackgroundWorker> Klasse.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#4)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#4)]
 [!code-vb[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" /> ist <see langword="false" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="CancellationPending">
      <MemberSignature Language="C#" Value="public bool CancellationPending { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CancellationPending" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.CancellationPending" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CancellationPending As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CancellationPending { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CancellationPending : bool" Usage="System.ComponentModel.BackgroundWorker.CancellationPending" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Anwendung den Abbruch eines Hintergrundvorgangs angefordert hat.</summary>
        <value>
          <see langword="true" />, wenn die Anwendung den Abbruch eines Hintergrundvorgangs angefordert hat, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> ist `true`, und klicken Sie dann die <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> Methode aufgerufen wurde, auf die <xref:System.ComponentModel.BackgroundWorker>.  
  
 Diese Eigenschaft ist für die Verwendung vorgesehen, durch den Arbeitsthread, der regelmäßig prüfen sollte, <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> und der Hintergrundvorgang abgebrochen, wenn er, um festgelegt ist `true`.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> Eigenschaft zur Abfrage einer <xref:System.ComponentModel.BackgroundWorker> Abbruchzustand. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.ComponentModel.BackgroundWorker> Klasse.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#8)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#8)]
 [!code-vb[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#8)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="backgroundWorker.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="backgroundWorker.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DoWork">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.DoWorkEventHandler DoWork;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.DoWorkEventHandler DoWork" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.DoWork" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoWork As DoWorkEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::DoWorkEventHandler ^ DoWork;" />
      <MemberSignature Language="F#" Value="member this.DoWork : System.ComponentModel.DoWorkEventHandler " Usage="member this.DoWork : System.ComponentModel.DoWorkEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DoWorkEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn <see cref="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync" /> aufgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn Sie beim Aufrufen der <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> Methode. Dies ist, in dem Sie den Vorgang zu starten, der der potenziell zeitaufwendigen Vorgang ausgeführt.  
  
 Den Code in die <xref:System.ComponentModel.BackgroundWorker.DoWork> -Ereignishandler sollte in regelmäßigen Abständen überprüfen. die <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> Eigenschaftswert "und" Abort "der Vorgang ist dies `true`. In diesem Fall können Sie festlegen der <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> flag von <xref:System.ComponentModel.DoWorkEventArgs?displayProperty=nameWithType> zu `true`, und die <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> flag von <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> in Ihre <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> -Ereignishandler festgelegt `true`.  
  
> [!CAUTION]
>  Beachten Sie, Ihren Code in die <xref:System.ComponentModel.BackgroundWorker.DoWork> -Ereignishandler kann seine Arbeit abgeschlossen, wie eine abbruchanforderung erfolgt, und Ihre Abrufschleife kann übersehen <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> festgelegt `true`. In diesem Fall die <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> flag von <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> in Ihre <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> -Ereignishandler kann nicht festgelegt werden, um `true`, auch wenn ein Abbruch angefordert wurde. Diese Situation wird aufgerufen, eine *Racebedingung* und ist ein häufiges Problem bei der Multithreadprogrammierung. Weitere Informationen zu multithreading entwerfen Probleme finden Sie unter [Managed Threading Best Practices](~/docs/standard/threading/managed-threading-best-practices.md).  
  
 Wenn der Vorgang ein Ergebnis erzeugt, können Sie das Ergebnis, das Zuweisen der <xref:System.ComponentModel.DoWorkEventArgs.Result%2A?displayProperty=nameWithType> Eigenschaft. Dadurch stehen die <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> -Ereignishandler in der <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn der Vorgang eine Ausnahme, die Ihren Code nicht behandelt auslöst, die <xref:System.ComponentModel.BackgroundWorker> fängt die Ausnahme ab und übergibt Sie ihn in die <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> -Ereignishandler als verfügbar die <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> Eigenschaft <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType>. Wenn Sie unter Visual Studio-Debugger ausgeführt werden, wird der Debugger am Punkt in der <xref:System.ComponentModel.BackgroundWorker.DoWork> -Ereignishandler, die nicht behandelte Ausnahme ausgelöst wurde. Wenn Sie über mehrere verfügen <xref:System.ComponentModel.BackgroundWorker>, Sie sollten nicht direkt auf verweisen einer von ihnen, wie dies koppeln würde Ihre <xref:System.ComponentModel.BackgroundWorker.DoWork> -Ereignishandler mit einer bestimmten Instanz des <xref:System.ComponentModel.BackgroundWorker>. Stattdessen greifen Sie auf Ihre <xref:System.ComponentModel.BackgroundWorker> durch Umwandeln der `sender` Parameter in Ihre <xref:System.ComponentModel.BackgroundWorker.DoWork> -Ereignishandler.  
  
 Achten Sie nicht zum Bearbeiten von UI-Objekte in Ihrem <xref:System.ComponentModel.BackgroundWorker.DoWork> -Ereignishandler. Kommunizieren Sie stattdessen mit der Benutzeroberfläche, über die <xref:System.ComponentModel.BackgroundWorker> Ereignisse.  
  
 Weitere Informationen zum Behandeln von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.ComponentModel.BackgroundWorker.DoWork> Ereignis, um einen asynchronen Vorgang zu starten. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.ComponentModel.BackgroundWorker> Klasse.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#5)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#5)]
 [!code-vb[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#5)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="http://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557">Empfohlene Vorgehensweise für das verwaltete Threading</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="IsBusy">
      <MemberSignature Language="C#" Value="public bool IsBusy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBusy" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.IsBusy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBusy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBusy { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBusy : bool" Usage="System.ComponentModel.BackgroundWorker.IsBusy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.ComponentModel.BackgroundWorker" /> einen asynchronen Vorgang ausführt.</summary>
        <value>
          <see langword="true" />, wenn der <see cref="T:System.ComponentModel.BackgroundWorker" /> einen asynchronen Vorgang ausführt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.BackgroundWorker> beim Aufruf startet einen asynchronen Vorgang <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.ComponentModel.BackgroundWorker.IsBusy%2A> Eigenschaft, um auf den Abschluss warten einer <xref:System.ComponentModel.BackgroundWorker> Vorgang. Dieses Codebeispiel ist Teil eines größeren Beispiels, die in beschriebenen [wie: Downloaden einer Datei im Hintergrund](~/docs/framework/winforms/controls/how-to-download-a-file-in-the-background.md).  
  
 [!code-csharp[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/CS/Form1.cs#2)]
 [!code-vb[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
        <altmember cref="T:System.EventArgs" />
        <altmember cref="Overload:System.ComponentModel.BackgroundWorker.RunWorkerAsync" />
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="OnDoWork">
      <MemberSignature Language="C#" Value="protected virtual void OnDoWork (System.ComponentModel.DoWorkEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDoWork(class System.ComponentModel.DoWorkEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnDoWork(System.ComponentModel.DoWorkEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDoWork (e As DoWorkEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDoWork(System::ComponentModel::DoWorkEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDoWork : System.ComponentModel.DoWorkEventArgs -&gt; unit&#xA;override this.OnDoWork : System.ComponentModel.DoWorkEventArgs -&gt; unit" Usage="backgroundWorker.OnDoWork e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.DoWorkEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.ComponentModel.BackgroundWorker.DoWork" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnProgressChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnProgressChanged (System.ComponentModel.ProgressChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnProgressChanged(class System.ComponentModel.ProgressChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnProgressChanged (e As ProgressChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnProgressChanged(System::ComponentModel::ProgressChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnProgressChanged : System.ComponentModel.ProgressChangedEventArgs -&gt; unit&#xA;override this.OnProgressChanged : System.ComponentModel.ProgressChangedEventArgs -&gt; unit" Usage="backgroundWorker.OnProgressChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.ProgressChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.ComponentModel.BackgroundWorker.OnProgressChanged%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.ComponentModel.BackgroundWorker.OnProgressChanged%2A> Methode, um den Fortschritt eines asynchronen Vorgangs anzugeben. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.ComponentModel.AsyncOperationManager> Klasse.  
  
 [!code-csharp[System.ComponentModel.AsyncOperationManager#24](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.AsyncOperationManager/CS/primenumbercalculatormain.cs#24)]
 [!code-vb[System.ComponentModel.AsyncOperationManager#24](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.AsyncOperationManager/VB/primenumbercalculatormain.vb#24)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="OnRunWorkerCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRunWorkerCompleted (System.ComponentModel.RunWorkerCompletedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRunWorkerCompleted(class System.ComponentModel.RunWorkerCompletedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRunWorkerCompleted (e As RunWorkerCompletedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRunWorkerCompleted(System::ComponentModel::RunWorkerCompletedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventArgs -&gt; unit&#xA;override this.OnRunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventArgs -&gt; unit" Usage="backgroundWorker.OnRunWorkerCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.RunWorkerCompletedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.EventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 Mit der <xref:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted%2A>-Methode können auch abgeleitete Klassen das Ereignis ohne Anfügen eines Delegaten behandeln. Dies ist das bevorzugte Verfahren für die Behandlung des Ereignisses in einer abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Wenn Sie <see cref="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die <see cref="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" />-Methode der Basisklasse aufrufen, damit registrierte Delegaten das Ereignis empfangen.</para>
        </block>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="ProgressChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.ProgressChangedEventHandler ProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.ProgressChangedEventHandler ProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProgressChanged As ProgressChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::ProgressChangedEventHandler ^ ProgressChanged;" />
      <MemberSignature Language="F#" Value="member this.ProgressChanged : System.ComponentModel.ProgressChangedEventHandler " Usage="member this.ProgressChanged : System.ComponentModel.ProgressChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ProgressChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn <see cref="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" /> aufgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn Sie beim Aufrufen der <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> Methode.  
  
 Weitere Informationen zum Behandeln von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> Ereignis, um den Status eines asynchronen Vorgangs für den Benutzer zu melden. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.ComponentModel.BackgroundWorker> Klasse.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#7)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#7)]
 [!code-vb[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReportProgress">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löst das <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />-Ereignis aus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReportProgress">
      <MemberSignature Language="C#" Value="public void ReportProgress (int percentProgress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReportProgress(int32 percentProgress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReportProgress (percentProgress As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReportProgress(int percentProgress);" />
      <MemberSignature Language="F#" Value="member this.ReportProgress : int -&gt; unit" Usage="backgroundWorker.ReportProgress percentProgress" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percentProgress" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="percentProgress">Bereits abgeschlossener Teil des Hintergrundvorgangs in Prozent (1-100).</param>
        <summary>Löst das <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den Vorgang im Hintergrund auf seinen Fortschritt melden benötigen, können Sie Aufrufen der <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> Methode zum Auslösen der <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> Ereignis. Die <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> Eigenschaftswert muss `true`, oder <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> löst eine <xref:System.InvalidOperationException>.  
  
 Es liegt an Ihnen sinnvollen Weise Messen des Fortschritts der als Prozentsatz der gesamten Aufgabe abgeschlossen zu implementieren.  
  
 Der Aufruf der <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> Methode ist asynchron und gibt sofort zurück. Die <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> -Ereignishandler ausgeführt wird, auf dem Thread aus, erstellt die <xref:System.ComponentModel.BackgroundWorker>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> Methode, um den Fortschritt eines asynchronen Vorgangs für den Benutzer anzugeben. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.ComponentModel.BackgroundWorker> Klasse.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#8)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#8)]
 [!code-vb[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" />-Eigenschaft ist auf <see langword="false" /> festgelegt.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="ReportProgress">
      <MemberSignature Language="C#" Value="public void ReportProgress (int percentProgress, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReportProgress(int32 percentProgress, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReportProgress (percentProgress As Integer, userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReportProgress(int percentProgress, System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.ReportProgress : int * obj -&gt; unit" Usage="backgroundWorker.ReportProgress (percentProgress, userState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percentProgress" Type="System.Int32" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="percentProgress">Bereits abgeschlossener Teil des Hintergrundvorgangs in Prozent (1-100).</param>
        <param name="userState">Das an <see cref="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync(System.Object)" /> übergebene Zustandsobjekt.</param>
        <summary>Löst das <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie den Vorgang im Hintergrund auf seinen Fortschritt melden benötigen, können Sie Aufrufen der <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> Methode zum Auslösen der <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> Ereignis. Die <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> Eigenschaftswert muss `true`, oder <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> löst eine <xref:System.InvalidOperationException>.  
  
 Es liegt an Ihnen sinnvollen Weise Messen des Fortschritts der als Prozentsatz der gesamten Aufgabe abgeschlossen zu implementieren.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> Methode, um den Fortschritt eines asynchronen Vorgangs für den Benutzer anzugeben. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Windows.Forms.ToolStripProgressBar> Klasse.  
  
 [!code-csharp[System.Windows.Forms.ToolStripProgressBar#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ToolStripProgressBar/CS/form1.cs#10)]
 [!code-vb[System.Windows.Forms.ToolStripProgressBar#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ToolStripProgressBar/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" />-Eigenschaft ist auf <see langword="false" /> festgelegt.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunWorkerAsync">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet die Ausführung eines Hintergrundvorgangs.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunWorkerAsync">
      <MemberSignature Language="C#" Value="public void RunWorkerAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunWorkerAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunWorkerAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunWorkerAsync();" />
      <MemberSignature Language="F#" Value="member this.RunWorkerAsync : unit -&gt; unit" Usage="backgroundWorker.RunWorkerAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet die Ausführung eines Hintergrundvorgangs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> Methode sendet eine Anforderung an die asynchrone Ausführung des Vorgangs zu starten. Wenn die Anforderung verarbeitet wurde, die <xref:System.ComponentModel.BackgroundWorker.DoWork> -Ereignis ausgelöst wird, die wiederum startet die Ausführung der Hintergrundvorgang.  
  
 Wenn der Vorgang im Hintergrund bereits ausgeführt wird, wird beim Aufrufen <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> erneut löst eine <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> Methode, um einen asynchronen Vorgang zu starten. Es ist Teil eines größeren Beispiels, die in beschriebenen [wie: Downloaden einer Datei im Hintergrund](~/docs/framework/winforms/controls/how-to-download-a-file-in-the-background.md).  
  
 [!code-csharp[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/CS/Form1.cs#2)]
 [!code-vb[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.ComponentModel.BackgroundWorker.IsBusy" /> ist <see langword="true" />.</exception>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.DoWork" />
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="http://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557">Empfohlene Vorgehensweise für das verwaltete Threading</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="RunWorkerAsync">
      <MemberSignature Language="C#" Value="public void RunWorkerAsync (object argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunWorkerAsync(object argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunWorkerAsync (argument As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunWorkerAsync(System::Object ^ argument);" />
      <MemberSignature Language="F#" Value="member this.RunWorkerAsync : obj -&gt; unit" Usage="backgroundWorker.RunWorkerAsync argument" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="argument">Ein Parameter, der von dem Hintergrundvorgang verwendet wird, der im <see cref="E:System.ComponentModel.BackgroundWorker.DoWork" />-Ereignishandler ausgeführt wird.</param>
        <summary>Startet die Ausführung eines Hintergrundvorgangs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> Methode sendet eine Anforderung an die asynchrone Ausführung des Vorgangs zu starten. Wenn die Anforderung verarbeitet wurde, die <xref:System.ComponentModel.BackgroundWorker.DoWork> -Ereignis ausgelöst wird, die wiederum startet die Ausführung der Hintergrundvorgang.  
  
 Wenn der Vorgang einen Parameter benötigt, können Sie angeben, als die `argument` Parameter <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>.  
  
 Wenn der Vorgang im Hintergrund bereits ausgeführt wird, wird beim Aufrufen <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> erneut löst eine <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> Methode, um einen asynchronen Vorgang zu starten. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.ComponentModel.BackgroundWorker> Klasse.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#3)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#3)]
 [!code-vb[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.ComponentModel.BackgroundWorker.IsBusy" /> ist <see langword="true" />.</exception>
        <altmember cref="E:System.ComponentModel.BackgroundWorker.DoWork" />
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
        <related type="Article" href="http://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557">Empfohlene Vorgehensweise für das verwaltete Threading</related>
      </Docs>
    </Member>
    <Member MemberName="RunWorkerCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.RunWorkerCompletedEventHandler RunWorkerCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.RunWorkerCompletedEventHandler RunWorkerCompleted" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RunWorkerCompleted As RunWorkerCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::RunWorkerCompletedEventHandler ^ RunWorkerCompleted;" />
      <MemberSignature Language="F#" Value="member this.RunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventHandler " Usage="member this.RunWorkerCompleted : System.ComponentModel.RunWorkerCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.RunWorkerCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der Hintergrundvorgang entweder abgeschlossen ist, abgebrochen wurde oder eine Ausnahme ausgelöst hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis wird ausgelöst, wenn die <xref:System.ComponentModel.BackgroundWorker.DoWork> Ereignishandler zurückkehrt.  
  
 Wenn der Vorgang erfolgreich abgeschlossen und das Ergebnis, in zugewiesen ist der <xref:System.ComponentModel.BackgroundWorker.DoWork> Ereignishandler, Sie können Zugriff auf das Ergebnis mithilfe von der <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> Eigenschaft <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> gibt an, dass der Vorgang eine Ausnahme ausgelöst wurde.  
  
 Die <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> Eigenschaft <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> gibt an, ob eine abbruchanforderung vom der Vorgang im Hintergrund verarbeitet wurde. Wenn Ihren Code in der <xref:System.ComponentModel.BackgroundWorker.DoWork> Ereignishandler erkennt eine abbruchanforderung durch Überprüfen der <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> Flag und der Einstellung der <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> flag von <xref:System.ComponentModel.DoWorkEventArgs?displayProperty=nameWithType> zu `true`, <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> flag von <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> wird auch festgelegt werden, um `true`.  
  
> [!CAUTION]
>  Beachten Sie, Ihren Code in die <xref:System.ComponentModel.BackgroundWorker.DoWork> -Ereignishandler kann seine Arbeit abgeschlossen, wie eine abbruchanforderung erfolgt, und Ihre Abrufschleife kann übersehen <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> festgelegt `true`. In diesem Fall die <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> flag von <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> in Ihre <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> -Ereignishandler kann nicht festgelegt werden, um `true`, auch wenn ein Abbruch angefordert wurde. Diese Situation wird aufgerufen, eine *Racebedingung* und ist ein häufiges Problem bei der Multithreadprogrammierung. Weitere Informationen zu multithreading entwerfen Probleme finden Sie unter [Managed Threading Best Practices](~/docs/standard/threading/managed-threading-best-practices.md).  
  
 Ihre <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Ereignishandler sollten immer überprüfen, die <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> und <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A?displayProperty=nameWithType> Eigenschaften vor dem Zugriff auf die <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> Eigenschaft. Wenn eine Ausnahme ausgelöst wurde, oder wenn der Vorgang abgebrochen wurde, den Zugriff auf die <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> Eigenschaft löst eine Ausnahme aus.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> Ereignis, um das Ergebnis eines asynchronen Vorgangs behandelt. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.ComponentModel.BackgroundWorker> Klasse.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#6)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#6)]
 [!code-vb[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#6)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="WorkerReportsProgress">
      <MemberSignature Language="C#" Value="public bool WorkerReportsProgress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WorkerReportsProgress" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" />
      <MemberSignature Language="VB.NET" Value="Public Property WorkerReportsProgress As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WorkerReportsProgress { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.WorkerReportsProgress : bool with get, set" Usage="System.ComponentModel.BackgroundWorker.WorkerReportsProgress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.ComponentModel.BackgroundWorker" /> Fortschrittsaktualisierungen melden kann, oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />, wenn der <see cref="T:System.ComponentModel.BackgroundWorker" /> Fortschrittsaktualisierungen unterstützt, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Festlegen der <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> Eigenschaft `true` Wunsch der <xref:System.ComponentModel.BackgroundWorker> um statusaktualisierungen zu unterstützen. Wenn diese Eigenschaft ist `true`, Benutzercode aufrufen kann die <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> Methode zum Auslösen der <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> Ereignis.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" />
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
    <Member MemberName="WorkerSupportsCancellation">
      <MemberSignature Language="C#" Value="public bool WorkerSupportsCancellation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WorkerSupportsCancellation" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" />
      <MemberSignature Language="VB.NET" Value="Public Property WorkerSupportsCancellation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WorkerSupportsCancellation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.WorkerSupportsCancellation : bool with get, set" Usage="System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.ComponentModel.BackgroundWorker" /> asynchrone Abbrüche unterstützt, oder legt diesen Wert fest.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.ComponentModel.BackgroundWorker" /> Abbrüche unterstützt, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie die <xref:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation%2A> Eigenschaft `true` Wunsch der <xref:System.ComponentModel.BackgroundWorker> zur Unterstützung des Abbruchs. Wenn diese Eigenschaft ist `true`, rufen Sie die <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> Methode zum Unterbrechen eines Hintergrundvorgangs.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.BackgroundWorker.CancelAsync" />
        <related type="Article" href="http://msdn.microsoft.com/library/5b56e2aa-dc05-444f-930c-2d7b23f9ad5b">Gewusst wie: Ausführen eines Vorgangs im Hintergrund</related>
        <related type="Article" href="http://msdn.microsoft.com/library/9b7bc5ae-051c-4904-9720-18f6667388bd">Gewusst wie: Downloaden einer Datei im Hintergrund</related>
      </Docs>
    </Member>
  </Members>
</Type>