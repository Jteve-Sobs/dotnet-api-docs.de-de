<Type Name="WindowsRuntimeBufferExtensions" FullName="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions">
  <Metadata><Meta Name="ms.openlocfilehash" Value="81c43314025076a057c262af23d65a85565df304" /><Meta Name="ms.sourcegitcommit" Value="367e1eae0725e6da7136cd073aaa856ded5d5c29" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/13/2019" /><Meta Name="ms.locfileid" Value="75026000" /></Metadata><TypeSignature Language="C#" Value="public static class WindowsRuntimeBufferExtensions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit WindowsRuntimeBufferExtensions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions" />
  <TypeSignature Language="VB.NET" Value="Public Module WindowsRuntimeBufferExtensions" />
  <TypeSignature Language="C++ CLI" Value="public ref class WindowsRuntimeBufferExtensions abstract sealed" />
  <TypeSignature Language="F#" Value="type WindowsRuntimeBufferExtensions = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.14.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="dotnet-uwp-10.0">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Erweiterungsmethoden für Vorgänge für Windows-Runtime-Puffer (Windows.Storage.Streams.IBuffer-Schnittstelle) bereit.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AsBuffer">
      <MemberSignature Language="C#" Value="public static Windows.Storage.Streams.IBuffer AsBuffer (this byte[] source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Windows.Storage.Streams.IBuffer AsBuffer(unsigned int8[] source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsBuffer(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsBuffer (source As Byte()) As IBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Windows::Storage::Streams::IBuffer ^ AsBuffer(cli::array &lt;System::Byte&gt; ^ source);" />
      <MemberSignature Language="F#" Value="static member AsBuffer : byte[] -&gt; Windows.Storage.Streams.IBuffer" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsBuffer source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Windows.Storage.Streams.IBuffer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Das Array, das dargestellt werden soll.</param>
        <summary>Gibt eine Windows.Storage.Streams.IBuffer-Schnittstelle zurück, die das angegebene Bytearray darstellt.</summary>
        <returns>Eine Windows.Storage.Streams.IBuffer-Schnittstelle, die das angegebene Bytearray darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsBuffer">
      <MemberSignature Language="C#" Value="public static Windows.Storage.Streams.IBuffer AsBuffer (this byte[] source, int offset, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Windows.Storage.Streams.IBuffer AsBuffer(unsigned int8[] source, int32 offset, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsBuffer(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsBuffer (source As Byte(), offset As Integer, length As Integer) As IBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Windows::Storage::Streams::IBuffer ^ AsBuffer(cli::array &lt;System::Byte&gt; ^ source, int offset, int length);" />
      <MemberSignature Language="F#" Value="static member AsBuffer : byte[] * int * int -&gt; Windows.Storage.Streams.IBuffer" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsBuffer (source, offset, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Windows.Storage.Streams.IBuffer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" RefType="this" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Das Array, das den Bytebereich enthält, der von der IBuffer-Schnittstelle dargestellt wird.</param>
        <param name="offset">Der Offset in <paramref name="source" />, an dem der Bereich beginnt.</param>
        <param name="length">Die Länge des Bereichs, der durch die IBuffer-Schnittstelle dargestellt wird.</param>
        <summary>Gibt eine Windows.Storage.Streams.IBuffer-Schnittstelle zurück, die einen Bytebereich im angegebenen Bytearray darstellt.</summary>
        <returns>Eine IBuffer-Schnittstelle, die den angegebenen Bytebereich in <paramref name="source" /> darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> oder <paramref name="length" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">Das Array ist nicht groß genug, um als Sicherungsspeicher für die IBuffer-Schnittstelle verwendet werden zu können. Dies bedeutet, dass die Anzahl der Bytes in <paramref name="source" />, beginnend bei <paramref name="offset" />, kleiner ist als <paramref name="length" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsBuffer">
      <MemberSignature Language="C#" Value="public static Windows.Storage.Streams.IBuffer AsBuffer (this byte[] source, int offset, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Windows.Storage.Streams.IBuffer AsBuffer(unsigned int8[] source, int32 offset, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsBuffer(System.Byte[],System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsBuffer (source As Byte(), offset As Integer, length As Integer, capacity As Integer) As IBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Windows::Storage::Streams::IBuffer ^ AsBuffer(cli::array &lt;System::Byte&gt; ^ source, int offset, int length, int capacity);" />
      <MemberSignature Language="F#" Value="static member AsBuffer : byte[] * int * int * int -&gt; Windows.Storage.Streams.IBuffer" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsBuffer (source, offset, length, capacity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Windows.Storage.Streams.IBuffer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" RefType="this" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Das Array, das den Bytebereich enthält, der von der IBuffer-Schnittstelle dargestellt wird.</param>
        <param name="offset">Der Offset in <paramref name="source" />, an dem der Bereich beginnt.</param>
        <param name="length">Der Wert der Length-Eigenschaft der IBuffer-Schnittstelle.</param>
        <param name="capacity">Die Größe des Bereichs, der durch die IBuffer-Schnittstelle dargestellt wird. Die Capacity-Eigenschaft der IBuffer-Schnittstelle wird auf diesen Wert festgelegt.</param>
        <summary>Gibt eine Windows.Storage.Streams.IBuffer-Schnittstelle zurück, die einen Bytebereich im angegebenen Bytearray darstellt. Legt optional die Length-Eigenschaft der IBuffer-Schnittstelle auf einen Wert fest, der kleiner ist als die Kapazität.</summary>
        <returns>Eine IBuffer-Schnittstelle, die den angegebenen Bytebereich in <paramref name="source" /> darstellt und über den angegebenen Length-Eigenschaftswert verfügt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" />, <paramref name="length" /> oder <paramref name="capacity" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> ist größer als <paramref name="capacity" />. Oder: Das Array ist nicht groß genug, um als Sicherungsspeicher für die IBuffer-Schnittstelle verwendet werden zu können. Dies bedeutet, dass die Anzahl der Bytes in <paramref name="source" />, beginnend bei <paramref name="offset" />, kleiner ist als <paramref name="length" /> oder <paramref name="capacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsStream">
      <MemberSignature Language="C#" Value="public static System.IO.Stream AsStream (this Windows.Storage.Streams.IBuffer source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream AsStream(class Windows.Storage.Streams.IBuffer source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsStream(Windows.Storage.Streams.IBuffer)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsStream (source As IBuffer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::IO::Stream ^ AsStream(Windows::Storage::Streams::IBuffer ^ source);" />
      <MemberSignature Language="F#" Value="static member AsStream : Windows.Storage.Streams.IBuffer -&gt; System.IO.Stream" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.AsStream source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Die IBuffer-Schnittstelle, die einen Stream darstellt.</param>
        <summary>Gibt einen Stream zurück, der den gleichen Speicher darstellt wie die angegebene Windows.Storage.Streams.IBuffer-Schnittstelle.</summary>
        <returns>Ein Stream, der den gleichen Speicher darstellt wie die angegebene Windows.Storage.Streams.IBuffer-Schnittstelle.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public static void CopyTo (this byte[] source, Windows.Storage.Streams.IBuffer destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo(unsigned int8[] source, class Windows.Storage.Streams.IBuffer destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo(System.Byte[],Windows.Storage.Streams.IBuffer)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo (source As Byte(), destination As IBuffer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(cli::array &lt;System::Byte&gt; ^ source, Windows::Storage::Streams::IBuffer ^ destination);" />
      <MemberSignature Language="F#" Value="static member CopyTo : byte[] * Windows.Storage.Streams.IBuffer -&gt; unit" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" RefType="this" />
        <Parameter Name="destination" Type="Windows.Storage.Streams.IBuffer" />
      </Parameters>
      <Docs>
        <param name="source">Das Array, aus dem Daten kopiert werden sollen.</param>
        <param name="destination">Der Puffer, in den Daten kopiert werden sollen.</param>
        <summary>Kopiert alle Bytes aus dem Quellarray in den Zielpuffer (Windows.Storage.Streams.IBuffer). Als Startindex wird jeweils der Offset 0 (null) verwendet. Die Methode aktualisiert nicht die Länge des Zielpuffers.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="destination" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Die Größe von <paramref name="source" /> überschreitet die Kapazität von <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public static void CopyTo (this Windows.Storage.Streams.IBuffer source, byte[] destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo(class Windows.Storage.Streams.IBuffer source, unsigned int8[] destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo(Windows.Storage.Streams.IBuffer,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo (source As IBuffer, destination As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(Windows::Storage::Streams::IBuffer ^ source, cli::array &lt;System::Byte&gt; ^ destination);" />
      <MemberSignature Language="F#" Value="static member CopyTo : Windows.Storage.Streams.IBuffer * byte[] -&gt; unit" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="destination" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, aus dem Daten kopiert werden sollen.</param>
        <param name="destination">Das Array, in das Daten kopiert werden sollen.</param>
        <summary>Kopiert alle Bytes aus dem Quellpuffer (Windows.Storage.Streams.IBuffer) in das Zielarray. Als Startindex wird jeweils der Offset 0 (null) verwendet.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="destination" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Die Größe von <paramref name="source" /> überschreitet die Größe von <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public static void CopyTo (this Windows.Storage.Streams.IBuffer source, Windows.Storage.Streams.IBuffer destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo(class Windows.Storage.Streams.IBuffer source, class Windows.Storage.Streams.IBuffer destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo(Windows.Storage.Streams.IBuffer,Windows.Storage.Streams.IBuffer)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo (source As IBuffer, destination As IBuffer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(Windows::Storage::Streams::IBuffer ^ source, Windows::Storage::Streams::IBuffer ^ destination);" />
      <MemberSignature Language="F#" Value="static member CopyTo : Windows.Storage.Streams.IBuffer * Windows.Storage.Streams.IBuffer -&gt; unit" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo (source, destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="destination" Type="Windows.Storage.Streams.IBuffer" />
      </Parameters>
      <Docs>
        <param name="source">Der Quellpuffer.</param>
        <param name="destination">Der Zielpuffer.</param>
        <summary>Kopiert alle Bytes aus dem Quellpuffer (Windows.Storage.Streams.IBuffer) in den Zielpuffer. Als Startindex wird jeweils der Offset 0 (null) verwendet.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="destination" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentException">Die Größe von <paramref name="source" /> überschreitet die Kapazität von <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public static void CopyTo (this byte[] source, int sourceIndex, Windows.Storage.Streams.IBuffer destination, uint destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo(unsigned int8[] source, int32 sourceIndex, class Windows.Storage.Streams.IBuffer destination, unsigned int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo(System.Byte[],System.Int32,Windows.Storage.Streams.IBuffer,System.UInt32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo (source As Byte(), sourceIndex As Integer, destination As IBuffer, destinationIndex As UInteger, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(cli::array &lt;System::Byte&gt; ^ source, int sourceIndex, Windows::Storage::Streams::IBuffer ^ destination, System::UInt32 destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="static member CopyTo : byte[] * int * Windows.Storage.Streams.IBuffer * uint32 * int -&gt; unit" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo (source, sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" RefType="this" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="Windows.Storage.Streams.IBuffer" />
        <Parameter Name="destinationIndex" Type="System.UInt32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Das Array, aus dem Daten kopiert werden sollen.</param>
        <param name="sourceIndex">Der Index in <paramref name="source" />, ab dem Daten kopiert werden sollen.</param>
        <param name="destination">Der Puffer, in den Daten kopiert werden sollen.</param>
        <param name="destinationIndex">Der Index in <paramref name="destination" />, ab dem mit dem Kopieren von Daten begonnen werden soll.</param>
        <param name="count">Die Anzahl der zu kopierenden Bytes.</param>
        <summary>Kopiert Bytes aus dem Quellarray in den Zielpuffer (Windows.Storage.Streams.IBuffer) und gibt den Startindex im Quellarray, den Startindex im Zielpuffer und die Anzahl der zu kopierenden Bytes an. Die Methode aktualisiert nicht die Length-Eigenschaft des Zielpuffers.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="destination" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />, <paramref name="sourceIndex" /> oder <paramref name="destinationIndex" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="sourceIndex" /> ist größer als oder gleich der Länge von <paramref name="source" />. Oder: Die Anzahl der Bytes in <paramref name="source" />, beginnend bei <paramref name="sourceIndex" />, ist kleiner als <paramref name="count" />. Oder: Durch das Kopieren von <paramref name="count" /> Bytes, beginnend bei <paramref name="destinationIndex" />, wird die Kapazität von <paramref name="destination" /> überschreiten.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public static void CopyTo (this Windows.Storage.Streams.IBuffer source, uint sourceIndex, byte[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo(class Windows.Storage.Streams.IBuffer source, unsigned int32 sourceIndex, unsigned int8[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo(Windows.Storage.Streams.IBuffer,System.UInt32,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo (source As IBuffer, sourceIndex As UInteger, destination As Byte(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(Windows::Storage::Streams::IBuffer ^ source, System::UInt32 sourceIndex, cli::array &lt;System::Byte&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="static member CopyTo : Windows.Storage.Streams.IBuffer * uint32 * byte[] * int * int -&gt; unit" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo (source, sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="sourceIndex" Type="System.UInt32" />
        <Parameter Name="destination" Type="System.Byte[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, aus dem Daten kopiert werden sollen.</param>
        <param name="sourceIndex">Der Index in <paramref name="source" />, ab dem Daten kopiert werden sollen.</param>
        <param name="destination">Das Array, in das Daten kopiert werden sollen.</param>
        <param name="destinationIndex">Der Index in <paramref name="destination" />, ab dem mit dem Kopieren von Daten begonnen werden soll.</param>
        <param name="count">Die Anzahl der zu kopierenden Bytes.</param>
        <summary>Kopiert Bytes aus dem Quellpuffer (Windows.Storage.Streams.IBuffer) in das Zielarray und gibt den Startindex im Quellpuffer, den Startindex im Zielarray und die Anzahl der zu kopierenden Bytes an.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="destination" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />, <paramref name="sourceIndex" /> oder <paramref name="destinationIndex" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> ist größer als oder gleich der Kapazität von <paramref name="source" />. Oder: <paramref name="destinationIndex" /> ist größer oder gleich der Länge von <paramref name="destination" />. Oder: Die Anzahl der Bytes in <paramref name="source" />, beginnend bei <paramref name="sourceIndex" />, ist kleiner als <paramref name="count" />. Oder: Durch das Kopieren von <paramref name="count" /> Bytes, beginnend bei <paramref name="destinationIndex" />, wird die Größe von <paramref name="destination" /> überschreiten.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public static void CopyTo (this Windows.Storage.Streams.IBuffer source, uint sourceIndex, Windows.Storage.Streams.IBuffer destination, uint destinationIndex, uint count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyTo(class Windows.Storage.Streams.IBuffer source, unsigned int32 sourceIndex, class Windows.Storage.Streams.IBuffer destination, unsigned int32 destinationIndex, unsigned int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo(Windows.Storage.Streams.IBuffer,System.UInt32,Windows.Storage.Streams.IBuffer,System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub CopyTo (source As IBuffer, sourceIndex As UInteger, destination As IBuffer, destinationIndex As UInteger, count As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void CopyTo(Windows::Storage::Streams::IBuffer ^ source, System::UInt32 sourceIndex, Windows::Storage::Streams::IBuffer ^ destination, System::UInt32 destinationIndex, System::UInt32 count);" />
      <MemberSignature Language="F#" Value="static member CopyTo : Windows.Storage.Streams.IBuffer * uint32 * Windows.Storage.Streams.IBuffer * uint32 * uint32 -&gt; unit" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.CopyTo (source, sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="sourceIndex" Type="System.UInt32" />
        <Parameter Name="destination" Type="Windows.Storage.Streams.IBuffer" />
        <Parameter Name="destinationIndex" Type="System.UInt32" />
        <Parameter Name="count" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, aus dem Daten kopiert werden sollen.</param>
        <param name="sourceIndex">Der Index in <paramref name="source" />, ab dem Daten kopiert werden sollen.</param>
        <param name="destination">Der Puffer, in den Daten kopiert werden sollen.</param>
        <param name="destinationIndex">Der Index in <paramref name="destination" />, ab dem mit dem Kopieren von Daten begonnen werden soll.</param>
        <param name="count">Die Anzahl der zu kopierenden Bytes.</param>
        <summary>Kopiert Bytes aus dem Quellpuffer (Windows.Storage.Streams.IBuffer) in den Zielpuffer und gibt den Startindex in der Quelle, den Startindex im Ziel und die Anzahl der zu kopierenden Bytes an.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> oder <paramref name="destination" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" />, <paramref name="sourceIndex" /> oder <paramref name="destinationIndex" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> ist größer als oder gleich der Kapazität von <paramref name="source" />. Oder: <paramref name="destinationIndex" /> ist größer oder gleich der Kapazität von <paramref name="destination" />. Oder: Die Anzahl der Bytes in <paramref name="source" />, beginnend bei <paramref name="sourceIndex" />, ist kleiner als <paramref name="count" />. Oder: Durch das Kopieren von <paramref name="count" /> Bytes, beginnend bei <paramref name="destinationIndex" />, wird die Kapazität von <paramref name="destination" /> überschreiten.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetByte">
      <MemberSignature Language="C#" Value="public static byte GetByte (this Windows.Storage.Streams.IBuffer source, uint byteOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 GetByte(class Windows.Storage.Streams.IBuffer source, unsigned int32 byteOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.GetByte(Windows.Storage.Streams.IBuffer,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetByte (source As IBuffer, byteOffset As UInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Byte GetByte(Windows::Storage::Streams::IBuffer ^ source, System::UInt32 byteOffset);" />
      <MemberSignature Language="F#" Value="static member GetByte : Windows.Storage.Streams.IBuffer * uint32 -&gt; byte" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.GetByte (source, byteOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="byteOffset" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, aus dem das Byte abgerufen werden soll.</param>
        <param name="byteOffset">Der Offset des Bytes.</param>
        <summary>Gibt das Byte am angegebenen Offset in der angegebenen Windows.Storage.Streams.IBuffer-Schnittstelle zurück.</summary>
        <returns>Das Byte am angegebenen Offset.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteOffset" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="byteOffset" /> ist größer als oder gleich der Kapazität von <paramref name="source" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetWindowsRuntimeBuffer">
      <MemberSignature Language="C#" Value="public static Windows.Storage.Streams.IBuffer GetWindowsRuntimeBuffer (this System.IO.MemoryStream underlyingStream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Windows.Storage.Streams.IBuffer GetWindowsRuntimeBuffer(class System.IO.MemoryStream underlyingStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.GetWindowsRuntimeBuffer(System.IO.MemoryStream)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetWindowsRuntimeBuffer (underlyingStream As MemoryStream) As IBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Windows::Storage::Streams::IBuffer ^ GetWindowsRuntimeBuffer(System::IO::MemoryStream ^ underlyingStream);" />
      <MemberSignature Language="F#" Value="static member GetWindowsRuntimeBuffer : System.IO.MemoryStream -&gt; Windows.Storage.Streams.IBuffer" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.GetWindowsRuntimeBuffer underlyingStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Windows.Storage.Streams.IBuffer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="underlyingStream" Type="System.IO.MemoryStream" RefType="this" />
      </Parameters>
      <Docs>
        <param name="underlyingStream">Der Stream, der den zusätzlichen Speicher für die IBuffer-Schnittstelle bereitstellt.</param>
        <summary>Gibt eine Windows.Storage.Streams.IBuffer-Schnittstelle zurück, die den gleichen Speicher wie der angegebene Speicherstream darstellt.</summary>
        <returns>Eine Windows.Storage.Streams.IBuffer-Schnittstelle, die durch denselben Speicher wie den des angegebenen Speicherstreams unterstützt wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWindowsRuntimeBuffer">
      <MemberSignature Language="C#" Value="public static Windows.Storage.Streams.IBuffer GetWindowsRuntimeBuffer (this System.IO.MemoryStream underlyingStream, int positionInStream, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Windows.Storage.Streams.IBuffer GetWindowsRuntimeBuffer(class System.IO.MemoryStream underlyingStream, int32 positionInStream, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.GetWindowsRuntimeBuffer(System.IO.MemoryStream,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function GetWindowsRuntimeBuffer (underlyingStream As MemoryStream, positionInStream As Integer, length As Integer) As IBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static Windows::Storage::Streams::IBuffer ^ GetWindowsRuntimeBuffer(System::IO::MemoryStream ^ underlyingStream, int positionInStream, int length);" />
      <MemberSignature Language="F#" Value="static member GetWindowsRuntimeBuffer : System.IO.MemoryStream * int * int -&gt; Windows.Storage.Streams.IBuffer" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.GetWindowsRuntimeBuffer (underlyingStream, positionInStream, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Windows.Storage.Streams.IBuffer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="underlyingStream" Type="System.IO.MemoryStream" RefType="this" />
        <Parameter Name="positionInStream" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="underlyingStream">Der Stream, der gemeinsam mit der IBuffer-Schnittstelle Speicher nutzt.</param>
        <param name="positionInStream">Die Position des freigegebenen Arbeitsspeicherbereichs in <paramref name="underlyingStream" />.</param>
        <param name="length">Die maximale Größe des freigegebenen Arbeitsspeicherbereichs. Wenn die Anzahl der Bytes in <paramref name="underlyingStream" />, beginnend bei <paramref name="positionInStream" />, kleiner als <paramref name="length" /> ist, stellt die zurückgegebene IBuffer-Schnittstelle nur die verfügbaren Bytes dar.</param>
        <summary>Gibt eine Windows.Storage.Streams.IBuffer-Schnittstelle zurück, die den Speicherbereich des angegebenen Speicherstreams darstellt.</summary>
        <returns>Eine Windows.Storage.Streams.IBuffer-Schnittstelle, die durch den Speicherbereich des angegebenen Speicherstreams unterstützt wird.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="underlyingStream" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="positionInStream" /> oder <paramref name="length" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="positionInStream" /> liegt hinter dem Ende von <paramref name="source" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="underlyingStream" /> kann den zugrunde liegenden Arbeitsspeicherpuffer nicht verfügbar machen.</exception>
        <exception cref="T:System.ObjectDisposedException"><paramref name="underlyingStream" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSameData">
      <MemberSignature Language="C#" Value="public static bool IsSameData (this Windows.Storage.Streams.IBuffer buffer, Windows.Storage.Streams.IBuffer otherBuffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSameData(class Windows.Storage.Streams.IBuffer buffer, class Windows.Storage.Streams.IBuffer otherBuffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.IsSameData(Windows.Storage.Streams.IBuffer,Windows.Storage.Streams.IBuffer)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function IsSameData (buffer As IBuffer, otherBuffer As IBuffer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool IsSameData(Windows::Storage::Streams::IBuffer ^ buffer, Windows::Storage::Streams::IBuffer ^ otherBuffer);" />
      <MemberSignature Language="F#" Value="static member IsSameData : Windows.Storage.Streams.IBuffer * Windows.Storage.Streams.IBuffer -&gt; bool" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.IsSameData (buffer, otherBuffer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="otherBuffer" Type="Windows.Storage.Streams.IBuffer" />
      </Parameters>
      <Docs>
        <param name="buffer">Der erste Puffer.</param>
        <param name="otherBuffer">Der zweite Puffer.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei Puffer (Windows.Storage.Streams.IBuffer-Objekte) den gleichen zugrunde liegenden Speicherbereich darstellen.</summary>
        <returns><see langword="true" />, wenn die Arbeitsspeicherbereiche, die durch die zwei Puffer dargestellt werden, denselben Ausgangspunkt besitzen, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public static byte[] ToArray (this Windows.Storage.Streams.IBuffer source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ToArray(class Windows.Storage.Streams.IBuffer source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.ToArray(Windows.Storage.Streams.IBuffer)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToArray (source As IBuffer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static cli::array &lt;System::Byte&gt; ^ ToArray(Windows::Storage::Streams::IBuffer ^ source);" />
      <MemberSignature Language="F#" Value="static member ToArray : Windows.Storage.Streams.IBuffer -&gt; byte[]" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.ToArray source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, dessen Inhalt das neue Array füllt.</param>
        <summary>Gibt ein neues Array zurück, das aus den Inhalten des angegebenen Puffers (Windows.Storage.Streams.IBuffer) erstellt wird. Die Größe des Arrays ist der Wert der Length-Eigenschaft der IBuffer-Schnittstelle.</summary>
        <returns>Ein Bytearray, das die Bytes in der angegebenen IBuffer-Schnittstelle enthält und am Offset 0 (null) beginnt. Dazu zählen Anzahl von Bytes, die gleich dem Wert der Length-Eigenschaft der IBuffer-Schnittstelle sind.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public static byte[] ToArray (this Windows.Storage.Streams.IBuffer source, uint sourceIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ToArray(class Windows.Storage.Streams.IBuffer source, unsigned int32 sourceIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.ToArray(Windows.Storage.Streams.IBuffer,System.UInt32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToArray (source As IBuffer, sourceIndex As UInteger, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static cli::array &lt;System::Byte&gt; ^ ToArray(Windows::Storage::Streams::IBuffer ^ source, System::UInt32 sourceIndex, int count);" />
      <MemberSignature Language="F#" Value="static member ToArray : Windows.Storage.Streams.IBuffer * uint32 * int -&gt; byte[]" Usage="System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeBufferExtensions.ToArray (source, sourceIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.WindowsRuntime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="Windows.Storage.Streams.IBuffer" RefType="this" />
        <Parameter Name="sourceIndex" Type="System.UInt32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">Der Puffer, dessen Inhalt das neue Array füllt.</param>
        <param name="sourceIndex">Der Index in <paramref name="source" />, ab dem Daten kopiert werden sollen.</param>
        <param name="count">Die Anzahl der zu kopierenden Bytes.</param>
        <summary>Gibt ein neues Array zurück, das aus den Inhalten des angegebenen Puffers (Windows.Storage.Streams.IBuffer) erstellt wird und die angegebene Anzahl von Bytes enthält. Der Startindex ist der angegebene Offset.</summary>
        <returns>Ein Bytearray, das den angegebenen Bytebereich enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> ist NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> oder <paramref name="sourceIndex" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> ist größer als oder gleich der Kapazität von <paramref name="source" />. Oder: Die Anzahl der Bytes in <paramref name="source" />, beginnend bei <paramref name="sourceIndex" />, ist kleiner als <paramref name="count" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
