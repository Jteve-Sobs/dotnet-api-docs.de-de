<Type Name="D3DImage" FullName="System.Windows.Interop.D3DImage">
  <Metadata><Meta Name="ms.openlocfilehash" Value="85790e0a264dd21c9244a0d6b89be4b1279e6bcb" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52590415" /></Metadata><TypeSignature Language="C#" Value="public class D3DImage : System.Windows.Media.ImageSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi D3DImage extends System.Windows.Media.ImageSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Interop.D3DImage" />
  <TypeSignature Language="VB.NET" Value="Public Class D3DImage&#xA;Inherits ImageSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class D3DImage : System::Windows::Media::ImageSource" />
  <TypeSignature Language="F#" Value="type D3DImage = class&#xA;    inherit ImageSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.ImageSource</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Eine <see cref="T:System.Windows.Media.ImageSource" />, die eine vom Benutzer erstellte Direct3D-Oberfläche anzeigt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Interop.D3DImage> Klasse, um die Direct3D-Inhalt in einer Windows Presentation Foundation (WPF)-Anwendung zu hosten.  
  
 Rufen Sie die <xref:System.Windows.Interop.D3DImage.Lock%2A> Methode, die Direct3D-Inhalte, die angezeigt werden, indem Sie ändern die <xref:System.Windows.Interop.D3DImage>. Rufen Sie die <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Methode zum Zuweisen einer Direct3D-Oberfläche, eine <xref:System.Windows.Interop.D3DImage>. Rufen Sie die <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> Methode zum Nachverfolgen von Updates an der Direct3D-Oberfläche. Rufen Sie die <xref:System.Windows.Interop.D3DImage.Unlock%2A> Methode, um die geänderten Bereiche anzuzeigen.  
  
 Die <xref:System.Windows.Interop.D3DImage> Klasse verwaltet zwei Anzeigepuffer, die aufgerufen werden, die *Hintergrundpuffer* und *Frontpuffer*. Der Hintergrundpuffer ist Ihrer Direct3D-Oberfläche.  Änderungen an den Hintergrundpuffer werden in den Frontpuffer vorwärts kopiert, beim Aufrufen der <xref:System.Windows.Interop.D3DImage.Unlock%2A> -Methode, in dem sie auf die Hardware angezeigt wird. In einigen Fällen wird der Front-Puffer nicht verfügbar. Diese mangelnde Verfügbarkeit kann durch Bildschirm sperren, Vollbild-exklusive Direct3D-Anwendungen, wechseln von Benutzern oder anderen Systemaktivitäten, die verursacht werden. In diesem Fall wird die WPF-Anwendung benachrichtigt, durch Behandeln der <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Ereignis.  Wie Ihre Anwendung in den Frontpuffer nicht verfügbar reagiert, hängt davon ab, ob WPF aktiviert ist, um auf Softwarerendering zurückzugreifen. Die <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Methode verfügt über eine Überladung, die einen Parameter, der angibt annimmt, ob WPF auf Softwarerendering zurückgegriffen.  
  
## <a name="responding-to-an-unavailable-front-buffer-when-wpf-does-not-fall-back-to-software-rendering"></a>Reagieren auf einen nicht verfügbar-Front-Puffer, wenn WPF nicht zurück auf Software Rendering fällt  
 Beim Aufrufen der <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> überladen, oder rufen Sie die <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> -Überladung mit der `enableSoftwareFallback` Parametersatz zu `false`, das rendernde System gibt seinen Verweis auf den Hintergrundpuffer frei, wenn es sich bei der Front-Puffer mehr verfügbar ist, und "nothing" ist angezeigt. Wenn die Frontpuffer wieder verfügbar ist, löst das Renderingsystem die <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Ereignis, um die WPF-Anwendung zu benachrichtigen.  Sie können angeben, erstellen einen Ereignishandler für die <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Ereignis, um das Rendering erneut mit einer gültigen Direct3D-Oberfläche neu zu starten. Um Rendering neu zu starten, rufen Sie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.  
  
## <a name="responding-to-an-unavailable-front-buffer-when-wpf-falls-back-to-software-rendering"></a>Reagieren auf eine nicht zur Verfügung Frontpuffer, beim WPF greift auf Softwarerendering zurück  
 Beim Aufrufen der <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> -Überladung mit dem `enableSoftwareFallback` Parametersatz zu `true`, das rendernde System behält seinen Verweis auf den Hintergrundpuffer, wird der Front-Puffer nicht verfügbar, daher keine Notwendigkeit zum Aufrufen besteht <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> beim im Vordergrund Puffer ist wieder verfügbar.  Es gibt möglicherweise Situationen, in dem das Gerät des Benutzers nicht mehr verfügbar ist.  In diesem Fall rufen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> WPF Verweis auf den Hintergrundpuffer freigibt.  Wenn Sie Ihr Gerät zurücksetzen möchten, rufen Sie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> mit der `backBuffer` Parametersatz zu `null`, und rufen Sie anschließend <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> mit `backBuffer` legen Sie auf eine gültige Direct3D-Oberfläche.  
  
> [!NOTE]
>  Leistung hängt stark von die Einstellungen der Direct3D-Oberfläche ab. Weitere Informationen finden Sie unter [Leistungsüberlegungen hinsichtlich Direct3D9 und WPF-Interoperabilität](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md).  
  
> [!NOTE]
>  Die <xref:System.Windows.Interop.D3DImage> Klasse zeigt keine Direct3D-Inhalte beim Rendern von WPF in der Software, z. B. über eine Remotedesktopverbindung, es sei denn, Sie rufen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> , und geben Sie `true` für die `enableSoftwareFallback` Parameter.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Deklarieren einer <xref:System.Windows.Interop.D3DImage> in XAML. Müssen Sie eine Zuordnung der <xref:System.Windows.Interop> -Namespace, da es nicht in den Standard-XAML-Namespaces enthalten ist. Weitere Informationen finden Sie unter [Exemplarische Vorgehensweise: Hosten Direct3D9-Inhalt in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-xaml[System.Windows.Interop.D3DImage#10](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml#10)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Interop.D3DImage" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public D3DImage ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; D3DImage();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Interop.D3DImage" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard-Bildschirmauflösung ist 1/96 Zoll.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public D3DImage (double dpiX, double dpiY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 dpiX, float64 dpiY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dpiX As Double, dpiY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; D3DImage(double dpiX, double dpiY);" />
      <MemberSignature Language="F#" Value="new System.Windows.Interop.D3DImage : double * double -&gt; System.Windows.Interop.D3DImage" Usage="new System.Windows.Interop.D3DImage (dpiX, dpiY)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="dpiX" Type="System.Double" />
        <Parameter Name="dpiY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="dpiX">Die Anzeigeauflösung auf der x-Achse.</param>
        <param name="dpiY">Die Anzeigeauflösung auf der y-Achse.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Interop.D3DImage" />-Klasse mit der angegebenen Anzeigeauflösung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard-Bildschirmauflösung ist 1/96 Zoll.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dpiX" /> oder <paramref name="dpiY" /> ist kleiner als 0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Windows.Interop.D3DImage.Height" />
        <altmember cref="P:System.Windows.Interop.D3DImage.Width" />
      </Docs>
    </Member>
    <Member MemberName="AddDirtyRect">
      <MemberSignature Language="C#" Value="public void AddDirtyRect (System.Windows.Int32Rect dirtyRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDirtyRect(valuetype System.Windows.Int32Rect dirtyRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDirtyRect (dirtyRect As Int32Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDirtyRect(System::Windows::Int32Rect dirtyRect);" />
      <MemberSignature Language="F#" Value="member this.AddDirtyRect : System.Windows.Int32Rect -&gt; unit" Usage="d3DImage.AddDirtyRect dirtyRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dirtyRect" Type="System.Windows.Int32Rect" />
      </Parameters>
      <Docs>
        <param name="dirtyRect">Ein <see cref="T:System.Windows.Int32Rect" />, das den geänderten Bereich darstellt.</param>
        <summary>Gibt den Bereich des Hintergrundpuffers an, der geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> Methode, um die Änderungen weisen den Hintergrundpuffer Code vorgenommen hat. Um gerendert werden muss, der geänderte Bereich im Hintergrundpuffer benötigen einen entsprechenden geänderten Bereich für die <xref:System.Windows.Interop.D3DImage>.  
  
 Rufen Sie die <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> und <xref:System.Windows.Interop.D3DImage.Lock%2A> Methoden vor dem Aufruf der <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> Methode.  
  
 Rufen Sie die <xref:System.Windows.Interop.D3DImage.Unlock%2A> Methode, um die geänderten Bereiche in den Front-Puffer zu kopieren.  
  
> [!NOTE]
>  Nach ein paar Aufrufe an die <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> -Methode, die geänderten Bereiche werden in einem einzigen Bereich zusammengeführt. Dies bedeutet, dass Sie gültige Daten außerhalb der geänderten Bereiche verfügen müssen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Aufrufen der <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> Methode, um den geänderten Bereich im Hintergrundpuffer anzugeben. Weitere Informationen finden Sie unter [Exemplarische Vorgehensweise: Hosten Direct3D9-Inhalt in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Bitmap wurde nicht durch einen Aufruf der <see cref="M:System.Windows.Interop.D3DImage.Lock" />-Methode oder der <see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />-Methode gesperrt.  
  
- oder -  
Der Hintergrundpuffer wurde nicht durch einen Aufruf der <see cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />-Methode zugewiesen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Mindestens eine der folgenden Bedingungen ist erfüllt.  
  
 <paramref name="dirtyRect.X" />&lt; 0 
 <paramref name="dirtyRect.Y" />&lt; 0 
 <paramref name="dirtyRect.Width" /> &lt; 0 oder <paramref name="dirtyRect.Width" /> &gt; <see cref="P:System.Windows.Interop.D3DImage.PixelWidth" /><paramref name="dirtyRect.Height" /> &lt; 0 oder <paramref name="dirtyRect.Height" /> &gt; <see cref="P:System.Windows.Interop.D3DImage.PixelHeight" /></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Interop.D3DImage Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Interop.D3DImage Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As D3DImage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Interop::D3DImage ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Interop.D3DImage" Usage="d3DImage.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.D3DImage</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon des <see cref="T:System.Windows.Interop.D3DImage" />-Objekts, indem tiefe Kopien der Werte dieses Objekts erzeugt werden. Beim Kopieren von Abhängigkeitseigenschaften kopiert diese Methode Ressourcenverweise und Datenbindungen (die möglicherweise nicht mehr aufgelöst werden können), jedoch keine Animationen oder deren aktuelle Werte.</summary>
        <returns>Ein änderbarer Klon des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true." /> war.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um änderbare Kopien zu erzeugen fixierten <xref:System.Windows.Freezable> Objekte (oder ein beliebiges <xref:System.Windows.Freezable> Objekt). Der Einfachheit halber führt Shadowing für diese Methode die geerbte Version mit einer Implementierung mit starker Typisierung.  
  
 Weitere Informationen finden Sie unter <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das zu klonende Objekt.</param>
        <summary>Definiert die Instanz als Klon (tiefe Kopie) des angegebenen <see cref="T:System.Windows.Freezable" />-Elements, indem Basiseigenschaftenwerte (nicht animiert) verwendet werden.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Interop.D3DImage CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Interop.D3DImage CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As D3DImage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Interop::D3DImage ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValue : unit -&gt; System.Windows.Interop.D3DImage" Usage="d3DImage.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.D3DImage</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon des <see cref="T:System.Windows.Interop.D3DImage" />-Objekts, indem tiefe Kopien der aktuellen Werte dieses Objekts erzeugt werden. Ressourcenverweise, Datenbindungen und Animationen werden nicht kopiert, ihre aktuellen Werte werden jedoch kopiert.</summary>
        <returns>Ein änderbarer Klon des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true" /> war.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um änderbare Kopien zu erzeugen fixierten <xref:System.Windows.Freezable> Objekte (oder ein beliebiges <xref:System.Windows.Freezable> Objekt). Der Einfachheit halber führt Shadowing für diese Methode die geerbte Version mit einer Implementierung mit starker Typisierung.  
  
 Weitere Informationen finden Sie unter <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Der <see cref="T:System.Windows.Freezable" />, der geklont werden soll.</param>
        <summary>Macht die Instanz mithilfe aktueller Eigenschaftswerte zu einem Klon (tiefe Kopie) des angegebenen <see cref="T:System.Windows.Freezable" />-Elements, der geändert werden kann.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CopyBackBuffer">
      <MemberSignature Language="C#" Value="protected internal virtual System.Windows.Media.Imaging.BitmapSource CopyBackBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.Media.Imaging.BitmapSource CopyBackBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CopyBackBuffer" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CopyBackBuffer () As BitmapSource" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Windows::Media::Imaging::BitmapSource ^ CopyBackBuffer();" />
      <MemberSignature Language="F#" Value="abstract member CopyBackBuffer : unit -&gt; System.Windows.Media.Imaging.BitmapSource&#xA;override this.CopyBackBuffer : unit -&gt; System.Windows.Media.Imaging.BitmapSource" Usage="d3DImage.CopyBackBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Imaging.BitmapSource</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Softwarekopie des <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
        <returns>Eine <see cref="T:System.Windows.Media.Imaging.BitmapSource" />, die eine Softwarekopie des aktuellen Zustands des Hintergrundpuffers darstellt, andernfalls <see langword="null" />, wenn der Hintergrundpuffer nicht gelesen werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> Methode wird von Clients wie z. B. das Drucksystem aufgerufen und die <xref:System.Windows.Media.Imaging.RenderTargetBitmap> Klasse.  
  
 Überschreiben Sie optional die <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> Methode, um benutzerdefinierte Logik zu implementieren und Zurückgeben einer anderen <xref:System.Windows.Media.Imaging.BitmapSource>. Sie können z. B. einen Platzhalter zurückgeben <xref:System.Windows.Media.Imaging.BitmapSource> Wenn standardmäßig <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> Implementierung gibt `null`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Windows.Media.Imaging.BitmapSource" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable&#xA;override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="d3DImage.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt beim Implementieren in einer abgeleiteten Klasse eine neue Instanz der abgeleiteten <see cref="T:System.Windows.Interop.D3DImage" />-Klasse.</summary>
        <returns>Die neue Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Ableitung von der <xref:System.Windows.Interop.D3DImage> -Klasse, die Sie überschreiben müssen die <xref:System.Windows.Interop.D3DImage.CreateInstanceCore%2A> Methode, um die richtige Klonen zu ermöglichen. Die Standardimplementierung nimmt eine `return new D3DImage()`, die werden nicht in der richtigen, wenn die Instanz eine andere Klasse ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~D3DImage ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!D3DImage ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="d3DImage.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt Ressourcen frei und führt andere Bereinigungsvorgänge durch, bevor das <see cref="T:System.Windows.Interop.D3DImage" /> durch die Garbage Collection wieder freigegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Object.Finalize%2A>. Anwendungscode sollte diese Methode nicht aufgerufen. ein Objekt des `Finalize` Methode wird automatisch während der Garbagecollection vom Garbage Collector durch einen Aufruf von Collection aufgerufen wurde hat die <xref:System.GC.SuppressFinalize%2A> Methode.  
  
 Weitere Informationen finden Sie unter [Finalize-Methoden und Destruktoren](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v%3dvs.100)), [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md), und [Überschreiben der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected override sealed bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="override this.FreezeCore : bool -&gt; bool" Usage="d3DImage.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">Hat keine Auswirkungen.</param>
        <summary>Legt das <see cref="T:System.Windows.Interop.D3DImage" /> als nicht änderbar fest oder bestimmt, ob es als nicht änderbar festgelegt werden kann.</summary>
        <returns><see langword="false" /> in allen Fällen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Interop.D3DImage> -Klasse lässt nicht zu fixieren, da Änderungen immer möglich, da Frontpuffer Verfügbarkeit sind.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Die zu kopierende Instanz.</param>
        <summary>Definiert die Instanz als fixierten Klon des angegebenen <see cref="T:System.Windows.Freezable" />-Elements, indem Basiseigenschaftenwerte (nicht animiert) verwendet werden.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das <see cref="T:System.Windows.Freezable" />, das kopiert und fixiert werden soll.</param>
        <summary>Macht diese aktuelle Instanz zu einem fixierten Klon des angegebenen <see cref="T:System.Windows.Freezable" />-Objekts. Wenn das Objekt über animierte Abhängigkeitseigenschaften verfügt, werden die aktuellen animierten Werte kopiert.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public override sealed double Height { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Height" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Height : double" Usage="System.Windows.Interop.D3DImage.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höhe des <see cref="T:System.Windows.Interop.D3DImage" /> ab.</summary>
        <value>Die Höhe des <see cref="T:System.Windows.Interop.D3DImage" /> in Maßeinheiten. Eine Maßeinheit ist 1/96 Zoll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert des <xref:System.Windows.Interop.D3DImage.Height%2A> können ändern, wenn ein neuer Hintergrundpuffer, durch einen Aufruf zugewiesen ist der <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.Width" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailable">
      <MemberSignature Language="C#" Value="public bool IsFrontBufferAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrontBufferAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrontBufferAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrontBufferAvailable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrontBufferAvailable : bool" Usage="System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Frontpuffer vorhanden ist.</summary>
        <value><see langword="true" />, wenn ein Frontpuffer vorhanden ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In einigen Fällen wird der Front-Puffer nicht verfügbar. Diese mangelnde Verfügbarkeit kann durch Bildschirm sperren, Vollbild-exklusive Direct3D-Anwendungen, wechseln von Benutzern oder anderen Systemaktivitäten, die verursacht werden. In diesem Fall wird die WPF-Anwendung benachrichtigt, durch Behandeln der <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Ereignis.  Wie Ihre Anwendung in den Frontpuffer nicht verfügbar reagiert, hängt davon ab, ob WPF aktiviert ist, um auf Softwarerendering zurückzugreifen. Die <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Methode verfügt über eine Überladung, die einen Parameter, der angibt annimmt, ob WPF auf Softwarerendering zurückgegriffen. Weitere Informationen finden Sie unter den Hinweisen in der <xref:System.Windows.Interop.D3DImage> Klasse.  
  
<a name="dependencyPropertyInfo_IsFrontBufferAvailable"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Überprüfen der <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable%2A> Eigenschaft, wenn das kompositionsziel zu rendern. Weitere Informationen finden Sie unter [Exemplarische Vorgehensweise: Hosten Direct3D9-Inhalt in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#2](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
        <altmember cref="E:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsFrontBufferAvailableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsFrontBufferAvailableChanged;" />
      <MemberSignature Language="F#" Value="member this.IsFrontBufferAvailableChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsFrontBufferAvailableChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich die <see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Behandeln der <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> benachrichtigt werden, wenn der Status des Front-Puffers wechselt. Wie Ihre Anwendung in den Frontpuffer nicht verfügbar reagiert, hängt davon ab, ob WPF aktiviert ist, um auf Softwarerendering zurückzugreifen. Die <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Methode verfügt über eine Überladung, die einen Parameter, der angibt annimmt, ob WPF auf Softwarerendering zurückgegriffen. Weitere Informationen finden Sie unter den Hinweisen in der <xref:System.Windows.Interop.D3DImage> Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFrontBufferAvailableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFrontBufferAvailableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFrontBufferAvailableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFrontBufferAvailableProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsFrontBufferAvailableProperty : System.Windows.DependencyProperty" Usage="System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public void Lock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Lock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Lock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Lock();" />
      <MemberSignature Language="F#" Value="member this.Lock : unit -&gt; unit" Usage="d3DImage.Lock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sperrt das <see cref="T:System.Windows.Interop.D3DImage" /> und aktiviert Vorgänge im Hintergrundpuffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Windows.Interop.D3DImage.Lock%2A> Methode so ändern Sie den Hintergrundpuffer durch Aufrufen der <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> und <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Methoden. Während der <xref:System.Windows.Interop.D3DImage> ist gesperrt, Rendern der Anwendung kann auch auf die Direct3D-Oberfläche, die auf den Hintergrundpuffer zugewiesen.  
  
> [!NOTE]
>  Die <xref:System.Windows.Interop.D3DImage.Lock%2A> Methode blockiert, wenn das Renderingsystem den Hintergrundpuffer den Frontpuffer aktualisieren liest. Verwenden der <xref:System.Windows.Interop.D3DImage.TryLock%2A> Methode, um auf unbestimmte Zeit blockieren zu verhindern.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Aufrufen der <xref:System.Windows.Interop.D3DImage.Lock%2A> Methode zum Aktivieren von Updates auf den Hintergrundpuffer. Weitere Informationen finden Sie unter [Exemplarische Vorgehensweise: Hosten Direct3D9-Inhalt in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Sperrenanzahl ist gleich <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altmember cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="Metadata">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.Media.ImageMetadata Metadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageMetadata Metadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Metadata" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Metadata As ImageMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageMetadata ^ Metadata { System::Windows::Media::ImageMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Metadata : System.Windows.Media.ImageMetadata" Usage="System.Windows.Interop.D3DImage.Metadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Metadaten ab, die der Bildquelle zugeordnet sind.</summary>
        <value><see langword="null" /> in allen Fällen.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PixelHeight">
      <MemberSignature Language="C#" Value="public int PixelHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PixelHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.PixelHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PixelHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PixelHeight { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PixelHeight : int" Usage="System.Windows.Interop.D3DImage.PixelHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höhe des <see cref="T:System.Windows.Interop.D3DImage" /> in Pixel ab.</summary>
        <value>Die Höhe des <see cref="T:System.Windows.Interop.D3DImage" /> in Pixel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert des <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> können ändern, wenn ein neuer Hintergrundpuffer, durch einen Aufruf zugewiesen ist der <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> Eigenschaft, um den geänderten Bereich im Hintergrundpuffer anzugeben. Weitere Informationen finden Sie unter [Exemplarische Vorgehensweise: Hosten Direct3D9-Inhalt in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.PixelWidth" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="PixelWidth">
      <MemberSignature Language="C#" Value="public int PixelWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PixelWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.PixelWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PixelWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PixelWidth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PixelWidth : int" Usage="System.Windows.Interop.D3DImage.PixelWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Breite des <see cref="T:System.Windows.Interop.D3DImage" /> in Pixel ab.</summary>
        <value>Die Breite des <see cref="T:System.Windows.Interop.D3DImage" /> in Pixel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert des <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> können ändern, wenn ein neuer Hintergrundpuffer, durch einen Aufruf zugewiesen ist der <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> Eigenschaft, um den geänderten Bereich im Hintergrundpuffer anzugeben. Weitere Informationen finden Sie unter [Exemplarische Vorgehensweise: Hosten Direct3D9-Inhalt in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.PixelHeight" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBackBuffer">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Weist eine Direct3D-Oberfläche als Quelle des Hintergrundpuffers zu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBackBuffer">
      <MemberSignature Language="C#" Value="public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBackBuffer(valuetype System.Windows.Interop.D3DResourceType backBufferType, native int backBuffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBackBuffer (backBufferType As D3DResourceType, backBuffer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBackBuffer(System::Windows::Interop::D3DResourceType backBufferType, IntPtr backBuffer);" />
      <MemberSignature Language="F#" Value="member this.SetBackBuffer : System.Windows.Interop.D3DResourceType * nativeint -&gt; unit" Usage="d3DImage.SetBackBuffer (backBufferType, backBuffer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backBufferType" Type="System.Windows.Interop.D3DResourceType" />
        <Parameter Name="backBuffer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="backBufferType">Der Typ der Direct3D-Oberfläche. Muss ein gültiger <see cref="T:System.Windows.Interop.D3DResourceType" /> sein.</param>
        <param name="backBuffer">Die Direct3D-Oberfläche, die als Hintergrundpuffer zugewiesen werden soll.</param>
        <summary>Weist eine Direct3D-Oberfläche als Quelle des Hintergrundpuffers zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Methode zum Zuweisen einer Direct3D-Oberfläche auf den Hintergrundpuffer.  
  
> [!NOTE]
>  Leistung hängt stark von die Einstellungen der Direct3D-Oberfläche ab. Weitere Informationen finden Sie unter [Leistungsüberlegungen hinsichtlich Direct3D9 und WPF-Interoperabilität](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md).  
  
 Aufrufen der <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> Überladung entspricht dem Aufrufen der <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> -Überladung mit dem `enableSoftwareFallback` Parametersatz zu `false`. Beim Aufruf <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> oder rufen Sie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> mit der `enableSoftwareFallback` Parametersatz zu `false`, das rendernde System gibt seinen Verweis auf den Hintergrundpuffer frei, wenn Frontpuffer nicht verfügbar ist mehr und es wird nichts angezeigt. Wenn die Frontpuffer wieder verfügbar ist, löst das Renderingsystem die <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Ereignis, um die WPF-Anwendung zu benachrichtigen.  Sie können angeben, erstellen einen Ereignishandler für die <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Ereignis, um das Rendering erneut mit einer gültigen Direct3D-Oberfläche neu zu starten. Um Rendering neu zu starten, rufen Sie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.  
  
 Die folgende Liste enthält die erforderlichen Hintergrundpuffer-Einstellungen für die `IDirect3DSurface9` Typ.  
  
-   `D3DFMT_A8R8G8B8` oder `D3DFMT_X8R8G8B8`  
  
-   `D3DUSAGE_RENDERTARGET`  
  
-   `D3DPOOL_DEFAULT`  
  
 Multisampling kann auf `IDirect3DSurface9Ex` deckt nur.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Aufrufen der <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Methode zum Zuweisen einer Direct3D-Oberfläche. Weitere Informationen finden Sie unter [Exemplarische Vorgehensweise: Hosten Direct3D9-Inhalt in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das <see cref="T:System.Windows.Interop.D3DImage" /> wurde nicht durch einen Aufruf der <see cref="M:System.Windows.Interop.D3DImage.Lock" />-Methode oder der <see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />-Methode gesperrt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="backBufferType" /> ist kein gültiger <see cref="T:System.Windows.Interop.D3DResourceType" />.</exception>
        <exception cref="T:System.ArgumentException">Die Erstellungsparameter für <paramref name="backBuffer" /> erfüllen nicht die Anforderungen für <paramref name="backBufferType" /> oder die <paramref name="backBuffer" />-Einheit ist ungültig.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="SetBackBuffer">
      <MemberSignature Language="C#" Value="public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBackBuffer(valuetype System.Windows.Interop.D3DResourceType backBufferType, native int backBuffer, bool enableSoftwareFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBackBuffer (backBufferType As D3DResourceType, backBuffer As IntPtr, enableSoftwareFallback As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBackBuffer(System::Windows::Interop::D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);" />
      <MemberSignature Language="F#" Value="member this.SetBackBuffer : System.Windows.Interop.D3DResourceType * nativeint * bool -&gt; unit" Usage="d3DImage.SetBackBuffer (backBufferType, backBuffer, enableSoftwareFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backBufferType" Type="System.Windows.Interop.D3DResourceType" />
        <Parameter Name="backBuffer" Type="System.IntPtr" />
        <Parameter Name="enableSoftwareFallback" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="backBufferType">Der Typ der Direct3D-Oberfläche. Muss ein gültiger <see cref="T:System.Windows.Interop.D3DResourceType" /> sein.</param>
        <param name="backBuffer">Die Direct3D-Oberfläche, die als Hintergrundpuffer zugewiesen werden soll.</param>
        <param name="enableSoftwareFallback"><see langword="true" />, um auf Softwarerendering zurückzugreifen; andernfalls <see langword="false" />.</param>
        <summary>Weist eine Direct3D-Oberfläche als Quelle des Hintergrundpuffers zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen der <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> überladen, oder rufen Sie die <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> -Überladung mit der `enableSoftwareFallback` Parametersatz zu `false`, das rendernde System gibt seinen Verweis auf den Hintergrundpuffer frei, wenn es sich bei der Front-Puffer mehr verfügbar ist, und "nothing" ist angezeigt. Wenn die Frontpuffer wieder verfügbar ist, löst das Renderingsystem die <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Ereignis, um die WPF-Anwendung zu benachrichtigen.  Sie können angeben, erstellen einen Ereignishandler für die <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Ereignis, um das Rendering erneut mit einer gültigen Direct3D-Oberfläche neu zu starten. Um Rendering neu zu starten, rufen Sie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.  
  
 Beim Aufruf <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> mit der `enableSoftwareFallback` Parametersatz zu `true`, der Renderingsystem behält seinen Verweis auf den Hintergrundpuffer, wird der Front-Puffer nicht verfügbar, daher keine Notwendigkeit zum Aufrufen besteht <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> bei der Front-Puffer ist Verfügbare erneut aus.  Es gibt möglicherweise Situationen, in dem das Gerät des Benutzers nicht mehr verfügbar ist.  In diesem Fall rufen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> WPF Verweis auf den Hintergrundpuffer freigibt.  Wenn Sie Ihr Gerät zurücksetzen möchten, rufen Sie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> mit `backBuffer` festgelegt `null`, und rufen Sie anschließend <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> mit `backBuffer` legen Sie auf eine gültige Direct3D-Oberfläche.  
  
 Die folgende Liste enthält die erforderlichen Hintergrundpuffer-Einstellungen für die `IDirect3DSurface9` Typ.  
  
-   `D3DFMT_A8R8G8B8` oder `D3DFMT_X8R8G8B8`  
  
-   `D3DUSAGE_RENDERTARGET`  
  
-   `D3DPOOL_DEFAULT`  
  
 Multisampling kann auf `IDirect3DSurface9Ex` deckt nur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryLock">
      <MemberSignature Language="C#" Value="public bool TryLock (System.Windows.Duration timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryLock(valuetype System.Windows.Duration timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryLock (timeout As Duration) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryLock(System::Windows::Duration timeout);" />
      <MemberSignature Language="F#" Value="member this.TryLock : System.Windows.Duration -&gt; bool" Usage="d3DImage.TryLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Windows.Duration" />
      </Parameters>
      <Docs>
        <param name="timeout">Der Zeitraum, über den auf den Erhalt der Sperre gewartet werden soll.</param>
        <summary>Versucht, das <see cref="T:System.Windows.Interop.D3DImage" /> zu sperren, und wartet den angegebenen Zeitraum ab.</summary>
        <returns><see langword="true" />, wenn die Sperre erhalten wurde, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Für <paramref name="timeout" /> ist <see cref="P:System.Windows.Duration.Automatic" /> festgelegt.</exception>
        <exception cref="T:System.InvalidOperationException">Die Sperrenanzahl ist gleich <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public void Unlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Unlock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unlock();" />
      <MemberSignature Language="F#" Value="member this.Unlock : unit -&gt; unit" Usage="d3DImage.Unlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verringert die Sperrenanzahl für das <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Sperrenanzahl für die <xref:System.Windows.Interop.D3DImage> NULL ist, erreicht der <xref:System.Windows.Interop.D3DImage> vollständig aufgehoben wird. Die <xref:System.Windows.Interop.D3DImage> wird markiert, für das Rendern, wenn das Bild Bereiche geändert hat, die von früheren aufrufen angegeben wurden die <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> Methode.  
  
 Wenn die Änderungen und gerendert, zusätzlichen Aufrufe an die <xref:System.Windows.Interop.D3DImage.Lock%2A> Methodenblock, bis der Renderthread den Inhalt des Hintergrundpuffers auf den Front-Puffer kopiert wurde. Diese Synchronisierung wird vermieden, Display-Elemente, z. B. liegen.  
  
> [!NOTE]
>  Aktualisieren die Direct3D-Oberfläche und nicht die <xref:System.Windows.Interop.D3DImage> wird entsperrt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Aufrufen der <xref:System.Windows.Interop.D3DImage.Unlock%2A> Methode, um den aktualisierten Hintergrundpuffer auf den Front-Puffer zu kopieren. Weitere Informationen finden Sie unter [Exemplarische Vorgehensweise: Hosten Direct3D9-Inhalt in WPF](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md).  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public override sealed double Width { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Width" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Width : double" Usage="System.Windows.Interop.D3DImage.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Breite des <see cref="T:System.Windows.Interop.D3DImage" /> ab.</summary>
        <value>Die Breite des <see cref="T:System.Windows.Interop.D3DImage" /> in Maßeinheiten. Eine Maßeinheit ist 1/96 Zoll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert des <xref:System.Windows.Interop.D3DImage.Width%2A> können ändern, wenn ein neuer Hintergrundpuffer, durch einen Aufruf zugewiesen ist der <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.Height" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
  </Members>
</Type>