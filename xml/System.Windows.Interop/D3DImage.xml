<Type Name="D3DImage" FullName="System.Windows.Interop.D3DImage">
  <Metadata><Meta Name="ms.openlocfilehash" Value="74028c4001ad887f58c00e47ec85b65a2cbfb8d3" /><Meta Name="ms.sourcegitcommit" Value="9506e50ec7beb4fa30206b9840dc546b035a6600" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/23/2020" /><Meta Name="ms.locfileid" Value="86991470" /></Metadata><TypeSignature Language="C#" Value="public class D3DImage : System.Windows.Media.ImageSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit D3DImage extends System.Windows.Media.ImageSource" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Interop.D3DImage" />
  <TypeSignature Language="VB.NET" Value="Public Class D3DImage&#xA;Inherits ImageSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class D3DImage : System::Windows::Media::ImageSource" />
  <TypeSignature Language="F#" Value="type D3DImage = class&#xA;    inherit ImageSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi D3DImage extends System.Windows.Media.ImageSource" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.ImageSource</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="19be9-101">Eine <see cref="T:System.Windows.Media.ImageSource" />, die eine vom Benutzer erstellte Direct3D-Oberfläche anzeigt.</span><span class="sxs-lookup"><span data-stu-id="19be9-101">An <see cref="T:System.Windows.Media.ImageSource" /> that displays a user-created Direct3D surface.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19be9-102">Verwenden Sie die- <xref:System.Windows.Interop.D3DImage> Klasse, um Direct3D-Inhalt in einer Windows Presentation Foundation (WPF)-Anwendung zu hosten.</span><span class="sxs-lookup"><span data-stu-id="19be9-102">Use the <xref:System.Windows.Interop.D3DImage> class to host Direct3D content in a Windows Presentation Foundation (WPF) application.</span></span>  
  
 <span data-ttu-id="19be9-103">Ruft die- <xref:System.Windows.Interop.D3DImage.Lock%2A> Methode auf, um den von angezeigten Direct3D-Inhalt zu ändern <xref:System.Windows.Interop.D3DImage> .</span><span class="sxs-lookup"><span data-stu-id="19be9-103">Call the <xref:System.Windows.Interop.D3DImage.Lock%2A> method to change the Direct3D content displayed by the <xref:System.Windows.Interop.D3DImage>.</span></span> <span data-ttu-id="19be9-104">Ruft die- <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Methode auf, um einer Direct3D-Oberfläche zuzuweisen <xref:System.Windows.Interop.D3DImage> .</span><span class="sxs-lookup"><span data-stu-id="19be9-104">Call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method to assign a Direct3D surface to a <xref:System.Windows.Interop.D3DImage>.</span></span> <span data-ttu-id="19be9-105">Ruft die- <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> Methode auf, um Aktualisierungen der Direct3D-Oberfläche zu verfolgen.</span><span class="sxs-lookup"><span data-stu-id="19be9-105">Call the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method to track updates to the Direct3D surface.</span></span> <span data-ttu-id="19be9-106">Aufrufen der- <xref:System.Windows.Interop.D3DImage.Unlock%2A> Methode, um die geänderten Bereiche anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="19be9-106">Call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method to display the changed areas.</span></span>  
  
 <span data-ttu-id="19be9-107">Die <xref:System.Windows.Interop.D3DImage> -Klasse verwaltet zwei Anzeige Puffer, die als *Hintergrund Puffer* und Vordergrund *Puffer*bezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="19be9-107">The <xref:System.Windows.Interop.D3DImage> class manages two display buffers, which are called the *back buffer* and the *front buffer*.</span></span> <span data-ttu-id="19be9-108">Der Hintergrund Puffer ist die Direct3D-Oberfläche.</span><span class="sxs-lookup"><span data-stu-id="19be9-108">The back buffer is your Direct3D surface.</span></span>  <span data-ttu-id="19be9-109">Änderungen am Hintergrund Puffer werden in den Vordergrund Puffer kopiert, wenn Sie die- <xref:System.Windows.Interop.D3DImage.Unlock%2A> Methode aufzurufen, wo Sie auf der Hardware angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="19be9-109">Changes to the back buffer are copied forward to the front buffer when you call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method, where it is displayed on the hardware.</span></span> <span data-ttu-id="19be9-110">Gelegentlich ist der Vorder-Puffer nicht mehr verfügbar.</span><span class="sxs-lookup"><span data-stu-id="19be9-110">Occasionally, the front buffer becomes unavailable.</span></span> <span data-ttu-id="19be9-111">Diese fehlende Verfügbarkeit kann durch eine Bildschirmsperre, voll Bild exklusive Direct3D Anwendungen, Benutzerwechsel oder andere Systemaktivitäten verursacht werden.</span><span class="sxs-lookup"><span data-stu-id="19be9-111">This lack of availability can be caused by screen locking, full-screen exclusive Direct3D applications, user-switching, or other system activities.</span></span> <span data-ttu-id="19be9-112">In diesem Fall wird die WPF-Anwendung durch Behandeln des- <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Ereignisses benachrichtigt.</span><span class="sxs-lookup"><span data-stu-id="19be9-112">When this occurs, your WPF application is notified by handling the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event.</span></span>  <span data-ttu-id="19be9-113">Wie die Anwendung auf den Vordergrund Puffer reagiert, hängt davon ab, ob WPF auf das Software Rendering zurückgreifen kann.</span><span class="sxs-lookup"><span data-stu-id="19be9-113">How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering.</span></span> <span data-ttu-id="19be9-114">Die- <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Methode verfügt über eine-Überladung, die einen-Parameter annimmt, der angibt, ob WPF auf Software Rendering zurückgreift.</span><span class="sxs-lookup"><span data-stu-id="19be9-114">The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering.</span></span>  
  
## <a name="responding-to-an-unavailable-front-buffer-when-wpf-does-not-fall-back-to-software-rendering"></a><span data-ttu-id="19be9-115">Reagieren auf einen nicht verfügbaren Front-Puffer, wenn WPF nicht auf Software Rendering zurückgreift</span><span class="sxs-lookup"><span data-stu-id="19be9-115">Responding to an Unavailable Front Buffer when WPF Does not Fall Back to Software Rendering</span></span>  
 <span data-ttu-id="19be9-116">Wenn Sie die-Überladung aufrufen oder die-Überladung <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> aufrufen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> , wobei der- `enableSoftwareFallback` Parameter auf festgelegt `false` ist, gibt das Renderingsystem seinen Verweis auf den Hintergrund Puffer frei, wenn der Vorder-Puffer nicht mehr verfügbar und keine</span><span class="sxs-lookup"><span data-stu-id="19be9-116">When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload or call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `false`, the rendering system releases its reference to the back buffer when the front buffer becomes unavailable and nothing is displayed.</span></span> <span data-ttu-id="19be9-117">Wenn der Front-Puffer wieder verfügbar ist, löst das Renderingsystem das-Ereignis aus, <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> um die WPF-Anwendung zu benachrichtigen.</span><span class="sxs-lookup"><span data-stu-id="19be9-117">When the front buffer is available again, the rendering system raises the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to notify your WPF application.</span></span>  <span data-ttu-id="19be9-118">Sie können einen Ereignishandler für das- <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Ereignis erstellen, um das Rendering erneut mit einer gültigen Direct3D-Oberfläche zu starten.</span><span class="sxs-lookup"><span data-stu-id="19be9-118">You can create an event handler for the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to restart rendering again with a valid Direct3D surface.</span></span> <span data-ttu-id="19be9-119">Um das Rendering neu zu starten, müssen Sie aufzurufen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> .</span><span class="sxs-lookup"><span data-stu-id="19be9-119">To restart rendering, you must call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.</span></span>  
  
## <a name="responding-to-an-unavailable-front-buffer-when-wpf-falls-back-to-software-rendering"></a><span data-ttu-id="19be9-120">Reagieren auf einen nicht verfügbaren Front-Puffer, wenn WPF auf Software Rendering zurückgreift</span><span class="sxs-lookup"><span data-stu-id="19be9-120">Responding to an Unavailable Front Buffer when WPF Falls Back to Software Rendering</span></span>  
 <span data-ttu-id="19be9-121">Wenn Sie die- <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> Überladung mit dem `enableSoftwareFallback` auf festgelegten-Parameter aufrufen `true` , behält das Renderingsystem seinen Verweis auf den Hintergrund Puffer bei, wenn der Vorder-Puffer nicht mehr verfügbar ist. Daher muss nicht aufgerufen werden, <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Wenn der Vorder-Puffer wieder verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="19be9-121">When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `true`, the rendering system retains its reference to the back buffer when the front buffer becomes unavailable, so there is no need to call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> when the front buffer is available again.</span></span>  <span data-ttu-id="19be9-122">Es kann Situationen geben, in denen das Gerät des Benutzers nicht mehr verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="19be9-122">There may be situations where the user's device becomes unavailable.</span></span>  <span data-ttu-id="19be9-123">Wenn dies auftritt, wird aufgerufen, <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> um den WPF-Verweis auf den Hintergrund Puffer freizugeben.</span><span class="sxs-lookup"><span data-stu-id="19be9-123">When that occurs, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> to release WPF's reference to the back buffer.</span></span>  <span data-ttu-id="19be9-124">Wenn Sie Ihr Gerät zurücksetzen müssen, müssen Sie aufrufen, <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> wobei der `backBuffer` -Parameter auf festgelegt `null` ist, und dann erneut aufrufen, <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> wobei `backBuffer` auf eine gültige Direct3D-Oberfläche festgelegt</span><span class="sxs-lookup"><span data-stu-id="19be9-124">If you need to reset your device, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> with the `backBuffer` parameter set to `null`, and then call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> again with `backBuffer` set to a valid Direct3D surface.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="19be9-125">Die Leistung hängt stark von den Einstellungen der Direct3D-Oberfläche ab.</span><span class="sxs-lookup"><span data-stu-id="19be9-125">Performance depends greatly on the settings of the Direct3D surface.</span></span> <span data-ttu-id="19be9-126">Weitere Informationen finden Sie unter [Überlegungen zur Leistung bei der von Direct3D9-und WPF-Interoperabilität](/dotnet/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability).</span><span class="sxs-lookup"><span data-stu-id="19be9-126">For more information, see [Performance Considerations for Direct3D9 and WPF Interoperability](/dotnet/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="19be9-127">Die <xref:System.Windows.Interop.D3DImage> Klasse zeigt Direct3D-Inhalt nicht an, wenn WPF in Software gerendert wird, z. b. über eine Remotedesktop Verbindung, es sei denn, Sie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> geben an und geben `true` für den `enableSoftwareFallback` Parameter</span><span class="sxs-lookup"><span data-stu-id="19be9-127">The <xref:System.Windows.Interop.D3DImage> class does not display Direct3D content when WPF renders in software, such as over a Remote Desktop connection, unless you call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> and specify `true` for the `enableSoftwareFallback` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="19be9-128">Im folgenden Codebeispiel wird gezeigt, wie ein <xref:System.Windows.Interop.D3DImage> in XAML deklariert wird.</span><span class="sxs-lookup"><span data-stu-id="19be9-128">The following code example shows how to declare a <xref:System.Windows.Interop.D3DImage> in XAML.</span></span> <span data-ttu-id="19be9-129">Sie müssen den <xref:System.Windows.Interop> Namespace zuordnen, da er nicht in den XAML-Standard Namespaces enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="19be9-129">You must map the <xref:System.Windows.Interop> namespace, because it is not included in the default XAML namespaces.</span></span> <span data-ttu-id="19be9-130">Weitere Informationen finden Sie unter Exemplarische Vorgehensweise [: Hosting von Direct3D9 Content in WPF](/dotnet/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf).</span><span class="sxs-lookup"><span data-stu-id="19be9-130">For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](/dotnet/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf).</span></span>  
  
 [!code-xaml[System.Windows.Interop.D3DImage#10](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml#10)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="19be9-131">Initialisiert eine neue Instanz der <see cref="T:System.Windows.Interop.D3DImage" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="19be9-131">Initializes a new instance of the <see cref="T:System.Windows.Interop.D3DImage" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public D3DImage ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; D3DImage();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="19be9-132">Initialisiert eine neue Instanz der <see cref="T:System.Windows.Interop.D3DImage" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="19be9-132">Initializes a new instance of the <see cref="T:System.Windows.Interop.D3DImage" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19be9-133">Die Standard Bildschirmauflösung ist 1/96 Zoll.</span><span class="sxs-lookup"><span data-stu-id="19be9-133">The default display resolution is 1/96th inch.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public D3DImage (double dpiX, double dpiY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 dpiX, float64 dpiY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dpiX As Double, dpiY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; D3DImage(double dpiX, double dpiY);" />
      <MemberSignature Language="F#" Value="new System.Windows.Interop.D3DImage : double * double -&gt; System.Windows.Interop.D3DImage" Usage="new System.Windows.Interop.D3DImage (dpiX, dpiY)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="dpiX" Type="System.Double" />
        <Parameter Name="dpiY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="dpiX"><span data-ttu-id="19be9-134">Die Anzeigeauflösung auf der x-Achse.</span><span class="sxs-lookup"><span data-stu-id="19be9-134">The display resolution on the x-axis.</span></span></param>
        <param name="dpiY"><span data-ttu-id="19be9-135">Die Anzeigeauflösung auf der y-Achse.</span><span class="sxs-lookup"><span data-stu-id="19be9-135">The display resolution on the y-axis.</span></span></param>
        <summary><span data-ttu-id="19be9-136">Initialisiert eine neue Instanz der <see cref="T:System.Windows.Interop.D3DImage" />-Klasse mit der angegebenen Anzeigeauflösung.</span><span class="sxs-lookup"><span data-stu-id="19be9-136">Initializes a new instance of the <see cref="T:System.Windows.Interop.D3DImage" /> class with the specified display resolution.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19be9-137">Die Standard Bildschirmauflösung ist 1/96 Zoll.</span><span class="sxs-lookup"><span data-stu-id="19be9-137">The default display resolution is 1/96th inch.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="19be9-138"><paramref name="dpiX" /> oder <paramref name="dpiY" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="19be9-138"><paramref name="dpiX" /> or <paramref name="dpiY" /> is less than zero.</span></span></exception>
        <altmember cref="P:System.Windows.Interop.D3DImage.Height" />
        <altmember cref="P:System.Windows.Interop.D3DImage.Width" />
      </Docs>
    </Member>
    <Member MemberName="AddDirtyRect">
      <MemberSignature Language="C#" Value="public void AddDirtyRect (System.Windows.Int32Rect dirtyRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDirtyRect(valuetype System.Windows.Int32Rect dirtyRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDirtyRect (dirtyRect As Int32Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDirtyRect(System::Windows::Int32Rect dirtyRect);" />
      <MemberSignature Language="F#" Value="member this.AddDirtyRect : System.Windows.Int32Rect -&gt; unit" Usage="d3DImage.AddDirtyRect dirtyRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dirtyRect" Type="System.Windows.Int32Rect" />
      </Parameters>
      <Docs>
        <param name="dirtyRect"><span data-ttu-id="19be9-139">Ein <see cref="T:System.Windows.Int32Rect" />, das den geänderten Bereich darstellt.</span><span class="sxs-lookup"><span data-stu-id="19be9-139">An <see cref="T:System.Windows.Int32Rect" /> that represents the area that changed.</span></span></param>
        <summary><span data-ttu-id="19be9-140">Gibt den Bereich des Hintergrundpuffers an, der geändert wurde.</span><span class="sxs-lookup"><span data-stu-id="19be9-140">Specifies the area of the back buffer that changed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19be9-141">Ruft die- <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> Methode auf, um Änderungen anzugeben, die Ihr Code an den Hintergrund Puffer vorgenommen hat.</span><span class="sxs-lookup"><span data-stu-id="19be9-141">Call the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method to indicate changes your code has made to the back buffer.</span></span> <span data-ttu-id="19be9-142">Um gerendert zu werden, muss der geänderte Bereich auf dem Hintergrund Puffer über einen entsprechenden geänderten Bereich im verfügen <xref:System.Windows.Interop.D3DImage> .</span><span class="sxs-lookup"><span data-stu-id="19be9-142">To be rendered, the changed area on the back buffer must have a corresponding changed area on the <xref:System.Windows.Interop.D3DImage>.</span></span>  
  
 <span data-ttu-id="19be9-143">Rufen Sie die <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> -Methode und die-Methode auf, <xref:System.Windows.Interop.D3DImage.Lock%2A> bevor Sie die <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A></span><span class="sxs-lookup"><span data-stu-id="19be9-143">Call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> and <xref:System.Windows.Interop.D3DImage.Lock%2A> methods before calling the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method.</span></span>  
  
 <span data-ttu-id="19be9-144">Ruft die- <xref:System.Windows.Interop.D3DImage.Unlock%2A> Methode auf, um die geänderten Bereiche in den Vorder-Puffer zu kopieren.</span><span class="sxs-lookup"><span data-stu-id="19be9-144">Call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method to copy the changed areas to the front buffer.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="19be9-145">Nach einigen wenigen Aufrufen der- <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> Methode werden die geänderten Bereiche in einem einzelnen Bereich zusammengeführt.</span><span class="sxs-lookup"><span data-stu-id="19be9-145">After a few calls to the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method, the changed areas are merged into a single area.</span></span> <span data-ttu-id="19be9-146">Dies bedeutet, dass Sie über gültige Daten außerhalb der geänderten Bereiche verfügen müssen.</span><span class="sxs-lookup"><span data-stu-id="19be9-146">This means you must have valid data outside of the changed areas.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="19be9-147">Im folgenden Codebeispiel wird gezeigt, wie die-Methode aufgerufen wird <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> , um den geänderten Bereich im Hintergrund Puffer anzugeben.</span><span class="sxs-lookup"><span data-stu-id="19be9-147">The following code example shows how to call the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method to specify the changed region in the back buffer.</span></span> <span data-ttu-id="19be9-148">Weitere Informationen finden Sie unter Exemplarische Vorgehensweise [: Hosting von Direct3D9 Content in WPF](/dotnet/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf).</span><span class="sxs-lookup"><span data-stu-id="19be9-148">For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](/dotnet/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf).</span></span>  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="19be9-149">Die Bitmap wurde nicht durch einen Aufruf der <see cref="M:System.Windows.Interop.D3DImage.Lock" />-Methode oder der <see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />-Methode gesperrt.</span><span class="sxs-lookup"><span data-stu-id="19be9-149">The bitmap has not been locked by a call to the <see cref="M:System.Windows.Interop.D3DImage.Lock" /> or <see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" /> methods.</span></span>  
  
<span data-ttu-id="19be9-150">- oder -</span><span class="sxs-lookup"><span data-stu-id="19be9-150">-or-</span></span> 
<span data-ttu-id="19be9-151">Der Hintergrundpuffer wurde nicht durch einen Aufruf der <see cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />-Methode zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="19be9-151">The back buffer has not been assigned by a call to the <see cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="19be9-152">Mindestens eine der folgenden Bedingungen ist erfüllt.</span><span class="sxs-lookup"><span data-stu-id="19be9-152">One or more of the following conditions is true.</span></span>  
  
 <span data-ttu-id="19be9-153"><paramref name="dirtyRect.X" />&lt;0</span><span class="sxs-lookup"><span data-stu-id="19be9-153"><paramref name="dirtyRect.X" /> &lt; 0</span></span> 
 <span data-ttu-id="19be9-154"><paramref name="dirtyRect.Y" />&lt;0</span><span class="sxs-lookup"><span data-stu-id="19be9-154"><paramref name="dirtyRect.Y" /> &lt; 0</span></span> 
 <span data-ttu-id="19be9-155"><paramref name="dirtyRect.Width" />&lt;0 oder <paramref name="dirtyRect.Width" /> &gt; <see cref="P:System.Windows.Interop.D3DImage.PixelWidth" /><paramref name="dirtyRect.Height" /> &lt; 0 oder <paramref name="dirtyRect.Height" /> &gt;<see cref="P:System.Windows.Interop.D3DImage.PixelHeight" /></span><span class="sxs-lookup"><span data-stu-id="19be9-155"><paramref name="dirtyRect.Width" /> &lt; 0 or <paramref name="dirtyRect.Width" /> &gt; <see cref="P:System.Windows.Interop.D3DImage.PixelWidth" /><paramref name="dirtyRect.Height" /> &lt; 0 or <paramref name="dirtyRect.Height" /> &gt; <see cref="P:System.Windows.Interop.D3DImage.PixelHeight" /></span></span></exception>
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Interop.D3DImage Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Interop.D3DImage Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As D3DImage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Interop::D3DImage ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Interop.D3DImage" Usage="d3DImage.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.D3DImage</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="19be9-156">Erstellt einen änderbaren Klon des <see cref="T:System.Windows.Interop.D3DImage" />-Objekts, indem tiefe Kopien der Werte dieses Objekts erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="19be9-156">Creates a modifiable clone of this <see cref="T:System.Windows.Interop.D3DImage" /> object, making deep copies of this object's values.</span></span> <span data-ttu-id="19be9-157">Beim Kopieren von Abhängigkeitseigenschaften kopiert diese Methode Ressourcenverweise und Datenbindungen (die möglicherweise nicht mehr aufgelöst werden können), jedoch keine Animationen oder deren aktuelle Werte.</span><span class="sxs-lookup"><span data-stu-id="19be9-157">When copying dependency properties, this method copies resource references and data bindings (which may no longer resolve), but not animations or their current values.</span></span></summary>
        <returns><span data-ttu-id="19be9-158">Ein änderbarer Klon des aktuellen Objekts.</span><span class="sxs-lookup"><span data-stu-id="19be9-158">A modifiable clone of the current object.</span></span> <span data-ttu-id="19be9-159">Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true" /> war.</span><span class="sxs-lookup"><span data-stu-id="19be9-159">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property will be <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property was <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19be9-160">Diese Methode wird verwendet, um änderbare Kopien von fixierten <xref:System.Windows.Freezable> Objekten (oder einem beliebigen <xref:System.Windows.Freezable> Objekt) zu liefern.</span><span class="sxs-lookup"><span data-stu-id="19be9-160">This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object).</span></span> <span data-ttu-id="19be9-161">Aus Gründen der praktische überschattet diese Methode die geerbte Version durch eine stark typisierte Implementierung.</span><span class="sxs-lookup"><span data-stu-id="19be9-161">For convenience, this method shadows the inherited version with a strongly typed implementation.</span></span>  
  
 <span data-ttu-id="19be9-162">Weitere Informationen finden Sie unter <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="19be9-162">For more information, see <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.CloneCore sourceFreezable" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="F#" Value="override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.CloneCore sourceFreezable" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><span data-ttu-id="19be9-163">Das zu klonende Objekt.</span><span class="sxs-lookup"><span data-stu-id="19be9-163">The object to clone.</span></span></param>
        <summary><span data-ttu-id="19be9-164">Definiert die Instanz als Klon (tiefe Kopie) des angegebenen <see cref="T:System.Windows.Freezable" />-Elements, indem Basiseigenschaftenwerte (nicht animiert) verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="19be9-164">Makes the instance a clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span></span></summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Interop.D3DImage CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Interop.D3DImage CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As D3DImage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Interop::D3DImage ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValue : unit -&gt; System.Windows.Interop.D3DImage" Usage="d3DImage.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.D3DImage</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="19be9-165">Erstellt einen änderbaren Klon des <see cref="T:System.Windows.Interop.D3DImage" />-Objekts, indem tiefe Kopien der aktuellen Werte dieses Objekts erzeugt werden.</span><span class="sxs-lookup"><span data-stu-id="19be9-165">Creates a modifiable clone of this <see cref="T:System.Windows.Interop.D3DImage" /> object, making deep copies of this object's current values.</span></span> <span data-ttu-id="19be9-166">Ressourcenverweise, Datenbindungen und Animationen werden nicht kopiert, ihre aktuellen Werte werden jedoch kopiert.</span><span class="sxs-lookup"><span data-stu-id="19be9-166">Resource references, data bindings, and animations are not copied, but their current values are copied.</span></span></summary>
        <returns><span data-ttu-id="19be9-167">Ein änderbarer Klon des aktuellen Objekts.</span><span class="sxs-lookup"><span data-stu-id="19be9-167">A modifiable clone of the current object.</span></span> <span data-ttu-id="19be9-168">Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true" /> war.</span><span class="sxs-lookup"><span data-stu-id="19be9-168">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property will be <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property was <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19be9-169">Diese Methode wird verwendet, um änderbare Kopien von fixierten <xref:System.Windows.Freezable> Objekten (oder einem beliebigen <xref:System.Windows.Freezable> Objekt) zu liefern.</span><span class="sxs-lookup"><span data-stu-id="19be9-169">This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object).</span></span> <span data-ttu-id="19be9-170">Aus Gründen der praktische überschattet diese Methode die geerbte Version durch eine stark typisierte Implementierung.</span><span class="sxs-lookup"><span data-stu-id="19be9-170">For convenience, this method shadows the inherited version with a strongly typed implementation.</span></span>  
  
 <span data-ttu-id="19be9-171">Weitere Informationen finden Sie unter <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="19be9-171">For more information, see <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.CloneCurrentValueCore sourceFreezable" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.CloneCurrentValueCore sourceFreezable" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><span data-ttu-id="19be9-172">Der <see cref="T:System.Windows.Freezable" />, der geklont werden soll.</span><span class="sxs-lookup"><span data-stu-id="19be9-172">The <see cref="T:System.Windows.Freezable" /> to be cloned.</span></span></param>
        <summary><span data-ttu-id="19be9-173">Macht die Instanz mithilfe aktueller Eigenschaftswerte zu einem Klon (tiefe Kopie) des angegebenen <see cref="T:System.Windows.Freezable" />-Elements, der geändert werden kann.</span><span class="sxs-lookup"><span data-stu-id="19be9-173">Makes the instance a modifiable clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using current property values.</span></span></summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CopyBackBuffer">
      <MemberSignature Language="C#" Value="protected internal virtual System.Windows.Media.Imaging.BitmapSource CopyBackBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.Media.Imaging.BitmapSource CopyBackBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CopyBackBuffer" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CopyBackBuffer () As BitmapSource" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Windows::Media::Imaging::BitmapSource ^ CopyBackBuffer();" />
      <MemberSignature Language="F#" Value="abstract member CopyBackBuffer : unit -&gt; System.Windows.Media.Imaging.BitmapSource&#xA;override this.CopyBackBuffer : unit -&gt; System.Windows.Media.Imaging.BitmapSource" Usage="d3DImage.CopyBackBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityTreatAsSafe]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityTreatAsSafe&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Imaging.BitmapSource</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="19be9-174">Erstellt eine Softwarekopie des <see cref="T:System.Windows.Interop.D3DImage" />.</span><span class="sxs-lookup"><span data-stu-id="19be9-174">Creates a software copy of the <see cref="T:System.Windows.Interop.D3DImage" />.</span></span></summary>
        <returns><span data-ttu-id="19be9-175">Eine <see cref="T:System.Windows.Media.Imaging.BitmapSource" />, die eine Softwarekopie des aktuellen Zustands des Hintergrundpuffers darstellt, andernfalls <see langword="null" />, wenn der Hintergrundpuffer nicht gelesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="19be9-175">A <see cref="T:System.Windows.Media.Imaging.BitmapSource" /> that is a software copy of the current state of the back buffer; otherwise, <see langword="null" /> if the back buffer cannot be read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19be9-176">Die <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> -Methode wird von Clients wie dem Drucksystem und der- <xref:System.Windows.Media.Imaging.RenderTargetBitmap> Klasse aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="19be9-176">The <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> method is called by clients such as the printing system and the <xref:System.Windows.Media.Imaging.RenderTargetBitmap> class.</span></span>  
  
 <span data-ttu-id="19be9-177">Überschreiben Sie optional die <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> -Methode, um benutzerdefinierte Logik zu implementieren und einen anderen zurückzugeben <xref:System.Windows.Media.Imaging.BitmapSource></span><span class="sxs-lookup"><span data-stu-id="19be9-177">Optionally override the <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> method to implement custom logic and return a different <xref:System.Windows.Media.Imaging.BitmapSource>.</span></span> <span data-ttu-id="19be9-178">Beispielsweise können Sie einen Platzhalter zurückgeben, <xref:System.Windows.Media.Imaging.BitmapSource> Wenn die Standard <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> Implementierung zurückgibt `null` .</span><span class="sxs-lookup"><span data-stu-id="19be9-178">For example, you can return a placeholder <xref:System.Windows.Media.Imaging.BitmapSource> if the default <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> implementation returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.Imaging.BitmapSource" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable&#xA;override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="d3DImage.CreateInstanceCore " FrameworkAlternate="net-5.0" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="d3DImage.CreateInstanceCore " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="19be9-179">Erstellt beim Implementieren in einer abgeleiteten Klasse eine neue Instanz der abgeleiteten <see cref="T:System.Windows.Interop.D3DImage" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="19be9-179">When implemented in a derived class, creates a new instance of the <see cref="T:System.Windows.Interop.D3DImage" /> derived class.</span></span></summary>
        <returns><span data-ttu-id="19be9-180">Die neue Instanz.</span><span class="sxs-lookup"><span data-stu-id="19be9-180">The new instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19be9-181">Wenn Sie von der- <xref:System.Windows.Interop.D3DImage> Klasse ableiten, müssen Sie die- <xref:System.Windows.Interop.D3DImage.CreateInstanceCore%2A> Methode überschreiben, um das ordnungsgemäße Klonen zu aktivieren.</span><span class="sxs-lookup"><span data-stu-id="19be9-181">If you derive from the <xref:System.Windows.Interop.D3DImage> class, you must override the <xref:System.Windows.Interop.D3DImage.CreateInstanceCore%2A> method to enable correct cloning.</span></span> <span data-ttu-id="19be9-182">Die Standard Implementierung führt einen aus `return new D3DImage()` , der nicht korrekt ist, wenn es sich bei der Instanz um eine andere Klasse handelt.</span><span class="sxs-lookup"><span data-stu-id="19be9-182">The default implementation performs a `return new D3DImage()`, which will not be correct if the instance is a different class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~D3DImage ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!D3DImage ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="d3DImage.Finalize " FrameworkAlternate="net-5.0" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="d3DImage.Finalize " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityTreatAsSafe]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityTreatAsSafe&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="19be9-183">Gibt Ressourcen frei und führt andere Bereinigungsvorgänge durch, bevor das <see cref="T:System.Windows.Interop.D3DImage" /> durch die Garbage Collection wieder freigegeben wird.</span><span class="sxs-lookup"><span data-stu-id="19be9-183">Frees resources and performs other cleanup operations before the <see cref="T:System.Windows.Interop.D3DImage" /> is reclaimed by garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19be9-184">Diese Methode überschreibt <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="19be9-184">This method overrides <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="19be9-185">Der Anwendungscode sollte diese Methode nicht aufzurufen. die-Methode eines Objekts `Finalize` wird automatisch während Garbage Collection aufgerufen, es sei denn, die Garbage Collector wurde durch einen Aufruf der- <xref:System.GC.SuppressFinalize%2A> Methode deaktiviert.</span><span class="sxs-lookup"><span data-stu-id="19be9-185">Application code should not call this method; an object's `Finalize` method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <xref:System.GC.SuppressFinalize%2A> method.</span></span>  
  
 <span data-ttu-id="19be9-186">Weitere Informationen finden Sie unter [Finalize-Methoden und debugtoren](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v%3dvs.100)), [Bereinigen von nicht verwalteten Ressourcen](/dotnet/standard/garbage-collection/unmanaged)und überschreiben [der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="19be9-186">For more information, see [Finalize Methods and Destructors](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v%3dvs.100)), [Cleaning Up Unmanaged Resources](/dotnet/standard/garbage-collection/unmanaged), and [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected override sealed bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="override this.FreezeCore : bool -&gt; bool" Usage="d3DImage.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking"><span data-ttu-id="19be9-187">Hat keinerlei Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="19be9-187">Has no effect.</span></span></param>
        <summary><span data-ttu-id="19be9-188">Legt das <see cref="T:System.Windows.Interop.D3DImage" /> als nicht änderbar fest oder bestimmt, ob es als nicht änderbar festgelegt werden kann.</span><span class="sxs-lookup"><span data-stu-id="19be9-188">Makes the <see cref="T:System.Windows.Interop.D3DImage" /> unmodifiable or determines whether it can be made unmodifiable.</span></span></summary>
        <returns><span data-ttu-id="19be9-189"><see langword="false" /> in allen Fällen.</span><span class="sxs-lookup"><span data-stu-id="19be9-189"><see langword="false" /> in all cases.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19be9-190">Die-Klasse lässt das <xref:System.Windows.Interop.D3DImage> Einfrieren nicht zu, da Änderungen aufgrund der Verfügbarkeit des Front Puffers immer möglich sind.</span><span class="sxs-lookup"><span data-stu-id="19be9-190">The <xref:System.Windows.Interop.D3DImage> class does not allow freezing because changes are always possible due to front buffer availability.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.GetAsFrozenCore sourceFreezable" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="F#" Value="override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.GetAsFrozenCore sourceFreezable" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><span data-ttu-id="19be9-191">Die zu kopierende Instanz.</span><span class="sxs-lookup"><span data-stu-id="19be9-191">The instance to copy.</span></span></param>
        <summary><span data-ttu-id="19be9-192">Definiert die Instanz als fixierten Klon des angegebenen <see cref="T:System.Windows.Freezable" />-Elements, indem Basiseigenschaftenwerte (nicht animiert) verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="19be9-192">Makes the instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span></span></summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.GetCurrentValueAsFrozenCore sourceFreezable" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="F#" Value="override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.GetCurrentValueAsFrozenCore sourceFreezable" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><span data-ttu-id="19be9-193">Das <see cref="T:System.Windows.Freezable" />, das kopiert und fixiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="19be9-193">The <see cref="T:System.Windows.Freezable" /> to copy and freeze.</span></span></param>
        <summary><span data-ttu-id="19be9-194">Macht diese aktuelle Instanz zu einem fixierten Klon des angegebenen <see cref="T:System.Windows.Freezable" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="19be9-194">Makes the current instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" />.</span></span> <span data-ttu-id="19be9-195">Wenn das Objekt über animierte Abhängigkeitseigenschaften verfügt, werden die aktuellen animierten Werte kopiert.</span><span class="sxs-lookup"><span data-stu-id="19be9-195">If the object has animated dependency properties, their current animated values are copied.</span></span></summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public override sealed double Height { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Height" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Height : double" Usage="System.Windows.Interop.D3DImage.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="19be9-196">Ruft die Höhe des <see cref="T:System.Windows.Interop.D3DImage" /> ab.</span><span class="sxs-lookup"><span data-stu-id="19be9-196">Gets the height of the <see cref="T:System.Windows.Interop.D3DImage" />.</span></span></summary>
        <value><span data-ttu-id="19be9-197">Die Höhe des <see cref="T:System.Windows.Interop.D3DImage" /> in Maßeinheiten.</span><span class="sxs-lookup"><span data-stu-id="19be9-197">The height of the <see cref="T:System.Windows.Interop.D3DImage" />, in measure units.</span></span> <span data-ttu-id="19be9-198">Eine Maßeinheit ist 1/96 Zoll.</span><span class="sxs-lookup"><span data-stu-id="19be9-198">A measure unit is 1/96th inch.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19be9-199">Der Wert von <xref:System.Windows.Interop.D3DImage.Height%2A> kann sich ändern, wenn ein neuer BackBuffer durch einen-Befehl der-Methode zugewiesen wird <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> .</span><span class="sxs-lookup"><span data-stu-id="19be9-199">The value of <xref:System.Windows.Interop.D3DImage.Height%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.Width" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailable">
      <MemberSignature Language="C#" Value="public bool IsFrontBufferAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrontBufferAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrontBufferAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrontBufferAvailable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrontBufferAvailable : bool" Usage="System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="19be9-200">Ruft einen Wert ab, der angibt, ob ein Frontpuffer vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="19be9-200">Gets a value that indicates whether a front buffer exists.</span></span></summary>
        <value><span data-ttu-id="19be9-201"><see langword="true" />, wenn ein Frontpuffer vorhanden ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="19be9-201"><see langword="true" /> if a front buffer exists; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19be9-202">Gelegentlich ist der Vorder-Puffer nicht mehr verfügbar.</span><span class="sxs-lookup"><span data-stu-id="19be9-202">Occasionally, the front buffer becomes unavailable.</span></span> <span data-ttu-id="19be9-203">Diese fehlende Verfügbarkeit kann durch eine Bildschirmsperre, voll Bild exklusive Direct3D Anwendungen, Benutzerwechsel oder andere Systemaktivitäten verursacht werden.</span><span class="sxs-lookup"><span data-stu-id="19be9-203">This lack of availability can be caused by screen locking, full-screen exclusive Direct3D applications, user-switching, or other system activities.</span></span> <span data-ttu-id="19be9-204">In diesem Fall wird die WPF-Anwendung durch Behandeln des- <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Ereignisses benachrichtigt.</span><span class="sxs-lookup"><span data-stu-id="19be9-204">When this occurs, your WPF application is notified by handling the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event.</span></span>  <span data-ttu-id="19be9-205">Wie die Anwendung auf den Vordergrund Puffer reagiert, hängt davon ab, ob WPF auf das Software Rendering zurückgreifen kann.</span><span class="sxs-lookup"><span data-stu-id="19be9-205">How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering.</span></span> <span data-ttu-id="19be9-206">Die- <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Methode verfügt über eine-Überladung, die einen-Parameter annimmt, der angibt, ob WPF auf Software Rendering zurückgreift.</span><span class="sxs-lookup"><span data-stu-id="19be9-206">The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering.</span></span> <span data-ttu-id="19be9-207">Weitere Informationen finden Sie in den Hinweisen in der- <xref:System.Windows.Interop.D3DImage> Klasse.</span><span class="sxs-lookup"><span data-stu-id="19be9-207">For more information, see the remarks in the <xref:System.Windows.Interop.D3DImage> class.</span></span>  
  
<a name="dependencyPropertyInfo_IsFrontBufferAvailable"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="19be9-208">Informationen zur Abhängigkeitseigenschaft</span><span class="sxs-lookup"><span data-stu-id="19be9-208">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="19be9-209">Bezeichnerfeld</span><span class="sxs-lookup"><span data-stu-id="19be9-209">Identifier field</span></span>|<xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty>|  
|<span data-ttu-id="19be9-210">Metadateneigenschaften auf `true` festgelegt</span><span class="sxs-lookup"><span data-stu-id="19be9-210">Metadata properties set to `true`</span></span>|<span data-ttu-id="19be9-211">Keine</span><span class="sxs-lookup"><span data-stu-id="19be9-211">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="19be9-212">Im folgenden Codebeispiel wird gezeigt, wie die- <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable%2A> Eigenschaft beim Rendern des Kompositions Ziels überprüft wird.</span><span class="sxs-lookup"><span data-stu-id="19be9-212">The following code example shows how to check the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable%2A> property when rendering the composition target.</span></span> <span data-ttu-id="19be9-213">Weitere Informationen finden Sie unter Exemplarische Vorgehensweise [: Hosting von Direct3D9 Content in WPF](/dotnet/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf).</span><span class="sxs-lookup"><span data-stu-id="19be9-213">For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](/dotnet/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf).</span></span>  
  
 [!code-csharp[System.Windows.Interop.D3DImage#2](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
        <altmember cref="E:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsFrontBufferAvailableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsFrontBufferAvailableChanged;" />
      <MemberSignature Language="F#" Value="member this.IsFrontBufferAvailableChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsFrontBufferAvailableChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="19be9-214">Tritt ein, wenn sich die <see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />-Eigenschaft ändert.</span><span class="sxs-lookup"><span data-stu-id="19be9-214">Occurs when the <see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" /> property changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19be9-215">Behandeln <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Sie den, der benachrichtigt werden soll, wenn sich der Status des Front Puffers ändert.</span><span class="sxs-lookup"><span data-stu-id="19be9-215">Handle the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> to be notified when the status of the front buffer changes.</span></span> <span data-ttu-id="19be9-216">Wie die Anwendung auf den Vordergrund Puffer reagiert, hängt davon ab, ob WPF auf das Software Rendering zurückgreifen kann.</span><span class="sxs-lookup"><span data-stu-id="19be9-216">How your application responds to the front buffer becoming unavailable depends on whether WPF is enabled to fall back to software rendering.</span></span> <span data-ttu-id="19be9-217">Die- <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Methode verfügt über eine-Überladung, die einen-Parameter annimmt, der angibt, ob WPF auf Software Rendering zurückgreift.</span><span class="sxs-lookup"><span data-stu-id="19be9-217">The <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method has an overload that takes a parameter that specifies whether WPF falls back to software rendering.</span></span> <span data-ttu-id="19be9-218">Weitere Informationen finden Sie in den Hinweisen in der- <xref:System.Windows.Interop.D3DImage> Klasse.</span><span class="sxs-lookup"><span data-stu-id="19be9-218">For more information, see the remarks in the <xref:System.Windows.Interop.D3DImage> class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFrontBufferAvailableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFrontBufferAvailableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFrontBufferAvailableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFrontBufferAvailableProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsFrontBufferAvailableProperty : System.Windows.DependencyProperty" Usage="System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="19be9-219">Bezeichnet die <see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />-Abhängigkeitseigenschaft.</span><span class="sxs-lookup"><span data-stu-id="19be9-219">Identifies the <see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public void Lock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Lock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Lock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Lock();" />
      <MemberSignature Language="F#" Value="member this.Lock : unit -&gt; unit" Usage="d3DImage.Lock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="19be9-220">Sperrt das <see cref="T:System.Windows.Interop.D3DImage" /> und aktiviert Vorgänge im Hintergrundpuffer.</span><span class="sxs-lookup"><span data-stu-id="19be9-220">Locks the <see cref="T:System.Windows.Interop.D3DImage" /> and enables operations on the back buffer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19be9-221">Rufen <xref:System.Windows.Interop.D3DImage.Lock%2A> Sie die-Methode auf, um den Hintergrund Puffer zu ändern, indem Sie die <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> Methoden und aufrufen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A></span><span class="sxs-lookup"><span data-stu-id="19be9-221">Call the <xref:System.Windows.Interop.D3DImage.Lock%2A> method to change the back buffer by calling the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> and <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> methods.</span></span> <span data-ttu-id="19be9-222">Während das <xref:System.Windows.Interop.D3DImage> gesperrt ist, kann die Anwendung auch auf die Direct3D-Oberfläche, die dem Hintergrund Puffer zugewiesen ist, Renderern.</span><span class="sxs-lookup"><span data-stu-id="19be9-222">While the <xref:System.Windows.Interop.D3DImage> is locked, your application can also render to the Direct3D surface assigned to the back buffer.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="19be9-223">Die- <xref:System.Windows.Interop.D3DImage.Lock%2A> Methode blockiert, wenn das Renderingsystem den Hintergrund Puffer liest, um den Frontpuffer zu aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="19be9-223">The <xref:System.Windows.Interop.D3DImage.Lock%2A> method blocks when the rendering system is reading the back buffer to update the front buffer.</span></span> <span data-ttu-id="19be9-224">Verwenden Sie die- <xref:System.Windows.Interop.D3DImage.TryLock%2A> Methode, um das unbegrenzte blockieren zu vermeiden</span><span class="sxs-lookup"><span data-stu-id="19be9-224">Use the <xref:System.Windows.Interop.D3DImage.TryLock%2A> method to avoid blocking indefinitely.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="19be9-225">Im folgenden Codebeispiel wird gezeigt, wie die-Methode aufgerufen wird <xref:System.Windows.Interop.D3DImage.Lock%2A> , um Aktualisierungen des Hintergrund Puffers zu aktivieren.</span><span class="sxs-lookup"><span data-stu-id="19be9-225">The following code example shows how to call the <xref:System.Windows.Interop.D3DImage.Lock%2A> method to enable updates to the back buffer.</span></span> <span data-ttu-id="19be9-226">Weitere Informationen finden Sie unter Exemplarische Vorgehensweise [: Hosting von Direct3D9 Content in WPF](/dotnet/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf).</span><span class="sxs-lookup"><span data-stu-id="19be9-226">For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](/dotnet/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf).</span></span>  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="19be9-227">Die Sperrenanzahl ist gleich <see cref="F:System.UInt32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="19be9-227">The lock count equals <see cref="F:System.UInt32.MaxValue" />.</span></span></exception>
        <altmember cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="Metadata">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.Media.ImageMetadata Metadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageMetadata Metadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Metadata" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Metadata As ImageMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageMetadata ^ Metadata { System::Windows::Media::ImageMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Metadata : System.Windows.Media.ImageMetadata" Usage="System.Windows.Interop.D3DImage.Metadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="19be9-228">Ruft die Metadaten ab, die der Bildquelle zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="19be9-228">Gets the metadata associated with the image source.</span></span></summary>
        <value><span data-ttu-id="19be9-229"><see langword="null" /> in allen Fällen.</span><span class="sxs-lookup"><span data-stu-id="19be9-229"><see langword="null" /> in all cases.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PixelHeight">
      <MemberSignature Language="C#" Value="public int PixelHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PixelHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.PixelHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PixelHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PixelHeight { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PixelHeight : int" Usage="System.Windows.Interop.D3DImage.PixelHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="19be9-230">Ruft die Höhe des <see cref="T:System.Windows.Interop.D3DImage" /> in Pixel ab.</span><span class="sxs-lookup"><span data-stu-id="19be9-230">Gets the height of the <see cref="T:System.Windows.Interop.D3DImage" />, in pixels.</span></span></summary>
        <value><span data-ttu-id="19be9-231">Die Höhe des <see cref="T:System.Windows.Interop.D3DImage" /> in Pixel.</span><span class="sxs-lookup"><span data-stu-id="19be9-231">The height of the <see cref="T:System.Windows.Interop.D3DImage" />, in pixels.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19be9-232">Der Wert von <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> kann sich ändern, wenn ein neuer BackBuffer durch einen-Befehl der-Methode zugewiesen wird <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> .</span><span class="sxs-lookup"><span data-stu-id="19be9-232">The value of <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="19be9-233">Im folgenden Codebeispiel wird gezeigt, wie die-Eigenschaft verwendet wird <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> , um den geänderten Bereich im Hintergrund Puffer anzugeben.</span><span class="sxs-lookup"><span data-stu-id="19be9-233">The following code example shows how to use the <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> property to specify the changed region in the back buffer.</span></span> <span data-ttu-id="19be9-234">Weitere Informationen finden Sie unter Exemplarische Vorgehensweise [: Hosting von Direct3D9 Content in WPF](/dotnet/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf).</span><span class="sxs-lookup"><span data-stu-id="19be9-234">For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](/dotnet/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf).</span></span>  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.PixelWidth" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="PixelWidth">
      <MemberSignature Language="C#" Value="public int PixelWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PixelWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.PixelWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PixelWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PixelWidth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PixelWidth : int" Usage="System.Windows.Interop.D3DImage.PixelWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="19be9-235">Ruft die Breite des <see cref="T:System.Windows.Interop.D3DImage" /> in Pixel ab.</span><span class="sxs-lookup"><span data-stu-id="19be9-235">Gets the width of the <see cref="T:System.Windows.Interop.D3DImage" />, in pixels.</span></span></summary>
        <value><span data-ttu-id="19be9-236">Die Breite des <see cref="T:System.Windows.Interop.D3DImage" /> in Pixel.</span><span class="sxs-lookup"><span data-stu-id="19be9-236">The width of the <see cref="T:System.Windows.Interop.D3DImage" />, in pixels.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19be9-237">Der Wert von <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> kann sich ändern, wenn ein neuer BackBuffer durch einen-Befehl der-Methode zugewiesen wird <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> .</span><span class="sxs-lookup"><span data-stu-id="19be9-237">The value of <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="19be9-238">Im folgenden Codebeispiel wird gezeigt, wie die-Eigenschaft verwendet wird <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> , um den geänderten Bereich im Hintergrund Puffer anzugeben.</span><span class="sxs-lookup"><span data-stu-id="19be9-238">The following code example shows how to use the <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> property to specify the changed region in the back buffer.</span></span> <span data-ttu-id="19be9-239">Weitere Informationen finden Sie unter Exemplarische Vorgehensweise [: Hosting von Direct3D9 Content in WPF](/dotnet/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf).</span><span class="sxs-lookup"><span data-stu-id="19be9-239">For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](/dotnet/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf).</span></span>  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.PixelHeight" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBackBuffer">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="19be9-240">Weist eine Direct3D-Oberfläche als Quelle des Hintergrundpuffers zu.</span><span class="sxs-lookup"><span data-stu-id="19be9-240">Assigns a Direct3D surface as the source of the back buffer.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBackBuffer">
      <MemberSignature Language="C#" Value="public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBackBuffer(valuetype System.Windows.Interop.D3DResourceType backBufferType, native int backBuffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBackBuffer (backBufferType As D3DResourceType, backBuffer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBackBuffer(System::Windows::Interop::D3DResourceType backBufferType, IntPtr backBuffer);" />
      <MemberSignature Language="F#" Value="member this.SetBackBuffer : System.Windows.Interop.D3DResourceType * nativeint -&gt; unit" Usage="d3DImage.SetBackBuffer (backBufferType, backBuffer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backBufferType" Type="System.Windows.Interop.D3DResourceType" />
        <Parameter Name="backBuffer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="backBufferType"><span data-ttu-id="19be9-241">Der Typ der Direct3D-Oberfläche.</span><span class="sxs-lookup"><span data-stu-id="19be9-241">The type of Direct3D surface.</span></span> <span data-ttu-id="19be9-242">Muss ein gültiger <see cref="T:System.Windows.Interop.D3DResourceType" /> sein.</span><span class="sxs-lookup"><span data-stu-id="19be9-242">Must be a valid <see cref="T:System.Windows.Interop.D3DResourceType" />.</span></span></param>
        <param name="backBuffer"><span data-ttu-id="19be9-243">Die Direct3D-Oberfläche, die als Hintergrundpuffer zugewiesen werden soll.</span><span class="sxs-lookup"><span data-stu-id="19be9-243">The Direct3D surface to assign as the back buffer.</span></span></param>
        <summary><span data-ttu-id="19be9-244">Weist eine Direct3D-Oberfläche als Quelle des Hintergrundpuffers zu.</span><span class="sxs-lookup"><span data-stu-id="19be9-244">Assigns a Direct3D surface as the source of the back buffer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19be9-245">Wenden Sie die- <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Methode an, um dem Hintergrund Puffer eine Direct3D-Oberfläche zuzuweisen.</span><span class="sxs-lookup"><span data-stu-id="19be9-245">Call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method to assign a Direct3D surface to the back buffer.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="19be9-246">Die Leistung hängt stark von den Einstellungen der Direct3D-Oberfläche ab.</span><span class="sxs-lookup"><span data-stu-id="19be9-246">Performance depends greatly on the settings of the Direct3D surface.</span></span> <span data-ttu-id="19be9-247">Weitere Informationen finden Sie unter [Überlegungen zur Leistung bei der von Direct3D9-und WPF-Interoperabilität](/dotnet/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability).</span><span class="sxs-lookup"><span data-stu-id="19be9-247">For more information, see [Performance Considerations for Direct3D9 and WPF Interoperability](/dotnet/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability).</span></span>  
  
 <span data-ttu-id="19be9-248">Das Aufrufen der- <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> Überladung ist identisch mit dem Aufruf der-Überladung, <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> bei der der- `enableSoftwareFallback` Parameter auf `false`</span><span class="sxs-lookup"><span data-stu-id="19be9-248">Calling the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload is identical to calling the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `false`.</span></span> <span data-ttu-id="19be9-249">Wenn Sie aufrufen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> oder aufrufen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> , wobei der- `enableSoftwareFallback` Parameter auf festgelegt `false` ist, gibt das Renderingsystem seinen Verweis auf den Hintergrund Puffer frei, wenn der Frontpuffer nicht verfügbar ist und nichts angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="19be9-249">When you call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> or call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> with the `enableSoftwareFallback` parameter set to `false`, the rendering system releases its reference to the back buffer when front buffer becomes unavailable and nothing is displayed.</span></span> <span data-ttu-id="19be9-250">Wenn der Front-Puffer wieder verfügbar ist, löst das Renderingsystem das-Ereignis aus, <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> um die WPF-Anwendung zu benachrichtigen.</span><span class="sxs-lookup"><span data-stu-id="19be9-250">When the front buffer is available again, the rendering system raises the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to notify your WPF application.</span></span>  <span data-ttu-id="19be9-251">Sie können einen Ereignishandler für das- <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Ereignis erstellen, um das Rendering erneut mit einer gültigen Direct3D-Oberfläche zu starten.</span><span class="sxs-lookup"><span data-stu-id="19be9-251">You can create an event handler for the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to restart rendering again with a valid Direct3D surface.</span></span> <span data-ttu-id="19be9-252">Um das Rendering neu zu starten, müssen Sie aufzurufen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> .</span><span class="sxs-lookup"><span data-stu-id="19be9-252">To restart rendering, you must call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.</span></span>  
  
 <span data-ttu-id="19be9-253">In der folgenden Liste werden die erforderlichen Einstellungen für den Hintergrund Puffer für den- `IDirect3DSurface9` Typ angezeigt.</span><span class="sxs-lookup"><span data-stu-id="19be9-253">The following list shows the required back buffer settings for the `IDirect3DSurface9` type.</span></span>  
  
-   <span data-ttu-id="19be9-254">`D3DFMT_A8R8G8B8` oder `D3DFMT_X8R8G8B8`</span><span class="sxs-lookup"><span data-stu-id="19be9-254">`D3DFMT_A8R8G8B8` or `D3DFMT_X8R8G8B8`</span></span>  
  
-   `D3DUSAGE_RENDERTARGET`  
  
-   `D3DPOOL_DEFAULT`  
  
 <span data-ttu-id="19be9-255">Multisampling ist nur auf `IDirect3DSurface9Ex` Oberflächen zulässig.</span><span class="sxs-lookup"><span data-stu-id="19be9-255">Multisampling is allowed on `IDirect3DSurface9Ex` surfaces only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="19be9-256">Im folgenden Codebeispiel wird gezeigt, wie die-Methode aufgerufen wird <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> , um eine Direct3D-Oberfläche zuzuweisen.</span><span class="sxs-lookup"><span data-stu-id="19be9-256">The following code example shows how to call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method to assign a Direct3D surface.</span></span> <span data-ttu-id="19be9-257">Weitere Informationen finden Sie unter Exemplarische Vorgehensweise [: Hosting von Direct3D9 Content in WPF](/dotnet/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf).</span><span class="sxs-lookup"><span data-stu-id="19be9-257">For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](/dotnet/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf).</span></span>  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="19be9-258">Das <see cref="T:System.Windows.Interop.D3DImage" /> wurde nicht durch einen Aufruf der <see cref="M:System.Windows.Interop.D3DImage.Lock" />-Methode oder der <see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />-Methode gesperrt.</span><span class="sxs-lookup"><span data-stu-id="19be9-258">The <see cref="T:System.Windows.Interop.D3DImage" /> has not been locked by a call to the <see cref="M:System.Windows.Interop.D3DImage.Lock" /> or <see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" /> methods.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="19be9-259"><paramref name="backBufferType" /> ist kein gültiger <see cref="T:System.Windows.Interop.D3DResourceType" />.</span><span class="sxs-lookup"><span data-stu-id="19be9-259"><paramref name="backBufferType" /> is not a valid <see cref="T:System.Windows.Interop.D3DResourceType" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="19be9-260">Die Erstellungsparameter für <paramref name="backBuffer" /> erfüllen nicht die Anforderungen für <paramref name="backBufferType" /> oder die <paramref name="backBuffer" />-Einheit ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="19be9-260">The creation parameters for <paramref name="backBuffer" /> do not meet the requirements for the <paramref name="backBufferType" />-or-The <paramref name="backBuffer" /> device is not valid.</span></span></exception>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="SetBackBuffer">
      <MemberSignature Language="C#" Value="public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBackBuffer(valuetype System.Windows.Interop.D3DResourceType backBufferType, native int backBuffer, bool enableSoftwareFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBackBuffer (backBufferType As D3DResourceType, backBuffer As IntPtr, enableSoftwareFallback As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBackBuffer(System::Windows::Interop::D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);" />
      <MemberSignature Language="F#" Value="member this.SetBackBuffer : System.Windows.Interop.D3DResourceType * nativeint * bool -&gt; unit" Usage="d3DImage.SetBackBuffer (backBufferType, backBuffer, enableSoftwareFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[System.Security.SecurityCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecurityCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backBufferType" Type="System.Windows.Interop.D3DResourceType" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="backBuffer" Type="System.IntPtr" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="enableSoftwareFallback" Type="System.Boolean" Index="2" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="backBufferType"><span data-ttu-id="19be9-261">Der Typ der Direct3D-Oberfläche.</span><span class="sxs-lookup"><span data-stu-id="19be9-261">The type of Direct3D surface.</span></span> <span data-ttu-id="19be9-262">Muss ein gültiger <see cref="T:System.Windows.Interop.D3DResourceType" /> sein.</span><span class="sxs-lookup"><span data-stu-id="19be9-262">Must be a valid <see cref="T:System.Windows.Interop.D3DResourceType" />.</span></span></param>
        <param name="backBuffer"><span data-ttu-id="19be9-263">Die Direct3D-Oberfläche, die als Hintergrundpuffer zugewiesen werden soll.</span><span class="sxs-lookup"><span data-stu-id="19be9-263">The Direct3D surface to assign as the back buffer.</span></span></param>
        <param name="enableSoftwareFallback"><span data-ttu-id="19be9-264"><see langword="true" />, um auf Softwarerendering zurückzugreifen; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="19be9-264"><see langword="true" /> to fall back on software rendering; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="19be9-265">Weist eine Direct3D-Oberfläche als Quelle des Hintergrundpuffers zu.</span><span class="sxs-lookup"><span data-stu-id="19be9-265">Assigns a Direct3D surface as the source of the back buffer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19be9-266">Wenn Sie die-Überladung aufrufen oder die-Überladung <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> aufrufen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> , wobei der- `enableSoftwareFallback` Parameter auf festgelegt `false` ist, gibt das Renderingsystem seinen Verweis auf den Hintergrund Puffer frei, wenn der Vorder-Puffer nicht mehr verfügbar und keine</span><span class="sxs-lookup"><span data-stu-id="19be9-266">When you call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> overload or call the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> overload with the `enableSoftwareFallback` parameter set to `false`, the rendering system releases its reference to the back buffer when the front buffer becomes unavailable and nothing is displayed.</span></span> <span data-ttu-id="19be9-267">Wenn der Front-Puffer wieder verfügbar ist, löst das Renderingsystem das-Ereignis aus, <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> um die WPF-Anwendung zu benachrichtigen.</span><span class="sxs-lookup"><span data-stu-id="19be9-267">When the front buffer is available again, the rendering system raises the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to notify your WPF application.</span></span>  <span data-ttu-id="19be9-268">Sie können einen Ereignishandler für das- <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Ereignis erstellen, um das Rendering erneut mit einer gültigen Direct3D-Oberfläche zu starten.</span><span class="sxs-lookup"><span data-stu-id="19be9-268">You can create an event handler for the <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> event to restart rendering again with a valid Direct3D surface.</span></span> <span data-ttu-id="19be9-269">Um das Rendering neu zu starten, müssen Sie aufzurufen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> .</span><span class="sxs-lookup"><span data-stu-id="19be9-269">To restart rendering, you must call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>.</span></span>  
  
 <span data-ttu-id="19be9-270">Wenn Sie aufrufen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> , wobei der- `enableSoftwareFallback` Parameter auf festgelegt ist `true` , behält das Renderingsystem seinen Verweis auf den Hintergrund Puffer bei, wenn der Vorder-Puffer nicht mehr verfügbar ist. Daher muss nicht aufgerufen werden, <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Wenn der Vorder-Puffer wieder verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="19be9-270">When you call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> with the `enableSoftwareFallback` parameter set to `true`, the rendering system retains its reference to the back buffer when the front buffer becomes unavailable, so there is no need to call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> when the front buffer is available again.</span></span>  <span data-ttu-id="19be9-271">Es kann Situationen geben, in denen das Gerät des Benutzers nicht mehr verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="19be9-271">There may be situations where the user's device becomes unavailable.</span></span>  <span data-ttu-id="19be9-272">Wenn dies auftritt, wird aufgerufen, <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> um den WPF-Verweis auf den Hintergrund Puffer freizugeben.</span><span class="sxs-lookup"><span data-stu-id="19be9-272">When that occurs, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> to release WPF's reference to the back buffer.</span></span>  <span data-ttu-id="19be9-273">Wenn Sie Ihr Gerät zurücksetzen müssen, können Sie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> mit `backBuffer` auf festlegen `null` und dann erneut aufzurufen, <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> wobei `backBuffer` auf eine gültige Direct3D-Oberfläche festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="19be9-273">If you need to reset your device, call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> with `backBuffer` set to `null`, and then call <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> again with `backBuffer` set to a valid Direct3D surface.</span></span>  
  
 <span data-ttu-id="19be9-274">In der folgenden Liste werden die erforderlichen Einstellungen für den Hintergrund Puffer für den- `IDirect3DSurface9` Typ angezeigt.</span><span class="sxs-lookup"><span data-stu-id="19be9-274">The following list shows the required back buffer settings for the `IDirect3DSurface9` type.</span></span>  
  
-   <span data-ttu-id="19be9-275">`D3DFMT_A8R8G8B8` oder `D3DFMT_X8R8G8B8`</span><span class="sxs-lookup"><span data-stu-id="19be9-275">`D3DFMT_A8R8G8B8` or `D3DFMT_X8R8G8B8`</span></span>  
  
-   `D3DUSAGE_RENDERTARGET`  
  
-   `D3DPOOL_DEFAULT`  
  
 <span data-ttu-id="19be9-276">Multisampling ist nur auf `IDirect3DSurface9Ex` Oberflächen zulässig.</span><span class="sxs-lookup"><span data-stu-id="19be9-276">Multisampling is allowed on `IDirect3DSurface9Ex` surfaces only.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryLock">
      <MemberSignature Language="C#" Value="public bool TryLock (System.Windows.Duration timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryLock(valuetype System.Windows.Duration timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryLock (timeout As Duration) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryLock(System::Windows::Duration timeout);" />
      <MemberSignature Language="F#" Value="member this.TryLock : System.Windows.Duration -&gt; bool" Usage="d3DImage.TryLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Windows.Duration" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="19be9-277">Der Zeitraum, über den auf den Erhalt der Sperre gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="19be9-277">The duration to wait for the lock to be acquired.</span></span></param>
        <summary><span data-ttu-id="19be9-278">Versucht, das <see cref="T:System.Windows.Interop.D3DImage" /> zu sperren, und wartet den angegebenen Zeitraum ab.</span><span class="sxs-lookup"><span data-stu-id="19be9-278">Attempts to lock the <see cref="T:System.Windows.Interop.D3DImage" /> and waits for the specified duration.</span></span></summary>
        <returns><span data-ttu-id="19be9-279"><see langword="true" />, wenn die Sperre erhalten wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="19be9-279"><see langword="true" /> if the lock was acquired; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="19be9-280">Für <paramref name="timeout" /> ist <see cref="P:System.Windows.Duration.Automatic" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="19be9-280"><paramref name="timeout" /> is set to <see cref="P:System.Windows.Duration.Automatic" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="19be9-281">Die Sperrenanzahl ist gleich <see cref="F:System.UInt32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="19be9-281">The lock count equals <see cref="F:System.UInt32.MaxValue" />.</span></span></exception>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public void Unlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Unlock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unlock();" />
      <MemberSignature Language="F#" Value="member this.Unlock : unit -&gt; unit" Usage="d3DImage.Unlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="19be9-282">Verringert die Sperrenanzahl für das <see cref="T:System.Windows.Interop.D3DImage" />.</span><span class="sxs-lookup"><span data-stu-id="19be9-282">Decrements the lock count for the <see cref="T:System.Windows.Interop.D3DImage" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19be9-283">Wenn die Sperrenanzahl für den <xref:System.Windows.Interop.D3DImage> Null erreicht, <xref:System.Windows.Interop.D3DImage> wird vollständig entsperrt.</span><span class="sxs-lookup"><span data-stu-id="19be9-283">When the lock count for the <xref:System.Windows.Interop.D3DImage> reaches zero, the <xref:System.Windows.Interop.D3DImage> is fully unlocked.</span></span> <span data-ttu-id="19be9-284">Der <xref:System.Windows.Interop.D3DImage> ist für das Rendering gekennzeichnet, wenn sich das Bild in den von vorherigen Aufrufen der-Methode angegebenen Bereichen geändert hat <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> .</span><span class="sxs-lookup"><span data-stu-id="19be9-284">The <xref:System.Windows.Interop.D3DImage> is marked for rendering if the image has changed areas that were specified by previous calls to the <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> method.</span></span>  
  
 <span data-ttu-id="19be9-285">Wenn für die Änderungen ein Commit ausgeführt wird und das Rendering stattfindet, werden zusätzliche Aufrufe der- <xref:System.Windows.Interop.D3DImage.Lock%2A> Methode blockiert, bis der Renderthread den Inhalt des Hintergrund Puffers in den Vordergrund Puffer kopiert hat.</span><span class="sxs-lookup"><span data-stu-id="19be9-285">When the changes are committed and rendering occurs, additional calls to the <xref:System.Windows.Interop.D3DImage.Lock%2A> method block until the render thread has copied the contents of the back buffer to the front buffer.</span></span> <span data-ttu-id="19be9-286">Diese Synchronisierung vermeidet Elemente, z. b. das Zerreißen, anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="19be9-286">This synchronization avoids display artifacts, such as tearing.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="19be9-287">Aktualisieren Sie die Direct3D-Oberfläche nicht, während der <xref:System.Windows.Interop.D3DImage> entsperrt wird.</span><span class="sxs-lookup"><span data-stu-id="19be9-287">Do not update the Direct3D surface while the <xref:System.Windows.Interop.D3DImage> is unlocked.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="19be9-288">Im folgenden Codebeispiel wird gezeigt, wie die-Methode aufgerufen wird <xref:System.Windows.Interop.D3DImage.Unlock%2A> , um den aktualisierten Hintergrund Puffer in den Vordergrund Puffer zu kopieren.</span><span class="sxs-lookup"><span data-stu-id="19be9-288">The following code example shows how to call the <xref:System.Windows.Interop.D3DImage.Unlock%2A> method to copy the updated back buffer to the front buffer.</span></span> <span data-ttu-id="19be9-289">Weitere Informationen finden Sie unter Exemplarische Vorgehensweise [: Hosting von Direct3D9 Content in WPF](/dotnet/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf).</span><span class="sxs-lookup"><span data-stu-id="19be9-289">For more information, see [Walkthrough: Hosting Direct3D9 Content in WPF](/dotnet/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf).</span></span>  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public override sealed double Width { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Width" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Width : double" Usage="System.Windows.Interop.D3DImage.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="19be9-290">Ruft die Breite des <see cref="T:System.Windows.Interop.D3DImage" /> ab.</span><span class="sxs-lookup"><span data-stu-id="19be9-290">Gets the width of the <see cref="T:System.Windows.Interop.D3DImage" />.</span></span></summary>
        <value><span data-ttu-id="19be9-291">Die Breite des <see cref="T:System.Windows.Interop.D3DImage" /> in Maßeinheiten.</span><span class="sxs-lookup"><span data-stu-id="19be9-291">The width of the <see cref="T:System.Windows.Interop.D3DImage" />, in measure units.</span></span> <span data-ttu-id="19be9-292">Eine Maßeinheit ist 1/96 Zoll.</span><span class="sxs-lookup"><span data-stu-id="19be9-292">A measure unit is 1/96th inch.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="19be9-293">Der Wert von <xref:System.Windows.Interop.D3DImage.Width%2A> kann sich ändern, wenn ein neuer BackBuffer durch einen-Befehl der-Methode zugewiesen wird <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> .</span><span class="sxs-lookup"><span data-stu-id="19be9-293">The value of <xref:System.Windows.Interop.D3DImage.Width%2A> can change when a new back buffer is assigned by a call to the <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.Height" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
  </Members>
</Type>
