<Type Name="D3DImage" FullName="System.Windows.Interop.D3DImage">
  <Metadata><Meta Name="ms.openlocfilehash" Value="567efaf4215fbce1c4cbe8f4e48b7b00f9bdfe91" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69168519" /></Metadata><TypeSignature Language="C#" Value="public class D3DImage : System.Windows.Media.ImageSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi D3DImage extends System.Windows.Media.ImageSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Interop.D3DImage" />
  <TypeSignature Language="VB.NET" Value="Public Class D3DImage&#xA;Inherits ImageSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class D3DImage : System::Windows::Media::ImageSource" />
  <TypeSignature Language="F#" Value="type D3DImage = class&#xA;    inherit ImageSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.ImageSource</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Eine <see cref="T:System.Windows.Media.ImageSource" />, die eine vom Benutzer erstellte Direct3D-Oberfläche anzeigt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie <xref:System.Windows.Interop.D3DImage> die-Klasse, um Direct3D-Inhalt in einer Windows Presentation Foundation (WPF)-Anwendung zu hosten.  
  
 Ruft die <xref:System.Windows.Interop.D3DImage.Lock%2A> -Methode auf, um den <xref:System.Windows.Interop.D3DImage>von angezeigten Direct3D-Inhalt zu ändern. Ruft die <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> -Methode auf, um einer Direct3D- <xref:System.Windows.Interop.D3DImage>Oberfläche zuzuweisen. Ruft die <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> -Methode auf, um Aktualisierungen der Direct3D-Oberfläche zu verfolgen. Aufrufen der <xref:System.Windows.Interop.D3DImage.Unlock%2A> -Methode, um die geänderten Bereiche anzuzeigen.  
  
 Die <xref:System.Windows.Interop.D3DImage> -Klasse verwaltet zwei Anzeige Puffer, die als *Hintergrund Puffer* und Vordergrund *Puffer*bezeichnet werden. Der Hintergrund Puffer ist die Direct3D-Oberfläche.  Änderungen am Hintergrund Puffer werden in den Vordergrund Puffer kopiert, wenn Sie die <xref:System.Windows.Interop.D3DImage.Unlock%2A> -Methode aufzurufen, wo Sie auf der Hardware angezeigt wird. Gelegentlich ist der Vorder-Puffer nicht mehr verfügbar. Diese fehlende Verfügbarkeit kann durch eine Bildschirmsperre, voll Bild exklusive Direct3D Anwendungen, Benutzerwechsel oder andere Systemaktivitäten verursacht werden. In diesem Fall wird die WPF-Anwendung durch Behandeln des <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> -Ereignisses benachrichtigt.  Wie die Anwendung auf den Vordergrund Puffer reagiert, hängt davon ab, ob WPF auf das Software Rendering zurückgreifen kann. Die <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> -Methode verfügt über eine-Überladung, die einen-Parameter annimmt, der angibt, ob WPF auf Software Rendering zurückgreift.  
  
## <a name="responding-to-an-unavailable-front-buffer-when-wpf-does-not-fall-back-to-software-rendering"></a>Reagieren auf einen nicht verfügbaren Front-Puffer, wenn WPF nicht auf Software Rendering zurückgreift  
 Wenn <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> Sie die-Überladung aufrufen oder <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> die-über `enableSoftwareFallback` Ladung aufrufen, `false`wobei der-Parameter auf festgelegt ist, gibt das Renderingsystem seinen Verweis auf den Hintergrund Puffer frei, wenn der Frontpuffer nicht mehr verfügbar ist gestellte. Wenn der Front-Puffer wieder verfügbar ist, löst das Renderingsystem das-Ereignis aus, um die <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> WPF-Anwendung zu benachrichtigen.  Sie können einen Ereignishandler für das- <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Ereignis erstellen, um das Rendering erneut mit einer gültigen Direct3D-Oberfläche zu starten. Um das Rendering neu zu starten, <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>müssen Sie aufzurufen.  
  
## <a name="responding-to-an-unavailable-front-buffer-when-wpf-falls-back-to-software-rendering"></a>Reagieren auf einen nicht verfügbaren Front-Puffer, wenn WPF auf Software Rendering zurückgreift  
 Wenn Sie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> die-Überladung mit `enableSoftwareFallback` dem auf `true`festgelegten-Parameter aufrufen, behält das Renderingsystem seinen Verweis auf den Hintergrund Puffer bei, wenn der Vorder-Puffer nicht <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> mehr verfügbar ist. Daher müssen Sie nicht aufrufen, wenn der Vordergrund der Puffer ist wieder verfügbar.  Es kann Situationen geben, in denen das Gerät des Benutzers nicht mehr verfügbar ist.  Wenn dies auftritt, wird <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> aufgerufen, um den WPF-Verweis auf den Hintergrund Puffer freizugeben.  Wenn Sie Ihr Gerät zurücksetzen müssen, müssen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Sie aufrufen `backBuffer` , wobei der `null`-Parameter auf fest <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> gelegt ist `backBuffer` , und dann erneut aufrufen, wobei auf eine gültige Direct3D-Oberfläche festgelegt  
  
> [!NOTE]
>  Die Leistung hängt stark von den Einstellungen der Direct3D-Oberfläche ab. Weitere Informationen finden Sie unter [Überlegungen zur Leistung bei der von Direct3D9-und WPF-Interoperabilität](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md).  
  
> [!NOTE]
>  Die <xref:System.Windows.Interop.D3DImage> Klasse zeigt Direct3D <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> -Inhalt nicht an, wenn WPF in Software gerendert wird, z. b. über eine Remotedesktop `true` Verbindung, es sei denn, Sie geben an und geben für den `enableSoftwareFallback` Parameter  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein <xref:System.Windows.Interop.D3DImage> in XAML deklariert wird. Sie müssen den <xref:System.Windows.Interop> Namespace zuordnen, da er nicht in den XAML-Standard Namespaces enthalten ist. Weitere Informationen finden Sie unter [Exemplarische Vorgehensweise: Hosting von von Direct3D9-Inhalten in](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)WPF.  
  
 [!code-xaml[System.Windows.Interop.D3DImage#10](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml#10)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwaltete Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Interop.D3DImage" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public D3DImage ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; D3DImage();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Interop.D3DImage" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Bildschirmauflösung ist 1/96 Zoll.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwaltete Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public D3DImage (double dpiX, double dpiY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 dpiX, float64 dpiY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dpiX As Double, dpiY As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; D3DImage(double dpiX, double dpiY);" />
      <MemberSignature Language="F#" Value="new System.Windows.Interop.D3DImage : double * double -&gt; System.Windows.Interop.D3DImage" Usage="new System.Windows.Interop.D3DImage (dpiX, dpiY)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="dpiX" Type="System.Double" />
        <Parameter Name="dpiY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="dpiX">Die Anzeigeauflösung auf der x-Achse.</param>
        <param name="dpiY">Die Anzeigeauflösung auf der y-Achse.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Interop.D3DImage" />-Klasse mit der angegebenen Anzeigeauflösung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Bildschirmauflösung ist 1/96 Zoll.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dpiX" /> oder <paramref name="dpiY" /> ist kleiner als 0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwaltete Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Windows.Interop.D3DImage.Height" />
        <altmember cref="P:System.Windows.Interop.D3DImage.Width" />
      </Docs>
    </Member>
    <Member MemberName="AddDirtyRect">
      <MemberSignature Language="C#" Value="public void AddDirtyRect (System.Windows.Int32Rect dirtyRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDirtyRect(valuetype System.Windows.Int32Rect dirtyRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.AddDirtyRect(System.Windows.Int32Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDirtyRect (dirtyRect As Int32Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDirtyRect(System::Windows::Int32Rect dirtyRect);" />
      <MemberSignature Language="F#" Value="member this.AddDirtyRect : System.Windows.Int32Rect -&gt; unit" Usage="d3DImage.AddDirtyRect dirtyRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dirtyRect" Type="System.Windows.Int32Rect" />
      </Parameters>
      <Docs>
        <param name="dirtyRect">Ein <see cref="T:System.Windows.Int32Rect" />, das den geänderten Bereich darstellt.</param>
        <summary>Gibt den Bereich des Hintergrundpuffers an, der geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ruft die <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> -Methode auf, um Änderungen anzugeben, die Ihr Code an den Hintergrund Puffer vorgenommen hat. Um gerendert zu werden, muss der geänderte Bereich auf dem Hintergrund Puffer über einen entsprechenden geänderten <xref:System.Windows.Interop.D3DImage>Bereich im verfügen.  
  
 Rufen Sie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> die <xref:System.Windows.Interop.D3DImage.Lock%2A> -Methode und die <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> -Methode auf, bevor Sie die  
  
 Ruft die <xref:System.Windows.Interop.D3DImage.Unlock%2A> -Methode auf, um die geänderten Bereiche in den Vorder-Puffer zu kopieren.  
  
> [!NOTE]
>  Nach einigen wenigen Aufrufen der <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> -Methode werden die geänderten Bereiche in einem einzelnen Bereich zusammengeführt. Dies bedeutet, dass Sie über gültige Daten außerhalb der geänderten Bereiche verfügen müssen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> -Methode aufgerufen wird, um den geänderten Bereich im Hintergrund Puffer anzugeben. Weitere Informationen finden Sie unter [Exemplarische Vorgehensweise: Hosting von von Direct3D9-Inhalten in](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)WPF.  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Bitmap wurde nicht durch einen Aufruf der <see cref="M:System.Windows.Interop.D3DImage.Lock" />-Methode oder der <see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />-Methode gesperrt.  
  
- oder - 
Der Hintergrundpuffer wurde nicht durch einen Aufruf der <see cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />-Methode zugewiesen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Mindestens eine der folgenden Bedingungen ist erfüllt.  
  
 <paramref name="dirtyRect.X" /> &lt; 0 
 <paramref name="dirtyRect.Y" /> &lt; 0 
 <paramref name="dirtyRect.Width" /> &lt; 0 oder <paramref name="dirtyRect.Width" /> &gt; <see cref="P:System.Windows.Interop.D3DImage.PixelWidth" /><paramref name="dirtyRect.Height" /> &lt; 0 oder <paramref name="dirtyRect.Height" /> &gt; <see cref="P:System.Windows.Interop.D3DImage.PixelHeight" /></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwaltete Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Interop.D3DImage Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Interop.D3DImage Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As D3DImage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Interop::D3DImage ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Interop.D3DImage" Usage="d3DImage.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.D3DImage</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon des <see cref="T:System.Windows.Interop.D3DImage" />-Objekts, indem tiefe Kopien der Werte dieses Objekts erzeugt werden. Beim Kopieren von Abhängigkeitseigenschaften kopiert diese Methode Ressourcenverweise und Datenbindungen (die möglicherweise nicht mehr aufgelöst werden können), jedoch keine Animationen oder deren aktuelle Werte.</summary>
        <returns>Ein änderbarer Klon des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true." /> war.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um änderbare Kopien von <xref:System.Windows.Freezable> fixierten Objekten (oder einem beliebigen <xref:System.Windows.Freezable> Objekt) zu liefern. Aus Gründen der praktische überschattet diese Methode die geerbte Version durch eine stark typisierte Implementierung.  
  
 Weitere Informationen finden Sie unter <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das zu klonende Objekt.</param>
        <summary>Definiert die Instanz als Klon (tiefe Kopie) des angegebenen <see cref="T:System.Windows.Freezable" />-Elements, indem Basiseigenschaftenwerte (nicht animiert) verwendet werden.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Interop.D3DImage CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Interop.D3DImage CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As D3DImage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Interop::D3DImage ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValue : unit -&gt; System.Windows.Interop.D3DImage" Usage="d3DImage.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.D3DImage</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon des <see cref="T:System.Windows.Interop.D3DImage" />-Objekts, indem tiefe Kopien der aktuellen Werte dieses Objekts erzeugt werden. Ressourcenverweise, Datenbindungen und Animationen werden nicht kopiert, ihre aktuellen Werte werden jedoch kopiert.</summary>
        <returns>Ein änderbarer Klon des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true" /> war.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um änderbare Kopien von <xref:System.Windows.Freezable> fixierten Objekten (oder einem beliebigen <xref:System.Windows.Freezable> Objekt) zu liefern. Aus Gründen der praktische überschattet diese Methode die geerbte Version durch eine stark typisierte Implementierung.  
  
 Weitere Informationen finden Sie unter <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Der <see cref="T:System.Windows.Freezable" />, der geklont werden soll.</param>
        <summary>Macht die Instanz mithilfe aktueller Eigenschaftswerte zu einem Klon (tiefe Kopie) des angegebenen <see cref="T:System.Windows.Freezable" />-Elements, der geändert werden kann.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CopyBackBuffer">
      <MemberSignature Language="C#" Value="protected internal virtual System.Windows.Media.Imaging.BitmapSource CopyBackBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.Media.Imaging.BitmapSource CopyBackBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CopyBackBuffer" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CopyBackBuffer () As BitmapSource" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Windows::Media::Imaging::BitmapSource ^ CopyBackBuffer();" />
      <MemberSignature Language="F#" Value="abstract member CopyBackBuffer : unit -&gt; System.Windows.Media.Imaging.BitmapSource&#xA;override this.CopyBackBuffer : unit -&gt; System.Windows.Media.Imaging.BitmapSource" Usage="d3DImage.CopyBackBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Imaging.BitmapSource</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine Softwarekopie des <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
        <returns>Eine <see cref="T:System.Windows.Media.Imaging.BitmapSource" />, die eine Softwarekopie des aktuellen Zustands des Hintergrundpuffers darstellt, andernfalls <see langword="null" />, wenn der Hintergrundpuffer nicht gelesen werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> -Methode wird von Clients wie dem Drucksystem und der <xref:System.Windows.Media.Imaging.RenderTargetBitmap> -Klasse aufgerufen.  
  
 Überschreiben Sie <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> optional die-Methode, um benutzerdefinierte Logik <xref:System.Windows.Media.Imaging.BitmapSource>zu implementieren und einen anderen zurückzugeben Beispielsweise können Sie einen Platzhalter <xref:System.Windows.Media.Imaging.BitmapSource> zurückgeben, wenn die Standard <xref:System.Windows.Interop.D3DImage.CopyBackBuffer%2A> Implementierung `null`zurückgibt.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwaltete Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Windows.Media.Imaging.BitmapSource" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="d3DImage.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt beim Implementieren in einer abgeleiteten Klasse eine neue Instanz der abgeleiteten <see cref="T:System.Windows.Interop.D3DImage" />-Klasse.</summary>
        <returns>Die neue Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie von der <xref:System.Windows.Interop.D3DImage> -Klasse ableiten, müssen Sie die-Methode überschreiben, um das <xref:System.Windows.Interop.D3DImage.CreateInstanceCore%2A> ordnungsgemäße Klonen zu aktivieren. Die Standard Implementierung führt einen `return new D3DImage()`aus, der nicht korrekt ist, wenn es sich bei der Instanz um eine andere Klasse handelt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~D3DImage ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!D3DImage ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="d3DImage.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt Ressourcen frei und führt andere Bereinigungsvorgänge durch, bevor das <see cref="T:System.Windows.Interop.D3DImage" /> durch die Garbage Collection wieder freigegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Object.Finalize%2A>. Der Anwendungscode sollte diese Methode nicht aufzurufen. die- `Finalize` Methode eines Objekts wird automatisch während Garbage Collection aufgerufen, es sei denn, die Garbage Collector wurde durch einen Aufruf der <xref:System.GC.SuppressFinalize%2A> -Methode deaktiviert.  
  
 Weitere Informationen finden Sie unter [Finalize-Methoden und](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v%3dvs.100))debugtoren, [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md)und überschreiben [der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwaltete Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected override sealed bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="override this.FreezeCore : bool -&gt; bool" Usage="d3DImage.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">Hat keine Auswirkungen.</param>
        <summary>Legt das <see cref="T:System.Windows.Interop.D3DImage" /> als nicht änderbar fest oder bestimmt, ob es als nicht änderbar festgelegt werden kann.</summary>
        <returns><see langword="false" /> in allen Fällen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Interop.D3DImage> -Klasse lässt das Einfrieren nicht zu, da Änderungen aufgrund der Verfügbarkeit des Front Puffers immer möglich sind.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Die zu kopierende Instanz.</param>
        <summary>Definiert die Instanz als fixierten Klon des angegebenen <see cref="T:System.Windows.Freezable" /> mit Basiseigenschaftswerten (nicht animiert).</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="d3DImage.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Das <see cref="T:System.Windows.Freezable" />, das kopiert und fixiert werden soll.</param>
        <summary>Legt die aktuelle Instanz als fixierten Klon des angegebenen <see cref="T:System.Windows.Freezable" /> fest. Wenn das Objekt über animierte Abhängigkeitseigenschaften verfügt, werden die aktuellen animierten Werte kopiert.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public override sealed double Height { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Height" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Height : double" Usage="System.Windows.Interop.D3DImage.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höhe des <see cref="T:System.Windows.Interop.D3DImage" /> ab.</summary>
        <value>Die Höhe des <see cref="T:System.Windows.Interop.D3DImage" /> in Maßeinheiten. Eine Maßeinheit ist 1/96 Zoll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert von <xref:System.Windows.Interop.D3DImage.Height%2A> kann sich ändern, wenn ein neuer BackBuffer durch einen-Befehl der <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> -Methode zugewiesen wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.Width" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailable">
      <MemberSignature Language="C#" Value="public bool IsFrontBufferAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrontBufferAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrontBufferAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrontBufferAvailable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrontBufferAvailable : bool" Usage="System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Frontpuffer vorhanden ist.</summary>
        <value><see langword="true" />, wenn ein Frontpuffer vorhanden ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gelegentlich ist der Vorder-Puffer nicht mehr verfügbar. Diese fehlende Verfügbarkeit kann durch eine Bildschirmsperre, voll Bild exklusive Direct3D Anwendungen, Benutzerwechsel oder andere Systemaktivitäten verursacht werden. In diesem Fall wird die WPF-Anwendung durch Behandeln des <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> -Ereignisses benachrichtigt.  Wie die Anwendung auf den Vordergrund Puffer reagiert, hängt davon ab, ob WPF auf das Software Rendering zurückgreifen kann. Die <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> -Methode verfügt über eine-Überladung, die einen-Parameter annimmt, der angibt, ob WPF auf Software Rendering zurückgreift. Weitere Informationen finden Sie in den Hinweisen in der <xref:System.Windows.Interop.D3DImage> -Klasse.  
  
<a name="dependencyPropertyInfo_IsFrontBufferAvailable"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailable%2A> -Eigenschaft beim Rendern des Kompositions Ziels überprüft wird. Weitere Informationen finden Sie unter [Exemplarische Vorgehensweise: Hosting von von Direct3D9-Inhalten in](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)WPF.  
  
 [!code-csharp[System.Windows.Interop.D3DImage#2](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
        <altmember cref="E:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsFrontBufferAvailableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsFrontBufferAvailableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsFrontBufferAvailableChanged;" />
      <MemberSignature Language="F#" Value="member this.IsFrontBufferAvailableChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsFrontBufferAvailableChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn sich die <see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />-Eigenschaft ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Behandeln Sie <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> den, der benachrichtigt werden soll, wenn sich der Status des Front Puffers ändert. Wie die Anwendung auf den Vordergrund Puffer reagiert, hängt davon ab, ob WPF auf das Software Rendering zurückgreifen kann. Die <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> -Methode verfügt über eine-Überladung, die einen-Parameter annimmt, der angibt, ob WPF auf Software Rendering zurückgreift. Weitere Informationen finden Sie in den Hinweisen in der <xref:System.Windows.Interop.D3DImage> -Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrontBufferAvailableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFrontBufferAvailableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFrontBufferAvailableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFrontBufferAvailableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFrontBufferAvailableProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsFrontBufferAvailableProperty : System.Windows.DependencyProperty" Usage="System.Windows.Interop.D3DImage.IsFrontBufferAvailableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die <see cref="P:System.Windows.Interop.D3DImage.IsFrontBufferAvailable" />-Abhängigkeitseigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public void Lock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Lock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Lock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Lock();" />
      <MemberSignature Language="F#" Value="member this.Lock : unit -&gt; unit" Usage="d3DImage.Lock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sperrt das <see cref="T:System.Windows.Interop.D3DImage" /> und aktiviert Vorgänge im Hintergrundpuffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie <xref:System.Windows.Interop.D3DImage.Lock%2A> die-Methode auf, um den Hintergrund Puffer <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> zu <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> ändern, indem Sie die Methoden und aufrufen Während das <xref:System.Windows.Interop.D3DImage> gesperrt ist, kann die Anwendung auch auf die Direct3D-Oberfläche, die dem Hintergrund Puffer zugewiesen ist, Renderern.  
  
> [!NOTE]
>  Die <xref:System.Windows.Interop.D3DImage.Lock%2A> -Methode blockiert, wenn das Renderingsystem den Hintergrund Puffer liest, um den Frontpuffer zu aktualisieren. Verwenden Sie <xref:System.Windows.Interop.D3DImage.TryLock%2A> die-Methode, um das unbegrenzte blockieren zu vermeiden  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die <xref:System.Windows.Interop.D3DImage.Lock%2A> -Methode aufgerufen wird, um Aktualisierungen des Hintergrund Puffers zu aktivieren. Weitere Informationen finden Sie unter [Exemplarische Vorgehensweise: Hosting von von Direct3D9-Inhalten in](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)WPF.  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Sperrenanzahl ist gleich <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altmember cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="Metadata">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.Media.ImageMetadata Metadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageMetadata Metadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Metadata" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Metadata As ImageMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageMetadata ^ Metadata { System::Windows::Media::ImageMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Metadata : System.Windows.Media.ImageMetadata" Usage="System.Windows.Interop.D3DImage.Metadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Metadaten ab, die der Bildquelle zugeordnet sind.</summary>
        <value><see langword="null" /> in allen Fällen.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PixelHeight">
      <MemberSignature Language="C#" Value="public int PixelHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PixelHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.PixelHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PixelHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PixelHeight { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PixelHeight : int" Usage="System.Windows.Interop.D3DImage.PixelHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Höhe des <see cref="T:System.Windows.Interop.D3DImage" /> in Pixel ab.</summary>
        <value>Die Höhe des <see cref="T:System.Windows.Interop.D3DImage" /> in Pixel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert von <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> kann sich ändern, wenn ein neuer BackBuffer durch einen-Befehl der <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> -Methode zugewiesen wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die <xref:System.Windows.Interop.D3DImage.PixelHeight%2A> -Eigenschaft verwendet wird, um den geänderten Bereich im Hintergrund Puffer anzugeben. Weitere Informationen finden Sie unter [Exemplarische Vorgehensweise: Hosting von von Direct3D9-Inhalten in](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)WPF.  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.PixelWidth" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <Member MemberName="PixelWidth">
      <MemberSignature Language="C#" Value="public int PixelWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PixelWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.PixelWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PixelWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PixelWidth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PixelWidth : int" Usage="System.Windows.Interop.D3DImage.PixelWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Breite des <see cref="T:System.Windows.Interop.D3DImage" /> in Pixel ab.</summary>
        <value>Die Breite des <see cref="T:System.Windows.Interop.D3DImage" /> in Pixel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert von <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> kann sich ändern, wenn ein neuer BackBuffer durch einen-Befehl der <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> -Methode zugewiesen wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die <xref:System.Windows.Interop.D3DImage.PixelWidth%2A> -Eigenschaft verwendet wird, um den geänderten Bereich im Hintergrund Puffer anzugeben. Weitere Informationen finden Sie unter [Exemplarische Vorgehensweise: Hosting von von Direct3D9-Inhalten in](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)WPF.  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.PixelHeight" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBackBuffer">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Weist eine Direct3D-Oberfläche als Quelle des Hintergrundpuffers zu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBackBuffer">
      <MemberSignature Language="C#" Value="public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBackBuffer(valuetype System.Windows.Interop.D3DResourceType backBufferType, native int backBuffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBackBuffer (backBufferType As D3DResourceType, backBuffer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBackBuffer(System::Windows::Interop::D3DResourceType backBufferType, IntPtr backBuffer);" />
      <MemberSignature Language="F#" Value="member this.SetBackBuffer : System.Windows.Interop.D3DResourceType * nativeint -&gt; unit" Usage="d3DImage.SetBackBuffer (backBufferType, backBuffer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backBufferType" Type="System.Windows.Interop.D3DResourceType" />
        <Parameter Name="backBuffer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="backBufferType">Der Typ der Direct3D-Oberfläche. Muss ein gültiger <see cref="T:System.Windows.Interop.D3DResourceType" /> sein.</param>
        <param name="backBuffer">Die Direct3D-Oberfläche, die als Hintergrundpuffer zugewiesen werden soll.</param>
        <summary>Weist eine Direct3D-Oberfläche als Quelle des Hintergrundpuffers zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenden Sie <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> die-Methode an, um dem Hintergrund Puffer eine Direct3D-Oberfläche zuzuweisen.  
  
> [!NOTE]
>  Die Leistung hängt stark von den Einstellungen der Direct3D-Oberfläche ab. Weitere Informationen finden Sie unter [Überlegungen zur Leistung bei der von Direct3D9-und WPF-Interoperabilität](~/docs/framework/wpf/advanced/performance-considerations-for-direct3d9-and-wpf-interoperability.md).  
  
 Das Aufrufen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> der-Überladung ist identisch <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> mit dem Aufruf `enableSoftwareFallback` der-über `false`Ladung, bei der der-Parameter auf Wenn Sie aufrufen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> oder aufrufen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> , wobei `enableSoftwareFallback` der-Parameter `false`auf festgelegt ist, gibt das Renderingsystem seinen Verweis auf den Hintergrund Puffer frei, wenn der Frontpuffer nicht verfügbar ist und nichts angezeigt wird. Wenn der Front-Puffer wieder verfügbar ist, löst das Renderingsystem das-Ereignis aus, um die <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> WPF-Anwendung zu benachrichtigen.  Sie können einen Ereignishandler für das- <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Ereignis erstellen, um das Rendering erneut mit einer gültigen Direct3D-Oberfläche zu starten. Um das Rendering neu zu starten, <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>müssen Sie aufzurufen.  
  
 In der folgenden Liste werden die erforderlichen Einstellungen für den Hintergrund `IDirect3DSurface9` Puffer für den-Typ angezeigt.  
  
-   `D3DFMT_A8R8G8B8` oder `D3DFMT_X8R8G8B8`  
  
-   `D3DUSAGE_RENDERTARGET`  
  
-   `D3DPOOL_DEFAULT`  
  
 Multisampling ist nur auf `IDirect3DSurface9Ex` Oberflächen zulässig.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> -Methode aufgerufen wird, um eine Direct3D-Oberfläche zuzuweisen. Weitere Informationen finden Sie unter [Exemplarische Vorgehensweise: Hosting von von Direct3D9-Inhalten in](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)WPF.  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das <see cref="T:System.Windows.Interop.D3DImage" /> wurde nicht durch einen Aufruf der <see cref="M:System.Windows.Interop.D3DImage.Lock" />-Methode oder der <see cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />-Methode gesperrt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="backBufferType" /> ist kein gültiger <see cref="T:System.Windows.Interop.D3DResourceType" />.</exception>
        <exception cref="T:System.ArgumentException">Die Erstellungsparameter für <paramref name="backBuffer" /> erfüllen nicht die Anforderungen für <paramref name="backBufferType" /> oder die <paramref name="backBuffer" />-Einheit ist ungültig.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwaltete Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugehörige Enumeration:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="SetBackBuffer">
      <MemberSignature Language="C#" Value="public void SetBackBuffer (System.Windows.Interop.D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBackBuffer(valuetype System.Windows.Interop.D3DResourceType backBufferType, native int backBuffer, bool enableSoftwareFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBackBuffer (backBufferType As D3DResourceType, backBuffer As IntPtr, enableSoftwareFallback As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBackBuffer(System::Windows::Interop::D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);" />
      <MemberSignature Language="F#" Value="member this.SetBackBuffer : System.Windows.Interop.D3DResourceType * nativeint * bool -&gt; unit" Usage="d3DImage.SetBackBuffer (backBufferType, backBuffer, enableSoftwareFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backBufferType" Type="System.Windows.Interop.D3DResourceType" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="backBuffer" Type="System.IntPtr" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="enableSoftwareFallback" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="backBufferType">Der Typ der Direct3D-Oberfläche. Muss ein gültiger <see cref="T:System.Windows.Interop.D3DResourceType" /> sein.</param>
        <param name="backBuffer">Die Direct3D-Oberfläche, die als Hintergrundpuffer zugewiesen werden soll.</param>
        <param name="enableSoftwareFallback"><see langword="true" />, um auf Softwarerendering zurückzugreifen; andernfalls <see langword="false" />.</param>
        <summary>Weist eine Direct3D-Oberfläche als Quelle des Hintergrundpuffers zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%29> Sie die-Überladung aufrufen oder <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> die-über `enableSoftwareFallback` Ladung aufrufen, `false`wobei der-Parameter auf festgelegt ist, gibt das Renderingsystem seinen Verweis auf den Hintergrund Puffer frei, wenn der Frontpuffer nicht mehr verfügbar ist gestellte. Wenn der Front-Puffer wieder verfügbar ist, löst das Renderingsystem das-Ereignis aus, um die <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> WPF-Anwendung zu benachrichtigen.  Sie können einen Ereignishandler für das- <xref:System.Windows.Interop.D3DImage.IsFrontBufferAvailableChanged> Ereignis erstellen, um das Rendering erneut mit einer gültigen Direct3D-Oberfläche zu starten. Um das Rendering neu zu starten, <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A>müssen Sie aufzurufen.  
  
 Wenn Sie aufrufen <xref:System.Windows.Interop.D3DImage.SetBackBuffer%28System.Windows.Interop.D3DResourceType%2CSystem.IntPtr%2CSystem.Boolean%29> , `enableSoftwareFallback` wobei der-Parameter `true`auf festgelegt ist, behält das Renderingsystem seinen Verweis auf den Hintergrund Puffer bei, wenn der Frontpuffer nicht mehr <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> verfügbar ist. Daher muss nicht aufgerufen werden, wenn der vordere Puffer ist. wieder verfügbar.  Es kann Situationen geben, in denen das Gerät des Benutzers nicht mehr verfügbar ist.  Wenn dies auftritt, wird <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> aufgerufen, um den WPF-Verweis auf den Hintergrund Puffer freizugeben.  Wenn Sie Ihr Gerät zurücksetzen müssen, können <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> Sie `backBuffer` mit auf `null`festlegen und dann erneut <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> aufzurufen `backBuffer` , wobei auf eine gültige Direct3D-Oberfläche festgelegt ist.  
  
 In der folgenden Liste werden die erforderlichen Einstellungen für den Hintergrund `IDirect3DSurface9` Puffer für den-Typ angezeigt.  
  
-   `D3DFMT_A8R8G8B8` oder `D3DFMT_X8R8G8B8`  
  
-   `D3DUSAGE_RENDERTARGET`  
  
-   `D3DPOOL_DEFAULT`  
  
 Multisampling ist nur auf `IDirect3DSurface9Ex` Oberflächen zulässig.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryLock">
      <MemberSignature Language="C#" Value="public bool TryLock (System.Windows.Duration timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryLock(valuetype System.Windows.Duration timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryLock (timeout As Duration) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryLock(System::Windows::Duration timeout);" />
      <MemberSignature Language="F#" Value="member this.TryLock : System.Windows.Duration -&gt; bool" Usage="d3DImage.TryLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Windows.Duration" />
      </Parameters>
      <Docs>
        <param name="timeout">Der Zeitraum, über den auf den Erhalt der Sperre gewartet werden soll.</param>
        <summary>Versucht, das <see cref="T:System.Windows.Interop.D3DImage" /> zu sperren, und wartet den angegebenen Zeitraum ab.</summary>
        <returns><see langword="true" />, wenn die Sperre erhalten wurde, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Für <paramref name="timeout" /> ist <see cref="P:System.Windows.Duration.Automatic" /> festgelegt.</exception>
        <exception cref="T:System.InvalidOperationException">Die Sperrenanzahl ist gleich <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public void Unlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.D3DImage.Unlock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unlock();" />
      <MemberSignature Language="F#" Value="member this.Unlock : unit -&gt; unit" Usage="d3DImage.Unlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verringert die Sperrenanzahl für das <see cref="T:System.Windows.Interop.D3DImage" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Sperrenanzahl für <xref:System.Windows.Interop.D3DImage> den Null erreicht <xref:System.Windows.Interop.D3DImage> , wird vollständig entsperrt. Der <xref:System.Windows.Interop.D3DImage> ist für das Rendering gekennzeichnet, wenn sich das Bild in den von vorherigen Aufrufen der <xref:System.Windows.Interop.D3DImage.AddDirtyRect%2A> -Methode angegebenen Bereichen geändert hat.  
  
 Wenn für die Änderungen ein Commit ausgeführt wird und das Rendering stattfindet <xref:System.Windows.Interop.D3DImage.Lock%2A> , werden zusätzliche Aufrufe der-Methode blockiert, bis der Renderthread den Inhalt des Hintergrund Puffers in den Vordergrund Puffer kopiert hat. Diese Synchronisierung vermeidet Elemente, z. b. das Zerreißen, anzuzeigen.  
  
> [!NOTE]
>  Aktualisieren Sie die Direct3D-Oberfläche nicht <xref:System.Windows.Interop.D3DImage> , während der entsperrt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die <xref:System.Windows.Interop.D3DImage.Unlock%2A> -Methode aufgerufen wird, um den aktualisierten Hintergrund Puffer in den Vordergrund Puffer zu kopieren. Weitere Informationen finden Sie unter [Exemplarische Vorgehensweise: Hosting von von Direct3D9-Inhalten in](~/docs/framework/wpf/advanced/walkthrough-hosting-direct3d9-content-in-wpf.md)WPF.  
  
 [!code-csharp[System.Windows.Interop.D3DImage#3](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Interop.D3DImage/CS/window1.xaml.cs#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Interop.D3DImage.Lock" />
        <altmember cref="M:System.Windows.Interop.D3DImage.TryLock(System.Windows.Duration)" />
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public override sealed double Width { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.D3DImage.Width" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable ReadOnly Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Width : double" Usage="System.Windows.Interop.D3DImage.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Breite des <see cref="T:System.Windows.Interop.D3DImage" /> ab.</summary>
        <value>Die Breite des <see cref="T:System.Windows.Interop.D3DImage" /> in Maßeinheiten. Eine Maßeinheit ist 1/96 Zoll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert von <xref:System.Windows.Interop.D3DImage.Width%2A> kann sich ändern, wenn ein neuer BackBuffer durch einen-Befehl der <xref:System.Windows.Interop.D3DImage.SetBackBuffer%2A> -Methode zugewiesen wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Interop.D3DImage.Height" />
        <altmember cref="M:System.Windows.Interop.D3DImage.SetBackBuffer(System.Windows.Interop.D3DResourceType,System.IntPtr)" />
      </Docs>
    </Member>
  </Members>
</Type>
