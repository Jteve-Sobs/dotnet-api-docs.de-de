<Type Name="XName" FullName="System.Xml.Linq.XName">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0053d2fc533e31d7991966191315d87239e52709" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75181188" /></Metadata><TypeSignature Language="C#" Value="public sealed class XName : IEquatable&lt;System.Xml.Linq.XName&gt;, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit XName extends System.Object implements class System.IEquatable`1&lt;class System.Xml.Linq.XName&gt;, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XName" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class XName&#xA;Implements IEquatable(Of XName), ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class XName sealed : IEquatable&lt;System::Xml::Linq::XName ^&gt;, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type XName = class&#xA;    interface IEquatable&lt;XName&gt;&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xml.Linq.XName&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.Serialization.KnownType(typeof(System.Xml.Linq.NameSerializer))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Namen eines XML-Elements oder -Attributs dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XML-Namen enthalten einen Namespace und einen lokalen Namen. Ein *voll qualifizierter Name* ist die Kombination aus dem Namespace und dem lokalen Namen.  
  
## <a name="creating-an-xname-object"></a>Erstellen eines XName-Objekts  
 <xref:System.Xml.Linq.XName> enthält keine öffentlichen Konstruktoren. Stattdessen stellt diese Klasse eine implizite Konvertierung von <xref:System.String> bereit, die es Ihnen ermöglicht, eine <xref:System.Xml.Linq.XName>zu erstellen. Diese Konvertierung wird am häufigsten verwendet, wenn ein Element oder Attribut erstellt wird: das erste Argument für den <xref:System.Xml.Linq.XElement> Konstruktor ist ein <xref:System.Xml.Linq.XName>. Durch die Übergabe einer Zeichenfolge profitieren Sie von der impliziten Konvertierung. Der folgende Code erstellt ein Element mit einem Namen, der sich in keinem Namespace befindet:  
  
```csharp  
XElement root = new XElement("ElementName", "content");  
Console.WriteLine(root);  
```  
  
 In Visual Basic ist die Verwendung von XML-Literalen besser geeignet:  
  
```vb  
Dim root As XElement = <ElementName>content</ElementName>  
Console.WriteLine(root)  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```xml  
<ElementName>content</ElementName>  
```  
  
 Wenn Sie einer <xref:System.Xml.Linq.XName> eine Zeichenfolge zuweisen, wird die implizite Konvertierung von <xref:System.String>verwendet.  
  
 Das Visual Basic Beispiel erstellt die <xref:System.Xml.Linq.XElement> mithilfe von XML-Literalen. Obwohl XML-Literale verwendet werden, wird für die <xref:System.Xml.Linq.XElement>ein <xref:System.Xml.Linq.XName>-Objekt erstellt.  
  
 Außerdem können Sie die <xref:System.Xml.Linq.XName.Get%2A>-Methode für ein <xref:System.Xml.Linq.XName>-Objekt aufzurufen. Die empfohlene Vorgehensweise ist jedoch die Verwendung der impliziten Konvertierung aus einer Zeichenfolge.  
  
## <a name="creating-an-xname-in-a-namespace"></a>Erstellen eines XName in einem Namespace  
 Wie bei XML kann sich ein <xref:System.Xml.Linq.XName> in einem Namespace oder in keinem Namespace befinden.  
  
 Für C#ist die empfohlene Vorgehensweise zum Erstellen einer <xref:System.Xml.Linq.XName> in einem Namespace das Deklarieren des <xref:System.Xml.Linq.XNamespace> Objekts und das anschließende Überschreiben des Additions Operators.  
  
 Für Visual Basic ist die empfohlene Vorgehensweise die Verwendung von XML-Literalen und globalen Namespace Deklarationen zum Erstellen von XML-Code, der sich in einem Namespace befindet.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "ElementName", "content");  
Console.WriteLine(root);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <ElementName>content</ElementName>  
        Console.WriteLine(root)  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```xml  
<ElementName xmlns="http://www.adventure-works.com">content</ElementName>  
```  
  
## <a name="creating-an-xname-in-no-namespace"></a>Erstellen eines XName in keinem Namespace  
 Die <xref:System.Xml.Linq.XName.Namespace%2A>-Eigenschaft eines <xref:System.Xml.Linq.XName> Objekts ist garantiert nicht NULL. Wenn die <xref:System.Xml.Linq.XName> keinen Namespace hat, wird die Eigenschaft <xref:System.Xml.Linq.XName.Namespace%2A> auf <xref:System.Xml.Linq.XNamespace.None%2A>festgelegt. Dies veranschaulicht der folgende Code:  
  
```csharp  
XElement root = new XElement("ElementName", "content");  
if (root.Name.Namespace == XNamespace.None)  
    Console.WriteLine("The element is in no namespace.");  
else  
    Console.WriteLine("The element is in a namespace.");  
```  
  
```vb  
Dim root As XElement = <ElementName>content</ElementName>  
If (root.Name.Namespace Is XNamespace.None) Then  
    Console.WriteLine("The element is in no namespace.")  
Else  
    Console.WriteLine("The element is in a namespace.")  
End If  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
The element is in no namespace.  
```  
  
## <a name="using-expanded-names"></a>Verwenden erweiterter Namen  
 Sie können auch eine <xref:System.Xml.Linq.XName> aus einem erweiterten XML-Namen im Formular `{namespace}localname`erstellen:  
  
```csharp  
XElement root = new XElement("{http://www.adventure-works.com}ElementName", "content");  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement = New XElement("{http://www.adventure-works.com}ElementName", "content")  
Console.WriteLine(root)  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```xml  
<ElementName xmlns="http://www.adventure-works.com">content</ElementName>  
```  
  
 Beachten Sie, dass das Erstellen einer <xref:System.Xml.Linq.XName> über einen erweiterten Namen weniger effizient ist als das Erstellen eines <xref:System.Xml.Linq.XNamespace> Objekts und das Verwenden der außer Kraft setzung des Additions Operators. Es ist auch weniger effizient als das Importieren eines globalen Namespace und das Verwenden von XML-Literalen in Visual Basic.  
  
 Wenn Sie einen <xref:System.Xml.Linq.XName> mit einem erweiterten Namen erstellen, muss LINQ to XML die atomisierte Instanz eines Namespaces finden. Diese Arbeit muss für jede Verwendung eines erweiterten Namens wiederholt werden. Diese zusätzliche Zeit ist wahrscheinlich unerheblich, wenn LINQ-Abfragen geschrieben werden. Dies kann jedoch beim Erstellen einer großen XML-Struktur von Bedeutung sein.  
  
## <a name="xname-objects-are-atomized"></a>XName-Objekte sind atomisiert.  
 <xref:System.Xml.Linq.XName> Objekte werden garantiert atomisiert. Das heißt, wenn zwei <xref:System.Xml.Linq.XName> Objekte genau denselben Namespace und genau denselben lokalen Namen aufweisen, verwenden Sie dieselbe Instanz gemeinsam. Die Gleichheits-und Vergleichs Operatoren werden ebenfalls explizit zu diesem Zweck bereitgestellt.  
  
 Diese Funktion ermöglicht neben anderen Vorteilen eine schnellere Ausführung von Abfragen. Beim Filtern nach dem Namen von Elementen oder Attributen wird bei den in Prädikaten ausgedrückten vergleichen der Identitäts Vergleich und kein Wert Vergleich verwendet. Es ist viel schneller zu bestimmen, dass zwei Verweise tatsächlich auf das gleiche Objekt verweisen, als zwei Zeichen folgen zu vergleichen.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
  </Docs>
  <Members>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xName.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Die <see cref="T:System.Xml.Linq.XName" />, die mit der aktuellen <see cref="T:System.Xml.Linq.XName" /> verglichen werden soll.</param>
        <summary>Bestimmt, ob der angegebene <see cref="T:System.Xml.Linq.XName" /> und dieser <see cref="T:System.Xml.Linq.XName" /> gleich sind.</summary>
        <returns><see langword="true" />, wenn der angegebene <see cref="T:System.Xml.Linq.XName" /> und der aktuelle <see cref="T:System.Xml.Linq.XName" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Damit zwei <xref:System.Xml.Linq.XName> Objekte gleich sind, müssen Sie denselben erweiterten Namen aufweisen.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Get">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Xml.Linq.XName" />-Objekt ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bietet über Ladungen, die es Ihnen ermöglichen, eine <xref:System.Xml.Linq.XName> aus einem erweiterten XML-Namen zu erstellen. Sie können eine <xref:System.Xml.Linq.XName> aus einer Zeichenfolge im Formular `{namespace}localname`oder einem Namespace und einem lokalen Namen erstellen, die separat angegeben werden.  
  
 Eine weitaus allgemeinere und einfachere Möglichkeit zum Erstellen eines <xref:System.Xml.Linq.XName> ist die Verwendung der impliziten Konvertierung aus einer Zeichenfolge. Um einen Namen zu erstellen, der sich in einem Namespace befindet, verwenden Sie die Additions Operator Überladung, die es Ihnen ermöglicht, ein <xref:System.Xml.Linq.XNamespace> Objekt und eine Zeichenfolge zu kombinieren.  
  
 Weitere Informationen und Beispiele finden Sie unter Gewusst [wie: Erstellen eines Dokuments mit Namespaces (C#) (LINQ to XML)](https://msdn.microsoft.com/library/af4a595e-ffb2-4187-a61b-d5ed71642c4c).  
  
 Weitere Informationen zur Verwendung von Namespaces in Visual Basic finden Sie unter [Namespaces in Visual Basic (LINQ to XML)](https://msdn.microsoft.com/library/10b7ba7b-518c-4f14-899f-892575d14dcc).  
  
 Da <xref:System.Xml.Linq.XName> Objekte atomisiert sind, verweist die zugewiesene Variable auf den vorhandenen <xref:System.Xml.Linq.XName>, wenn eine vorhandene <xref:System.Xml.Linq.XName> mit exakt demselben Namen vorhanden ist. Wenn keine <xref:System.Xml.Linq.XName>vorhanden ist, wird eine neue erstellt und initialisiert.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XName Get (string expandedName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XName Get(string expandedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.Get(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Get (expandedName As String) As XName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XName ^ Get(System::String ^ expandedName);" />
      <MemberSignature Language="F#" Value="static member Get : string -&gt; System.Xml.Linq.XName" Usage="System.Xml.Linq.XName.Get expandedName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expandedName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expandedName">Ein <see cref="T:System.String" />, der einen erweiterten XML-Namen im Format <c>{namespace}localname</c> enthält.</param>
        <summary>Ruft ein <see cref="T:System.Xml.Linq.XName" />-Objekt aus einem erweiterten Namen ab.</summary>
        <returns>Ein <see cref="T:System.Xml.Linq.XName" />-Objekt, das aus dem erweiterten Namen erstellt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode enthält über Ladungen, mit denen Sie eine <xref:System.Xml.Linq.XName>erstellen können. Sie können Sie aus einem erweiterten XML-Namen im Formular `{namespace}localname`oder einem Namespace und einem lokalen Namen erstellen, die separat angegeben werden.  
  
 Eine weitaus allgemeinere und einfachere Möglichkeit zum Erstellen eines <xref:System.Xml.Linq.XName> ist die Verwendung der impliziten Konvertierung aus einer Zeichenfolge.  
  
 Da <xref:System.Xml.Linq.XName> atomisiert sind, verweist die zugewiesene Variable auf den vorhandenen <xref:System.Xml.Linq.XName>, wenn ein vorhandener <xref:System.Xml.Linq.XName> mit exakt demselben Namen vorhanden ist. Wenn keine <xref:System.Xml.Linq.XName>vorhanden ist, wird eine neue erstellt und initialisiert.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung dieser Methode.  
  
```csharp  
XName name = XName.Get("{http://www.adventure-works.com}Root");  
XElement el = new XElement(name, "content");  
Console.WriteLine(el);  
  
// This is the preferred approach for specifying the XName in the  
// constructor of XElement.  
XNamespace aw = "http://www.adventure-works.com";  
XElement el2 = new XElement(aw + "Root", "content");  
Console.WriteLine(el2);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim name As XName = XName.Get("{http://www.adventure-works.com}Root")  
        Dim el As XElement = New XElement(name, "content")  
        Console.WriteLine(el)  
  
        ' The preferred approach for specifying an XName in a namespace  
        ' for Visual Basic is to import a global namespace.  
        Dim el2 As XElement = <Root>content</Root>  
        Console.WriteLine(el2)  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
<Root xmlns="http://www.adventure-works.com">content</Root>  
<Root xmlns="http://www.adventure-works.com">content</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XName Get (string localName, string namespaceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XName Get(string localName, string namespaceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Get (localName As String, namespaceName As String) As XName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XName ^ Get(System::String ^ localName, System::String ^ namespaceName);" />
      <MemberSignature Language="F#" Value="static member Get : string * string -&gt; System.Xml.Linq.XName" Usage="System.Xml.Linq.XName.Get (localName, namespaceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Ein lokaler (nicht qualifizierter) Name.</param>
        <param name="namespaceName">Ein XML-Namespace.</param>
        <summary>Ruft ein <see cref="T:System.Xml.Linq.XName" />-Objekt aus einem lokalen Namen und einem Namespace ab.</summary>
        <returns>Ein aus dem angegebenen lokalen Namen und Namespace erstelltes <see cref="T:System.Xml.Linq.XName" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode enthält über Ladungen, mit denen Sie eine <xref:System.Xml.Linq.XName>erstellen können. Sie können Sie aus einem erweiterten XML-Namen im Formular `{namespace}localname`oder einem Namespace und einem lokalen Namen erstellen, die separat angegeben werden.  
  
 Eine weitaus allgemeinere und einfachere Möglichkeit zum Erstellen eines <xref:System.Xml.Linq.XName> ist die Verwendung der impliziten Konvertierung aus einer Zeichenfolge.  
  
 Da <xref:System.Xml.Linq.XName> atomisiert sind, verweist die zugewiesene Variable auf den vorhandenen <xref:System.Xml.Linq.XName>, wenn ein vorhandener <xref:System.Xml.Linq.XName> mit exakt demselben Namen vorhanden ist. Wenn keine <xref:System.Xml.Linq.XName>vorhanden ist, wird eine neue erstellt und initialisiert.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung dieser Methode.  
  
```csharp  
XName name = XName.Get("Root", "http://www.adventure-works.com");  
XElement el = new XElement(name, "content");  
Console.WriteLine(el);  
  
// This is the preferred form.  
XNamespace aw = "http://www.adventure-works.com";  
XElement el2 = new XElement(aw + "Root", "content");  
Console.WriteLine(el2);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim name As XName = XName.Get("{http://www.adventure-works.com}Root")  
        Dim el As XElement = New XElement(name, "content")  
        Console.WriteLine(el)  
  
        ' The preferred approach for specifying an XName in a namespace  
        ' for Visual Basic is to import a global namespace.  
        Dim el2 As XElement = <Root>content</Root>  
        Console.WriteLine(el2)  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
<Root xmlns="http://www.adventure-works.com">content</Root>  
<Root xmlns="http://www.adventure-works.com">content</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xName.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Hashcode für diese <see cref="T:System.Xml.Linq.XName" /> ab.</summary>
        <returns>Ein <see cref="T:System.Int32" />-Wert, der den Hashcode für den <see cref="T:System.Xml.Linq.XName" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode dient als Hash Funktion für <xref:System.Xml.Linq.XName>. Sie können <xref:System.Xml.Linq.XName.GetHashCode%2A> in Hash Algorithmen oder in Datenstrukturen (z. b. in einer Hash Tabelle) verwenden.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XName.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.Linq.XName.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den lokalen (nicht qualifizierten) Teil des Namens ab.</summary>
        <value>Ein <see cref="T:System.String" />, der den lokalen (nicht qualifizierten) Teil des Namens enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es ist garantiert, dass diese Eigenschaft nicht `null`wird.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung dieser Eigenschaft.  
  
```csharp  
XNamespace ns = "http://www.adventure-works.com";  
XElement root = new XElement(ns + "Root", "content");  
Console.WriteLine(root.Name);  
Console.WriteLine(root.Name.LocalName);  
Console.WriteLine(root.Name.Namespace);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <Root/>  
        Console.WriteLine(root.Name)  
        Console.WriteLine(root.Name.LocalName)  
        Console.WriteLine(root.Name.Namespace)  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
{http://www.adventure-works.com}Root  
Root  
http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.Linq.XName.Namespace" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNamespace Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XNamespace Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XName.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Namespace As XNamespace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XNamespace ^ Namespace { System::Xml::Linq::XNamespace ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : System.Xml.Linq.XNamespace" Usage="System.Xml.Linq.XName.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNamespace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namespaceteil des vollqualifizierten Namens ab.</summary>
        <value>Ein <see cref="T:System.Xml.Linq.XNamespace" />, der den Namespaceteil des Namens enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es ist gewährleistet, dass die <xref:System.Xml.Linq.XName.Namespace%2A>-Eigenschaft nicht `null` ist. Wenn eine <xref:System.Xml.Linq.XName> keinen Namespace hat, gibt diese Eigenschaft <xref:System.Xml.Linq.XNamespace.None%2A>zurück.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung dieser Eigenschaft.  
  
```csharp  
XNamespace ns = "http://www.adventure-works.com";  
XElement root = new XElement(ns + "Root", "content");  
Console.WriteLine(root.Name);  
Console.WriteLine(root.Name.LocalName);  
Console.WriteLine(root.Name.Namespace);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <Root/>  
        Console.WriteLine(root.Name)  
        Console.WriteLine(root.Name.LocalName)  
        Console.WriteLine(root.Name.Namespace)  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
{http://www.adventure-works.com}Root  
Root  
http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="NamespaceName">
      <MemberSignature Language="C#" Value="public string NamespaceName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XName.NamespaceName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NamespaceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ NamespaceName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamespaceName : string" Usage="System.Xml.Linq.XName.NamespaceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt den URI des <see cref="T:System.Xml.Linq.XNamespace" /> für diesen <see cref="T:System.Xml.Linq.XName" /> zurück.</summary>
        <value>Der URI des <see cref="T:System.Xml.Linq.XNamespace" /> für diesen <see cref="T:System.Xml.Linq.XName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine bequeme Eigenschaft, um den Namespace Namen aus einer <xref:System.Xml.Linq.XName>zu erhalten.  
  
   
  
## Examples  
 In diesem Beispiel wird ein-Element in einem-Namespace erstellt, und anschließend wird der Namespace des Elements ausgegeben.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root");  
Console.WriteLine(root.Name.NamespaceName);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <Root/>  
        Console.WriteLine(root.Name.NamespaceName)  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xml.Linq.XName left, System.Xml.Linq.XName right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xml.Linq.XName left, class System.Xml.Linq.XName right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As XName, right As XName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xml::Linq::XName ^ left, System::Xml::Linq::XName ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xml.Linq.XName * System.Xml.Linq.XName -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Xml.Linq.XName" />
        <Parameter Name="right" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende <see cref="T:System.Xml.Linq.XName" />.</param>
        <param name="right">Der zweite zu vergleichende <see cref="T:System.Xml.Linq.XName" />.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei Instanzen von <see cref="T:System.Xml.Linq.XName" /> gleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die überladenen `==` und `!=` eingeschlossen, um Vergleiche zwischen <xref:System.Xml.Linq.XName> und ein `string`, wie z. B.`element.Name == "SomeElementName"` Die vordefinierten Verweis Gleichheits Operatoren in C# erfordern, dass ein Operand nur durch Verweis Konvertierungen in den Typ des anderen konvertierbar ist. Diese Operatoren können die implizite Konvertierung von String in <xref:System.Xml.Linq.XName>nicht in Erwägung gezogen.  
  
## Examples  
 Das folgende Beispiel zeigt einige Vergleiche zwischen <xref:System.Xml.Linq.XName> Objekten und Zeichen folgen.  
  
```csharp  
XName xn;  
xn = XName.Get("Root");  
Console.WriteLine(xn == "Root");  
  
xn = XName.Get("Root", "http://www.adventure-works.com");  
Console.WriteLine(xn == "{http://www.adventure-works.com}Root");  
  
XElement root = new XElement("Root", "content");  
Console.WriteLine(root.Name == "Root");  
```  
  
```vb  
Dim xn As XName  
xn = XName.Get("Root")  
Console.WriteLine(xn = "Root")  
  
xn = XName.Get("Root", "http://www.adventure-works.com")  
Console.WriteLine(xn = "{http://www.adventure-works.com}Root")  
  
Dim root As XElement = New XElement("Root", "content")  
Console.WriteLine(root.Name = "Root")  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
True  
True  
True  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Xml.Linq.XName (string expandedName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Xml.Linq.XName op_Implicit(string expandedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.op_Implicit(System.String)~System.Xml.Linq.XName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (expandedName As String) As XName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Xml::Linq::XName ^(System::String ^ expandedName);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; System.Xml.Linq.XName" Usage="System.Xml.Linq.XName.op_Implicit expandedName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expandedName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expandedName">Eine Zeichenfolge, die einen erweiterten XML-Namen im Format <c>{namespace}localname</c> enthält.</param>
        <summary>Konvertiert eine als erweiterter XML-Name (d.h. <c>{namespace}localname</c>) formatierte Zeichenfolge in ein <see cref="T:System.Xml.Linq.XName" />-Objekt.</summary>
        <returns>Ein <see cref="T:System.Xml.Linq.XName" />-Objekt, das aus dem erweiterten Namen erstellt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie verwenden diesen impliziten Operator, wenn Sie eine <xref:System.Xml.Linq.XElement> oder <xref:System.Xml.Linq.XAttribute> erstellen, indem Sie eine Zeichenfolge an den entsprechenden Konstruktor übergeben.  
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Xml.Linq.XName> erstellt, indem ihr eine Zeichenfolge zugewiesen wird, die diesen impliziten Konvertierungs Operator aufruft.  
  
```csharp  
XElement el = new XElement("{http://www.adventure-works.com}Root", "content");  
Console.WriteLine(el);  
  
// The preferred approach is to initialize an XNamespace object  
// and use the overload of the addition operator.  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root", "content");  
Console.WriteLine(root);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim el As XElement = New XElement("{http://www.adventure-works.com}Root", "content")  
        Console.WriteLine(el)  
  
        ' The preferred approach is to import a global namespace and   
        ' use an XML literal.  
        Dim root As XElement = <Root>content</Root>  
        Console.WriteLine(root)  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
<Root xmlns="http://www.adventure-works.com">content</Root>  
<Root xmlns="http://www.adventure-works.com">content</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xml.Linq.XName left, System.Xml.Linq.XName right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xml.Linq.XName left, class System.Xml.Linq.XName right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As XName, right As XName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xml::Linq::XName ^ left, System::Xml::Linq::XName ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xml.Linq.XName * System.Xml.Linq.XName -&gt; bool" Usage="System.Xml.Linq.XName.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Xml.Linq.XName" />
        <Parameter Name="right" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende <see cref="T:System.Xml.Linq.XName" />.</param>
        <param name="right">Der zweite zu vergleichende <see cref="T:System.Xml.Linq.XName" />.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei Instanzen von <see cref="T:System.Xml.Linq.XName" /> ungleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die überladenen `==` und `!=` eingeschlossen, um Vergleiche zwischen <xref:System.Xml.Linq.XName> und eine Zeichenfolge, z. B.`element.Name == "SomeElementName"` Die vordefinierten Verweis Gleichheits Operatoren in C# erfordern, dass ein Operand nur durch Verweis Konvertierungen in den Typ des anderen konvertierbar ist. Diese Operatoren können die implizite Konvertierung von String in <xref:System.Xml.Linq.XName>nicht in Erwägung gezogen.  
  
## Examples  
 Im folgenden C# Beispiel wird ein <xref:System.Xml.Linq.XName>-Objekt mit einer Zeichenfolge verglichen, die diesen Operator aufruft.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root", "content");  
  
Console.WriteLine(root.Name != "{http://www.adventure-works.com}Root");  
  
// the following is the preferred idiom  
Console.WriteLine(root.Name != aw + "Root");  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <Root>content</Root>  
        Console.WriteLine(root.Name <> "{http://www.adventure-works.com}Root")  
  
        ' the following is the preferred idiom  
        Console.WriteLine(root.Name <> GetXmlNamespace() + "Root")  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
False  
False  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="System.IEquatable&lt;System.Xml.Linq.XName&gt;.Equals">
      <MemberSignature Language="C#" Value="bool IEquatable&lt;XName&gt;.Equals (System.Xml.Linq.XName other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IEquatable&lt;System.Xml.Linq.XName&gt;.Equals(class System.Xml.Linq.XName other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.System#IEquatable&lt;System#Xml#Linq#XName&gt;#Equals(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As XName) As Boolean Implements IEquatable(Of XName).Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IEquatable&lt;System.Xml.Linq.XName&gt;.Equals(System::Xml::Linq::XName ^ other) = IEquatable&lt;System::Xml::Linq::XName ^&gt;::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="other">Das <see cref="T:System.Xml.Linq.XName" />, das mit diesem <see cref="T:System.Xml.Linq.XName" /> verglichen werden soll.</param>
        <summary>Zeigt an, ob der aktuelle <see cref="T:System.Xml.Linq.XName" /> dem angegebenen <see cref="T:System.Xml.Linq.XName" /> entspricht.</summary>
        <returns><see langword="true" />, wenn dieser <see cref="T:System.Xml.Linq.XName" /> dem angegebenen <see cref="T:System.Xml.Linq.XName" /> entspricht, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="info">Die mit Daten zu füllende <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">Das Ziel (siehe <see cref="T:System.Runtime.Serialization.StreamingContext" />) dieser Serialisierung.</param>
        <summary>Füllt eine <see cref="T:System.Runtime.Serialization.SerializationInfo" /> mit den Daten auf, die zum Serialisieren des Zielobjekts erforderlich sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird intern zum Serialisieren von Objekt Diagrammen verwendet, die LINQ to XML-Objekte enthalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xName.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den erweiterten XML-Namen im Format <c>{namespace}localname</c> zurück.</summary>
        <returns>Ein <see cref="T:System.String" />, der den erweiterten XML-Namen im Format <c>{namespace}localname</c> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Console.WriteLine%2A>aufgerufen, wobei ein <xref:System.Xml.Linq.XName>übergeben wird. Dies bewirkt, dass die <xref:System.Xml.Linq.XName.ToString%2A>-Methode aufgerufen wird.  
  
```csharp  
XNamespace ns = "http://www.adventure-works.com";  
XElement root = new XElement(ns + "Root", "content");  
Console.WriteLine(root.Name);  
Console.WriteLine(root.Name.LocalName);  
Console.WriteLine(root.Name.Namespace);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <Root>content</Root>  
        Console.WriteLine(root.Name)  
        Console.WriteLine(root.Name.LocalName)  
        Console.WriteLine(root.Name.Namespace)  
    End Sub  
End Module  
```  
  
 Dieses Beispiel erzeugt die folgende Ausgabe:  
  
```  
{http://www.adventure-works.com}Root  
Root  
http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
  </Members>
</Type>
