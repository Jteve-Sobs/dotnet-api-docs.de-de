<Type Name="XAttribute" FullName="System.Xml.Linq.XAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="62235d92943920d446140dedc5f2fe683c584498" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83525574" /></Metadata><TypeSignature Language="C#" Value="public class XAttribute : System.Xml.Linq.XObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XAttribute extends System.Xml.Linq.XObject" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XAttribute" />
  <TypeSignature Language="VB.NET" Value="Public Class XAttribute&#xA;Inherits XObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class XAttribute : System::Xml::Linq::XObject" />
  <TypeSignature Language="F#" Value="type XAttribute = class&#xA;    inherit XObject" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.Xml.Linq" FromVersion="4.0.0.0" To="System.Xml.XDocument" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Xml.XDocument" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Xml.Linq.XObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.Xml.Linq.ComponentModel.XTypeDescriptionProvider`1&lt;System.Xml.Linq.XAttribute&gt;))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5">
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(System.Xml.Linq.ComponentModel.XTypeDescriptionProvider`1&lt;System.Xml.Linq.XAttribute&gt;))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt ein XML-Attribut dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein XML-Attribut ist ein Name-Wert-Paar, das einem XML-Element zugeordnet ist.  
  
 Jede <xref:System.Xml.Linq.XElement> enthält eine Liste der Attribute für dieses Element. Attribute müssen einen qualifizierten Namen aufweisen, der für das Element eindeutig ist. Attribute werden nicht von <xref:System.Xml.Linq.XNode>abgeleitet; Sie sind keine Knoten in der XML-Struktur. Stattdessen handelt es sich einfach um Name-Wert-Paare, die einem Element zugeordnet sind.  
  
 Attribute werden in der XML-Struktur in der Reihenfolge beibehalten, in der Sie dem-Element hinzugefügt wurden. Wenn <xref:System.Xml.Linq.XElement.Attributes%2A>eine Auflistung von Attributen zurückgibt, werden diese in der Reihenfolge zurückgegeben, in der Sie dem-Element hinzugefügt wurden, und werden nicht sortiert.  
  
 Technisch gesehen sind Namespace Deklarationen in XML keine ordnungsgemäßen Attribute. Dieser Unterschied wird jedoch normalerweise nicht von vielen XML-Programmierern getroffen. Da Namespace Deklarationen genau dieselbe XML-Syntax wie Attribute aufweisen, stellen die meisten XML-Programmierer Namespaces als Attribute dar. Um die [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] Programmierschnittstelle zu vereinfachen, werden Namespaces in der XML-Struktur als Attribute dargestellt. Solche Namespace Attribute beeinflussen die Serialisierung einer XML-Struktur. Beim Serialisieren [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] versucht, mit dem in den Namespace Attributen angegebenen Namespace Präfix zu serialisieren. Sie können den <xref:System.Xml.Linq.XAttribute.IsNamespaceDeclaration%2A> verwenden, um zu bestimmen, ob ein Attribut tatsächlich eine Namespace Deklaration ist.  
  
 Die <xref:System.Xml.Linq.XAttribute>-Klasse wird von <xref:System.Xml.Linq.XObject> abgeleitet. Sie können den Attributen Anmerkungen hinzufügen und Ereignisse für diese Elemente beobachten.  
  
 Einige <xref:System.Xml.Linq.XAttribute> Methoden können in XAML verwendet werden. Weitere Informationen finden Sie unter [Dynamische Eigenschaften in LINQ to XML](https://msdn.microsoft.com/library/0455f47c-4a68-4f2e-a3f8-dd1d85b99012).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xml.Linq.XElement" />
    <altmember cref="T:System.Xml.Linq.XDocument" />
    <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
    <related type="Article" href="https://msdn.microsoft.com/library/ab0fed32-994c-4593-b307-54aa72c6bdc3">Übersicht über die XAttribute-Klasse</related>
    <related type="Article" href="https://msdn.microsoft.com/library/0455f47c-4a68-4f2e-a3f8-dd1d85b99012">Dynamische Eigenschaften in LINQ to XML</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Xml.Linq.XAttribute" />.</summary>
        <altmember cref="P:System.Xml.Linq.XAttribute.Name" />
        <altmember cref="P:System.Xml.Linq.XAttribute.Value" />
        <altmember cref="P:System.Xml.Linq.XAttribute.NodeType" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
        <related type="Article" href="https://msdn.microsoft.com/library/ab0fed32-994c-4593-b307-54aa72c6bdc3">Übersicht über die XAttribute-Klasse</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XAttribute (System.Xml.Linq.XAttribute other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XAttribute other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.#ctor(System.Xml.Linq.XAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (other As XAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XAttribute(System::Xml::Linq::XAttribute ^ other);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XAttribute : System.Xml.Linq.XAttribute -&gt; System.Xml.Linq.XAttribute" Usage="new System.Xml.Linq.XAttribute other" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="other" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="other">Ein <see cref="T:System.Xml.Linq.XAttribute" />-Objekt, aus dem kopiert werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xml.Linq.XAttribute" />-Klasse aus einem anderen <see cref="T:System.Xml.Linq.XAttribute" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird hauptsächlich intern verwendet, wenn Sie eine tiefe Kopie einer XML-Struktur erstellen.  
  
   
  
## Examples  
 In diesem Beispiel wird veranschaulicht, dass das Erstellen einer tiefen Kopie einer XML-Struktur eine Kopie, nicht einen Klon, eines Attributs in der Struktur erstellt.  
  
```csharp  
XElement root1 = XElement.Parse("<Root Att1='abc' />");  
// Make a deep copy.  
XElement root2 = new XElement(root1);  
if (root1.Attribute("Att1") == root2.Attribute("Att1"))  
    Console.WriteLine("This will not be printed");  
else  
    Console.WriteLine("Creating a deep copy created a new attribute from the original.");  
```  
  
```vb  
Dim root1 As XElement = <Root Att1='abc'/>  
' Make a deep copy.  
Dim root2 As XElement = New XElement(root1)  
If root1.Attribute("Att1") Is root2.Attribute("Att1") Then  
    Console.WriteLine("This will not be printed")  
Else  
    Console.WriteLine("Creating a deep copy created a new attribute from the original.")  
End If  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
  
Creating a deep copy created a new attribute from the original.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="other" /> ist <see langword="null" />.</exception>
        <altmember cref="P:System.Xml.Linq.XAttribute.Name" />
        <altmember cref="P:System.Xml.Linq.XAttribute.Value" />
        <altmember cref="P:System.Xml.Linq.XAttribute.NodeType" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
        <related type="Article" href="https://msdn.microsoft.com/library/ab0fed32-994c-4593-b307-54aa72c6bdc3">Übersicht über die XAttribute-Klasse</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XAttribute (System.Xml.Linq.XName name, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.#ctor(System.Xml.Linq.XName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XAttribute(System::Xml::Linq::XName ^ name, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XAttribute : System.Xml.Linq.XName * obj -&gt; System.Xml.Linq.XAttribute" Usage="new System.Xml.Linq.XAttribute (name, value)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Der <see cref="T:System.Xml.Linq.XName" /> des Attributs.</param>
        <param name="value">Ein <see cref="T:System.Object" />, das den Wert des Attributs enthält.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xml.Linq.XAttribute" />-Klasse mit dem angegebenen Namen und Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt eine implizite Konvertierung von einer Zeichenfolge in <xref:System.Xml.Linq.XName>. Die typische Verwendung dieses Konstruktors besteht darin, eine Zeichenfolge als ersten Parameter anzugeben, anstatt wie folgt eine neue <xref:System.Xml.Linq.XName>zu erstellen:  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("AnAttributeName", "Content")  
);  
```  
  
 Sie können auch die Additions Operator Überladung mit einem <xref:System.Xml.Linq.XNamespace> und eine Zeichenfolge verwenden, um wie folgt eine <xref:System.Xml.Linq.XName>zu erstellen:  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root",  
    new XAttribute(aw + "AnAttributeName", "Content")  
);  
```  
  
 Weitere Informationen finden Sie unter [Arbeiten mit XML-Namespaces](https://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430).  
  
 Diese Vorgehensweisen funktionieren auch für Visual Basic, aber XML-Literale bieten einen besseren Ansatz für das Erstellen von XML-Strukturen.  
  
 Der `value`-Parameter kann ein <xref:System.String>, `double`, `float`, `decimal`, `bool`, <xref:System.DateTime>oder <xref:System.TimeSpan>sein. Wenn der Wert eine <xref:System.DateTime> oder <xref:System.TimeSpan>ist, wird der Wert des Attributs gemäß den W3C-Spezifikationen ordnungsgemäß formatiert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird dieser Konstruktor zum Erstellen von Attributen verwendet. Sie übergibt Zeichen folgen als erstes Argument an den <xref:System.Xml.Linq.XAttribute>-Konstruktor, der dann implizit in <xref:System.Xml.Linq.XName> Objekte konvertiert wird. Die Attribute werden einem Element hinzugefügt.  
  
```csharp  
XElement root;  
  
double dbl = 12.345;  
XAttribute[] attArray = {  
    new XAttribute("Att4", 1),  
    new XAttribute("Att5", 2),  
    new XAttribute("Att6", 3)  
};  
DateTime dt = new DateTime(2006, 10, 6, 12, 30, 00);  
  
// string content  
root = new XElement("Root",  
    new XAttribute("Att1", "Some text"),  
  
    // double content  
    new XAttribute("Att2", dbl),  
  
    // DateTime content  
    new XAttribute("Att3", dt),  
  
    // XAttribute array content  
    attArray  
);  
  
Console.WriteLine(root);  
```  
  
```vb  
Dim dbl As Double = 12.345  
Dim attArray As XAttribute() = { _  
    New XAttribute("Att4", 1), _  
    New XAttribute("Att5", 2), _  
    New XAttribute("Att6", 3) _  
}  
Dim dt As DateTime = New DateTime(2006, 10, 6, 12, 30, 0)  
Dim root As XElement = <Root Att1="Some text"  
                           Att2=<%= dbl %>  
                           Att3=<%= dt %>  
                           <%= attArray %>  
                       />  
Console.WriteLine(root)  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
  
<Root Att1="Some text" Att2="12.345" Att3="2006-10-06T12:30:00" Att4="1" Att5="2" Att6="3" />  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter oder der <paramref name="value" />-Parameter ist <see langword="null" />.</exception>
        <altmember cref="P:System.Xml.Linq.XAttribute.Name" />
        <altmember cref="P:System.Xml.Linq.XAttribute.Value" />
        <altmember cref="P:System.Xml.Linq.XAttribute.NodeType" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
        <related type="Article" href="https://msdn.microsoft.com/library/ab0fed32-994c-4593-b307-54aa72c6bdc3">Übersicht über die XAttribute-Klasse</related>
      </Docs>
    </Member>
    <Member MemberName="EmptySequence">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt; EmptySequence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XAttribute&gt; EmptySequence" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XAttribute.EmptySequence" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EmptySequence As IEnumerable(Of XAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XAttribute ^&gt; ^ EmptySequence { System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XAttribute ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EmptySequence : seq&lt;System.Xml.Linq.XAttribute&gt;" Usage="System.Xml.Linq.XAttribute.EmptySequence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XAttribute&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine leere Auflistung von Attributen ab.</summary>
        <value>Ein <see cref="T:System.Collections.Generic.IEnumerable`1" /> vom Typ <see cref="T:System.Xml.Linq.XAttribute" />, das eine leere Auflistung enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird normalerweise von Klassen Implementierungen verwendet, wenn Sie eine Methode schreiben, die eine Auflistung von Attributen zurückgibt. Wenn die Methode eine leere Auflistung von Attributen zurückgeben muss, kann diese Eigenschaft verwendet werden, um eine leere Auflistung von <xref:System.Xml.Linq.XAttribute> Objekten zu erhalten.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.Linq.XElement.EmptySequence" />
        <altmember cref="Overload:System.Xml.Linq.XAttribute.#ctor" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="IsNamespaceDeclaration">
      <MemberSignature Language="C#" Value="public bool IsNamespaceDeclaration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNamespaceDeclaration" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XAttribute.IsNamespaceDeclaration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNamespaceDeclaration As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNamespaceDeclaration { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNamespaceDeclaration : bool" Usage="System.Xml.Linq.XAttribute.IsNamespaceDeclaration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bestimmt, ob dieses Attribut eine Namespacedeklaration ist.</summary>
        <value><see langword="true" />, wenn dieses Attribut eine Namespacedeklaration ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Technisch gesehen sind Namespace Deklarationen in XML keine ordnungsgemäßen Attribute. Dieser Unterschied wird jedoch normalerweise nicht von den meisten XML-Programmierern getroffen. Da Namespace Deklarationen genau dieselbe Syntax wie Attribute aufweisen, stellen die meisten XML-Programmierer Namespaces als Attribute dar. Um die [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] Programmierschnittstelle zu vereinfachen, werden Namespaces in der XML-Struktur als Attribute dargestellt. Sie können diese Eigenschaft verwenden, um zu bestimmen, ob ein bestimmtes [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] Attribut wirklich eine Namespace Deklaration ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Attribut erstellt, das eine Namespace Deklaration und ein Attribut ist, das nicht ist. Anschließend wird diese Eigenschaft verwendet, um anzuzeigen, ob jedes Attribut eine Namespace Deklaration ist.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root",  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"),  
    new XAttribute(aw + "Att", "content")  
);  
  
foreach (XAttribute att in root.Attributes()) {  
    if (att.IsNamespaceDeclaration)  
        Console.WriteLine("{0} is a namespace declaration", att.Name);  
    else  
        Console.WriteLine("{0} is not a namespace declaration", att.Name);  
}  
```  
  
```vb  
Dim root As XElement = <aw:Root xmlns:aw='http://www.adventure-works.com'  
                           aw:Att='content'/>  
  
For Each att As XAttribute In root.Attributes()  
    If (att.IsNamespaceDeclaration) Then  
        Console.WriteLine("{0} is a namespace declaration", att.Name)  
    Else  
        Console.WriteLine("{0} is not a namespace declaration", att.Name)  
    End If  
Next  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
{http://www.w3.org/2000/xmlns/}aw is a namespace declaration  
{http://www.adventure-works.com}Att is not a namespace declaration  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Linq.XNamespace" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XName Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XName Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As XName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XName ^ Name { System::Xml::Linq::XName ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : System.Xml.Linq.XName" Usage="System.Xml.Linq.XAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den erweiterten Namen dieses Attributs ab.</summary>
        <value>Ein <see cref="T:System.Xml.Linq.XName" />, der den Namen dieses Attributs enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der von dieser Eigenschaft zurückgegebene erweiterte Name hat die Form `{namespace}localname`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein-Element mit drei Attributen erstellt. Anschließend wird diese Eigenschaft verwendet, um den Namen der einzelnen Attribute auszugeben. Das Beispiel zeigt auch die Erstellung eines neuen Attributs mit dem Namen eines vorhandenen Attributs.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root",  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"),  
    new XAttribute(aw + "Att", "content"),  
    new XAttribute("Att2", "different content")  
);  
  
foreach (XAttribute att in root.Attributes())  
    Console.WriteLine("{0}={1}", att.Name, att.Value);  
Console.WriteLine("");  
  
XElement newRoot = new XElement(aw + "Root",  
    from att in root.Attributes("Att2")  
    select new XAttribute(att.Name, "new content"));  
  
foreach (XAttribute att in newRoot.Attributes())  
    Console.WriteLine("{0}={1}", att.Name, att.Value);  
```  
  
```vb  
Dim root As XElement = _   
    <aw:Root xmlns:aw='http://www.adventure-works.com'  
        aw:Att='content'  
        Att2='different content'/>  
  
For Each att As XAttribute In root.Attributes()  
    Console.WriteLine("{0}={1}", att.Name, att.Value)  
Next  
Console.WriteLine("")  
  
Dim NewRoot As XElement = _  
<Root  
    <%= _  
        From att In root.Attributes("Att2") _  
        Select New XAttribute(att.Name, "new content") _  
    %>>_  
</Root>  
  
For Each att As XAttribute In NewRoot.Attributes()  
    Console.WriteLine("{0}={1}", att.Name, att.Value)  
Next  
  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
{http://www.w3.org/2000/xmlns/}aw=http://www.adventure-works.com  
{http://www.adventure-works.com}Att=content  
Att2=different content  
  
Att2=new content  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Linq.XName" />
        <altmember cref="P:System.Xml.Linq.XAttribute.Value" />
        <altmember cref="M:System.Xml.Linq.XAttribute.ToString" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="NextAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XAttribute NextAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XAttribute NextAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XAttribute.NextAttribute" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextAttribute As XAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XAttribute ^ NextAttribute { System::Xml::Linq::XAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NextAttribute : System.Xml.Linq.XAttribute" Usage="System.Xml.Linq.XAttribute.NextAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das nächste Attribut des übergeordneten Elements ab.</summary>
        <value>Ein <see cref="T:System.Xml.Linq.XAttribute" />, das das nächste Attribut des übergeordneten Elements enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attribute werden in der XML-Struktur in der Reihenfolge beibehalten, in der Sie dem-Element hinzugefügt wurden. Wenn <xref:System.Xml.Linq.XElement.Attributes%2A>eine Auflistung von Attributen zurückgibt, werden diese in der Reihenfolge zurückgegeben, in der Sie hinzugefügt wurden, und werden nicht sortiert. Wenn Sie das nächste Attribut über diese Eigenschaft anfordern, gibt diese Eigenschaft das Attribut zurück, das nach diesem Attribut hinzugefügt wurde.  
  
 Wenn dieses Attribut nicht über ein übergeordnetes Element verfügt oder wenn kein nächstes Attribut vorhanden ist, gibt diese Eigenschaft `null`zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die Attribute eines Elements mithilfe dieser Eigenschaft durchlaufen werden.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3),  
    new XAttribute("Att4", 4)  
);  
  
XAttribute att = root.FirstAttribute;  
do {  
    Console.WriteLine(att);  
}  
while((att = att.NextAttribute) != null);  
```  
  
```vb  
Dim root As XElement = <Root Att1="1" Att2="2" Att3="3" Att4="4"/>  
Dim att As XAttribute = root.FirstAttribute  
Dim val As Boolean = True  
Do  
    Console.WriteLine(att)  
    att = att.NextAttribute  
Loop While (Not (att Is Nothing))  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
Att1="1"  
Att2="2"  
Att3="3"  
Att4="4"  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.Linq.XAttribute.PreviousAttribute" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XAttribute.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.Linq.XAttribute.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Knotentyp für diesen Knoten ab.</summary>
        <value>Der Knotentyp. Für <see cref="T:System.Xml.Linq.XAttribute" />-Objekte ist dieser Wert <see cref="F:System.Xml.XmlNodeType.Attribute" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da alle Klassen, die von <xref:System.Xml.Linq.XObject> abgeleitet sind, eine <xref:System.Xml.Linq.XObject.NodeType%2A> Eigenschaft enthalten, können Sie Code schreiben, der auf Auflistungen einer konkreten Unterklasse von <xref:System.Xml.Linq.XObject>angewendet wird. Der Code kann dann auf den Knotentyp der einzelnen Knoten in der Auflistung testen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein-Attribut erstellt, und anschließend wird der Knotentyp mithilfe dieser Eigenschaft angezeigt.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att", "content")  
);  
  
XAttribute att = root.FirstAttribute;  
Console.WriteLine(att.NodeType);  
```  
  
```vb  
Dim root As XElement = <Root Att="content"/>  
Dim att As XAttribute = root.FirstAttribute  
Console.WriteLine(att.NodeType.ToString)  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
  
Attribute  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeType" />
        <altmember cref="T:System.Xml.Linq.XNode" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator bool (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Boolean" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator bool(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; bool" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in <see cref="T:System.Boolean" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in einen <see cref="T:System.Boolean" /> um.</summary>
        <returns>Ein <see cref="T:System.Boolean" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Konvertieren in <xref:System.Boolean> aus einem Attribut oder Element sind zulässige Werte "0", "1" und eine beliebige Zeichenfolge, die nach dem kürzen und konvertieren in Kleinbuchstaben "true" oder "false" ergibt.  
 
## Examples  
 Im folgenden Beispiel wird ein Attribut mit einem <xref:System.Boolean> Wert erstellt und dann in <xref:System.Boolean>umgewandelt.  
  
```csharp  
XElement root = new XElement("Root",   
    new XAttribute("BoolValue", true)  
);  
bool bv = (bool)root.Attribute("BoolValue");  
Console.WriteLine("(bool)BoolValue={0}", bv);  
```  
  
```vb  
Dim root As XElement = <root BoolValue="true"/>  
Dim bv As Boolean = CBool(root.Attribute("BoolValue"))  
Console.WriteLine("(bool)BoolValue={0}", bv)  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
(bool)BoolValue=True  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.Boolean" />-Wert.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="attribute" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.Boolean}" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator DateTime (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.DateTime op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.DateTime" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator DateTime(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; DateTime" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in <see cref="T:System.DateTime" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in einen <see cref="T:System.DateTime" /> um.</summary>
        <returns>Ein <see cref="T:System.DateTime" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert Bereich eines Attributs oder Elements, das Datums-und Uhrzeit Inhalte enthält, ist eng mit den in ISO 8601 beschriebenen Datums-und Uhrzeitangaben verknüpft. Beim Erstellen eines Attributs oder Elements, das Datums-und Uhrzeit Inhalte enthält, werden die Attribut-oder Element Werte gemäß der W3C-Spezifikation formatiert. Weitere Informationen finden Sie in der W3C-Spezifikation.  
  
 Das Verhalten ist Lax, wenn eine Umwandlung in eine <xref:System.DateTime> von einem Attribut oder Element erfolgt. Auch wenn der Attribut-oder Elementwert nicht exakt gemäß der W3C-Spezifikation formatiert ist, wird der Wert entsprechend in eine <xref:System.DateTime>konvertiert.  
  
 Dieser Konvertierungs Operator verwendet <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, um eine <xref:System.DateTime>zu konvertieren.  
 
## Examples  
 Im folgenden Beispiel wird ein Attribut mit Datums-und Uhrzeit Inhalt erstellt. Anschließend wird Sie in <xref:System.DateTime> umgewandelt, um den Wert abzurufen.  
  
```csharp  
// Behavior is strict when formatting an XML element or attribute from a DateTime,  
// but behavior is lax when casting to a DateTime from an element or attribute.  
  
XElement root = new XElement("Root",  
    new XAttribute("Att", new DateTime(2006, 10, 6, 12, 30, 0))  
);  
Console.WriteLine(root);  
  
// casting from a strictly formatted XML attribute  
DateTime dt = (DateTime)root.Attribute("Att");  
Console.WriteLine("dt={0}", dt);  
Console.WriteLine("-----");  
  
// if root is formatted in some different way than the standard ISO 8601, if at all possible,  
// the value is appropriately converted to DateTime  
  
XAttribute dtAtt = new XAttribute("OrderDate", "October 6, 2006");  
Console.WriteLine(dtAtt);  
DateTime orderDate = (DateTime)dtAtt;  
Console.WriteLine("OrderDate={0:d}", orderDate);  
```  
  
```vb  
' Behavior is strict when formatting an XML element or attribute from a DateTime,  
' but behavior is lax when casting to a DateTime from an element or attribute.  
Dim root As XElement = <Root Att=<%= New DateTime(2006, 10, 6, 12, 30, 0) %>/>  
  
Console.WriteLine(root)  
  
' casting from a strictly formatted XML attribute  
Dim dt As DateTime = CType(root.Attribute("Att"), DateTime)  
Console.WriteLine("dt={0}", dt)  
Console.WriteLine("-----")  
  
' if root is formatted in some different way than the standard ISO 8601, if at all possible,  
' the value is appropriately converted to DateTime  
Dim dtAtt As XAttribute = New XAttribute("OrderDate", "October 6, 2006")  
Console.WriteLine(dtAtt)  
Dim orderDate As DateTime = CType(dtAtt, DateTime)  
Console.WriteLine("OrderDate={0:d}", orderDate)  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
<Root Att="2006-10-06T12:30:00" />  
dt=10/6/2006 12:30:00 PM  
-----  
OrderDate="October 6, 2006"  
OrderDate=10/6/2006  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.DateTime" />-Wert.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="attribute" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.DateTime}" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator DateTimeOffset (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.DateTimeOffset op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.DateTimeOffset" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator DateTimeOffset(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; DateTimeOffset" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in <see cref="T:System.DateTimeOffset" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in einen <see cref="T:System.DateTimeOffset" /> um.</summary>
        <returns>Ein <see cref="T:System.DateTimeOffset" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konvertierungs Operator verwendet die <xref:System.Xml.XmlConvert>-Klasse, um die Konvertierung durchzuführen.  

## Examples  
 Im folgenden Beispiel wird ein Attribut mit Datums-und Uhrzeit Inhalt erstellt. Anschließend wird Sie in <xref:System.DateTimeOffset> umgewandelt, um den Wert abzurufen.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att", new DateTimeOffset(new DateTime(2006, 10, 6, 12, 30, 0)))  
);  
Console.WriteLine(root);  
  
// casting from a strictly formatted XML attribute  
DateTimeOffset dt = (DateTimeOffset)root.Attribute("Att");  
Console.WriteLine("dt={0}", dt);  
```  
  
```vb  
Dim root As XElement = _  
    <Root  
        Att=<%= New DateTimeOffset(New DateTime(2006, 10, 6, 12, 30, 0)) %>/>  
Console.WriteLine(root)  
  
' casting from a strictly formatted XML attribute  
Dim dt As DateTimeOffset = CType(root.Attribute("Att"), DateTimeOffset)  
Console.WriteLine("dt={0}", dt)  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
<Root Att="2006-10-06T12:30:00-07:00" />  
dt=10/6/2006 12:30:00 PM -07:00  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.DateTimeOffset" />-Wert.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="attribute" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.DateTimeOffset}" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; decimal" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in <see cref="T:System.Decimal" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in einen <see cref="T:System.Decimal" /> um.</summary>
        <returns>Ein <see cref="T:System.Decimal" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[## Examples  
 Im folgenden Beispiel wird ein Attribut mit einem Dezimalwert erstellt. Anschließend wird der Wert des-Attributs durch Umwandeln in <xref:System.Decimal>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att", "79228162514264337593543950335")  
);  
decimal value = (decimal)root.Attribute("Att");  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
Dim root As XElement = <Root Att="79228162514264337593543950335"/>  
Dim value As Decimal = CDec(root.Attribute("Att"))  
Console.WriteLine("value={0}", value)  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
value=79228162514264337593543950335  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.Decimal" />-Wert.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="attribute" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.Decimal}" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; double" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in <see cref="T:System.Double" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in einen <see cref="T:System.Double" /> um.</summary>
        <returns>Ein <see cref="T:System.Double" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[## Examples  
 Im folgenden Beispiel wird ein Attribut mit <xref:System.Double> Inhalt erstellt. Anschließend wird der Wert durch Umwandeln in <xref:System.Double>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att", 1.79769313486231e308)  
);  
double value = (double)root.Attribute("Att");  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
Dim root As XElement = <Root Att="1.79769313486231E+308"/>  
Dim value As Double = CDbl(root.Attribute("Att"))  
Console.WriteLine("value={0}", value)  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
value=1.79769313486231E+308  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.Double" />-Wert.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="attribute" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.Double}" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Guid (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Guid op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Guid" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Guid(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; Guid" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in <see cref="T:System.Guid" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in einen <see cref="T:System.Guid" /> um.</summary>
        <returns>Ein <see cref="T:System.Guid" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[## Examples  
 Im folgenden Beispiel wird ein Attribut mit einer GUID als Inhalt erstellt. Anschließend wird der Wert durch Umwandeln in <xref:System.Guid>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att", new Guid("3c1cc55b-baff-4b7a-9d17-077af3aa5730"))  
);  
Guid value = (Guid)root.Attribute("Att");  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
Dim root As XElement = <Root Att=<%= New Guid("3c1cc55b-baff-4b7a-9d17-077af3aa5730") %>/>  
Dim value As Guid = CType(root.Attribute("Att"), Guid)  
Console.WriteLine("value={0}", value)  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
value=3c1cc55b-baff-4b7a-9d17-077af3aa5730  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.Guid" />-Wert.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="attribute" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.Guid}" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; int" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in <see cref="T:System.Int32" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in einen <see cref="T:System.Int32" /> um.</summary>
        <returns>Ein <see cref="T:System.Int32" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[## Examples  
 Im folgenden Beispiel wird ein Attribut mit einer Ganzzahl als Inhalt erstellt. Anschließend wird der Wert durch Umwandeln in <xref:System.Int32>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att", 2147483647)  
);  
int value = (int)root.Attribute("Att");  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
Dim root As XElement = <Root Att="2147483647"/>  
Dim value As Integer = CInt(root.Attribute("Att"))  
Console.WriteLine("value={0}", value)  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
value=2147483647  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.Int32" />-Wert.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="attribute" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.Int32}" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; int64" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in <see cref="T:System.Int64" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in einen <see cref="T:System.Int64" /> um.</summary>
        <returns>Ein <see cref="T:System.Int64" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[## Examples  
 Im folgenden Beispiel wird ein Attribut mit einer langen ganzen Zahl als Inhalt erstellt. Anschließend wird der Wert des-Attributs durch Umwandeln in <xref:System.Int64>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att", 9223372036854775807)  
);  
long value = (long)root.Attribute("Att");  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
Dim root As XElement = <Root Att="9223372036854775807"/>  
Dim value As Long = CLng(root.Attribute("Att"))  
Console.WriteLine("value={0}", value)  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
value=9223372036854775807  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.Int64" />-Wert.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="attribute" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.Int64}" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator bool? (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;bool&gt; op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.Boolean}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;bool&gt;(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; Nullable&lt;bool&gt;" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Boolean" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Boolean" /> um.</summary>
        <returns>Ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Boolean" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Konvertieren in <xref:System.Boolean> aus einem Attribut oder Element sind zulässige Werte "0", "1" und eine beliebige Zeichenfolge, die nach dem kürzen und konvertieren in Kleinbuchstaben "true" oder "false" ergibt.  

## Examples  
 Im folgenden Beispiel wird ein Attribut mit booleschem Inhalt erstellt. Anschließend wird der Wert durch Umwandeln in <xref:System.Nullable%601> <xref:System.Boolean>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",   
    new XAttribute("BoolValue1", true),  
    new XAttribute("BoolValue2", false)  
);  
bool? bool1 = (bool?)root.Attribute("BoolValue1");  
bool? bool2 = (bool?)root.Attribute("BoolValue2");  
Console.WriteLine("Nullable boolean: BoolValue1={0}", bool1);  
Console.WriteLine("Nullable boolean: BoolValue2={0}", bool2);  
```  
  
```vb  
Dim root As XElement = <Root BoolValue1="true" BoolValue2="false"/>  
Dim bool1 As Nullable(Of Boolean) = CType(root.Attribute("BoolValue1"), Nullable(Of Boolean))  
Dim bool2 As Nullable(Of Boolean) = CType(root.Attribute("BoolValue2"), Nullable(Of Boolean))  
Console.WriteLine("Nullable boolean: BoolValue1={0}", bool1)  
Console.WriteLine("Nullable boolean: BoolValue2={0}", bool2)  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
Nullable boolean: BoolValue1=True  
Nullable boolean: BoolValue2=False  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.Boolean" />-Wert.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Boolean" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator DateTime? (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;valuetype System.DateTime&gt; op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.DateTime}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As Nullable(Of DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;DateTime&gt;(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; Nullable&lt;DateTime&gt;" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.DateTime&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.DateTime" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.DateTime" /> um.</summary>
        <returns>Ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.DateTime" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert Bereich eines Attributs oder Elements, das Datums-und Uhrzeit Inhalte enthält, ist eng mit den in ISO 8601 beschriebenen Datums-und Uhrzeitangaben verknüpft. Beim Erstellen eines Attributs oder Elements, das Datums-und Uhrzeit Inhalte enthält, werden die Attribut-oder Element Werte gemäß der W3C-Spezifikation formatiert. Weitere Informationen finden Sie in der W3C-Spezifikation.  
  
 Das Verhalten ist Lax, wenn eine Umwandlung in eine <xref:System.Nullable%601> <xref:System.DateTime> von einem Attribut oder Element erfolgt. Auch wenn der Attribut-oder Elementwert nicht exakt gemäß der W3C-Spezifikation formatiert ist, wird der Wert entsprechend in eine <xref:System.Nullable%601> <xref:System.DateTime>konvertiert.  
  
 Dieser Konvertierungs Operator verwendet <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, um eine <xref:System.DateTime>zu konvertieren.  
  
## Examples  
 Im folgenden Beispiel wird ein Attribut mit einem Datum und einer Uhrzeit als Inhalt erstellt. Anschließend wird der Wert durch Umwandeln in <xref:System.Nullable%601> <xref:System.DateTime>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att", new DateTime(2006, 10, 6, 12, 30, 0))  
);  
DateTime? value = (DateTime?)root.Attribute("Att");  
Console.WriteLine("Nullable DateTime: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = <Root Att=<%= New DateTime(2006, 10, 6, 12, 30, 0) %>/>  
Dim value As Nullable(Of DateTime) = CType(root.Attribute("Att"), Nullable(Of DateTime))  
Console.WriteLine("Nullable DateTime: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
Nullable DateTime: value=10/6/2006 12:30:00 PM  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.DateTime" />-Wert.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.DateTime" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator DateTimeOffset? (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;valuetype System.DateTimeOffset&gt; op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.DateTimeOffset}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As Nullable(Of DateTimeOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;DateTimeOffset&gt;(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; Nullable&lt;DateTimeOffset&gt;" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.DateTimeOffset&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.DateTimeOffset" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.DateTimeOffset" /> um.</summary>
        <returns>Ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.DateTimeOffset" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konvertierungs Operator verwendet die <xref:System.Xml.XmlConvert>-Klasse, um die Konvertierung durchzuführen.  
 
## Examples  
 Im folgenden Beispiel wird ein Attribut mit einem Datum und einer Uhrzeit als Inhalt erstellt. Anschließend wird der Wert durch Umwandeln in <xref:System.Nullable%601> <xref:System.DateTimeOffset>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att", new DateTimeOffset(new DateTime(2006, 10, 6, 12, 30, 0)))  
);  
DateTimeOffset? value = (DateTimeOffset?)root.Attribute("Att");  
Console.WriteLine("Nullable DateTimeOffset: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = _  
    <Root  
        Att=<%= New DateTimeOffset(New DateTime(2006, 10, 6, 12, 30, 0)) %>/>  
Dim value As Nullable(Of DateTimeOffset) = CType(root.Attribute("Att"), Nullable(Of DateTimeOffset))  
Console.WriteLine("Nullable DateTimeOffset: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
Nullable DateTimeOffset: value=10/6/2006 12:30:00 PM -07:00  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.DateTimeOffset" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal? (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.Decimal}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As Nullable(Of Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;System::Decimal&gt;(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; Nullable&lt;decimal&gt;" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Decimal" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Decimal" /> um.</summary>
        <returns>Ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Decimal" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[## Examples  
 Im folgenden Beispiel wird ein Attribut mit Decimal-Inhalt erstellt. Anschließend wird der Wert durch Umwandeln in <xref:System.Nullable%601> <xref:System.Decimal>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att", "79228162514264337593543950335")  
);  
decimal? value = (decimal?)root.Attribute("Att");  
Console.WriteLine("Nullable decimal: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = <Root Att="79228162514264337593543950335"/>  
Dim value As Nullable(Of Decimal) = CType(root.Attribute("Att"), Nullable(Of Decimal))  
Console.WriteLine("Nullable decimal: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
Nullable decimal: value=79228162514264337593543950335  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.Decimal" />-Wert.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Decimal" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double? (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;float64&gt; op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.Double}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;double&gt;(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; Nullable&lt;double&gt;" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Double" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Double" /> um.</summary>
        <returns>Ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Double" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[## Examples  
 Im folgenden Beispiel wird ein Attribut mit Gleit Komma Inhalt mit doppelter Genauigkeit erstellt. Anschließend wird der Wert durch Umwandeln in <xref:System.Nullable%601> <xref:System.Double>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att", 1.79769313486231e308)  
);  
double? value = (double?)root.Attribute("Att");  
Console.WriteLine("Nullable double: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = <Root Att="1.79769313486231E+308"/>  
Dim value As Nullable(Of Double) = CType(root.Attribute("Att"), Nullable(Of Double))  
Console.WriteLine("Nullable double: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
Nullable double: value=1.79769313486231E+308  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.Double" />-Wert.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Double" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator Guid? (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;valuetype System.Guid&gt; op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.Guid}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As Nullable(Of Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;Guid&gt;(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; Nullable&lt;Guid&gt;" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Guid&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Guid" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Guid" /> um.</summary>
        <returns>Ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Guid" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[## Examples  
 Im folgenden Beispiel wird ein Attribut mit dem GUID-Inhalt erstellt. Anschließend wird der Wert durch Umwandeln in <xref:System.Nullable%601> <xref:System.Guid>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att", new Guid("3c1cc55b-baff-4b7a-9d17-077af3aa5730"))  
);  
Guid? value = (Guid?)root.Attribute("Att");  
Console.WriteLine("Nullable Guid: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = <Root Att=<%= New Guid("3c1cc55b-baff-4b7a-9d17-077af3aa5730") %>/>  
Dim value As Nullable(Of Guid) = CType(root.Attribute("Att"), Nullable(Of Guid))  
Console.WriteLine("Nullable Guid: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
Nullable Guid: value=3c1cc55b-baff-4b7a-9d17-077af3aa5730  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.Guid" />-Wert.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Guid" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int? (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;int32&gt; op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.Int32}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;int&gt;(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; Nullable&lt;int&gt;" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Int32" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Int32" /> um.</summary>
        <returns>Ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Int32" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[## Examples  
 Im folgenden Beispiel wird ein Attribut mit ganzzahligen Inhalten erstellt. Anschließend wird der Wert durch Umwandeln in <xref:System.Nullable%601> <xref:System.Int32>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",   
    new XAttribute("Att", 2147483647)  
);  
int? value = (int?)root.Attribute("Att");  
Console.WriteLine("Nullable int: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = <Root Att="2147483647"/>  
Dim value As Nullable(Of Integer) = CType(root.Attribute("Att"), Nullable(Of Integer))  
Console.WriteLine("Nullable int: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
Nullable int: value=2147483647  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Int32" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long? (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;int64&gt; op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.Int64}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;long&gt;(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; Nullable&lt;int64&gt;" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Int64" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Int64" /> um.</summary>
        <returns>Ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Int64" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[## Examples  
 Im folgenden Beispiel wird ein Attribut mit Long Integer-Inhalt erstellt. Anschließend wird der Wert durch Umwandeln in <xref:System.Nullable%601> <xref:System.Int64>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",   
    new XAttribute("Att", 9223372036854775807)  
);  
long? value = (long?)root.Attribute("Att");  
Console.WriteLine("Nullable long: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = <Root Att="9223372036854775807"/>  
Dim value As Nullable(Of Long) = CType(root.Attribute("Att"), Nullable(Of Long))  
Console.WriteLine("Nullable long: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
Nullable long: value=9223372036854775807  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.Int64" />-Wert.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Int64" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float? (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;float32&gt; op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.Single}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As Nullable(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;float&gt;(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; Nullable&lt;single&gt;" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Single" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Single" /> um.</summary>
        <returns>Ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.Single" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[## Examples  
 Im folgenden Beispiel wird ein Attribut mit einem Gleit Komma Inhalt mit einfacher Genauigkeit erstellt. Anschließend wird der Wert durch Umwandeln in <xref:System.Nullable%601> <xref:System.Single>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",   
    new XAttribute("Att", 3.402823e38)  
);  
float? value = (float?)root.Attribute("Att");  
Console.WriteLine("Nullable Single: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = <Root Att="3.402823E+38"/>  
Dim value As Nullable(Of Single) = CType(root.Attribute("Att"), Nullable(Of Single))  
Console.WriteLine("Nullable Single: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
Nullable Single: value=3.402823E+38  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.Single" />-Wert.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Single" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator TimeSpan? (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.TimeSpan}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;TimeSpan&gt;(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; Nullable&lt;TimeSpan&gt;" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.TimeSpan" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.TimeSpan" /> um.</summary>
        <returns>Ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.TimeSpan" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert Bereich eines Attributs oder Elements, das Zeitspannen Inhalte enthält, ist eng mit dem Dauer Inhalt verknüpft, wie in ISO 8601 beschrieben. Beim Erstellen eines Attributs oder Elements, das Zeitspannen Inhalte enthält, werden die Attribut-oder Element Werte gemäß der W3C-Spezifikation formatiert. Weitere Informationen finden Sie in der W3C-Spezifikation.  
  
 Das Verhalten ist Lax, wenn eine Umwandlung in eine <xref:System.Nullable%601> <xref:System.TimeSpan> von einem Attribut oder Element erfolgt. Auch wenn der Attribut-oder Elementwert nicht exakt gemäß der W3C-Spezifikation formatiert ist, wird der Wert entsprechend in eine <xref:System.Nullable%601> <xref:System.TimeSpan>konvertiert.  

## Examples  
 Im folgenden Beispiel wird ein Attribut mit Zeitspannen Inhalt erstellt. Anschließend wird der Wert durch Umwandeln in <xref:System.Nullable%601> <xref:System.TimeSpan>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att", new TimeSpan(1, 5, 30))  
);  
TimeSpan? value = (TimeSpan?)root.Attribute("Att");  
Console.WriteLine("Nullable TimeSpan: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = <Root Att=<%= New TimeSpan(1, 5, 30) %>/>  
Dim value As Nullable(Of TimeSpan) = CType(root.Attribute("Att"), Nullable(Of TimeSpan))  
Console.WriteLine("Nullable TimeSpan: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
Nullable TimeSpan: value=01:05:30  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.TimeSpan" />-Wert.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.TimeSpan" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint? (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;unsigned int32&gt; op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.UInt32}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As Nullable(Of UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;System::UInt32&gt;(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; Nullable&lt;uint32&gt;" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.UInt32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.UInt32" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.UInt32" /> um.</summary>
        <returns>Ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.UInt32" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[## Examples  
 Im folgenden Beispiel wird ein Attribut mit einem ganzzahligen Inhalt ohne Vorzeichen erstellt. Anschließend wird der Wert durch Umwandeln in <xref:System.Nullable%601> <xref:System.UInt32>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",   
    new XAttribute("Att", 4294967295)  
);  
uint? value = (uint?)root.Attribute("Att");  
Console.WriteLine("Nullable uint: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = <Root Att="4294967295"/>  
Dim value As Nullable(Of UInteger) = CType(root.Attribute("Att"), Nullable(Of UInteger))  
Console.WriteLine("Nullable uint: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
Nullable uint: value=4294967295  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.UInt32" />-Wert.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.UInt32" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong? (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Nullable`1&lt;unsigned int64&gt; op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.UInt64}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As Nullable(Of ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator Nullable&lt;System::UInt64&gt;(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; Nullable&lt;uint64&gt;" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.UInt64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.UInt64" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.UInt64" /> um.</summary>
        <returns>Ein <see cref="T:System.Nullable`1" /> vom Typ <see cref="T:System.UInt64" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[## Examples  
 Im folgenden Beispiel wird ein Attribut mit einem unsignierten langen ganzzahligen Inhalt erstellt. Anschließend wird der Wert durch Umwandeln in <xref:System.Nullable%601> <xref:System.UInt64>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",   
    new XAttribute("Att", 9223372036854775807)  
);  
ulong? value = (ulong?)root.Attribute("Att");  
Console.WriteLine("Nullable ulong: value={0}", value == null ? "null" : value.ToString());  
```  
  
```vb  
Dim root As XElement = <Root Att="9223372036854775807"/>  
Dim value As Nullable(Of ULong) = CType(root.Attribute("Att"), Nullable(Of ULong))  
Console.WriteLine("Nullable ulong: value={0}", IIf(value.HasValue, value.ToString(), "null"))  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
Nullable ulong: value=9223372036854775807  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.UInt64" />-Wert.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.UInt64" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; single" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in <see cref="T:System.Single" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in einen <see cref="T:System.Single" /> um.</summary>
        <returns>Ein <see cref="T:System.Single" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[## Examples  
 Im folgenden Beispiel wird ein Attribut mit einem Gleit Komma Inhalt mit einfacher Genauigkeit erstellt. Anschließend wird der Wert durch Umwandeln in <xref:System.Single>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att", 3.402823e38)  
);  
float value = (float)root.Attribute("Att");  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
Dim root As XElement = <Root Att="3.402823E+38"/>  
Dim value As Single = CSng(root.Attribute("Att"))  
Console.WriteLine("value={0}", value)  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
value=3.402823E+38  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.Single" />-Wert.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="attribute" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.Single}" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator string (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname string op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.String" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::String ^(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; string" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in <see cref="T:System.String" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in einen <see cref="T:System.String" /> um.</summary>
        <returns>Ein <see cref="T:System.String" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[## Examples  
 Im folgenden Beispiel wird ein Attribut mit Zeichen folgen Inhalt erstellt. Anschließend wird der Wert durch Umwandeln in <xref:System.String>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att", "attribute content")  
);  
XAttribute att = root.Attribute("Att");  
string str = (string)att;  
Console.WriteLine("(string)att={0}", str);  
```  
  
```vb  
Dim root As XElement = <Root Att="attribute content"/>  
Dim att As XAttribute = root.Attribute("Att")  
Dim str As String = CStr(att)  
Console.WriteLine("(string)att={0}", str)  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
(string)att=attribute content  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XAttribute.ToString" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator TimeSpan (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.TimeSpan op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.TimeSpan" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator TimeSpan(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; TimeSpan" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in <see cref="T:System.TimeSpan" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in einen <see cref="T:System.TimeSpan" /> um.</summary>
        <returns>Ein <see cref="T:System.TimeSpan" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert Bereich eines Attributs oder Elements, das Zeitspannen Inhalte enthält, ist eng mit dem Dauer Inhalt verknüpft, wie in ISO 8601 beschrieben. Beim Erstellen eines Attributs oder Elements, das Zeitspannen Inhalte enthält, werden die Attribut-oder Element Werte gemäß der W3C-Spezifikation formatiert. Weitere Informationen finden Sie in der W3C-Spezifikation.  
  
 Das Verhalten ist Lax, wenn eine Umwandlung in eine <xref:System.TimeSpan> von einem Attribut oder Element erfolgt. Auch wenn der Attribut-oder Elementwert nicht exakt gemäß der W3C-Spezifikation formatiert ist, wird der Wert entsprechend in eine <xref:System.TimeSpan>konvertiert.  

## Examples  
 Im folgenden Beispiel wird ein Attribut mit Zeitspannen Inhalt erstellt. Anschließend wird der Wert durch Umwandeln in <xref:System.TimeSpan>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att", new TimeSpan(1, 5, 30))  
);  
TimeSpan value = (TimeSpan)root.Attribute("Att");  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
Dim root As XElement = <Root Att=<%= New TimeSpan(1, 5, 30) %>/>  
Dim value As TimeSpan = CType(root.Attribute("Att"), TimeSpan)  
Console.WriteLine("value={0}", value)  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
value=01:05:30  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.TimeSpan" />-Wert.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="attribute" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.TimeSpan}" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; uint32" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in <see cref="T:System.UInt32" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in einen <see cref="T:System.UInt32" /> um.</summary>
        <returns>Ein <see cref="T:System.UInt32" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[## Examples  
 Im folgenden Beispiel wird ein Attribut mit einem ganzzahligen Inhalt ohne Vorzeichen erstellt. Anschließend wird der Wert durch Umwandeln in <xref:System.UInt32>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",   
    new XAttribute("Att", 4294967295)  
);  
uint value = (uint)root.Attribute("Att");  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
Dim root As XElement = <Root Att="4294967295"/>  
Dim value As UInteger = CUInt(root.Attribute("Att"))  
Console.WriteLine("value={0}", value)  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
value=4294967295  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.UInt32" />-Wert.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="attribute" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.UInt32}" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Xml.Linq.XAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(class System.Xml.Linq.XAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (attribute As XAttribute) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Xml::Linq::XAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Xml.Linq.XAttribute -&gt; uint64" Usage="System.Xml.Linq.XAttribute.op_Explicit attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Xml.Linq.XAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">Das <see cref="T:System.Xml.Linq.XAttribute" />, das in <see cref="T:System.UInt64" /> umgewandelt werden soll.</param>
        <summary>Wandelt den Wert dieses <see cref="T:System.Xml.Linq.XAttribute" /> in einen <see cref="T:System.UInt64" /> um.</summary>
        <returns>Ein <see cref="T:System.UInt64" />, das den Inhalt dieses <see cref="T:System.Xml.Linq.XAttribute" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[## Examples  
 Im folgenden Beispiel wird ein Attribut mit einem unsignierten langen ganzzahligen Inhalt erstellt. Anschließend wird der Wert durch Umwandeln in <xref:System.UInt64>abgerufen.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att", 1844674407370955161)  
);  
ulong value = (ulong)root.Attribute("Att");  
Console.WriteLine("value={0}", value);  
```  
  
```vb  
Dim root As XElement = <Root Att="1844674407370955161"/>  
Dim value As ULong = CULng(root.Attribute("Att"))  
Console.WriteLine("value={0}", value)  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
value=1844674407370955161  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Das Attribut enthält keinen gültigen <see cref="T:System.UInt64" />-Wert.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="attribute" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.Nullable{System.UInt64}" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="PreviousAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XAttribute PreviousAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XAttribute PreviousAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XAttribute.PreviousAttribute" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousAttribute As XAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XAttribute ^ PreviousAttribute { System::Xml::Linq::XAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousAttribute : System.Xml.Linq.XAttribute" Usage="System.Xml.Linq.XAttribute.PreviousAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das vorherige Attribut des übergeordneten Elements ab.</summary>
        <value>Ein <see cref="T:System.Xml.Linq.XAttribute" />, das das vorherige Attribut des übergeordneten Elements enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Attribute werden in der XML-Struktur in der Reihenfolge beibehalten, in der Sie dem-Element hinzugefügt wurden. Wenn <xref:System.Xml.Linq.XElement.Attributes%2A>eine Auflistung von Attributen zurückgibt, werden diese in der Reihenfolge zurückgegeben, in der Sie hinzugefügt wurden, und werden nicht sortiert. Wenn Sie das vorherige Attribut über diese Eigenschaft anfordern, gibt diese Eigenschaft das Attribut zurück, das vor diesem Attribut hinzugefügt wurde.  
  
 Wenn dieses Attribut nicht über ein übergeordnetes Element verfügt oder wenn dieses Attribut das erste Attribut ist, gibt diese Eigenschaft `null`zurück.  
  
 Die <xref:System.Xml.Linq.XElement>-Klasse speichert ihre Attribute als einzeln verknüpfte Liste von <xref:System.Xml.Linq.XAttribute> Objekten. Dies bedeutet, dass die <xref:System.Xml.Linq.XAttribute.PreviousAttribute%2A>-Eigenschaft die Liste der Attribute durchlaufen muss, die zum-Element gehören. Daher kann sich die Verwendung dieser Eigenschaft auf die Leistung auswirken.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die Attribute eines Elements mithilfe dieser Eigenschaft durchlaufen werden.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XAttribute("Att3", 3),  
    new XAttribute("Att4", 4)  
);  
XAttribute att = root.LastAttribute;  
do {  
    Console.WriteLine(att);  
}  
while((att = att.PreviousAttribute) != null);  
```  
  
```vb  
Dim root As XElement = <Root Att1="1" Att2="2" Att3="3" Att4="4"/>  
Dim att As XAttribute = root.LastAttribute  
Dim val As Boolean = True  
Do  
    Console.WriteLine(att)  
    att = att.PreviousAttribute  
Loop While (Not (att Is Nothing))  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
Att4="4"  
Att3="3"  
Att2="2"  
Att1="1"  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.Linq.XAttribute.NextAttribute" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove();" />
      <MemberSignature Language="F#" Value="member this.Remove : unit -&gt; unit" Usage="xAttribute.Remove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt dieses Attribut aus seinem übergeordneten Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode können Sie eine XML-Struktur ändern. Diese Methode führt zu Ereignissen.  
  
 Es gibt viele Szenarien, in denen Sie möglicherweise einen Satz von Attributen entfernen möchten. In [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] Programmierung sollten Sie eine Gruppe von Knoten nicht bearbeiten oder ändern, während Sie die Knoten in dieser Gruppe Abfragen. In praktischer Hinsicht bedeutet dies, dass Sie eine Gruppe von Attributen nicht durchlaufen und Sie entfernen sollten. Stattdessen sollten Sie diese mithilfe der <xref:System.Linq.Enumerable.ToList%2A>-Erweiterungsmethode in eine <xref:System.Collections.Generic.List%601> materialisieren. Anschließend können Sie die Liste durchlaufen und die Attribute entfernen. Weitere Informationen finden Sie unter [Fehler mit gemischtem deklarativem Code/imperativem Code (LINQ to XML)](https://msdn.microsoft.com/library/d9a5c404-2b0e-46cd-a358-0e78773b3094).  
  
 Wenn Sie einen Satz von Attributen entfernen möchten, empfiehlt es sich, die <xref:System.Xml.Linq.Extensions.Remove%2A?displayProperty=nameWithType>-Methode zu verwenden. Diese Methode kopiert die Attribute in eine Liste, durchläuft dann die Liste, wobei die Attribute entfernt werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein-Element mit drei Attributen erstellt. Anschließend wird eines der Attribute entfernt.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att1", "content1"),  
    new XAttribute("Att2", "content2"),  
    new XAttribute("Att3", "content3")  
);  
XAttribute att = root.Attribute("Att2");  
att.Remove();  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement = <Root Att1="content1" Att2="content2" Att3="content3"/>  
Dim att As XAttribute = root.Attribute("Att2")  
att.Remove()  
Console.WriteLine(root)  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
<Root Att1="content1" Att3="content3" />  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das übergeordnete Element ist <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.SetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj -&gt; unit" Usage="xAttribute.SetValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der diesem Attribut zugewiesen werden soll.</param>
        <summary>Legt den Wert dieses Attributs fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert wird in seine Zeichenfolgenentsprechung konvertiert und der <xref:System.Xml.Linq.XAttribute.Value%2A>-Eigenschaft zugewiesen.  
  
 Es ist ungültig, eine Instanz einer Klasse zu übergeben, die von <xref:System.Xml.Linq.XObject>abgeleitet ist, z. b. <xref:System.Xml.Linq.XElement> oder <xref:System.Xml.Linq.XAttribute>.  
  
 Diese Methode gibt die <xref:System.Xml.Linq.XObject.Changed> und die <xref:System.Xml.Linq.XObject.Changing> Ereignisse aus.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein-Element mit mehreren Attributen erstellt. Anschließend wird der Inhalt eines der Attribute geändert.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att1", "content1"),  
    new XAttribute("Att2", "content2"),  
    new XAttribute("Att3", "content3")  
);  
XAttribute att = root.Attribute("Att2");  
att.SetValue("new content");  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement = <Root Att1="content1" Att2="content2" Att3="content3"/>  
Dim att As XAttribute = root.Attribute("Att2")  
att.SetValue("new content")  
Console.WriteLine(root)  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
<Root Att1="content1" Att2="new content" Att3="content3" />  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="value" /> ist ein <see cref="T:System.Xml.Linq.XObject" />.</exception>
        <altmember cref="M:System.Xml.Linq.XElement.SetValue(System.Object)" />
        <altmember cref="M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)" />
        <altmember cref="M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)" />
        <altmember cref="P:System.Xml.Linq.XAttribute.Value" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XAttribute.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xAttribute.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert das aktuelle <see cref="T:System.Xml.Linq.XAttribute" />-Objekt in eine Zeichenfolgendarstellung.</summary>
        <returns>Eine <see cref="T:System.String" />, die die XML-Textdarstellung eines Attributs und seines Werts enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt eine Zeichenfolge in Form von `AttributeName="content"`zurück.  
  
> [!WARNING]
>  Wenn diese Methode aufgerufen wird und <xref:System.Xml.Linq.XAttribute> ein Steuerzeichen enthält, wird eine Ausnahme mit einer Meldung wie der Hexadezimalwert 0x0B, einem ungültigen Zeichen, ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein-Element mit mehreren Attributen erstellt. Anschließend ruft er ein Attribut ab und zeigt ihn und seinen Inhalt durch Aufrufen dieser Methode an.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att1", "content1"),  
    new XAttribute("Att2", "content2"),  
    new XAttribute("Att3", "content3")  
);  
XAttribute att = root.Attribute("Att2");  
Console.WriteLine(att.ToString());  
```  
  
```vb  
Dim root As XElement = <Root Att1="content1" Att2="content2" Att3="content3"/>  
Dim att As XAttribute = root.Attribute("Att2")  
Console.WriteLine(att.ToString())  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
Att2="content2"  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.Linq.XAttribute.Name" />
        <altmember cref="P:System.Xml.Linq.XAttribute.Value" />
        <altmember cref="M:System.Xml.Linq.XAttribute.op_Explicit(System.Xml.Linq.XAttribute)~System.String" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public string Value { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Value { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Value : string with get, set" Usage="System.Xml.Linq.XAttribute.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des Attributs ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.String" />-Objekt, das den Wert dieses Attributs enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Eigenschaft verwenden, um den Wert eines Attributs zu erhalten oder festzulegen.  
  
 Wenn diese Eigenschaft festgelegt wird, werden die <xref:System.Xml.Linq.XObject.Changed> und die <xref:System.Xml.Linq.XObject.Changing> Ereignisse angehoben.  
  
 Wenn Sie den Wert erhalten und das Attribut möglicherweise nicht vorhanden ist, ist es einfacher, die expliziten Konvertierungs Operatoren zu verwenden, und das Attribut einem Typ zuweisen, der NULL-Werte zulässt, wie z. b. `string` oder <xref:System.Nullable%601> <xref:System.Int32>. Wenn das Attribut nicht vorhanden ist, wird der Werte zulässt-Typ auf `null`festgelegt. Bevor Sie diese Eigenschaft verwenden, müssen Sie sicherstellen, dass die <xref:System.Xml.Linq.XElement.Attribute%2A>-Methode `null`nicht zurückgibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein-Element mit einem-Attribut erstellt. Anschließend ruft Sie den Wert des Attributs ab und legt ihn fest.  
  
 Beachten Sie, dass im Visual Basic Beispiel die XML-Attribut Eigenschaft verwendet wird.  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att", "content")  
);  
XAttribute att = root.FirstAttribute;  
Console.WriteLine(att.Value);  
att.Value = "new text";  
Console.WriteLine(att.Value);  
```  
  
```vb  
Dim root As XElement = <Root Att="content"/>  
Console.WriteLine(root.@Att)  
root.@Att = "new text"  
Console.WriteLine(root.@Att)  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
content  
new text  
```  
  
 Das folgende Beispiel zeigt den Vorteil, dass die expliziten Konvertierungs Operatoren verwendet werden, um den Wert eines Attributs zu erhalten, das möglicherweise nicht existiert:  
  
```csharp  
XElement root = new XElement("Root",  
    new XAttribute("Att1", "attribute 1 content"),  
    new XAttribute("Att2", "2")  
);  
  
// The following assignments demonstrate why it is easier to use  
// casting when the attribute might or might not exist.  
  
string c1 = (string)root.Attribute("Att1");  
Console.WriteLine("c1:{0}", c1 == null ? "attribute does not exist" : c1);  
  
int? c2 = (int?)root.Attribute("Att2");  
Console.WriteLine("c2:{0}", c2 == null ? "attribute does not exist" : c2.ToString());  
  
string c3 = (string)root.Attribute("Att3");  
Console.WriteLine("c3:{0}", c3 == null ? "attribute does not exist" : c3);  
  
int? c4 = (int?)root.Attribute("Att4");  
Console.WriteLine("c4:{0}", c4 == null ? "attribute does not exist" : c4.ToString());  
  
Console.WriteLine();  
  
// The following assignments show the necessary code when using  
// the value property when the attribute might or might not exist.  
  
XAttribute att1 = root.Attribute("Att1");  
string v1;  
if (att1 == null)  
    v1 = null;  
else  
    v1 = att1.Value;  
Console.WriteLine("v1:{0}", v1 == null ? "attribute does not exist" : v1);  
  
XAttribute att2 = root.Attribute("Att2");  
int? v2;  
if (att2 == null)  
    v2 = null;  
else  
    v2 = Int32.Parse(att2.Value);  
Console.WriteLine("v2:{0}", v2 == null ? "attribute does not exist" : v2.ToString());  
  
XAttribute att3 = root.Attribute("Att3");  
string v3;  
if (att3 == null)  
    v3 = null;  
else  
    v3 = att3.Value;  
Console.WriteLine("v3:{0}", v3 == null ? "attribute does not exist" : v3);  
  
XAttribute att4 = root.Attribute("Att4");  
int? v4;  
if (att4 == null)  
    v4 = null;  
else  
    v4 = Int32.Parse(att4.Value);  
Console.WriteLine("v4:{0}", v4 == null ? "attribute does not exist" : v4.ToString());  
```  
  
```vb  
Dim root As XElement = <Root Att1="attribute 1 content" Att2="2"/>  
  
' The following assignments demonstrate why it is easier to use  
' casting when the attribute might or might not exist.  
  
Dim c1 As String = CStr(root.Attribute("Att1"))  
Console.WriteLine("c1:{0}", IIf(c1 Is Nothing, "attribute does not exist", c1))  
  
Dim c2 As Nullable(Of Integer) = CType(root.Attribute("Att2"), Nullable(Of Integer))  
Console.WriteLine("c2:{0}", IIf(c2.HasValue, c2, "attribute does not exist"))  
  
Dim c3 As String = CStr(root.Attribute("Att3"))  
Console.WriteLine("c3:{0}", IIf(c3 Is Nothing, "attribute does not exist", c3))  
  
Dim c4 As Nullable(Of Integer) = CType(root.Attribute("Att4"), Nullable(Of Integer))  
Console.WriteLine("c4:{0}", IIf(c4.HasValue, c4, "attribute does not exist"))  
  
Console.WriteLine()  
  
' The following assignments show the necessary code when using  
' the value property when the attribute might or might not exist.  
  
Dim att1 As XAttribute = root.Attribute("Att1")  
Dim v1 As String  
If att1 Is Nothing Then  
    v1 = Nothing  
Else  
    v1 = att1.Value  
End If  
  
Console.WriteLine("v1:{0}", IIf(v1 Is Nothing, "attribute does not exist", v1))  
  
Dim att2 As XAttribute = root.Attribute("Att2")  
Dim v2 As Nullable(Of Integer)  
If att2 Is Nothing Then  
    v2 = Nothing  
Else  
    v2 = Int32.Parse(att2.Value)  
End If  
  
Console.WriteLine("v2:{0}", IIf(v2.HasValue, v2, "attribute does not exist"))  
  
Dim att3 As XAttribute = root.Attribute("Att3")  
Dim v3 As String  
If att3 Is Nothing Then  
    v3 = Nothing  
Else  
    v3 = att3.Value  
End If  
  
Console.WriteLine("v3:{0}", IIf(v3 Is Nothing, "attribute does not exist", v3))  
  
Dim att4 As XAttribute = root.Attribute("Att4")  
Dim v4 As Nullable(Of Integer)  
If att4 Is Nothing Then  
    v4 = Nothing  
Else  
    v4 = Int32.Parse(att4.Value)  
End If  
  
Console.WriteLine("v4:{0}", IIf(v4.HasValue, v4, "attribute does not exist"))  
```  
  
 Hierdurch wird folgende Ausgabe generiert:  
  
```  
c1:attribute 1 content  
c2:2  
c3:attribute does not exist  
c4:attribute does not exist  
  
v1:attribute 1 content  
v2:2  
v3:attribute does not exist  
v4:attribute does not exist  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wenn dieser Ausnahmetyp festgelegt wird, ist <paramref name="value" /><see langword="null" />.</exception>
        <altmember cref="M:System.Xml.Linq.XAttribute.SetValue(System.Object)" />
        <altmember cref="P:System.Xml.Linq.XAttribute.Name" />
        <altmember cref="M:System.Xml.Linq.XAttribute.ToString" />
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
  </Members>
</Type>
