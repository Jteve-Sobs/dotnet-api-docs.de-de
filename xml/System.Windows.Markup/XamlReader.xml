<Type Name="XamlReader" FullName="System.Windows.Markup.XamlReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="eb09b92c85f6899f8f0386e85d5fda59b541d871" />
    <Meta Name="ms.sourcegitcommit" Value="4303c81814c0b4fd5963444073ed25c176c5ddad" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/31/2018" />
    <Meta Name="ms.locfileid" Value="39361140" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlReader extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.XamlReader" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlReader" />
  <TypeSignature Language="F#" Value="type XamlReader = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Liest XAML-Eingabe und erstellt ein Objektdiagramm und verwendet dazu den WPF-XAML-Standardparser sowie einen zugeordneten XAML-Objektwriter.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die synchrone <xref:System.Windows.Markup.XamlReader.Load%2A> Methoden sind statisch, aber die asynchronen <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> Methoden sind nicht statisch und erfordern eine Instanz der dem <xref:System.Windows.Markup.XamlReader> zu verwendende Klasse an.  
  
 Die Ausgabe der `Load` Methoden wird ein einzelnes Objekt, das das Stammobjekt der erstellten Objektstruktur oder eines Objektdiagramms darstellt. Objektdiagramme, die vom erstellten <xref:System.Windows.Markup.XamlReader> werden in der Regel an der vorhandenen Objektstruktur einer WPF-Anwendung zur Laufzeit hinzugefügt. Andernfalls gilt die neue Objektdiagramm als zum Zweck der WPF-Anwendungsmodell getrennt. Dies bedeutet, dass es nicht gerendert, nicht auf der WPF-Anwendung Hauptobjektstruktur angewendet zugegriffen mithilfe eines der Verfahren der Objekt-Struktur als werden (z. B. die APIs <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>). Weitere Informationen zu den Konzepten der Objekt-Struktur finden Sie unter [Strukturen in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 <xref:System.Windows.Markup.XamlReader> unterstützt die folgenden Hauptszenarien:  
  
-   **Das Klonen/Objekt-Factory**: ohne zusätzliche Mechanismen kann ein Verweistyp in der Regel kann nicht einbezogen werden in mehr als eine Position in der Struktur eines WPF-Objekts. (Beispiele für weiterer Mechanismen, die bieten Unterstützung für die Freigabe erneut in WPF oder Verwendung sind Objekte auf der Grundlage von <xref:System.Windows.Freezable>, oder Unterstützung für häufig gemeinsam nutzbare Objekte wie z. B. <xref:System.Windows.Media.Brush> verwiesen wird, werden als ein Element aus einem <xref:System.Windows.ResourceDictionary>.) Eine Möglichkeit, ein Objekt zu klonen, der bereits in die Objektstruktur wird serialisiert das Objekt mit <xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType>. Sie verwenden dann die serialisierte Zeichenfolge als Eingabe für einen Aufruf von <xref:System.Windows.Markup.XamlReader.Load%2A>, mit einem Stream oder <xref:System.Xml.XmlReader> als Vermittler.  
  
-   **Erstellen Objekte basierend auf just-in-Time-Informationen**: Es gibt häufig weitere Möglichkeiten, die späte Bindung oder vom Benutzer bereitgestellte Eingabe, die der Status von vorhandenen Objekten geändert haben. Beispielsweise können den gleichen Wert verwenden, um mehr als eine Eigenschaft festzulegen oder mithilfe der Datenbindung. Aber wenn Sie ein Szenario, in dem auch der Typ des zu erstellenden Objekts nur bestimmbar zur Laufzeit oder Interaktion des Benutzers ist, verfügen, erstellen Sie ein solches Objekt durch das Einrichten einer Zeichenfolge für <xref:System.Windows.Markup.XamlReader.Load%2A> Eingabe ist oft eine nützliche Technik.  
  
-   **Verwenden die vorhandene Ressource Techniken**: die <xref:System.IO.Stream> Typ wird häufig in anderen Frameworks oder Technologien verwendet, für die Übertragung von Daten oder Objekte über Anwendungsgrenzen hinweg oder für ähnliche Situationen. Anschließend können Sie die <xref:System.IO.Stream> Techniken speichern oder Abrufen von XAML-formatierte Daten, die Sie später verwenden, um ein Objekt als Teil Ihrer Anwendung zu erstellen.  
  
-   **Dokumente behoben:** Ihrer Anwendung möglicherweise lokale oder heruntergeladene XPS-Dokumente für die Aufnahme in eine Struktur des WPF-Objekts und die Benutzeroberfläche geladen.  
  
> [!NOTE]
>  In dieser Dokumentation manchmal wird ein Objektdiagramm, im Gegensatz zu einer Objektstruktur beschrieben. Eine strenge über-/ unterordnungsbeziehung existiert immer nicht in das Objekt zur Laufzeit Beziehungen zwischen einer WPF-Anwendung zur Laufzeit ein Objektdiagramm ist ein Begriff mit der zunehmenden Verbreitung anwendbar. Aber da WPF auch zwei andere Struktur Konzeptualisierung APIs umfasst (<xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>) die Baumstrukturmetapher gilt weiterhin ordnungsgemäß auf den meisten realen praktischen Fällen in WPF. Aus der Perspektive der XAML-Sprache, das Objektdiagramm ist jedoch häufig die beste Möglichkeit, stellen Sie sich zur Erstellung von Objekten aus XAML, da die XAML-Sprache selbst nicht unbedingt angibt Helper-Klasse Methoden, die den Beziehungen, die mehr bieten in einem Baumstruktur erneut aus.  
  
## <a name="code-access-security-loose-xaml-and-xamlreader"></a>Codezugriffssicherheit Loose XAML und XamlReader  
 XAML ist eine Markupsprache, die Objektinstanziierung und -ausführung direkt darstellt. Daher verfügen in XAML erstellte Elemente über dieselbe Fähigkeit zur Interaktion mit Systemressourcen (z.B. Netzwerkzugriff, Dateisystem E/A), wie der gleichwertig generierte Code.  
  
 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] unterstützt die [!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)] Sicherheitsframework [!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)]. Dies bedeutet, dass in der Internetzone ausgeführter [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Inhalt eingeschränkte Ausführungsberechtigungen hat. "Loose XAML" (Seiten nicht kompilierten XAML-Codes, die beim Laden von einem XAML-Viewer interpretiert werden) und [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] werden normalerweise in dieser Internetzone ausgeführt und verwenden die gleiche Berechtigungsmenge.  Wenn XAML allerdings in eine voll vertrauenswürdige Anwendung geladen wird, hat es den gleichen Zugriff auf Systemressourcen wie die Hostanwendung. Weitere Informationen finden Sie unter [WPF-Sicherheit mit teilweiser Vertrauenswürdigkeit](~/docs/framework/wpf/wpf-partial-trust-security.md).  
  
 Die Auswirkungen dieser Anweisungen für <xref:System.Windows.Markup.XamlReader> besteht darin, dass der Entwurf der Anwendung vornehmen muss Entscheidungen über die Vertrauenswürdigkeit über die XAML Sie laden möchten. Wenn Sie XAML, die nicht vertrauenswürdig ist laden, sollten erwägen Sie, Ihre eigenen Sandkastentechnik für, wie Sie das resultierende Objektdiagramm laden zu verwenden.  
  
 <xref:System.Windows.Markup.XamlReader> kann auch von teilweise vertrauenswürdigem Code aufgerufen werden. In diesem Fall wird die Sicherheit der Zone des Internets für Codezugriffssicherheit angewendet. Wenn alle Elemente in der geladenen XAML Internetsicherheitszone ungültig ist, wird eine XAML-Analyse-Ausnahme ausgelöst. Unter XBAP und in anderen Fällen mit teilweiser Vertrauenswürdigkeit auf Plattformebene, wobei <xref:System.Windows.Markup.XamlReader> ist Teil der Ausführung erhalten Sie das gleiche Verhalten wie bei expliziten teilweiser Vertrauenswürdigkeit Aufrufe.  
  
## <a name="wpf-xaml-xaml-readerswriters-and-xaml-language-versioning"></a>WPF-XAML, XAML-Leser/Schreiber und Versionsverwaltung für XAML-Sprache  
 XAML2009 enthält Funktionen, wie z. B. [X: Reference-](~/docs/framework/xaml-services/x-reference-markup-extension.md) und [X: FactoryMethod-](~/docs/framework/xaml-services/x-factorymethod-directive.md). Sie können die Signaturen der `Load` oder `Parse` XAML geladen, die diese Funktionen verwendet. Diese Sprachfunktionen werden jedoch nicht unterstützt, für XAML, das Markup kompiliert werden muss (z. B. XAML für die **Seite** Buildvorgang in einer WPF-Anwendung oder eine beliebige XAML, der die Aufgabe in den Buildvorgängen Markup beinhaltet).  
  
 WPF-Typen und die WPF-Technologie unterstützen im allgemeinen Konzepte, die für den Zugriff auf WPF-Interna basieren. Beispielsweise, basiert wie WPF Abhängigkeitseigenschaften implementiert auf internen Techniken für die effiziente Typmember-Suche. Zugriff auf diese internen Werte ist aktiviert, die XAML Lesen und Schreiben von APIs, die im bereitgestellten <xref:System.Windows.Markup.XamlWriter> und <xref:System.Windows.Markup.XamlReader> aus der <xref:System.Windows.Markup> Namespace und PresentationFramework-Assembly. Allerdings die Low-Level-XAML-Reader und XAML-Writern aus System.Xaml-Assembly (Klassen basierend auf <xref:System.Xaml.XamlReader?displayProperty=nameWithType>, <xref:System.Xaml.XamlWriter?displayProperty=nameWithType>) haben keinen Zugriff auf die WPF-Interna. Es gibt keine Abhängigkeit von "System.xaml" für jede WPF-spezifische-Assembly. Ohne Zugriff auf die WPF-Interna System.Xaml-Readern und Writern können nicht ordnungsgemäß geladen werden, oder speichern Sie alle WPF-Typen oder Typen basierend auf WPF-Typen. Insbesondere, dass "System.xaml" Reader und Writer nicht verstanden Konzepte, z. B. Unterstützung Eigenschaftenspeicher, oder alle Einzelheiten wie die WPF-Stile, Ressourcenverzeichnisse und Vorlagen verwendet der WPF-Abhängigkeitseigenschaft. Aus diesem Grund müssen Sie eine Auswahl treffen:  
  
-   Wenn Sie WPF-Typen laden, und/oder Sie XAML in BAML-Form, in keiner Weise verwenden, verwenden Sie PresentationFramework XAML-Reader und XAML-Writer.  
  
-   Wenn Sie nicht auf alle WPF-Typen oder die BAML-Form von XAML verlassen, und verwenden einen anderen bestimmten Technologie des XAML-Reader oder XAML-Writer-Implementierung nicht aus Gründen, die für dieses Framework spezifisch sind, verwenden Sie "System.xaml"-XAML-Reader und XAML-Writer.  
  
## <a name="systemxaml-backing-implementation-in-net-4"></a>"System.xaml" enthalten, sichern die Implementierung in .NET 4  
 <xref:System.Windows.Markup.XamlReader> ist die aufrufbare API-Oberfläche für den XAML-Parser in WPF-Frameworkebene. Führt der gleiche zugrunde liegenden XAML-Parser die XAML zur Laufzeit laden und Analysieren von ASP.NET-Vorlagen für WPF-Anwendungen, die auf [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] und [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)].  
  
 Wenn Sie Anzielen [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], die externe API ist identisch, aber Teile der Implementierung auf Grundlage der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] allgemeinen XAML-Implementierung in der System.Xaml-Assembly, die zahlreiche Aspekte der Analyse von XAML technischen und verbessert. Zielgruppenadressierung [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] unbedingt bringt, einschließlich "System.xaml" als Verweis und Details der Implementierung, wie z. B. "System.xaml" enthalten die gemeldeten Ausnahmen stammen möglicherweise Typen definiert.  
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Windows.Controls.Button> in eine Zeichenfolge mithilfe der <xref:System.Windows.Markup.XamlWriter> Klasse.  Die Zeichenfolge dann wieder geladen wird eine <xref:System.Windows.Controls.Button> mit der statischen <xref:System.Windows.Markup.XamlReader.Load%2A> Methode für die <xref:System.Windows.Markup.XamlReader> Klasse.  
  
 [!code-csharp[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Markup.XamlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Markup.XamlReader" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : unit -&gt; unit" Usage="xamlReader.CancelAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bricht den aktuellen asynchronen Ladevorgang ab, wenn noch ein asynchroner Ladevorgang aussteht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Markup.XamlReader.CancelAsync%2A> ist ein asynchroner Vorgang. aus diesem Grund kann einige Laden auftreten, bevor der Vorgang abgebrochen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWpfSchemaContext">
      <MemberSignature Language="C#" Value="public static System.Xaml.XamlSchemaContext GetWpfSchemaContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xaml.XamlSchemaContext GetWpfSchemaContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.GetWpfSchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetWpfSchemaContext () As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xaml::XamlSchemaContext ^ GetWpfSchemaContext();" />
      <MemberSignature Language="F#" Value="static member GetWpfSchemaContext : unit -&gt; System.Xaml.XamlSchemaContext" Usage="System.Windows.Markup.XamlReader.GetWpfSchemaContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Xaml.XamlSchemaContext" />-Objekt zurück, das die Kontexteinstellungen des WPF-Schemas für einen <see cref="T:System.Windows.Markup.XamlReader" /> darstellt.</summary>
        <returns>Ein <see cref="T:System.Xaml.XamlSchemaContext" />-Objekt, das die Kontexteinstellungen des WPF-Schemas für einen <see cref="T:System.Windows.Markup.XamlReader" /> darstellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest XAML-Eingaben und gibt das Stammelement der entsprechenden Objektstruktur zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Das XAML, das geladen werden soll, als Stream.</param>
        <summary>Liest die XAML-Eingabe im angegebenen <see cref="T:System.IO.Stream" /> und gibt ein <see cref="T:System.Object" /> zurück, das das Stammelement der entsprechenden Objektstruktur darstellt.</summary>
        <returns>Das Objekt am Stamm der erstellten Objektstruktur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Windows.Controls.Button> in einem <xref:System.IO.MemoryStream> mithilfe der <xref:System.Windows.Markup.XamlWriter> Klasse. Der Datenstrom wird dann wieder geladen eine <xref:System.Windows.Controls.Button> mit der statischen <xref:System.Windows.Markup.XamlReader.Load%2A> Methode für die <xref:System.Windows.Markup.XamlReader> Klasse.  
  
 [!code-csharp[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.Xaml.XamlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.Xaml.XamlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XamlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::Xaml::XamlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xaml.XamlReader -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xaml.XamlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Ein <see cref="T:System.Xaml.XamlReader" />-Objekt. Es wird davon ausgegangen, dass das Objekt mit Eingabe-XAML initialisiert wird.</param>
        <summary>Liest die XAML-Eingabe über einen bereitgestellten <see cref="T:System.Xaml.XamlReader" /> und gibt ein Objekt zurück, das das Stammelement der entsprechenden Objektstruktur darstellt.</summary>
        <returns>Das Objekt, das das Stammelement der erstellten Objektstruktur darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Eingabe <xref:System.Xaml.XamlReader> kann <xref:System.Windows.Baml2006.Baml2006Reader>. Dies ist, wie Sie BAML für Lokalisierungszwecke-Tool oder zur Laufzeit laden können.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xml.XmlReader -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Der <see cref="T:System.Xml.XmlReader" />, der die im XML-Format zu ladende XAML-Eingabe bereits geladen hat.</param>
        <summary>Liest die XAML-Eingabe im angegebenen <see cref="T:System.Xml.XmlReader" /> und gibt ein Objekt zurück, das das Stammelement der entsprechenden Objektstruktur darstellt.</summary>
        <returns>Das Objekt, das das Stammelement der erstellten Objektstruktur darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Windows.Controls.Button> in eine Zeichenfolge mithilfe der <xref:System.Windows.Markup.XamlWriter> Klasse.  Die Zeichenfolge dann wieder geladen wird eine <xref:System.Windows.Controls.Button> mit der statischen <xref:System.Windows.Markup.XamlReader.Load%2A> Methode für die <xref:System.Windows.Markup.XamlReader> Klasse.  
  
 [!code-csharp[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.IO.Stream stream, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::IO::Stream ^ stream, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream * System.Windows.Markup.ParserContext -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load (stream, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="stream">Der Stream, der die XAML-Eingabe enthält, die geladen werden soll.</param>
        <param name="parserContext">Vom Parser verwendete Kontextinformationen.</param>
        <summary>Liest die XAML-Eingabe im angegebenen <see cref="T:System.IO.Stream" /> und gibt ein Objekt zurück, das das Stammelement der entsprechenden Objektstruktur darstellt.</summary>
        <returns>Das Objekt, das das Stammelement der erstellten Objektstruktur darstellt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ist <see langword="null" />.  Oder:  <paramref name="parserContext" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadAsync">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest XAML-Markup und gibt ein Objekt zurück, das dem Stammelement des angegebenen Markups entspricht.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.IO.Stream -&gt; obj" Usage="xamlReader.LoadAsync stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Der Stream, der die zu ladende XAML-Eingabe enthält.</param>
        <summary>Liest die XAML-Eingabe im angegebenen <see cref="T:System.IO.Stream" /> und gibt das Stammelement der entsprechenden Objektstruktur zurück.</summary>
        <returns>Das Objekt, das das Stammelement der erstellten Objektstruktur darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein asynchroner Ladevorgang von XAML wird zunächst ein Objekt zurück, die nur das Stammobjekt ist. Asynchron, XAML-Analyse dann weiterhin, und alle untergeordneten Objekte werden unter dem Stamm ausgefüllt. Dies steht im Gegensatz zu den typischen WPF XAML verarbeitet wird, Verhalten und die Interaktion mit WPF-Konzepte der Lebensdauer eines Objekts. Bei der Interaktion typische (nicht asynchronen) werden alle Eigenschaften eines Objekts, einschließlich aller untergeordneten Sammlungen vor dem Zurückgeben eines Elements und der Meldung beim Laden gefüllt. Dieses Verhalten entspricht eine Bottom-up-Methode zum Erstellen der Struktur, in dem das Stammobjekt für das letzte Objekt verfügbar ist.  
  
 Sie in der Regel würden das zurückgegebene Objekt in einen Speicherort in der WPF-Anwendung-Objektstruktur zuweisen, mit dem wissen, die Inhalte möglicherweise immer noch werden ausfüllen und möglicherweise inkrementelles Layout-Updates aus, wenn der gesamte Inhalt als Teil der Benutzeroberfläche verfügbar gemacht wird. Aus diesem Grund ist es typisch, zu isolieren oder virtualisieren asynchron geladene Objekte aus XAML und Anwendungsspezifischer Logik oder Anwendungsstatus verwenden, um Sie darüber informieren, dass <xref:System.Windows.Markup.XamlReader.LoadCompleted> erfolgt.  
  
 In der Reihenfolge für <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> um XAML-Eingaben asynchron zu laden, muss das Stammelement in der XAML-Eingabe enthalten, das Attribut und Wert `x:SynchronousMode="Async"`. Der Wert wird Groß-und Kleinschreibung behandelt. Wenn der XAML-Eingabe-Stamm keine `x:SynchronousMode="Async"`, wird keine Ausnahme ausgelöst und der Aufruf als synchrone Last verarbeitet wird (finden Sie unter <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29>).  
  
 Nur ein asynchroner Ladevorgang pro Instanz von der <xref:System.Windows.Markup.XamlReader> Klasse kann zu einem Zeitpunkt ausgeführt werden.  Wenn mehr als einen asynchronen Vorgang, klicken Sie auf der gleichen Instanz von versucht wird der <xref:System.Windows.Markup.XamlReader> Klasse eine <xref:System.InvalidOperationException> ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Es stehen mehrere Ladevorgänge mit demselben <see cref="T:System.Windows.Markup.XamlReader" /> gleichzeitig an.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadAsync (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.Xml.XmlReader -&gt; obj" Usage="xamlReader.LoadAsync reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Ein vorhandener <see cref="T:System.Xml.XmlReader" />, der die XAML-Eingabe bereits geladen bzw. gelesen hat.</param>
        <summary>Liest die XAML-Eingabe im angegebenen <see cref="T:System.Xml.XmlReader" /> und gibt das Stammelement der entsprechenden Objektstruktur zurück.</summary>
        <returns>Das Stammelement der erstellten Objektstruktur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein asynchroner Ladevorgang von XAML wird zunächst ein Objekt zurück, die nur das Stammobjekt ist. Asynchron, XAML-Analyse dann weiterhin, und alle untergeordneten Objekte werden unter dem Stamm ausgefüllt. Dies steht im Gegensatz zu den typischen WPF XAML verarbeitet wird, Verhalten und die Interaktion mit WPF-Konzepte der Lebensdauer eines Objekts. Bei der Interaktion typische (nicht asynchronen) werden alle Eigenschaften eines Objekts, einschließlich aller untergeordneten Sammlungen vor dem Zurückgeben eines Elements und der Meldung beim Laden gefüllt. Dieses Verhalten entspricht eine Bottom-up-Methode zum Erstellen der Struktur, in dem das Stammobjekt für das letzte Objekt verfügbar ist.  
  
 Das zurückgegebene Objekt von würde in der Regel weisen <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> in einen Speicherort in Ihrer Anwendung Objektstruktur, mit dem wissen, dass Inhalt möglicherweise immer noch werden Sie ausfüllen und möglicherweise inkrementelles Layout-Updates aus, wenn der gesamte Inhalt verfügbar, als Teil gemacht wird der -BENUTZEROBERFLÄCHE. Aus diesem Grund ist es typisch, zu isolieren oder virtualisieren asynchron geladene Objekte aus XAML und Anwendungsspezifischer Logik oder Anwendungsstatus verwenden, um Sie darüber informieren, dass <xref:System.Windows.Markup.XamlReader.LoadCompleted> erfolgt.  
  
 In der Reihenfolge für <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> um XAML-Eingaben asynchron zu laden, muss das Stammelement in der XAML-Markup enthalten, das Attribut und Wert `x:SynchronousMode="Async"`. Der Wert wird Groß-und Kleinschreibung behandelt. Wenn die Stammelement des XAML-Markups keine `x:SynchronousMode="Async"`, wird keine Ausnahme ausgelöst und der Aufruf stattdessen als synchrone Last verarbeitet wird (finden Sie unter <xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29>).  
  
 Nur ein asynchroner Ladevorgang pro Instanz von der <xref:System.Windows.Markup.XamlReader> Klasse kann zu einem Zeitpunkt ausgeführt werden.  Wenn mehr als einen asynchronen Vorgang, klicken Sie auf der gleichen Instanz von versucht wird der <xref:System.Windows.Markup.XamlReader> Klasse eine <xref:System.InvalidOperationException> ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Es werden mehrere Ladevorgänge mit demselben <see cref="T:System.Windows.Markup.XamlReader" /> gleichzeitig ausgeführt.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.IO.Stream stream, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::IO::Stream ^ stream, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.IO.Stream * System.Windows.Markup.ParserContext -&gt; obj" Usage="xamlReader.LoadAsync (stream, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="stream">Ein Stream, der die zu ladende XAML-Eingabe enthält.</param>
        <param name="parserContext">Vom Parser verwendete Kontextinformationen.</param>
        <summary>Liest die XAML-Eingabe im angegebenen <see cref="T:System.IO.Stream" /> und gibt das Stammelement der entsprechenden Objektstruktur zurück.</summary>
        <returns>Das Stammelement der erstellten Objektstruktur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein asynchroner Ladevorgang von XAML wird zunächst ein Objekt zurück, die nur das Stammobjekt ist. Asynchron, XAML-Analyse dann weiterhin, und alle untergeordneten Objekte werden unter dem Stamm ausgefüllt. Dies steht im Gegensatz zu den typischen WPF XAML verarbeitet wird, Verhalten und die Interaktion mit WPF-Konzepte der Lebensdauer eines Objekts. Bei der Interaktion typische (nicht asynchronen) werden alle Eigenschaften eines Objekts, einschließlich aller untergeordneten Sammlungen vor dem Zurückgeben eines Elements und der Meldung beim Laden gefüllt. Dieses Verhalten entspricht eine Bottom-up-Methode zum Erstellen der Struktur, in dem das Stammobjekt für das letzte Objekt verfügbar ist.  
  
 Sie in der Regel würden das zurückgegebene Objekt in einen Speicherort in Ihrer Anwendung Objektstruktur zuweisen, mit dem wissen, die Inhalte möglicherweise immer noch werden ausfüllen und möglicherweise inkrementelles Layout-Updates aus, wenn der gesamte Inhalt als Teil der Benutzeroberfläche verfügbar gemacht wird. Aus diesem Grund ist es typisch, zu isolieren oder virtualisieren asynchron geladene Objekte aus XAML und Anwendungsspezifischer Logik oder Anwendungsstatus verwenden, um Sie darüber informieren, dass <xref:System.Windows.Markup.XamlReader.LoadCompleted> erfolgt.  
  
 In der Reihenfolge für <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> Markup asynchron zu laden, muss das Stammelement in der XAML-Markup enthalten, das Attribut und Wert `x:SynchronousMode="Async"`. Der Wert wird Groß-und Kleinschreibung behandelt. Wenn die Stammelement des XAML-Markups keine `x:SynchronousMode="Async"`, wird keine Ausnahme ausgelöst und der Aufruf als synchrone Last verarbeitet wird (finden Sie unter <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29>).  
  
 Nur ein asynchroner Ladevorgang pro Instanz von der <xref:System.Windows.Markup.XamlReader> Klasse kann zu einem Zeitpunkt ausgeführt werden.  Wenn mehr als einen asynchronen Vorgang, klicken Sie auf der gleichen Instanz von versucht wird der <xref:System.Windows.Markup.XamlReader> Klasse eine <xref:System.InvalidOperationException> ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Es werden mehrere Ladevorgänge mit demselben <see cref="T:System.Windows.Markup.XamlReader" /> gleichzeitig ausgeführt.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.AsyncCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.AsyncCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Markup.XamlReader.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As AsyncCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::AsyncCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.ComponentModel.AsyncCompletedEventHandler " Usage="member this.LoadCompleted : System.ComponentModel.AsyncCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AsyncCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein asynchroner Ladevorgang abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Markup.XamlReader.LoadCompleted> wird auch ausgelöst, wenn ein asynchroner Ladevorgang abgebrochen wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.AsyncCompletedEventHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest das Markup in der angegebenen Textzeichenfolge und gibt ein Objekt zurück, das dem Stammelement des angegebenen Markups entspricht.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (string xamlText);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(string xamlText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (xamlText As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(System::String ^ xamlText);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; obj" Usage="System.Windows.Markup.XamlReader.Parse xamlText" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlText" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlText">Das Eingabe-XAML als einzelne Textzeichenfolge.</param>
        <summary>Liest die XAML-Eingabe in der angegebenen Textzeichenfolge und gibt ein Objekt zurück, das dem Stammelement des angegebenen entspricht.</summary>
        <returns>Das Stammelement der erstellten Objektstruktur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung ruft <xref:System.Windows.Markup.XamlReader.Load%2A> intern, nachdem Sie erstellt einen Datenstrom aus der Zeichenfolge. Finden Sie unter <xref:System.Windows.Markup.XamlReader.Load%2A> für zusätzliche Informationen wie z. B. möglichen Ausnahmen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (string xamlText, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(string xamlText, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(System::String ^ xamlText, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Windows.Markup.ParserContext -&gt; obj" Usage="System.Windows.Markup.XamlReader.Parse (xamlText, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlText" Type="System.String" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="xamlText">Das Eingabe-XAML als einzelne Textzeichenfolge.</param>
        <param name="parserContext">Vom Parser verwendete Kontextinformationen.</param>
        <summary>Liest das XAML-Markup in der angegebenen Textzeichenfolge (mithilfe eines angegebenen <see cref="T:System.Windows.Markup.ParserContext" />) und gibt ein Objekt zurück, das dem Stammelement des angegebenen Markups entspricht.</summary>
        <returns>Das Stammelement der erstellten Objektstruktur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung ruft <xref:System.Windows.Markup.XamlReader.Load%2A> intern, nachdem Sie erstellt einen Datenstrom aus der Zeichenfolge. Finden Sie unter <xref:System.Windows.Markup.XamlReader.Load%2A> für zusätzliche Informationen wie z. B. möglichen Ausnahmen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>