<Type Name="INameScope" FullName="System.Windows.Markup.INameScope">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1ae350a552fc26c4cf919e3c7ddd4041a5f79898" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36502831" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface INameScope" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract INameScope" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.INameScope" />
  <TypeSignature Language="VB.NET" Value="Public Interface INameScope" />
  <TypeSignature Language="C++ CLI" Value="public interface class INameScope" />
  <TypeSignature Language="F#" Value="type INameScope = interface" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiert einen Vertrag dafür, wie in einem bestimmten XAML-Namensbereich auf Namen von Elementen zugegriffen werden soll und wie die Eindeutigkeit von Namen innerhalb dieses XAML-Namensbereichs durchgesetzt wird.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Schnittstelle wird von Klassen implementiert, die über untergeordnete Elemente verfügen, die wiederverwendet werden, durch die Vorlage oder das Aufschieben Metapher vorgesehen sind. Vorlagen, Factorys und ähnliche Konstrukte müssen eindeutige Verwendung von XAML-Namensbereiche, die aus einem Diagramm Hauptobjekt getrennt sind und die Stamm-XAML. Hier das Prinzip ist, dass es darf keine Namenskonflikte, wenn Objekte, die von diesen untergeordneten Elementen erstellt in einer Anwendung Objektdiagramm eingeführt werden, und DOM-Operationen und Verwendung von XAML-Verweis Techniken, die auf der Namensbezeichner basieren auf Namen basieren können Eindeutigkeit in jeder XAML-Namensbereich.  
  
 In früheren Versionen von .NET Framework war diese Schnittstelle in der WPF-spezifischen Assembly WindowsBase. In [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Windows.Markup.INameScope> befindet sich in der System.Xaml-Assembly. Weitere Informationen finden Sie unter [aus WPF zu System.Xaml migrierte Typen](~/docs/framework/xaml-services/types-migrated-from-wpf-to-system-xaml.md).  
  
## <a name="wpf-usage-notes"></a>Hinweise zur WPF-Verwendung  
 Diese Schnittstelle wird von der WPF-Klasse implementiert <xref:System.Windows.NameScope>. Die meisten XAML-Namensbereich-Vorgänge in [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] mithilfe der <xref:System.Windows.NameScope> Instanzen, aber Informationen wird gelegentlich intern mit kommuniziert <xref:System.Windows.Markup.INameScope> Verweise.  
  
 Beispiele für WPF-Klassen, die eine Factory verwenden oder das Aufschieben der Metapher in Kombination mit XAML-Darstellung sind <xref:System.Windows.Style> und <xref:System.Windows.FrameworkTemplate>. Diese Implementierungen abhängig die explizite Versionen erhältlich Schnittstellenmethoden in der Regel die <xref:System.Windows.NameScope> Klasse.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.NameScope" />
    <altmember cref="T:System.Windows.Markup.INameScopeDictionary" />
  </Docs>
  <Members>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.INameScope.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member FindName : string -&gt; obj" Usage="iNameScope.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Namensbezeichner für das angeforderte Objekt.</param>
        <summary>Gibt ein Objekt zurück, das über den bereitgestellten kennzeichnenden Namen verfügt.</summary>
        <returns>Das Objekt, falls gefunden. Gibt <see langword="null" /> zurück, wenn kein Objekt dieses Namens gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gültige Namenszeichenfolgen in XAML-Markup müssen die Anforderungen finden Sie im übereinstimmen [XamlName-Grammatik](~/docs/framework/xaml-services/xamlname-grammar.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.INameScope.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="abstract member RegisterName : string * obj -&gt; unit" Usage="iNameScope.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Der zu registrierende Name.</param>
        <param name="scopedElement">Das bestimmte Element, auf das <c>name</c> verweist.</param>
        <summary>Registriert den angegebenen Namen beim aktuellen XAML-Namensbereich.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Doppelte Namen in einem XAML-Namensbereich sind nicht zulässig.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Erlauben Sie keine doppelte Namen registriert werden. Wenn die Eingabe <paramref name="name" /> ist bereits mit einem vorhandenen Element in der internen Auflistung Darstellung der Verwendung von XAML-Namensbereich zugewiesen (auch wenn er als identisch ist <paramref name="scopedElement" />), lösen eine Ausnahme aus.  Auch in Betracht ziehen Sie, eine Ausnahme auszulösen, wenn der angegebene Name nicht [XamlName Grammar](~/docs/framework/xaml-services/xamlname-grammar.md). entspricht</para>
        </block>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.INameScope.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member UnregisterName : string -&gt; unit" Usage="iNameScope.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name, dessen Registrierung aufgehoben werden soll.</param>
        <summary>Hebt die Registrierung des angegebenen Namens beim aktuellen XAML-Namensbereich auf.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Wenn der input-Name nicht vorhanden ist, wird eine Ausnahme ausgelöst.  Sie sollten den Namen und das zuvor registrierten-Element, das aus der Auflistung-Darstellung der XAML-Namensbereich bezieht entfernen, sodass der gleichnamigen möglicherweise erneut in der Zukunft registriert werden konnte.</para>
        </block>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
  </Members>
</Type>