<Type Name="ValueSerializer" FullName="System.Windows.Markup.ValueSerializer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dd9c7e663d9329812873901baee075ff328d0f04" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53501606" /></Metadata><TypeSignature Language="C#" Value="public abstract class ValueSerializer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract ValueSerializer extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.ValueSerializer" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ValueSerializer" />
  <TypeSignature Language="C++ CLI" Value="public ref class ValueSerializer abstract" />
  <TypeSignature Language="F#" Value="type ValueSerializer = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Abstrakte Klasse, die das Konvertierungsverhalten für die Serialisierung aus einer Objektdarstellung definiert.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zeichenfolge, die ein Konverter für die Serialisierung gibt muss verlustfrei und der Konverter muss immer die gleiche Zeichenfolge für einen bestimmten Wert zurückgeben.  Wenn ein Typkonverter (abgeleitet <xref:System.ComponentModel.TypeConverter>) nicht erfüllt diese Anforderungen in der `ConvertTo` Implementierungen für die Zeichenfolgenausgabe, die eine benutzerdefinierte <xref:System.Windows.Markup.ValueSerializer> muss deklariert werden. Entweder die <xref:System.Windows.Markup.ValueSerializer> erfüllen muss, der Anforderungen oder ein NULL-Wert <xref:System.Windows.Markup.ValueSerializer> mit dem Typ zugeordnet werden soll. Ein <xref:System.Windows.Markup.ValueSerializer> bezieht sich auf einen Typ durch Anwenden der <xref:System.Windows.Markup.ValueSerializerAttribute> Attribut.  
  
 Ein NULL-Wert <xref:System.Windows.Markup.ValueSerializer> gibt an, der den Typkonverter für Konvertierungen von Convert-to-Zeichenfolge aus dem Objektdiagramm ignoriert werden sollen.  
  
> [!IMPORTANT]
>  Implementierung von <xref:System.Windows.Markup.ValueSerializer> sollte das Auslösen von Ausnahmen zu vermeiden. Alle ausgelösten Ausnahmen können die Serialisierung beendet.  
  
 <xref:System.Windows.Markup.IValueSerializerContext> für eine <xref:System.Windows.Markup.ValueSerializer> und seiner APIs ist analog zu <xref:System.ComponentModel.ITypeDescriptorContext> für eine <xref:System.ComponentModel.TypeConverter>. In der Tat <xref:System.Windows.Markup.IValueSerializerContext> erbt <xref:System.ComponentModel.ITypeDescriptorContext>. Wenn eine <xref:System.Windows.Markup.ValueSerializer> abgeleiteten API aufgerufen wird, wird der Aufrufer (in der Regel ein Serialisierungsprogramm-Prozess) übergeben wird, einen Kontext an, die bestimmte Dienste bereitstellen kann. Da die allgemeine Empfehlung, die eine <xref:System.Windows.Markup.ValueSerializer> dürfen keine Ausnahmen ausgelöst. Fehler beim Zurückgeben eines bestimmten Diensts aus dem Kontext muss auch keine Ausnahmen auslöst.  
  
 In früheren Versionen von .NET Framework war diese Klasse in der Assembly "WPF-spezifische" WindowsBase. In [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Windows.Markup.ValueSerializer> befindet sich in der System.Xaml-Assembly. Weitere Informationen finden Sie unter [Types Migrated from WPF to System.Xaml](~/docs/framework/xaml-services/types-migrated-from-wpf-to-system-xaml.md).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlXmlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ValueSerializer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Markup.ValueSerializer" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Text des Konstruktors ist leer. die <xref:System.Windows.Markup.ValueSerializer> Klasse enthält keine Werte, die Initialisierung erfordern.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertFromString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertFromString (value As String, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; bool&#xA;override this.CanConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; bool" Usage="valueSerializer.CanConvertFromString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die für die Konvertierung ausgewertet werden soll.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Bestimmt beim Überschreiben in einer abgeleiteten Klasse, ob die angegebene <see cref="T:System.String" /> in eine Instanz des Typs konvertiert werden kann, den die Implementierung von <see cref="T:System.Windows.Markup.ValueSerializer" /> unterstützt.</summary>
        <returns><see langword="true" />, wenn der Wert konvertiert werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Basisimplementierung gibt immer `false` zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertToString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertToString (value As Object, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; bool&#xA;override this.CanConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; bool" Usage="valueSerializer.CanConvertToString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Das Objekt, das für die Konvertierung ausgewertet werden soll.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Bestimmt beim Überschreiben in einer abgeleiteten Klasse, ob das angegebene Objekt in eine <see cref="T:System.String" /> konvertiert werden kann.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" /> in eine <see cref="T:System.String" /> konvertiert werden kann, andernfalls <see langword="false." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Basisimplementierung gibt immer `false` zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertFromString">
      <MemberSignature Language="C#" Value="public virtual object ConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertFromString (value As String, context As IValueSerializerContext) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; obj&#xA;override this.ConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; obj" Usage="valueSerializer.ConvertFromString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Die zu konvertierende Zeichenfolge.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Konvertiert beim Überschreiben in einer abgeleiteten Klasse eine <see cref="T:System.String" /> in eine Instanz des Typs, den die Implementierung von <see cref="T:System.Windows.Markup.ValueSerializer" /> unterstützt.</summary>
        <returns>Eine neue Instanz des Typs, der von der Implementierung von <see cref="T:System.Windows.Markup.ValueSerializer" /> auf Basis des bereitgestellten <paramref name="value" />s unterstützt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die basisimplementierung immer eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="value" /> kann nicht konvertiert werden.</exception>
        <block subset="none" type="overrides"><para>Vermeiden Sie das Auslösen von Ausnahmen von Implementierungen. Siehe <see cref="T:System.Windows.Markup.ValueSerializer" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ConvertToString">
      <MemberSignature Language="C#" Value="public virtual string ConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertToString (value As Object, context As IValueSerializerContext) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; string&#xA;override this.ConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; string" Usage="valueSerializer.ConvertToString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Das in eine Zeichenfolge zu konvertierende Objekt.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Konvertiert das angegebene Objekt beim Überschreiben in einer abgeleiteten Klasse in eine <see cref="T:System.String" />.</summary>
        <returns>Eine Zeichenfolgendarstellung des angegebenen Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die basisimplementierung immer eine Ausnahme ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="value" /> kann nicht konvertiert werden.</exception>
        <block subset="none" type="overrides"><para>Vermeiden Sie das Auslösen von Ausnahmen von Implementierungen. Siehe <see cref="T:System.Windows.Markup.ValueSerializer" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetConvertFromException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertFromException (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertFromException(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertFromException(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertFromException (value As Object) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertFromException(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.GetConvertFromException : obj -&gt; Exception" Usage="valueSerializer.GetConvertFromException value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das Objekt, das nicht konvertiert werden konnte.</param>
        <summary>Gibt eine Ausnahme zurück, wenn eine Konvertierung nicht erfolgen kann.</summary>
        <returns>Ein <see cref="T:System.Exception" />-Objekt für die auszulösende Ausnahme, wenn keine <see langword="ConvertFrom" />-Konvertierung ausgeführt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die tatsächliche `throw` Schlüsselwort wird nicht von dieser Methode aufgerufen, die typische Verwendung ist daher `throw GetConvertFromException` (mit den bereitgestellten Parametern).  
  
 Die spezielle Ausnahme zurückgegeben wird <xref:System.InvalidOperationException>, mit `value` übergeben, die in der Ausnahmemeldung. Das Muster für die Verwendung ist identisch mit Ausnahme von Hilfsprogrammen in <xref:System.ComponentModel.TypeConverter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConvertToException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertToException (object value, Type destinationType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertToException(object value, class System.Type destinationType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertToException(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertToException (value As Object, destinationType As Type) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertToException(System::Object ^ value, Type ^ destinationType);" />
      <MemberSignature Language="F#" Value="member this.GetConvertToException : obj * Type -&gt; Exception" Usage="valueSerializer.GetConvertToException (value, destinationType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="destinationType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">Das Objekt, das nicht konvertiert werden konnte.</param>
        <param name="destinationType">Ein Typ, der die Art der angestrebten Konvertierung darstellt.</param>
        <summary>Gibt eine Ausnahme zurück, wenn eine Konvertierung nicht erfolgen kann.</summary>
        <returns>Ein <see cref="T:System.Exception" />-Objekt für die auszulösende Ausnahme, wenn keine <see langword="ConvertTo" />-Konvertierung ausgeführt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die tatsächliche `throw` Schlüsselwort wird nicht von dieser Methode aufgerufen, die typische Verwendung ist daher `throw GetConvertToException` (mit `value` Parameter angegeben).  
  
 Die spezielle Ausnahme zurückgegeben wird <xref:System.InvalidOperationException>, mit `value` übergeben, die in der Ausnahmemeldung. Das Muster für die Verwendung ist identisch mit Ausnahme von Hilfsprogrammen in <xref:System.ComponentModel.TypeConverter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSerializerFor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.Markup.ValueSerializer" /> für ein Objekt ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : System.ComponentModel.PropertyDescriptor -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor descriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="descriptor">Der CLR-Eigenschaftendeskriptor für die Eigenschaft, die serialisiert werden soll.</param>
        <summary>Ruft den <see cref="T:System.Windows.Markup.ValueSerializer" /> ab, der für eine Eigenschaft deklariert ist, indem ein CLR-Eigenschaftendeskriptor für die Eigenschaft übergeben wird.</summary>
        <returns>Das Serialisierungsprogramm, das der angegebenen Eigenschaft zugeordnet ist. Gibt möglicherweise <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Markup.ValueSerializer> für eine Eigenschaft oder für einen Typ, der als Wert für eine Eigenschaft verwendet wird, wird angegeben, durch Anwenden der <xref:System.Windows.Markup.ValueSerializerAttribute> Attribut für die Deklaration der Eigenschaft oder Typ. Die <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> Methode ist eine Hilfsmethode, die die CLR-Typinformationen System liest und gibt eine neue <xref:System.Windows.Markup.ValueSerializer> Klasse basierend auf dem Attribut, wenn für die Eigenschaft gefunden, oder dann, wenn gefunden wird, auf den Typ der Eigenschaft. `null` kann zurückgegeben werden, wenn kein solches Serialisierungsprogramm vorhanden ist. `null` kann auch zurückgegeben werden, wenn ein Typ oder eine Eigenschaft mit einem Null-Wert absichtlich zugeschrieben wird <xref:System.Windows.Markup.ValueSerializerAttribute>.  
  
 Einen anderen Modus, <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> unterstützt, gibt die interne `TypeConverterValueSerializer` Klasse, die eine <xref:System.Windows.Markup.ValueSerializer> -Implementierung, die dient als Wrapper für eine <xref:System.ComponentModel.TypeConverter> und übersetzt die `Convert` Methoden `Convert*String` Methoden (z. B. <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>wird aufgerufen, mit der Eingabe der <xref:System.String> geben, und übersetzt in <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A>. Dies erfolgt nur in Fällen, in dem alle der folgenden Bedingungen erfüllt sind:  
  
-   Ein <xref:System.ComponentModel.TypeConverterAttribute> befindet sich auf die relevante Eigenschaft oder den entsprechenden Typ der Eigenschaft.  
  
-   Das angezeigte <xref:System.ComponentModel.TypeConverter> wurde erfolgreich erstellt werden können.  
  
-   Die <xref:System.ComponentModel.TypeConverter> gibt `true` für <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>Namens verweisen auf die <xref:System.String> Typ.  
  
-   Die <xref:System.ComponentModel.TypeConverter> gibt `true` für <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType>Namens verweisen auf die <xref:System.String> Typ.  
  
-   Die <xref:System.ComponentModel.TypeConverter> gibt `true` für <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType>Namens verweisen auf die <xref:System.String> Typ.  
  
> [!NOTE]
>  Im folgenden sind spezielle Fälle: <xref:System.DateTime> Typen geben einen <xref:System.Windows.Markup.DateTimeValueSerializer>; <xref:System.String> Rückgabetypen ein internes, aber funktionale-Serialisierungsprogramm (`StringValueSerializer`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="descriptor" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : Type -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, für den der <see cref="T:System.Windows.Markup.ValueSerializer" /> abgerufen werden soll.</param>
        <summary>Ruft den <see cref="T:System.Windows.Markup.ValueSerializer" /> ab, der für den angegebenen Typ deklariert wurde.</summary>
        <returns>Das Serialisierungsprogramm, das dem angegebenen Typ zugeordnet ist. Gibt möglicherweise <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Markup.ValueSerializer> für ein Typ, durch Anwenden angegeben wird der <xref:System.Windows.Markup.ValueSerializerAttribute> Attribut für die Deklaration des Typs. Die <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> Methode ist eine Hilfsmethode, die die CLR-Typinformationen System liest und gibt eine neue <xref:System.Windows.Markup.ValueSerializer> Klasse basierend auf dem Attribut, wenn finden Sie auf den angegebenen `type`. `null` kann zurückgegeben werden, wenn kein solches Serialisierungsprogramm vorhanden ist. `null` kann auch zurückgegeben, wenn ein Typ mit einem Null-Wert absichtlich zugeschrieben wird <xref:System.Windows.Markup.ValueSerializerAttribute>.  
  
 Einen anderen Modus, <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> unterstützt, gibt die interne `TypeConverterValueSerializer` Klasse, die eine <xref:System.Windows.Markup.ValueSerializer> -Implementierung, die dient als Wrapper für eine <xref:System.ComponentModel.TypeConverter> und übersetzt die `Convert` Methoden `Convert*String` Methoden (z. B. <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>wird aufgerufen, mit der Eingabe der <xref:System.String> geben, und übersetzt in <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A>. Dies erfolgt nur in Fällen, in dem alle der folgenden Bedingungen erfüllt sind:  
  
-   Ein <xref:System.ComponentModel.TypeConverterAttribute> befindet sich auf `type`.  
  
-   Das angezeigte <xref:System.ComponentModel.TypeConverter> wurde erfolgreich erstellt werden können.  
  
-   Die <xref:System.ComponentModel.TypeConverter> gibt `true` für <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>Namens verweisen auf die <xref:System.String> Typ.  
  
-   Die <xref:System.ComponentModel.TypeConverter> gibt `true` für <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType>Namens verweisen auf die <xref:System.String> Typ.  
  
-   Die <xref:System.ComponentModel.TypeConverter> gibt `true` für <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType>Namens verweisen auf die <xref:System.String> Typ.  
  
> [!NOTE]
>  Im folgenden sind spezielle Fälle: <xref:System.DateTime> Typen geben einen <xref:System.Windows.Markup.DateTimeValueSerializer>; <xref:System.String> Rückgabetypen ein internes, aber funktionale-Serialisierungsprogramm (`StringValueSerializer`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor, context As IValueSerializerContext) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : System.ComponentModel.PropertyDescriptor * System.Windows.Markup.IValueSerializerContext -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor (descriptor, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="descriptor">Der Deskriptor für die Eigenschaft, die serialisiert werden soll.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Ruft mit dem angegebenen Kontext den <see cref="T:System.Windows.Markup.ValueSerializer" /> ab, der für die angegebene Eigenschaft deklariert ist.</summary>
        <returns>Das Serialisierungsprogramm, das der angegebenen Eigenschaft zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Statt nur auf Attribute gemeldeten im CLR-Typsystem, diese Überladung verwendet die `context` als Dienst und ruft die dienstimplementierung des <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>. Die <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> Implementierung würde in der Regel auch basieren auf der `descriptor`, könnte aber spezielles Verhalten für bestimmte Kontexte implementieren.  
  
 Diese Methode sollte aufgerufen werden, wenn der Aufrufer einen verfügbaren hat <xref:System.Windows.Markup.IValueSerializerContext> von einem Dienst.  Dies stellt sicher, dass die richtige <xref:System.Windows.Markup.ValueSerializer> wird für den angegebenen Kontext zurückgegeben.  
  
 Wenn der Kontext zurückgibt `null` aus der <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> für Ihre angegebenen `descriptor`, oder wenn der Kontext, die Sie angeben, ist `null`, Verhalten identisch mit der Aufruf ist die <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.ComponentModel.PropertyDescriptor%29> überladen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="descriptor" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : Type * System.Windows.Markup.IValueSerializerContext -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor (type, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, für den der <see cref="T:System.Windows.Markup.ValueSerializer" /> abgerufen werden soll.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Ruft mit dem angegebenen Kontext den <see cref="T:System.Windows.Markup.ValueSerializer" /> ab, der für den angegebenen Typ deklariert ist.</summary>
        <returns>Das Serialisierungsprogramm, das dem angegebenen Typ zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Statt nur auf Attribute gemeldeten im CLR-Typsystem, diese Überladung verwendet die `context` als Dienst und ruft die dienstimplementierung des <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>. Die <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> Implementierung würde in der Regel auch basieren auf der `type`, könnte aber spezielles Verhalten für bestimmte Kontexte implementieren.  
  
 Diese Methode sollte aufgerufen werden, wenn der Aufrufer einen verfügbaren hat <xref:System.Windows.Markup.IValueSerializerContext> von einem Dienst. Dies stellt sicher, dass die richtige <xref:System.Windows.Markup.ValueSerializer> wird für den angegebenen Kontext zurückgegeben.  
  
 Wenn der Kontext zurückgibt `null` aus der <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> für Ihre angegebenen `type`, oder wenn der Kontext, die Sie angeben, ist `null`, Verhalten identisch mit der Aufruf ist die <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.Type%29> überladen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeReferences">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; TypeReferences (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; TypeReferences(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.TypeReferences(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TypeReferences (value As Object, context As IValueSerializerContext) As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ TypeReferences(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member TypeReferences : obj * System.Windows.Markup.IValueSerializerContext -&gt; seq&lt;Type&gt;&#xA;override this.TypeReferences : obj * System.Windows.Markup.IValueSerializerContext -&gt; seq&lt;Type&gt;" Usage="valueSerializer.TypeReferences (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Der zu serialisierende Wert.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Ruft eine Enumeration der Typen auf, auf die <see cref="T:System.Windows.Markup.ValueSerializer" /> verweist.</summary>
        <returns>Die von diesem Serialisierungsprogramm konvertierten Typen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Typen einen <xref:System.Windows.Markup.ValueSerializer> konvertiert, die in der zurückgegebenen Enumeration eingeschlossen werden soll.  Dadurch kann es sich um ein Serialisierungsprogramm sicherstellen, dass ein Deserialisierungsprogramm verfügt, genügend Informationen zu den vom Serialisierungsprogramm konvertierten.  
  
 Diese Methode überschreiben, ist ein erweitertes Szenario. Überschreiben darf nur sein erforderlich, wenn Sie ein System implementieren, in denen CLR System Besitzertyp-Eigenschaft typbeziehungen für einen XAML-Schemakontext verfügbar nicht genügend Informationen melden.  
  
## <a name="wpf-usage-notes"></a>Hinweise zur WPF-Verwendung  
 Die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Eigenschaftensystem implementiert eine interne Werte-Serialisierungsprogramm, das überschreibt <xref:System.Windows.Markup.ValueSerializer.TypeReferences%2A> da eine Abhängigkeitseigenschaft über ein Konzept hat, dass er Besitzer hinzugefügt haben, kann. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Ausdrücke können spezielle interne Behandlung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>