<Type Name="ValueSerializer" FullName="System.Windows.Markup.ValueSerializer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="531f9d9ba781b72f2ffeebff4f24830e253106be" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69166924" /></Metadata><TypeSignature Language="C#" Value="public abstract class ValueSerializer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract ValueSerializer extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.ValueSerializer" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ValueSerializer" />
  <TypeSignature Language="C++ CLI" Value="public ref class ValueSerializer abstract" />
  <TypeSignature Language="F#" Value="type ValueSerializer = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Abstrakte Klasse, die Konvertierungsverhalten für die Serialisierung von einer Objektdarstellung definiert.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zeichenfolge, die ein Konverter für die Serialisierung zurückgibt, muss weniger Verlust sein, und der Konverter muss immer dieselbe Zeichenfolge für einen bestimmten Wert zurückgeben.  Wenn ein Typkonverter (abgeleitet von <xref:System.ComponentModel.TypeConverter>) diese Anforderungen in seinen Implementierungen für die `ConvertTo` Zeichen folgen Ausgabe nicht erfüllt, muss <xref:System.Windows.Markup.ValueSerializer> ein benutzerdefinierter deklariert werden. Der muss die Anforderungen erfüllen, oder dem Typ muss <xref:System.Windows.Markup.ValueSerializer> ein NULL-Wert zugeordnet werden. <xref:System.Windows.Markup.ValueSerializer> Ein <xref:System.Windows.Markup.ValueSerializer> wird einem Typ durch Anwenden des <xref:System.Windows.Markup.ValueSerializerAttribute> -Attributs zugeordnet.  
  
 Ein NULL <xref:System.Windows.Markup.ValueSerializer> -Wert gibt an, dass der Typkonverter für Konvertierungen von Konvertierungen aus dem Objekt Diagramm ignoriert werden soll.  
  
> [!IMPORTANT]
>  Die Implementierung <xref:System.Windows.Markup.ValueSerializer> von sollte das Auslösen von Ausnahmen vermeiden. Alle ausgelösten Ausnahmen könnten die Serialisierung beenden.  
  
 <xref:System.Windows.Markup.IValueSerializerContext>für eine <xref:System.Windows.Markup.ValueSerializer> und ihre APIs ist analog zu <xref:System.ComponentModel.ITypeDescriptorContext> für eine <xref:System.ComponentModel.TypeConverter>. Tatsächlich <xref:System.Windows.Markup.IValueSerializerContext> erbt <xref:System.ComponentModel.ITypeDescriptorContext>. Wenn eine <xref:System.Windows.Markup.ValueSerializer> abgeleitete Klassen-API aufgerufen wird, übergibt der Aufrufer (in der Regel ein Serialisierungsprozess) einen Kontext, der möglicherweise bestimmte Dienste bereitstellt. Aufgrund der allgemeinen Anleitung, dass ein <xref:System.Windows.Markup.ValueSerializer> keine Ausnahmen auslösen darf. Wenn ein bestimmter Dienst nicht aus dem Kontext zurückgegeben wird, müssen auch keine Ausnahmen ausgelöst werden.  
  
 In früheren Versionen des .NET Framework war diese Klasse in der WPF-spezifischen Assembly Windows Base vorhanden. In [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]befindetsichin derSystem.XAML-Assembly.<xref:System.Windows.Markup.ValueSerializer> Weitere Informationen finden Sie unter [Types Migrated from WPF to System.Xaml](~/docs/framework/xaml-services/types-migrated-from-wpf-to-system-xaml.md).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlXmlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ValueSerializer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Markup.ValueSerializer" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Hauptteil dieses Konstruktors ist leer. die <xref:System.Windows.Markup.ValueSerializer> -Klasse enthält keine Werte, für die eine Initialisierung erforderlich ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertFromString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertFromString (value As String, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; bool&#xA;override this.CanConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; bool" Usage="valueSerializer.CanConvertFromString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die für die Konvertierung ausgewertet werden soll.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Bestimmt beim Überschreiben in einer abgeleiteten Klasse, ob die angegebene <see cref="T:System.String" /> in eine Instanz des Typs konvertiert werden kann, den die Implementierung von <see cref="T:System.Windows.Markup.ValueSerializer" /> unterstützt.</summary>
        <returns><see langword="true" />, wenn der Wert konvertiert werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Basisimplementierung gibt immer `false` zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertToString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertToString (value As Object, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; bool&#xA;override this.CanConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; bool" Usage="valueSerializer.CanConvertToString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Das Objekt, das für die Konvertierung ausgewertet werden soll.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Bestimmt beim Überschreiben in einer abgeleiteten Klasse, ob das angegebene Objekt in eine <see cref="T:System.String" /> konvertiert werden kann.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" /> in eine <see cref="T:System.String" /> konvertiert werden kann, andernfalls <see langword="false." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Basisimplementierung gibt immer `false` zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertFromString">
      <MemberSignature Language="C#" Value="public virtual object ConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertFromString (value As String, context As IValueSerializerContext) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; obj&#xA;override this.ConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; obj" Usage="valueSerializer.ConvertFromString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Die zu konvertierende Zeichenfolge.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Konvertiert beim Überschreiben in einer abgeleiteten Klasse eine <see cref="T:System.String" /> in eine Instanz des Typs, den die Implementierung von <see cref="T:System.Windows.Markup.ValueSerializer" /> unterstützt.</summary>
        <returns>Eine neue Instanz des Typs, der von der Implementierung von <see cref="T:System.Windows.Markup.ValueSerializer" /> auf Basis des bereitgestellten <paramref name="value" />s unterstützt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Basis Implementierung löst immer eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="value" /> kann nicht konvertiert werden.</exception>
        <block subset="none" type="overrides"><para>Vermeiden Sie das Auslösen von Ausnahmen aus-Implementierungen. Siehe <see cref="T:System.Windows.Markup.ValueSerializer" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ConvertToString">
      <MemberSignature Language="C#" Value="public virtual string ConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertToString (value As Object, context As IValueSerializerContext) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; string&#xA;override this.ConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; string" Usage="valueSerializer.ConvertToString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Das in eine Zeichenfolge zu konvertierende Objekt.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Konvertiert das angegebene Objekt beim Überschreiben in einer abgeleiteten Klasse in eine <see cref="T:System.String" />.</summary>
        <returns>Eine Zeichenfolgendarstellung des angegebenen Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Basis Implementierung löst immer eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="value" /> kann nicht konvertiert werden.</exception>
        <block subset="none" type="overrides"><para>Vermeiden Sie das Auslösen von Ausnahmen aus-Implementierungen. Siehe <see cref="T:System.Windows.Markup.ValueSerializer" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetConvertFromException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertFromException (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertFromException(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertFromException(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertFromException (value As Object) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertFromException(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.GetConvertFromException : obj -&gt; Exception" Usage="valueSerializer.GetConvertFromException value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Das Objekt, das nicht konvertiert werden konnte.</param>
        <summary>Gibt eine Ausnahme zurück, die ausgelöst wird, wenn eine Konvertierung nicht durchgeführt werden kann.</summary>
        <returns>Ein <see cref="T:System.Exception" />-Objekt für die Ausnahme, die ausgelöst wird, wenn eine <see langword="ConvertFrom" />-Konvertierung nicht durchgeführt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Schlüssel `throw` Wort "Actual" wird nicht von dieser Methode aufgerufen, daher ist `throw GetConvertFromException` die typische Verwendung (mit Parametern angegeben).  
  
 Die spezifische Ausnahme, die <xref:System.InvalidOperationException>zurückgegeben `value` wird, ist, wobei in der Ausnahme Meldung ausgegeben wird. Das Verwendungs Muster ist das gleiche wie bei Ausnahme Dienstprogrammen in <xref:System.ComponentModel.TypeConverter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConvertToException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertToException (object value, Type destinationType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertToException(object value, class System.Type destinationType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertToException(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertToException (value As Object, destinationType As Type) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertToException(System::Object ^ value, Type ^ destinationType);" />
      <MemberSignature Language="F#" Value="member this.GetConvertToException : obj * Type -&gt; Exception" Usage="valueSerializer.GetConvertToException (value, destinationType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="destinationType" Type="System.Type" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Das Objekt, das nicht konvertiert werden konnte.</param>
        <param name="destinationType">Ein Typ, der den Typ darstellt, in den konvertiert werden sollte.</param>
        <summary>Gibt eine Ausnahme zurück, die ausgelöst wird, wenn eine Konvertierung nicht durchgeführt werden kann.</summary>
        <returns>Ein <see cref="T:System.Exception" />-Objekt für die Ausnahme, die ausgelöst wird, wenn eine <see langword="ConvertTo" />-Konvertierung nicht durchgeführt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Schlüssel `throw` Wort "Actual" wird nicht von dieser Methode aufgerufen, daher ist `throw GetConvertToException` die typische `value` Verwendung (mit dem angegebenen Parameter).  
  
 Die spezifische Ausnahme, die <xref:System.InvalidOperationException>zurückgegeben `value` wird, ist, wobei in der Ausnahme Meldung ausgegeben wird. Das Verwendungs Muster ist das gleiche wie bei Ausnahme Dienstprogrammen in <xref:System.ComponentModel.TypeConverter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSerializerFor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.Markup.ValueSerializer" /> für ein Objekt ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : System.ComponentModel.PropertyDescriptor -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor descriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" Index="0" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="descriptor">Der CLR-Eigenschaftendeskriptor für die zu serialisierende Eigenschaft.</param>
        <summary>Ruft den <see cref="T:System.Windows.Markup.ValueSerializer" /> ab, der für eine Eigenschaft deklariert wurde, indem ein CLR-Eigenschaftendeskriptor für die Eigenschaft übergeben wird.</summary>
        <returns>Das der angegebenen Eigenschaft zugeordnete Serialisierungsprogramm. Gibt möglicherweise <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Windows.Markup.ValueSerializer> für eine Eigenschaft oder für einen Typ, der als Wert für eine Eigenschaft verwendet wird, wird durch Anwenden des <xref:System.Windows.Markup.ValueSerializerAttribute> -Attributs auf die Eigenschaft oder Typdeklaration angegeben. Bei <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> der-Methode handelt es sich um eine hilfsprogrammmethode, die die Systeminformationen des <xref:System.Windows.Markup.ValueSerializer> CLR-Typs liest und eine neue Klasse auf der Grundlage des-Attributs zurückgibt, wenn Sie in der-Eigenschaft gefunden wird. `null`kann zurückgegeben werden, wenn kein solcher Serialisierungsprogramm vorhanden ist. `null`kann auch zurückgegeben werden, wenn ein Typ oder eine Eigenschaft absichtlich mit einem NULL- <xref:System.Windows.Markup.ValueSerializerAttribute>Wert attributiert wird.  
  
 Ein anderer Modus <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> , der unterstützt, `TypeConverterValueSerializer` gibt die interne-Klasse <xref:System.Windows.Markup.ValueSerializer> zurück. Hierbei handelt es sich um `Convert` eine- `Convert*String` Implementierung, die einen <xref:System.ComponentModel.TypeConverter> umschließt und die Methoden in Methoden übersetzt ( <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>wird mit Eingabe des <xref:System.String> Typs aufgerufen und übersetzt in. <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A> Dies geschieht nur in Fällen, in denen alle folgenden Punkte zutreffen:  
  
-   Eine <xref:System.ComponentModel.TypeConverterAttribute> wird für die relevante Eigenschaft oder den Typ der relevanten Eigenschaft gefunden.  
  
-   Die Angabe <xref:System.ComponentModel.TypeConverter> kann erfolgreich erstellt werden.  
  
-   Der <xref:System.ComponentModel.TypeConverter> gibt `true` für <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>zurück, der als Verweis <xref:System.String> auf den Typ bezeichnet wird.  
  
-   Der <xref:System.ComponentModel.TypeConverter> gibt `true` für <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType>zurück, der als Verweis <xref:System.String> auf den Typ bezeichnet wird.  
  
-   Der <xref:System.ComponentModel.TypeConverter> gibt `true` für <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType>zurück, der als Verweis <xref:System.String> auf den Typ bezeichnet wird.  
  
> [!NOTE]
>  Folgendes sind Sonderfälle: <xref:System.DateTime> -Typen geben einen <xref:System.Windows.Markup.DateTimeValueSerializer>zurück. Typen geben einen internen, aber funktionalen Serialisierer`StringValueSerializer`() zurück. <xref:System.String>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="descriptor" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : Type -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, für den der <see cref="T:System.Windows.Markup.ValueSerializer" /> abgerufen werden soll.</param>
        <summary>Ruft den für den angegebenen Typ deklarierten <see cref="T:System.Windows.Markup.ValueSerializer" /> ab.</summary>
        <returns>Das dem angegebenen Typ zugeordnete Serialisierungsprogramm. Gibt möglicherweise <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Markup.ValueSerializer> für einen Typ wird durch Anwenden des <xref:System.Windows.Markup.ValueSerializerAttribute> -Attributs auf die Typdeklaration angegeben. Die <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> -Methode ist eine hilfsprogrammmethode, die die CLR-typsysteminformationen liest <xref:System.Windows.Markup.ValueSerializer> und eine neue-Klasse auf Grundlage des-Attributs zurückgibt, sofern diese im angegebenen `type`gefunden wird. `null`kann zurückgegeben werden, wenn kein solcher Serialisierungsprogramm vorhanden ist. `null`kann auch zurückgegeben werden, wenn ein Typ absichtlich mit einem NULL-Wert <xref:System.Windows.Markup.ValueSerializerAttribute>attributiert wird.  
  
 Ein anderer Modus <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> , der unterstützt, `TypeConverterValueSerializer` gibt die interne-Klasse <xref:System.Windows.Markup.ValueSerializer> zurück. Hierbei handelt es sich um `Convert` eine- `Convert*String` Implementierung, die einen <xref:System.ComponentModel.TypeConverter> umschließt und die Methoden in Methoden übersetzt ( <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>wird mit Eingabe des <xref:System.String> Typs aufgerufen und übersetzt in. <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A> Dies geschieht nur in Fällen, in denen alle folgenden Punkte zutreffen:  
  
-   Ein <xref:System.ComponentModel.TypeConverterAttribute> -Wert finden `type`Sie unter.  
  
-   Die Angabe <xref:System.ComponentModel.TypeConverter> kann erfolgreich erstellt werden.  
  
-   Der <xref:System.ComponentModel.TypeConverter> gibt `true` für <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>zurück, der als Verweis <xref:System.String> auf den Typ bezeichnet wird.  
  
-   Der <xref:System.ComponentModel.TypeConverter> gibt `true` für <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType>zurück, der als Verweis <xref:System.String> auf den Typ bezeichnet wird.  
  
-   Der <xref:System.ComponentModel.TypeConverter> gibt `true` für <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType>zurück, der als Verweis <xref:System.String> auf den Typ bezeichnet wird.  
  
> [!NOTE]
>  Folgendes sind Sonderfälle: <xref:System.DateTime> -Typen geben einen <xref:System.Windows.Markup.DateTimeValueSerializer>zurück. Typen geben einen internen, aber funktionalen Serialisierer`StringValueSerializer`() zurück. <xref:System.String>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor, context As IValueSerializerContext) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : System.ComponentModel.PropertyDescriptor * System.Windows.Markup.IValueSerializerContext -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor (descriptor, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="descriptor">Deskriptor für die zu serialisierende Eigenschaft.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Ruft im angegebenen Kontext den für die angegebene Eigenschaft deklarierten <see cref="T:System.Windows.Markup.ValueSerializer" /> ab.</summary>
        <returns>Das der angegebenen Eigenschaft zugeordnete Serialisierungsprogramm.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt sich ausschließlich auf Attribute zu verlassen, die im CLR-Typsystem gemeldet werden, `context` verwendet diese Überladung den as-a-Service und <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>Ruft die-Implementierung des dienstanders von auf. Die <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> Implementierung würde in der Regel auch `descriptor`auf basieren, kann jedoch ein spezielles Verhalten für bestimmte Kontexte implementieren.  
  
 Diese Methode sollte aufgerufen werden, wenn der Aufrufer <xref:System.Windows.Markup.IValueSerializerContext> über einen aus einem Dienst verfügbar ist.  Dadurch wird sichergestellt, dass <xref:System.Windows.Markup.ValueSerializer> der richtige Wert für den jeweiligen Kontext zurückgegeben wird.  
  
 Wenn der Kontext <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> aus `null` dem für die angegebene `descriptor`zurückgibt, oder wenn der von Ihnen angegebene `null`Kontext ist, dann ist das Verhalten mit <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.ComponentModel.PropertyDescriptor%29> dem Aufruf der-Überladung identisch.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="descriptor" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : Type * System.Windows.Markup.IValueSerializerContext -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor (type, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, für den der <see cref="T:System.Windows.Markup.ValueSerializer" /> abgerufen werden soll.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Ruft im angegebenen Kontext den für den angegebenen Typ deklarierten <see cref="T:System.Windows.Markup.ValueSerializer" /> ab.</summary>
        <returns>Das dem angegebenen Typ zugeordnete Serialisierungsprogramm.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt sich ausschließlich auf Attribute zu verlassen, die im CLR-Typsystem gemeldet werden, `context` verwendet diese Überladung den as-a-Service und <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>Ruft die-Implementierung des dienstanders von auf. Die <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> Implementierung würde in der Regel auch `type`auf basieren, kann jedoch ein spezielles Verhalten für bestimmte Kontexte implementieren.  
  
 Diese Methode sollte aufgerufen werden, wenn der Aufrufer <xref:System.Windows.Markup.IValueSerializerContext> über einen aus einem Dienst verfügbar ist. Dadurch wird sichergestellt, dass <xref:System.Windows.Markup.ValueSerializer> der richtige Wert für den jeweiligen Kontext zurückgegeben wird.  
  
 Wenn der Kontext <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> aus `null` dem für die angegebene `type`zurückgibt, oder wenn der von Ihnen angegebene `null`Kontext ist, dann ist das Verhalten mit <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.Type%29> dem Aufruf der-Überladung identisch.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeReferences">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; TypeReferences (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; TypeReferences(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.TypeReferences(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TypeReferences (value As Object, context As IValueSerializerContext) As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ TypeReferences(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member TypeReferences : obj * System.Windows.Markup.IValueSerializerContext -&gt; seq&lt;Type&gt;&#xA;override this.TypeReferences : obj * System.Windows.Markup.IValueSerializerContext -&gt; seq&lt;Type&gt;" Usage="valueSerializer.TypeReferences (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-4.8" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" Index="1" FrameworkAlternate="netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Der serialisierte Wert.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Ruft eine Enumeration der vom <see cref="T:System.Windows.Markup.ValueSerializer" /> referenzierten Typen ab.</summary>
        <returns>Die durch dieses Serialisierungsprogramm konvertierten Typen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Typen, <xref:System.Windows.Markup.ValueSerializer> die von a konvertiert werden, sollten in der zurückgegebenen Enumeration enthalten sein.  Dadurch kann ein Serialisierungsprogramm sicherstellen, dass ein Deserialisierungsprogramm über genügend Informationen zu den Typen verfügt, die von diesem Serialisierungsprogramm konvertiert werden.  
  
 Das Überschreiben dieser Methode ist ein erweitertes Szenario. Das Überschreiben ist nur erforderlich, wenn Sie ein System implementieren, bei dem CLR-Typsystem Besitzer-Eigenschafts Beziehungen, die für einen XAML-Schema Kontext verfügbar sind, nicht genügend Informationen melden.  
  
## <a name="wpf-usage-notes"></a>Hinweise zur WPF-Verwendung  
 Das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Eigenschaften System implementiert einen internen wertserialisierer, der über <xref:System.Windows.Markup.ValueSerializer.TypeReferences%2A> schreibt, da eine Abhängigkeits Eigenschaft über ein Konzept verfügt, das Sie hinzufügen kann. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]Ausdrücke verfügen auch über eine spezielle interne Verarbeitung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
