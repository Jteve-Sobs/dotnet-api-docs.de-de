<Type Name="ValueSerializer" FullName="System.Windows.Markup.ValueSerializer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f0f2c4a65c825c475081f4131da78103a60aed28" /><Meta Name="ms.sourcegitcommit" Value="9506e50ec7beb4fa30206b9840dc546b035a6600" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/23/2020" /><Meta Name="ms.locfileid" Value="86980680" /></Metadata><TypeSignature Language="C#" Value="public abstract class ValueSerializer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ValueSerializer extends System.Object" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.ValueSerializer" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ValueSerializer" />
  <TypeSignature Language="C++ CLI" Value="public ref class ValueSerializer abstract" />
  <TypeSignature Language="F#" Value="type ValueSerializer = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract ValueSerializer extends System.Object" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="WindowsBase" FromVersion="4.0.0.0" To="System.Xaml" ToVersion="4.0.0.0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.Runtime.CompilerServices.TypeForwardedFrom("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TypeForwardedFrom("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Abstrakte Klasse, die das Konvertierungsverhalten für die Serialisierung aus einer Objektdarstellung definiert.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zeichenfolge, die ein Konverter für die Serialisierung zurückgibt, muss weniger Verlust sein, und der Konverter muss immer dieselbe Zeichenfolge für einen bestimmten Wert zurückgeben.  Wenn ein Typkonverter (abgeleitet von <xref:System.ComponentModel.TypeConverter> ) diese Anforderungen in seinen `ConvertTo` Implementierungen für die Zeichen folgen Ausgabe nicht erfüllt, muss ein benutzerdefinierter <xref:System.Windows.Markup.ValueSerializer> deklariert werden. Der <xref:System.Windows.Markup.ValueSerializer> muss die Anforderungen erfüllen, oder dem Typ muss ein NULL-Wert <xref:System.Windows.Markup.ValueSerializer> zugeordnet werden. Ein <xref:System.Windows.Markup.ValueSerializer> wird einem Typ durch Anwenden des- <xref:System.Windows.Markup.ValueSerializerAttribute> Attributs zugeordnet.  
  
 Ein NULL-Wert <xref:System.Windows.Markup.ValueSerializer> gibt an, dass der Typkonverter für Konvertierungen von Konvertierungen aus dem Objekt Diagramm ignoriert werden soll.  
  
> [!IMPORTANT]
>  Die Implementierung von sollte das Auslösen von <xref:System.Windows.Markup.ValueSerializer> Ausnahmen vermeiden. Alle ausgelösten Ausnahmen könnten die Serialisierung beenden.  
  
 <xref:System.Windows.Markup.IValueSerializerContext>für eine <xref:System.Windows.Markup.ValueSerializer> und ihre APIs ist analog zu <xref:System.ComponentModel.ITypeDescriptorContext> für eine <xref:System.ComponentModel.TypeConverter> . Tatsächlich <xref:System.Windows.Markup.IValueSerializerContext> erbt <xref:System.ComponentModel.ITypeDescriptorContext> . Wenn eine <xref:System.Windows.Markup.ValueSerializer> abgeleitete Klassen-API aufgerufen wird, übergibt der Aufrufer (in der Regel ein Serialisierungsprozess) einen Kontext, der möglicherweise bestimmte Dienste bereitstellt. Aufgrund der allgemeinen Anleitung, dass ein <xref:System.Windows.Markup.ValueSerializer> keine Ausnahmen auslösen darf. Wenn ein bestimmter Dienst nicht aus dem Kontext zurückgegeben wird, müssen auch keine Ausnahmen ausgelöst werden.  
  
 In früheren Versionen des .NET Framework war diese Klasse in der WPF-spezifischen Assembly Windows Base vorhanden. In [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] <xref:System.Windows.Markup.ValueSerializer> befindet sich in der System. XAML-Assembly. Weitere Informationen finden Sie unter [Types Migrated from WPF to System.Xaml](/dotnet/framework/xaml-services/types-migrated-from-wpf-to-system-xaml).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlXmlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ValueSerializer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Markup.ValueSerializer" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Hauptteil dieses Konstruktors ist leer. die- <xref:System.Windows.Markup.ValueSerializer> Klasse enthält keine Werte, für die eine Initialisierung erforderlich ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertFromString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertFromString (value As String, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; bool&#xA;override this.CanConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; bool" Usage="valueSerializer.CanConvertFromString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die für die Konvertierung ausgewertet werden soll.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Bestimmt beim Überschreiben in einer abgeleiteten Klasse, ob die angegebene <see cref="T:System.String" /> in eine Instanz des Typs konvertiert werden kann, den die Implementierung von <see cref="T:System.Windows.Markup.ValueSerializer" /> unterstützt.</summary>
        <returns><see langword="true" />, wenn der Wert konvertiert werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Basisimplementierung gibt immer `false` zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertToString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertToString (value As Object, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; bool&#xA;override this.CanConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; bool" Usage="valueSerializer.CanConvertToString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Das Objekt, das für die Konvertierung ausgewertet werden soll.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Bestimmt beim Überschreiben in einer abgeleiteten Klasse, ob das angegebene Objekt in eine <see cref="T:System.String" /> konvertiert werden kann.</summary>
        <returns><see langword="true" />, wenn <paramref name="value" /> in einen konvertiert werden kann, <see cref="T:System.String" /> andernfalls <see langword="false" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Basisimplementierung gibt immer `false` zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertFromString">
      <MemberSignature Language="C#" Value="public virtual object ConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertFromString (value As String, context As IValueSerializerContext) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; obj&#xA;override this.ConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; obj" Usage="valueSerializer.ConvertFromString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Die zu konvertierende Zeichenfolge.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Konvertiert beim Überschreiben in einer abgeleiteten Klasse eine <see cref="T:System.String" /> in eine Instanz des Typs, den die Implementierung von <see cref="T:System.Windows.Markup.ValueSerializer" /> unterstützt.</summary>
        <returns>Eine neue Instanz des Typs, der von der Implementierung von <see cref="T:System.Windows.Markup.ValueSerializer" /> auf Basis des bereitgestellten <paramref name="value" />s unterstützt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Basis Implementierung löst immer eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="value" /> kann nicht konvertiert werden.</exception>
        <block subset="none" type="overrides"><para>Vermeiden Sie das Auslösen von Ausnahmen aus-Implementierungen. Siehe <see cref="T:System.Windows.Markup.ValueSerializer" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ConvertToString">
      <MemberSignature Language="C#" Value="public virtual string ConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertToString (value As Object, context As IValueSerializerContext) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; string&#xA;override this.ConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; string" Usage="valueSerializer.ConvertToString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Das in eine Zeichenfolge zu konvertierende Objekt.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Konvertiert das angegebene Objekt beim Überschreiben in einer abgeleiteten Klasse in eine <see cref="T:System.String" />.</summary>
        <returns>Eine Zeichenfolgendarstellung des angegebenen Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Basis Implementierung löst immer eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="value" /> kann nicht konvertiert werden.</exception>
        <block subset="none" type="overrides"><para>Vermeiden Sie das Auslösen von Ausnahmen aus-Implementierungen. Siehe <see cref="T:System.Windows.Markup.ValueSerializer" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetConvertFromException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertFromException (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertFromException(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertFromException(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertFromException (value As Object) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertFromException(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.GetConvertFromException : obj -&gt; Exception" Usage="valueSerializer.GetConvertFromException value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das Objekt, das nicht konvertiert werden konnte.</param>
        <summary>Gibt eine Ausnahme zurück, wenn eine Konvertierung nicht erfolgen kann.</summary>
        <returns>Ein <see cref="T:System.Exception" />-Objekt für die auszulösende Ausnahme, wenn keine <see langword="ConvertFrom" />-Konvertierung ausgeführt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Schlüsselwort "Actual" `throw` wird nicht von dieser Methode aufgerufen, daher ist die typische Verwendung `throw GetConvertFromException` (mit Parametern angegeben).  
  
 Die spezifische Ausnahme, die zurückgegeben wird <xref:System.InvalidOperationException> , ist, wobei `value` in der Ausnahme Meldung ausgegeben wird. Das Verwendungs Muster ist das gleiche wie bei Ausnahme Dienstprogrammen in <xref:System.ComponentModel.TypeConverter> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConvertToException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertToException (object value, Type destinationType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertToException(object value, class System.Type destinationType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertToException(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertToException (value As Object, destinationType As Type) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertToException(System::Object ^ value, Type ^ destinationType);" />
      <MemberSignature Language="F#" Value="member this.GetConvertToException : obj * Type -&gt; Exception" Usage="valueSerializer.GetConvertToException (value, destinationType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="destinationType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">Das Objekt, das nicht konvertiert werden konnte.</param>
        <param name="destinationType">Ein Typ, der die Art der angestrebten Konvertierung darstellt.</param>
        <summary>Gibt eine Ausnahme zurück, wenn eine Konvertierung nicht erfolgen kann.</summary>
        <returns>Ein <see cref="T:System.Exception" />-Objekt für die auszulösende Ausnahme, wenn keine <see langword="ConvertTo" />-Konvertierung ausgeführt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Schlüsselwort "Actual" `throw` wird nicht von dieser Methode aufgerufen, daher ist die typische Verwendung `throw GetConvertToException` (mit dem `value` angegebenen Parameter).  
  
 Die spezifische Ausnahme, die zurückgegeben wird <xref:System.InvalidOperationException> , ist, wobei `value` in der Ausnahme Meldung ausgegeben wird. Das Verwendungs Muster ist das gleiche wie bei Ausnahme Dienstprogrammen in <xref:System.ComponentModel.TypeConverter> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSerializerFor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.Markup.ValueSerializer" /> für ein Objekt ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : System.ComponentModel.PropertyDescriptor -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor descriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="descriptor">Der CLR-Eigenschaftendeskriptor für die Eigenschaft, die serialisiert werden soll.</param>
        <summary>Ruft den <see cref="T:System.Windows.Markup.ValueSerializer" /> ab, der für eine Eigenschaft deklariert ist, indem ein CLR-Eigenschaftendeskriptor für die Eigenschaft übergeben wird.</summary>
        <returns>Das Serialisierungsprogramm, das der angegebenen Eigenschaft zugeordnet ist. Gibt möglicherweise <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Windows.Markup.ValueSerializer> für eine Eigenschaft oder für einen Typ, der als Wert für eine Eigenschaft verwendet wird, wird durch Anwenden des- <xref:System.Windows.Markup.ValueSerializerAttribute> Attributs auf die Eigenschaft oder Typdeklaration angegeben. Bei der- <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> Methode handelt es sich um eine hilfsprogrammmethode, die die Systeminformationen des CLR-Typs liest und eine neue <xref:System.Windows.Markup.ValueSerializer> Klasse auf der Grundlage des-Attributs zurückgibt, wenn Sie in der-Eigenschaft gefunden wird. `null`kann zurückgegeben werden, wenn kein solcher Serialisierungsprogramm vorhanden ist. `null`kann auch zurückgegeben werden, wenn ein Typ oder eine Eigenschaft absichtlich mit einem NULL-Wert attributiert wird <xref:System.Windows.Markup.ValueSerializerAttribute> .  
  
 Ein anderer Modus, <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> der von unterstützt wird, gibt die interne-Klasse zurück. hierbei `TypeConverterValueSerializer` handelt es sich um eine-Implementierung, die ein umschließt <xref:System.Windows.Markup.ValueSerializer> <xref:System.ComponentModel.TypeConverter> und die `Convert` Methoden in Methoden übersetzt (z. b. `Convert*String` <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType> wird mit Eingabe des <xref:System.String> -Typs aufgerufen und übersetzt <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A> Dies geschieht nur in Fällen, in denen alle folgenden Punkte zutreffen:  
  
-   Eine <xref:System.ComponentModel.TypeConverterAttribute> wird für die relevante Eigenschaft oder den Typ der relevanten Eigenschaft gefunden.  
  
-   Die Angabe <xref:System.ComponentModel.TypeConverter> kann erfolgreich erstellt werden.  
  
-   Der <xref:System.ComponentModel.TypeConverter> gibt `true` für zurück <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType> , der als Verweis auf den Typ bezeichnet wird <xref:System.String> .  
  
-   Der <xref:System.ComponentModel.TypeConverter> gibt `true` für zurück <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType> , der als Verweis auf den Typ bezeichnet wird <xref:System.String> .  
  
-   Der <xref:System.ComponentModel.TypeConverter> gibt `true` für zurück <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType> , der als Verweis auf den Typ bezeichnet wird <xref:System.String> .  
  
> [!NOTE]
>  Im folgenden sind Sonderfälle aufgeführt:- <xref:System.DateTime> Typen geben einen zurück <xref:System.Windows.Markup.DateTimeValueSerializer> .- <xref:System.String> Typen geben einen internen, aber funktionalen Serialisierer ( `StringValueSerializer` ) zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="descriptor" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (type As Type) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : Type -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, für den der <see cref="T:System.Windows.Markup.ValueSerializer" /> abgerufen werden soll.</param>
        <summary>Ruft den <see cref="T:System.Windows.Markup.ValueSerializer" /> ab, der für den angegebenen Typ deklariert wurde.</summary>
        <returns>Das Serialisierungsprogramm, das dem angegebenen Typ zugeordnet ist. Gibt möglicherweise <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Markup.ValueSerializer> für einen Typ wird durch Anwenden des- <xref:System.Windows.Markup.ValueSerializerAttribute> Attributs auf die Typdeklaration angegeben. Die- <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> Methode ist eine hilfsprogrammmethode, die die CLR-typsysteminformationen liest und eine neue- <xref:System.Windows.Markup.ValueSerializer> Klasse auf Grundlage des-Attributs zurückgibt, sofern diese im angegebenen gefunden wird `type` . `null`kann zurückgegeben werden, wenn kein solcher Serialisierungsprogramm vorhanden ist. `null`kann auch zurückgegeben werden, wenn ein Typ absichtlich mit einem NULL-Wert attributiert wird <xref:System.Windows.Markup.ValueSerializerAttribute> .  
  
 Ein anderer Modus, <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> der von unterstützt wird, gibt die interne-Klasse zurück. hierbei `TypeConverterValueSerializer` handelt es sich um eine-Implementierung, die ein umschließt <xref:System.Windows.Markup.ValueSerializer> <xref:System.ComponentModel.TypeConverter> und die `Convert` Methoden in Methoden übersetzt (z. b. `Convert*String` <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType> wird mit Eingabe des <xref:System.String> -Typs aufgerufen und übersetzt <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A> Dies geschieht nur in Fällen, in denen alle folgenden Punkte zutreffen:  
  
-   Ein-Wert <xref:System.ComponentModel.TypeConverterAttribute> finden Sie unter `type` .  
  
-   Die Angabe <xref:System.ComponentModel.TypeConverter> kann erfolgreich erstellt werden.  
  
-   Der <xref:System.ComponentModel.TypeConverter> gibt `true` für zurück <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType> , der als Verweis auf den Typ bezeichnet wird <xref:System.String> .  
  
-   Der <xref:System.ComponentModel.TypeConverter> gibt `true` für zurück <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType> , der als Verweis auf den Typ bezeichnet wird <xref:System.String> .  
  
-   Der <xref:System.ComponentModel.TypeConverter> gibt `true` für zurück <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType> , der als Verweis auf den Typ bezeichnet wird <xref:System.String> .  
  
> [!NOTE]
>  Im folgenden sind Sonderfälle aufgeführt:- <xref:System.DateTime> Typen geben einen zurück <xref:System.Windows.Markup.DateTimeValueSerializer> .- <xref:System.String> Typen geben einen internen, aber funktionalen Serialisierer ( `StringValueSerializer` ) zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor, context As IValueSerializerContext) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : System.ComponentModel.PropertyDescriptor * System.Windows.Markup.IValueSerializerContext -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor (descriptor, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="descriptor">Der Deskriptor für die Eigenschaft, die serialisiert werden soll.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Ruft mit dem angegebenen Kontext den <see cref="T:System.Windows.Markup.ValueSerializer" /> ab, der für die angegebene Eigenschaft deklariert ist.</summary>
        <returns>Das Serialisierungsprogramm, das der angegebenen Eigenschaft zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt sich ausschließlich auf Attribute zu verlassen, die im CLR-Typsystem gemeldet werden, verwendet diese Überladung den `context` As-a-Service und ruft die-Implementierung des dienstanders von auf <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> . Die <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> Implementierung würde in der Regel auch auf basieren `descriptor` , kann jedoch ein spezielles Verhalten für bestimmte Kontexte implementieren.  
  
 Diese Methode sollte aufgerufen werden, wenn der Aufrufer über einen <xref:System.Windows.Markup.IValueSerializerContext> aus einem Dienst verfügbar ist.  Dadurch wird sichergestellt, dass der richtige Wert <xref:System.Windows.Markup.ValueSerializer> für den jeweiligen Kontext zurückgegeben wird.  
  
 Wenn der Kontext aus dem für die angegebene zurückgibt `null` <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> `descriptor` , oder wenn der von Ihnen angegebene Kontext ist `null` , dann ist das Verhalten mit dem Aufruf der-Überladung identisch <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.ComponentModel.PropertyDescriptor%29> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="descriptor" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (type As Type, context As IValueSerializerContext) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : Type * System.Windows.Markup.IValueSerializerContext -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor (type, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, für den der <see cref="T:System.Windows.Markup.ValueSerializer" /> abgerufen werden soll.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Ruft mit dem angegebenen Kontext den <see cref="T:System.Windows.Markup.ValueSerializer" /> ab, der für den angegebenen Typ deklariert ist.</summary>
        <returns>Das Serialisierungsprogramm, das dem angegebenen Typ zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt sich ausschließlich auf Attribute zu verlassen, die im CLR-Typsystem gemeldet werden, verwendet diese Überladung den `context` As-a-Service und ruft die-Implementierung des dienstanders von auf <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> . Die <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> Implementierung würde in der Regel auch auf basieren `type` , kann jedoch ein spezielles Verhalten für bestimmte Kontexte implementieren.  
  
 Diese Methode sollte aufgerufen werden, wenn der Aufrufer über einen <xref:System.Windows.Markup.IValueSerializerContext> aus einem Dienst verfügbar ist. Dadurch wird sichergestellt, dass der richtige Wert <xref:System.Windows.Markup.ValueSerializer> für den jeweiligen Kontext zurückgegeben wird.  
  
 Wenn der Kontext aus dem für die angegebene zurückgibt `null` <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> `type` , oder wenn der von Ihnen angegebene Kontext ist `null` , dann ist das Verhalten mit dem Aufruf der-Überladung identisch <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.Type%29> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeReferences">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; TypeReferences (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; TypeReferences(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.TypeReferences(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TypeReferences (value As Object, context As IValueSerializerContext) As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ TypeReferences(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member TypeReferences : obj * System.Windows.Markup.IValueSerializerContext -&gt; seq&lt;Type&gt;&#xA;override this.TypeReferences : obj * System.Windows.Markup.IValueSerializerContext -&gt; seq&lt;Type&gt;" Usage="valueSerializer.TypeReferences (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Der zu serialisierende Wert.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Ruft eine Enumeration der Typen auf, auf die <see cref="T:System.Windows.Markup.ValueSerializer" /> verweist.</summary>
        <returns>Die von diesem Serialisierungsprogramm konvertierten Typen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Typen, <xref:System.Windows.Markup.ValueSerializer> die von a konvertiert werden, sollten in der zurückgegebenen Enumeration enthalten sein.  Dadurch kann ein Serialisierungsprogramm sicherstellen, dass ein Deserialisierungsprogramm über genügend Informationen zu den Typen verfügt, die von diesem Serialisierungsprogramm konvertiert werden.  
  
 Das Überschreiben dieser Methode ist ein erweitertes Szenario. Das Überschreiben ist nur erforderlich, wenn Sie ein System implementieren, bei dem CLR-Typsystem Besitzer-Eigenschafts Beziehungen, die für einen XAML-Schema Kontext verfügbar sind, nicht genügend Informationen melden.  
  
## <a name="wpf-usage-notes"></a>Hinweise zur WPF-Verwendung  
 Das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Eigenschaften System implementiert einen internen wertserialisierer, der überschreibt, <xref:System.Windows.Markup.ValueSerializer.TypeReferences%2A> da eine Abhängigkeits Eigenschaft über ein Konzept verfügt, das Sie hinzufügen kann. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]Ausdrücke verfügen auch über eine spezielle interne Verarbeitung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
