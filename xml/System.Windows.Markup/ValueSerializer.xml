<Type Name="ValueSerializer" FullName="System.Windows.Markup.ValueSerializer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f9944fe4d34b3205ff4fa0097cb38e4b4d800468" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78840069" /></Metadata><TypeSignature Language="C#" Value="public abstract class ValueSerializer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ValueSerializer extends System.Object" FrameworkAlternate="netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.ValueSerializer" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ValueSerializer" />
  <TypeSignature Language="C++ CLI" Value="public ref class ValueSerializer abstract" />
  <TypeSignature Language="F#" Value="type ValueSerializer = class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract ValueSerializer extends System.Object" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="WindowsBase" FromVersion="4.0.0.0" To="System.Xaml" ToVersion="4.0.0.0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Abstrakte Klasse, die das Konvertierungsverhalten für die Serialisierung aus einer Objektdarstellung definiert.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zeichenfolge, die ein Konverter für die Serialisierung zurückgibt, muss weniger Verlust sein, und der Konverter muss immer dieselbe Zeichenfolge für einen bestimmten Wert zurückgeben.  Wenn ein Typkonverter (abgeleitet von <xref:System.ComponentModel.TypeConverter>) diese Anforderungen in seinen `ConvertTo`-Implementierungen für die Zeichen folgen Ausgabe nicht erfüllt, muss ein benutzerdefinierter <xref:System.Windows.Markup.ValueSerializer> deklariert werden. Der <xref:System.Windows.Markup.ValueSerializer> muss die Anforderungen erfüllen, oder dem Typ muss eine NULL-<xref:System.Windows.Markup.ValueSerializer> zugeordnet werden. Ein <xref:System.Windows.Markup.ValueSerializer> wird einem Typ durch Anwenden des <xref:System.Windows.Markup.ValueSerializerAttribute> Attributs zugeordnet.  
  
 Ein NULL-<xref:System.Windows.Markup.ValueSerializer> gibt an, dass der Typkonverter für Konvertierungen von Konvertierungen aus dem Objekt Diagramm ignoriert werden soll.  
  
> [!IMPORTANT]
>  Die Implementierung von <xref:System.Windows.Markup.ValueSerializer> sollte das Auslösen von Ausnahmen vermeiden. Alle ausgelösten Ausnahmen könnten die Serialisierung beenden.  
  
 <xref:System.Windows.Markup.IValueSerializerContext> für einen <xref:System.Windows.Markup.ValueSerializer> und seine APIs entsprechen <xref:System.ComponentModel.ITypeDescriptorContext> für eine <xref:System.ComponentModel.TypeConverter>. Tatsächlich erbt <xref:System.Windows.Markup.IValueSerializerContext> <xref:System.ComponentModel.ITypeDescriptorContext>. Wenn eine <xref:System.Windows.Markup.ValueSerializer> abgeleitete Klassen-API aufgerufen wird, übergibt der Aufrufer (in der Regel ein Serialisierungsprogramme) einen Kontext, der möglicherweise bestimmte Dienste bereitstellt. Aufgrund der allgemeinen Anleitung, dass ein <xref:System.Windows.Markup.ValueSerializer> keine Ausnahmen auslösen darf. Wenn ein bestimmter Dienst nicht aus dem Kontext zurückgegeben wird, müssen auch keine Ausnahmen ausgelöst werden.  
  
 In früheren Versionen des .NET Framework war diese Klasse in der WPF-spezifischen Assembly Windows Base vorhanden. In [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]befindet sich <xref:System.Windows.Markup.ValueSerializer> in der Assembly "System. XAML". Weitere Informationen finden Sie unter [Types Migrated from WPF to System.Xaml](~/docs/framework/xaml-services/types-migrated-from-wpf-to-system-xaml.md).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlXmlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ValueSerializer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Markup.ValueSerializer" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Hauptteil dieses Konstruktors ist leer. die <xref:System.Windows.Markup.ValueSerializer>-Klasse enthält keine Werte, für die eine Initialisierung erforderlich ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertFromString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertFromString (value As String, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; bool&#xA;override this.CanConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; bool" Usage="valueSerializer.CanConvertFromString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolge, die für die Konvertierung ausgewertet werden soll.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Bestimmt beim Überschreiben in einer abgeleiteten Klasse, ob die angegebene <see cref="T:System.String" /> in eine Instanz des Typs konvertiert werden kann, den die Implementierung von <see cref="T:System.Windows.Markup.ValueSerializer" /> unterstützt.</summary>
        <returns><see langword="true" />, wenn der Wert konvertiert werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Basisimplementierung gibt immer `false` zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertToString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertToString (value As Object, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; bool&#xA;override this.CanConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; bool" Usage="valueSerializer.CanConvertToString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Das Objekt, das für die Konvertierung ausgewertet werden soll.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Bestimmt beim Überschreiben in einer abgeleiteten Klasse, ob das angegebene Objekt in eine <see cref="T:System.String" /> konvertiert werden kann.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" /> in eine <see cref="T:System.String" /> konvertiert werden kann, andernfalls <see langword="false." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Basisimplementierung gibt immer `false` zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertFromString">
      <MemberSignature Language="C#" Value="public virtual object ConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertFromString (value As String, context As IValueSerializerContext) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; obj&#xA;override this.ConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; obj" Usage="valueSerializer.ConvertFromString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Die zu konvertierende Zeichenfolge.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Konvertiert beim Überschreiben in einer abgeleiteten Klasse eine <see cref="T:System.String" /> in eine Instanz des Typs, den die Implementierung von <see cref="T:System.Windows.Markup.ValueSerializer" /> unterstützt.</summary>
        <returns>Eine neue Instanz des Typs, der von der Implementierung von <see cref="T:System.Windows.Markup.ValueSerializer" /> auf Basis des bereitgestellten <paramref name="value" />s unterstützt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Basis Implementierung löst immer eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="value" /> kann nicht konvertiert werden.</exception>
        <block subset="none" type="overrides"><para>Vermeiden Sie das Auslösen von Ausnahmen aus-Implementierungen. Siehe <see cref="T:System.Windows.Markup.ValueSerializer" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ConvertToString">
      <MemberSignature Language="C#" Value="public virtual string ConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertToString (value As Object, context As IValueSerializerContext) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; string&#xA;override this.ConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; string" Usage="valueSerializer.ConvertToString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Das in eine Zeichenfolge zu konvertierende Objekt.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Konvertiert das angegebene Objekt beim Überschreiben in einer abgeleiteten Klasse in eine <see cref="T:System.String" />.</summary>
        <returns>Eine Zeichenfolgendarstellung des angegebenen Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Basis Implementierung löst immer eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="value" /> kann nicht konvertiert werden.</exception>
        <block subset="none" type="overrides"><para>Vermeiden Sie das Auslösen von Ausnahmen aus-Implementierungen. Siehe <see cref="T:System.Windows.Markup.ValueSerializer" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetConvertFromException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertFromException (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertFromException(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertFromException(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertFromException (value As Object) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertFromException(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.GetConvertFromException : obj -&gt; Exception" Usage="valueSerializer.GetConvertFromException value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Das Objekt, das nicht konvertiert werden konnte.</param>
        <summary>Gibt eine Ausnahme zurück, wenn eine Konvertierung nicht erfolgen kann.</summary>
        <returns>Ein <see cref="T:System.Exception" />-Objekt für die auszulösende Ausnahme, wenn keine <see langword="ConvertFrom" />-Konvertierung ausgeführt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das tatsächliche `throw`-Schlüsselwort wird von dieser Methode nicht aufgerufen, daher wird die typische Verwendung `throw GetConvertFromException` (mit den angegebenen Parametern).  
  
 Die spezifische Ausnahme, die zurückgegeben wird, ist <xref:System.InvalidOperationException>, wobei `value` in der Ausnahme Meldung übermittelt wurde. Das Verwendungs Muster ist das gleiche wie bei Ausnahme Dienstprogrammen in <xref:System.ComponentModel.TypeConverter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConvertToException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertToException (object value, Type destinationType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertToException(object value, class System.Type destinationType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertToException(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertToException (value As Object, destinationType As Type) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertToException(System::Object ^ value, Type ^ destinationType);" />
      <MemberSignature Language="F#" Value="member this.GetConvertToException : obj * Type -&gt; Exception" Usage="valueSerializer.GetConvertToException (value, destinationType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="destinationType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">Das Objekt, das nicht konvertiert werden konnte.</param>
        <param name="destinationType">Ein Typ, der den Typ darstellt, in den konvertiert werden sollte.</param>
        <summary>Gibt eine Ausnahme zurück, wenn eine Konvertierung nicht erfolgen kann.</summary>
        <returns>Ein <see cref="T:System.Exception" />-Objekt für die auszulösende Ausnahme, wenn keine <see langword="ConvertTo" />-Konvertierung ausgeführt werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das tatsächliche `throw`-Schlüsselwort wird von dieser Methode nicht aufgerufen, daher ist die typische Verwendung `throw GetConvertToException` (mit `value` Parameter).  
  
 Die spezifische Ausnahme, die zurückgegeben wird, ist <xref:System.InvalidOperationException>, wobei `value` in der Ausnahme Meldung übermittelt wurde. Das Verwendungs Muster ist das gleiche wie bei Ausnahme Dienstprogrammen in <xref:System.ComponentModel.TypeConverter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSerializerFor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den <see cref="T:System.Windows.Markup.ValueSerializer" /> für ein Objekt ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : System.ComponentModel.PropertyDescriptor -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor descriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="descriptor">Der CLR-Eigenschaftendeskriptor für die zu serialisierende Eigenschaft.</param>
        <summary>Ruft den <see cref="T:System.Windows.Markup.ValueSerializer" /> ab, der für eine Eigenschaft deklariert wurde, indem ein CLR-Eigenschaftendeskriptor für die Eigenschaft übergeben wird.</summary>
        <returns>Das der angegebenen Eigenschaft zugeordnete Serialisierungsprogramm. Gibt möglicherweise <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Windows.Markup.ValueSerializer> für eine Eigenschaft oder für einen Typ, der als Wert für eine Eigenschaft verwendet wird, wird durch Anwenden des <xref:System.Windows.Markup.ValueSerializerAttribute>-Attributs auf die Eigenschaft oder Typdeklaration angegeben. Die <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A>-Methode ist eine hilfsprogrammmethode, die die CLR-typsysteminformationen liest und eine neue <xref:System.Windows.Markup.ValueSerializer> Klasse auf der Grundlage des Attributs zurückgibt, wenn Sie in der Eigenschaft gefunden wird, oder wenn Sie für den Eigenschaftentyp gefunden wurde. `null` kann zurückgegeben werden, wenn kein solcher Serialisierungsprogramm vorhanden ist. `null` kann auch zurückgegeben werden, wenn ein Typ oder eine Eigenschaft absichtlich mit einem NULL-Wert-<xref:System.Windows.Markup.ValueSerializerAttribute>attributiert wird.  
  
 Ein anderer Modus, den <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> unterstützt, gibt die interne `TypeConverterValueSerializer`-Klasse zurück. Hierbei handelt es sich um eine <xref:System.Windows.Markup.ValueSerializer>-Implementierung, die ein <xref:System.ComponentModel.TypeConverter> umschließt und die `Convert` Methoden in `Convert*String` Methoden übersetzt (z. b. wird <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType> mit Eingabe des <xref:System.String> Typs aufgerufen und in <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A>übersetzt. Dies geschieht nur in Fällen, in denen alle folgenden Punkte zutreffen:  
  
-   Eine <xref:System.ComponentModel.TypeConverterAttribute> wird für die relevante Eigenschaft oder den Typ der relevanten Eigenschaft gefunden.  
  
-   Der <xref:System.ComponentModel.TypeConverter>, der angezeigt wird, kann erfolgreich erstellt werden.  
  
-   Der <xref:System.ComponentModel.TypeConverter> gibt `true` für <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>zurück, die als Verweis auf den <xref:System.String> Typ bezeichnet werden.  
  
-   Der <xref:System.ComponentModel.TypeConverter> gibt `true` für <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType>zurück, die als Verweis auf den <xref:System.String> Typ bezeichnet werden.  
  
-   Der <xref:System.ComponentModel.TypeConverter> gibt `true` für <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType>zurück, die als Verweis auf den <xref:System.String> Typ bezeichnet werden.  
  
> [!NOTE]
>  Folgendes sind Sonderfälle: <xref:System.DateTime> Typen geben eine <xref:System.Windows.Markup.DateTimeValueSerializer>zurück. <xref:System.String> Typen geben einen internen, aber funktionalen Serialisierer (`StringValueSerializer`) zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="descriptor" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (type As Type) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : Type -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, für den der <see cref="T:System.Windows.Markup.ValueSerializer" /> abgerufen werden soll.</param>
        <summary>Ruft den für den angegebenen Typ deklarierten <see cref="T:System.Windows.Markup.ValueSerializer" /> ab.</summary>
        <returns>Das dem angegebenen Typ zugeordnete Serialisierungsprogramm. Gibt möglicherweise <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Windows.Markup.ValueSerializer> für einen Typ wird durch Anwenden des <xref:System.Windows.Markup.ValueSerializerAttribute>-Attributs auf die Typdeklaration angegeben. Die <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A>-Methode ist eine hilfsprogrammmethode, die die CLR-typsysteminformationen liest und eine neue <xref:System.Windows.Markup.ValueSerializer> Klasse auf Grundlage des-Attributs zurückgibt, wenn Sie auf dem angegebenen `type`gefunden wird. `null` kann zurückgegeben werden, wenn kein solcher Serialisierungsprogramm vorhanden ist. `null` kann auch zurückgegeben werden, wenn ein Typ absichtlich mit einem NULL-Wert-<xref:System.Windows.Markup.ValueSerializerAttribute>attributiert wird.  
  
 Ein anderer Modus, den <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> unterstützt, gibt die interne `TypeConverterValueSerializer`-Klasse zurück. Hierbei handelt es sich um eine <xref:System.Windows.Markup.ValueSerializer>-Implementierung, die ein <xref:System.ComponentModel.TypeConverter> umschließt und die `Convert` Methoden in `Convert*String` Methoden übersetzt (z. b. wird <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType> mit Eingabe des <xref:System.String> Typs aufgerufen und in <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A>übersetzt. Dies geschieht nur in Fällen, in denen alle folgenden Punkte zutreffen:  
  
-   Ein <xref:System.ComponentModel.TypeConverterAttribute> wird auf `type`gefunden.  
  
-   Der <xref:System.ComponentModel.TypeConverter>, der angezeigt wird, kann erfolgreich erstellt werden.  
  
-   Der <xref:System.ComponentModel.TypeConverter> gibt `true` für <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>zurück, die als Verweis auf den <xref:System.String> Typ bezeichnet werden.  
  
-   Der <xref:System.ComponentModel.TypeConverter> gibt `true` für <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType>zurück, die als Verweis auf den <xref:System.String> Typ bezeichnet werden.  
  
-   Der <xref:System.ComponentModel.TypeConverter> gibt `true` für <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType>zurück, die als Verweis auf den <xref:System.String> Typ bezeichnet werden.  
  
> [!NOTE]
>  Folgendes sind Sonderfälle: <xref:System.DateTime> Typen geben eine <xref:System.Windows.Markup.DateTimeValueSerializer>zurück. <xref:System.String> Typen geben einen internen, aber funktionalen Serialisierer (`StringValueSerializer`) zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor, context As IValueSerializerContext) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : System.ComponentModel.PropertyDescriptor * System.Windows.Markup.IValueSerializerContext -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor (descriptor, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="descriptor">Deskriptor für die zu serialisierende Eigenschaft.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Ruft im angegebenen Kontext den für die angegebene Eigenschaft deklarierten <see cref="T:System.Windows.Markup.ValueSerializer" /> ab.</summary>
        <returns>Das Serialisierungsprogramm, das der angegebenen Eigenschaft zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt sich ausschließlich auf Attribute zu verlassen, die im CLR-Typsystem gemeldet werden, verwendet diese Überladung den `context` als Dienst und ruft die Implementierung von <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>des dienstaners auf. Die <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>-Implementierung beruht in der Regel auch auf der `descriptor`, kann jedoch ein spezielles Verhalten für bestimmte Kontexte implementieren.  
  
 Diese Methode sollte aufgerufen werden, wenn der Aufrufer über eine verfügbare <xref:System.Windows.Markup.IValueSerializerContext> aus einem Dienst verfügt.  Dadurch wird sichergestellt, dass die richtige <xref:System.Windows.Markup.ValueSerializer> für den jeweiligen Kontext zurückgegeben wird.  
  
 Wenn der Kontext `null` aus seiner <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> für den angegebenen `descriptor`zurückgibt, oder wenn der von Ihnen angegebene Kontext `null`ist, ist das Verhalten mit dem Aufrufen der <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.ComponentModel.PropertyDescriptor%29> Überladung identisch.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="descriptor" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (type As Type, context As IValueSerializerContext) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : Type * System.Windows.Markup.IValueSerializerContext -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor (type, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, für den der <see cref="T:System.Windows.Markup.ValueSerializer" /> abgerufen werden soll.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Ruft im angegebenen Kontext den für den angegebenen Typ deklarierten <see cref="T:System.Windows.Markup.ValueSerializer" /> ab.</summary>
        <returns>Das Serialisierungsprogramm, das dem angegebenen Typ zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anstatt sich ausschließlich auf Attribute zu verlassen, die im CLR-Typsystem gemeldet werden, verwendet diese Überladung den `context` als Dienst und ruft die Implementierung von <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>des dienstaners auf. Die <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>-Implementierung beruht in der Regel auch auf der `type`, kann jedoch ein spezielles Verhalten für bestimmte Kontexte implementieren.  
  
 Diese Methode sollte aufgerufen werden, wenn der Aufrufer über eine verfügbare <xref:System.Windows.Markup.IValueSerializerContext> aus einem Dienst verfügt. Dadurch wird sichergestellt, dass die richtige <xref:System.Windows.Markup.ValueSerializer> für den jeweiligen Kontext zurückgegeben wird.  
  
 Wenn der Kontext `null` aus seiner <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> für den angegebenen `type`zurückgibt, oder wenn der von Ihnen angegebene Kontext `null`ist, ist das Verhalten mit dem Aufrufen der <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.Type%29> Überladung identisch.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeReferences">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; TypeReferences (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; TypeReferences(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.TypeReferences(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TypeReferences (value As Object, context As IValueSerializerContext) As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ TypeReferences(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member TypeReferences : obj * System.Windows.Markup.IValueSerializerContext -&gt; seq&lt;Type&gt;&#xA;override this.TypeReferences : obj * System.Windows.Markup.IValueSerializerContext -&gt; seq&lt;Type&gt;" Usage="valueSerializer.TypeReferences (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">Der serialisierte Wert.</param>
        <param name="context">Die für die Konvertierung verwendeten Kontextinformationen.</param>
        <summary>Ruft eine Enumeration der vom <see cref="T:System.Windows.Markup.ValueSerializer" /> referenzierten Typen ab.</summary>
        <returns>Die von diesem Serialisierungsprogramm konvertierten Typen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Typen, die von einem <xref:System.Windows.Markup.ValueSerializer> konvertiert werden, sollten in der zurückgegebenen Enumeration enthalten sein.  Dadurch kann ein Serialisierungsprogramm sicherstellen, dass ein Deserialisierungsprogramm über genügend Informationen zu den Typen verfügt, die von diesem Serialisierungsprogramm konvertiert werden.  
  
 Das Überschreiben dieser Methode ist ein erweitertes Szenario. Das Überschreiben ist nur erforderlich, wenn Sie ein System implementieren, bei dem CLR-Typsystem Besitzer-Eigenschafts Beziehungen, die für einen XAML-Schema Kontext verfügbar sind, nicht genügend Informationen melden.  
  
## <a name="wpf-usage-notes"></a>Hinweise zur WPF-Verwendung  
 Das [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Eigenschaften System implementiert einen internen wertserialisierer, der <xref:System.Windows.Markup.ValueSerializer.TypeReferences%2A> überschreibt, da eine Abhängigkeits Eigenschaft über ein Konzept verfügt, das Sie hinzufügen kann. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Ausdrücke weisen auch eine spezielle interne Behandlung auf.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
