<Type Name="WriteableBitmap" FullName="System.Windows.Media.Imaging.WriteableBitmap">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d8faee124c2155a6b75d903b393c805332cebd28" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30669664" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class WriteableBitmap : System.Windows.Media.Imaging.BitmapSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WriteableBitmap extends System.Windows.Media.Imaging.BitmapSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Imaging.WriteableBitmap" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WriteableBitmap&#xA;Inherits BitmapSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class WriteableBitmap sealed : System::Windows::Media::Imaging::BitmapSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Imaging.BitmapSource</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt eine <see cref="T:System.Windows.Media.Imaging.BitmapSource" /> bereit, in die geschrieben werden kann und die aktualisiert werden kann.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Media.Imaging.WriteableBitmap> Klasse zu aktualisieren und eine Bitmap für eine pro-Frame zu rendern. Dies ist hilfreich für algorithmische Inhalt, z. B. ein Bild Fraktal zu generieren und Visualisierung von Daten, z. B. eine Schnellansicht für Musik.  
  
 Die <xref:System.Windows.Media.Imaging.WriteableBitmap> -Klasse verwendet zwei Puffer. Die *Hintergrundpuffer* im Arbeitsspeicher reserviert ist und sammelt Inhalt, der derzeit nicht angezeigt wird. Die *front Puffer* wird im Systemspeicher reserviert und enthält den Inhalt, der derzeit angezeigt wird. Das Renderingsystem kopiert die Front-Puffer in Grafikspeicher für die Anzeige.  
  
 Zwei Threads verwenden diese Puffer. Die *Thread (Benutzeroberflächenthread)* generiert die Benutzeroberfläche, aber nicht auf dem Bildschirm darstellen. UI-Thread reagiert auf eine Benutzereingabe, Timer und anderen Ereignissen. Eine Anwendung kann mehrere UI-Threads verwenden. Die *Rendern Thread* verfasst und rendert Sie Änderungen im UI-Thread. Es ist nur eine Renderthread pro Anwendung.  
  
 Die UI-Thread schreibt Inhalt in den Hintergrundpuffer. Der Renderthread liest den Inhalt aus dem Puffer front und kopiert ihn in Videospeicher. Änderungen an den Hintergrundpuffer werden mit geänderten rechteckige Bereiche nachverfolgt.  
  
 Rufen Sie eine von der <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> Überladungen zu aktualisieren und Anzeigen von Inhalt in den Hintergrundpuffer automatisch.  
  
 Verwenden Sie für größere Kontrolle über Updates, und für Multithreadzugriff auf den Hintergrundpuffer des folgenden Workflows.  
  
1.  Rufen Sie die <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> Methode, um den Hintergrundpuffer für Updates zu reservieren.  
  
2.  Einen Zeiger auf den Hintergrundpuffer abrufen, indem Sie den Zugriff auf die <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> Eigenschaft.  
  
3.  Schreiben Sie Änderungen in den Hintergrundpuffer. Andere Threads möglicherweise Änderungen geschrieben, die in den Hintergrund zu Puffern, wenn die <xref:System.Windows.Media.Imaging.WriteableBitmap> ist gesperrt.  
  
4.  Rufen Sie die <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> Methode, um ein Hinweis auf Bereiche, die geändert wurden.  
  
5.  Rufen Sie die <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> Methode, um den Hintergrundpuffer freizugeben und die Darstellung auf dem Bildschirm zu ermöglichen.  
  
 Beim Senden von Updates an den Renderingthread kopiert im Renderingthread geänderte Rechtecke aus den Hintergrundpuffer auf den Front-Puffer an. Das Renderingsystem steuert diese Exchange zur Vermeidung von Deadlocks und neu gezeichnet werden Elemente, z. B. "beendet".  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie eine <xref:System.Windows.Media.Imaging.WriteableBitmap> dient als Quelle für eine <xref:System.Windows.Controls.Image> Pixel gezeichnet werden soll, wenn die Maus bewegt.  
  
 [!code-csharp[WriteableBitmap2#WriteableBitmapFullPage](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#writeablebitmapfullpage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Media.Imaging.BitmapSource" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WriteableBitmap (System.Windows.Media.Imaging.BitmapSource source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Media.Imaging.BitmapSource source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Windows.Media.Imaging.BitmapSource)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (source As BitmapSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WriteableBitmap(System::Windows::Media::Imaging::BitmapSource ^ source);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="source" Type="System.Windows.Media.Imaging.BitmapSource" />
      </Parameters>
      <Docs>
        <param name="source">Die für die Initialisierung zu verwendende <see cref="T:System.Windows.Media.Imaging.BitmapSource" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />-Klasse mit dem angegebenen <see cref="T:System.Windows.Media.Imaging.BitmapSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Media.Imaging.WriteableBitmap.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Double%2CSystem.Double%2CSystem.Windows.Media.PixelFormat%2CSystem.Windows.Media.Imaging.BitmapPalette%29> Konstruktor wird bevorzugt, über die Verwendung dieses Konstruktors.  
  
 Wenn `source` verwendet keine systemintern unterstützten Bitmapformat Format Konvertierungen gelten für jedes Update Frame, der Leistung wird reduziert.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WriteableBitmap (int pixelWidth, int pixelHeight, double dpiX, double dpiY, System.Windows.Media.PixelFormat pixelFormat, System.Windows.Media.Imaging.BitmapPalette palette);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 pixelWidth, int32 pixelHeight, float64 dpiX, float64 dpiY, valuetype System.Windows.Media.PixelFormat pixelFormat, class System.Windows.Media.Imaging.BitmapPalette palette) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Windows.Media.PixelFormat,System.Windows.Media.Imaging.BitmapPalette)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WriteableBitmap(int pixelWidth, int pixelHeight, double dpiX, double dpiY, System::Windows::Media::PixelFormat pixelFormat, System::Windows::Media::Imaging::BitmapPalette ^ palette);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pixelWidth" Type="System.Int32" />
        <Parameter Name="pixelHeight" Type="System.Int32" />
        <Parameter Name="dpiX" Type="System.Double" />
        <Parameter Name="dpiY" Type="System.Double" />
        <Parameter Name="pixelFormat" Type="System.Windows.Media.PixelFormat" />
        <Parameter Name="palette" Type="System.Windows.Media.Imaging.BitmapPalette" />
      </Parameters>
      <Docs>
        <param name="pixelWidth">Die gewünschte Breite der Bitmap.</param>
        <param name="pixelHeight">Die gewünschte Höhe der Bitmap.</param>
        <param name="dpiX">Die horizontalen [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] der Bitmap.</param>
        <param name="dpiY">Die vertikalen [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] der Bitmap.</param>
        <param name="pixelFormat">Das <see cref="T:System.Windows.Media.PixelFormat" /> der Bitmap.</param>
        <param name="palette">Das <see cref="T:System.Windows.Media.Imaging.BitmapPalette" /> der Bitmap.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />-Klasse mit den angegebenen Parametern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die bevorzugte Werte für `pixelFormat` sind <xref:System.Windows.Media.PixelFormats.Bgr32%2A> und <xref:System.Windows.Media.PixelFormats.Pbgra32%2A>. Diese Formate werden systemeigen unterstützt sowie eine formatkonvertierung ist nicht erforderlich. Andere `pixelFormat` Werte erfordern eine formatkonvertierung für jedes Update Frame, der Leistung wird reduziert.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AddDirtyRect">
      <MemberSignature Language="C#" Value="public void AddDirtyRect (System.Windows.Int32Rect dirtyRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDirtyRect(valuetype System.Windows.Int32Rect dirtyRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect(System.Windows.Int32Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDirtyRect (dirtyRect As Int32Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDirtyRect(System::Windows::Int32Rect dirtyRect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dirtyRect" Type="System.Windows.Int32Rect" />
      </Parameters>
      <Docs>
        <param name="dirtyRect">Ein <see cref="T:System.Windows.Int32Rect" />, das den geänderten Bereich darstellt. Abmessungen werden in Pixel angegeben.</param>
        <summary>Gibt den Bereich der Bitmap an, der geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> Methode an, dass Änderungen Code, den Hintergrundpuffer versucht hat.  
  
 Wenn Sie diese Methode mehrmals aufrufen, werden die geänderten Bereiche in einer ausreichenden, aber nicht notwendigerweise minimalen Darstellung gesammelt. Aus Effizienzgründen garantiert nur die Bereiche, die als geändert markiert sind vorwärts in der Front-Puffer kopiert werden. Allerdings dürfen ein Teils der Bitmap vorwärts, kopiert werden, deshalb Sie sicherstellen müssen, dass der gesamte Hintergrundpuffer immer gültig ist.  
  
 Rufen Sie die <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> Methode nur zwischen den Aufrufen der <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> und <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> Methoden, wie in beschrieben die <xref:System.Windows.Media.Imaging.WriteableBitmap> -Klasse "Hinweise".  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie der Bereich des Hintergrunds an Puffern, die geändert, indem die <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> Methode.  
  
 [!code-csharp[WriteableBitmap2#2](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Bitmap wurde nicht durch einen Aufruf der <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" />-Methode oder der <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" />-Methode gesperrt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="dirtyRect" /> liegt außerhalb der Grenzen von <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BackBuffer">
      <MemberSignature Language="C#" Value="public IntPtr BackBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int BackBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BackBuffer As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr BackBuffer { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Zeiger auf den Hintergrundpuffer ab.</summary>
        <value>Ein <see cref="T:System.IntPtr" />, der auf die Basisadresse des Hintergrundpuffers zeigt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Hintergrundpuffer enthält den Bitmapinhalt in das Pixelformat, das vom Benutzer angefordert wird.  
  
 Aktualisieren Sie den Hintergrundpuffer nur zwischen den Aufrufen der <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> und <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> Methoden. Befolgen Sie nicht die Sperren/Entsperren-Workflows beschrieben, die der <xref:System.Windows.Media.Imaging.WriteableBitmap> Klasse "Hinweise" nicht definierten Verhalten, z. B. liegen, auftreten können.  
  
 Die Adresse des Hintergrundpuffers wird nicht geändert.  
  
## <a name="thread-safety"></a>Threadsicherheit  
 Sie können übergeben der <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> Zeiger auf externe Komponenten und anderen Threads für die Verarbeitung, aber wenn Sie dies tun, müssen Sie angeben Sie eigenen Thread Koordination. Insbesondere müssen Sie sicherstellen, dass im UI-Thread geänderten Bereiche durch den Aufruf gibt die <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> -Methode, und im UI-Thread durch Aufrufen den Puffer entsperrt die <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackBufferStride">
      <MemberSignature Language="C#" Value="public int BackBufferStride { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BackBufferStride" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Imaging.WriteableBitmap.BackBufferStride" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BackBufferStride As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BackBufferStride { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Anzahl der Bytes in einer einzelnen Zeile der Pixeldaten angibt.</summary>
        <value>Eine ganze Zahl, die die Anzahl der Bytes in einer einzelnen Zeile der Pixeldaten angibt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Imaging.WriteableBitmap Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Imaging.WriteableBitmap Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As WriteableBitmap" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Imaging::WriteableBitmap ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Imaging.WriteableBitmap</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon dieser <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />, indem tiefe Kopien der Werte dieses Objekts erzeugt werden. Beim Kopieren von Abhängigkeitseigenschaften kopiert diese Methode Ressourcenverweise und Datenbindungen (die aber möglicherweise nicht mehr aufgelöst werden können), jedoch keine Animationen oder ihre aktuellen Werte.</summary>
        <returns>Ein änderbarer Klon des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true." /> war.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um änderbare Kopien erzeugen fixierte <xref:System.Windows.Freezable> Objekte (oder eine beliebige <xref:System.Windows.Freezable> Objekt). Der Einfachheit halber führt Shadowing für diese Methode die geerbte Version mit einer Implementierung mit starker Typisierung.  
  
 Weitere Informationen finden Sie unter <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected override void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Imaging.WriteableBitmap CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Imaging.WriteableBitmap CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As WriteableBitmap" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Imaging::WriteableBitmap ^ CloneCurrentValue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Imaging.WriteableBitmap</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon des <see cref="T:System.Windows.Media.Animation.ByteAnimationUsingKeyFrames" />-Objekts, indem tiefe Kopien der aktuellen Werte dieses Objekts erzeugt werden. Ressourcenverweise, Datenbindungen und Animationen werden nicht kopiert, ihre aktuellen Werte werden jedoch kopiert.</summary>
        <returns>Ein änderbarer Klon des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true" /> war.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um änderbare Kopien erzeugen fixierte <xref:System.Windows.Freezable> Objekte (oder eine beliebige <xref:System.Windows.Freezable> Objekt). Der Einfachheit halber führt Shadowing für diese Methode die geerbte Version mit einer Implementierung mit starker Typisierung.  
  
 Weitere Informationen finden Sie unter <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected override bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool FreezeCore(bool isChecking);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public void Lock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Lock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Lock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reserviert den Hintergrundpuffer für Aktualisierungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> Methode inkrementiert die Anzahl der Sperren. Wenn eine <xref:System.Windows.Media.Imaging.WriteableBitmap> ist gesperrt, das Renderingsystem sendet keine Updates bis der <xref:System.Windows.Media.Imaging.WriteableBitmap> ist vollständig entsperrt werden durch Aufrufe von der <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> Methode.  
  
 Sie können die <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> -Methode zur Unterstützung der Multithread-Implementierungen. In diesen Szenarien werden im UI-Thread sperrt die Bitmap und macht den Hintergrundpuffer für andere Threads. Wenn der Thread einen Frame abgeschlossen ist, werden im UI-Thread geänderte Rechtecke hinzugefügt und entsperrt den Puffer.  
  
 Die UI-Thread kann blockieren, wenn der Renderthread auf eine Sperre für den Hintergrundpuffer vorwärts auf den Front-Puffer kopieren erhält. Wenn die Latenzzeit aus diesem Block zu lang ist, verwenden Sie die <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> Methode für eine kurze Zeit warten und Sie dann die Blockierung der UI-Thread, um andere Aufgaben auszuführen, während der Hintergrundpuffer gesperrt ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mithilfe der Hintergrundpuffer Reservieren der <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> Methode.  
  
 [!code-csharp[WriteableBitmap2#2](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" />
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="TryLock">
      <MemberSignature Language="C#" Value="public bool TryLock (System.Windows.Duration timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryLock(valuetype System.Windows.Duration timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryLock (timeout As Duration) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryLock(System::Windows::Duration timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Windows.Duration" />
      </Parameters>
      <Docs>
        <param name="timeout">Eine <see cref="T:System.Windows.Duration" />, die die Zeitspanne für den Wartevorgang darstellt. Beim Wert 0 wird nicht gewartet. Bei einem Wert von <see cref="P:System.Windows.Duration.Forever" /> wird für unbegrenzte Zeit blockiert.</param>
        <summary>Versucht, die Bitmap zu sperren, und wartet höchstens die angegebene Zeit.</summary>
        <returns>
          <see langword="true" />, wenn die Sperre erhalten wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Sperre abgerufen wird, das Verhalten der <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> Methode ist identisch mit der <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Für <paramref name="timeout" /> ist <see cref="P:System.Windows.Duration.Automatic" /> festgelegt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" />
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.Unlock" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public void Unlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.Unlock" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hintergrundpuffer frei, um ihn für die Anzeige verfügbar zu machen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> Methode verringert die Sperrenanzahl. Wenn die Anzahl der Sperren 0 erreicht, wird eine Renderings angefordert, wenn die <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> -Methode aufgerufen wurde.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie mithilfe der Hintergrundpuffer Freigeben der <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> Methode.  
  
 [!code-csharp[WriteableBitmap2#2](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Bitmap wurde nicht durch einen Aufruf der <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" />-Methode oder der <see cref="M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)" />-Methode gesperrt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.Lock" />
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect(System.Windows.Int32Rect)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WritePixels">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualisiert die Pixel der Bitmap, in die geschrieben werden kann.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WritePixels">
      <MemberSignature Language="C#" Value="public void WritePixels (System.Windows.Int32Rect sourceRect, Array pixels, int stride, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WritePixels(valuetype System.Windows.Int32Rect sourceRect, class System.Array pixels, int32 stride, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WritePixels (sourceRect As Int32Rect, pixels As Array, stride As Integer, offset As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WritePixels(System::Windows::Int32Rect sourceRect, Array ^ pixels, int stride, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceRect" Type="System.Windows.Int32Rect" />
        <Parameter Name="pixels" Type="System.Array" />
        <Parameter Name="stride" Type="System.Int32" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceRect">Das Rechteck der zu aktualisierenden <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</param>
        <param name="pixels">Das Pixelarray, das zum Aktualisieren der Bitmap verwendet wird.</param>
        <param name="stride">Der Sprung des Aktualisierungsbereichs in <c>Pixeln</c>.</param>
        <param name="offset">Der Offset des Eingabepuffers.</param>
        <summary>Aktualisiert die Pixel im angegebenen Bereich der Bitmap.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> und <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> Überladungen werden bevorzugt, über die Verwendung dieser Methode.  
  
> [!NOTE]
>  Verwenden Sie bei teilweiser Vertrauenswürdigkeit die <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> überladen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie ein Pixel im Hintergrundpuffer Aktualisieren der <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> Methode.  
  
 [!code-csharp[WriteableBitmap2#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Mindestens eine der folgenden Bedingungen ist erfüllt.  
  
 <paramref name="sourceRect" /> liegt außerhalb der Grenzen von <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="stride" /> &lt; 1  
  
 <paramref name="offset" />&lt; 0</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pixels" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="pixels" /> besitzt einen Rang ungleich 1 oder 2, oder seine Länge ist kleiner oder gleich 0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WritePixels">
      <MemberSignature Language="C#" Value="public void WritePixels (System.Windows.Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WritePixels(valuetype System.Windows.Int32Rect sourceRect, native int buffer, int32 bufferSize, int32 stride) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WritePixels (sourceRect As Int32Rect, buffer As IntPtr, bufferSize As Integer, stride As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WritePixels(System::Windows::Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceRect" Type="System.Windows.Int32Rect" />
        <Parameter Name="buffer" Type="System.IntPtr" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="stride" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceRect">Das Rechteck der zu aktualisierenden <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.</param>
        <param name="buffer">Der Eingabepuffer, der zum Aktualisieren der Bitmap verwendet wird.</param>
        <param name="bufferSize">Die Größe des Eingabepuffers.</param>
        <param name="stride">Der Sprung des Aktualisierungsbereichs in <c>Puffer</c>.</param>
        <summary>Aktualisiert die Pixel im angegebenen Bereich der Bitmap.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> und <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> Überladungen werden bevorzugt, über die Verwendung dieser Methode.  
  
> [!NOTE]
>  Verwenden Sie bei teilweiser Vertrauenswürdigkeit die <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> überladen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Mindestens eine der folgenden Bedingungen ist erfüllt.  
  
 <paramref name="sourceRect" /> liegt außerhalb der Grenzen von <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="bufferSize" /> &lt; 1  
  
 <paramref name="stride" /> &lt; 1</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WritePixels">
      <MemberSignature Language="C#" Value="public void WritePixels (System.Windows.Int32Rect sourceRect, Array sourceBuffer, int sourceBufferStride, int destinationX, int destinationY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WritePixels(valuetype System.Windows.Int32Rect sourceRect, class System.Array sourceBuffer, int32 sourceBufferStride, int32 destinationX, int32 destinationY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WritePixels (sourceRect As Int32Rect, sourceBuffer As Array, sourceBufferStride As Integer, destinationX As Integer, destinationY As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WritePixels(System::Windows::Int32Rect sourceRect, Array ^ sourceBuffer, int sourceBufferStride, int destinationX, int destinationY);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceRect" Type="System.Windows.Int32Rect" />
        <Parameter Name="sourceBuffer" Type="System.Array" />
        <Parameter Name="sourceBufferStride" Type="System.Int32" />
        <Parameter Name="destinationX" Type="System.Int32" />
        <Parameter Name="destinationY" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceRect">Das Rechteck in <c>sourceBuffer</c>, das kopiert werden soll.</param>
        <param name="sourceBuffer">Der Eingabepuffer, der zum Aktualisieren der Bitmap verwendet wird.</param>
        <param name="sourceBufferStride">Der Schritt des Eingabepuffers in Bytes.</param>
        <param name="destinationX">Die Ziel-x-Koordinate des äußersten linken Pixel im Hintergrundpuffer.</param>
        <param name="destinationY">Die Ziel-y-Koordinate des äußersten oberen Pixel im Hintergrundpuffer.</param>
        <summary>Aktualisiert die Pixel im angegebenen Bereich der Bitmap.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> Methode zum Aktualisieren der <xref:System.Windows.Media.Imaging.WriteableBitmap> automatisch mit dem Inhalt des `sourceBuffer`. Beim Aufrufen dieser Methode entspricht der Verwendung der <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> und <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> Workflow beschrieben, der <xref:System.Windows.Media.Imaging.WriteableBitmap> -Klasse "Hinweise".  
  
> [!NOTE]
>  Verwenden Sie diese Überladung bei teilweiser Vertrauenswürdigkeit.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Mindestens eine der folgenden Bedingungen ist erfüllt.  
  
 <paramref name="sourceRect" /> liegt außerhalb der Grenzen von <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="destinationX" /> oder <paramref name="destinationY" /> liegen außerhalb der Grenzen von <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="sourceBufferStride" /> &lt; 1</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceBuffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceBuffer" /> besitzt einen Rang ungleich 1 oder 2, oder seine Länge ist kleiner oder gleich 0.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WritePixels">
      <MemberSignature Language="C#" Value="public void WritePixels (System.Windows.Int32Rect sourceRect, IntPtr sourceBuffer, int sourceBufferSize, int sourceBufferStride, int destinationX, int destinationY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WritePixels(valuetype System.Windows.Int32Rect sourceRect, native int sourceBuffer, int32 sourceBufferSize, int32 sourceBufferStride, int32 destinationX, int32 destinationY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WritePixels (sourceRect As Int32Rect, sourceBuffer As IntPtr, sourceBufferSize As Integer, sourceBufferStride As Integer, destinationX As Integer, destinationY As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WritePixels(System::Windows::Int32Rect sourceRect, IntPtr sourceBuffer, int sourceBufferSize, int sourceBufferStride, int destinationX, int destinationY);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceRect" Type="System.Windows.Int32Rect" />
        <Parameter Name="sourceBuffer" Type="System.IntPtr" />
        <Parameter Name="sourceBufferSize" Type="System.Int32" />
        <Parameter Name="sourceBufferStride" Type="System.Int32" />
        <Parameter Name="destinationX" Type="System.Int32" />
        <Parameter Name="destinationY" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceRect">Das Rechteck in <c>sourceBuffer</c>, das kopiert werden soll.</param>
        <param name="sourceBuffer">Der Eingabepuffer, der zum Aktualisieren der Bitmap verwendet wird.</param>
        <param name="sourceBufferSize">Die Größe des Eingabepuffers.</param>
        <param name="sourceBufferStride">Der Schritt des Eingabepuffers in Bytes.</param>
        <param name="destinationX">Die Ziel-x-Koordinate des äußersten linken Pixel im Hintergrundpuffer.</param>
        <param name="destinationY">Die Ziel-y-Koordinate des äußersten oberen Pixel im Hintergrundpuffer.</param>
        <summary>Aktualisiert die Pixel im angegebenen Bereich der Bitmap.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie die <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> Methode zum Aktualisieren der <xref:System.Windows.Media.Imaging.WriteableBitmap> automatisch mit dem Inhalt des `sourceBuffer`. Beim Aufrufen dieser Methode entspricht der Verwendung der <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> und <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> Workflow beschrieben, der <xref:System.Windows.Media.Imaging.WriteableBitmap> -Klasse "Hinweise".  
  
> [!NOTE]
>  Verwenden Sie bei teilweiser Vertrauenswürdigkeit die <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> überladen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Mindestens eine der folgenden Bedingungen ist erfüllt.  
  
 <paramref name="sourceRect" /> liegt außerhalb der Grenzen von <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="destinationX" /> oder <paramref name="destinationY" /> liegen außerhalb der Grenzen von <see cref="T:System.Windows.Media.Imaging.WriteableBitmap" />.  
  
 <paramref name="sourceBufferSize" /> &lt; 1  
  
 <paramref name="sourceBufferStride" /> &lt; 1</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceBuffer" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Ressourcen. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>